{"title": "个税计算器 / 微信小程序开发 ", "author": "Rolan", "pub_time": "2019-1-2 00:36", "article_content": "019年1月1日即将到来，码农们除了关心自己的技能之外，还有薪资是不是可以多拿点。 每次算的时候 都要百度一下个人所得税，但是很多都是老的税率计算，找一个新的出来还是比较麻烦，所以个人开发了一个最新税率的小程序。解决和我有着一样痛苦的码农们的问题。根据最新税改后计算个人所得税的计算器。目前支持南京，后续开放 杭州 上海 北京等城市。 如果有疑问的可以加最下方 开发者微信。首先在微信官网下载微信小程序开发工具 https://mp.weixin.qq.com在https://mp.weixin.qq.com 注册小程序账号，完成个人实名认证。在小程序后台拿到appid，下面就可以开发了。实例查看二维码：先使用weui 小程序ui框架就行页面布局<button block type=\"dark\" bindtap='calculationBindtap'>计算</button>其次写JS代码（计算按钮逻辑代码）import data from './data'\r\n\r\nconst app = getApp;\r\n\r\nPage({\r\n    data: {\r\n        options1: data,\r\n        value: '1',\r\n        checked: true,\r\n        standard: 1,\r\n        marking: 5000,\r\n        beforetaxCount: 0,\r\n        specialitemCount: 0\r\n    },\r\n    \r\n\r\n    calculationBindtap:function(){\r\n        // 开始计算  计算完成把计算结果放在result对象中\r\n        var beforetaxCount = this.data.beforetaxCount;\r\n        var specialitemCount = this.data.specialitemCount;\r\n        var marking = this.data.marking;\r\n        if (beforetaxCount == null || beforetaxCount == 0 || beforetaxCount == ''){\r\n            wx.showToast({\r\n                title: '输入正确薪资',\r\n                mask: true,\r\n                icon: 'loading'\r\n            })\r\n            return;\r\n        }\r\n        if (specialitemCount == null || specialitemCount == ''){\r\n            specialitemCount = 0;\r\n        }\r\n        // 开始计算\r\n\r\n        var oldNum = 0.08;\r\n        var medNum = 0.02;\r\n        var unemNum = 0.005;\r\n        var workNum = 0;\r\n        var giveNum = 0;\r\n\r\n        var providentfundNum = 0.08;\r\n\r\n        var insuranceBase = 19935;\r\n        var providentfundBase = 25300;\r\n\r\n        var oldcount = 0;\r\n        var medcount = 0;\r\n        var unemcount = 0;\r\n        var workcount = 0;\r\n        var givecount = 0;\r\n\r\n        var providentfundcount = 0;\r\n\r\n        var privateFee = 0;\r\n        var plusFee = 0;\r\n\r\n        if(this.data.checked){\r\n            if (parseFloat(beforetaxCount) > parseFloat(insuranceBase)) {\r\n                oldcount = parseFloat(insuranceBase) * parseFloat(oldNum);\r\n                medcount = parseFloat(insuranceBase) * parseFloat(medNum);\r\n                unemcount = parseFloat(insuranceBase) * parseFloat(unemNum);\r\n                workcount = parseFloat(insuranceBase) * parseFloat(workNum);\r\n                givecount = parseFloat(insuranceBase) * parseFloat(giveNum);\r\n            } else {\r\n                oldcount = parseFloat(beforetaxCount) * parseFloat(oldNum);\r\n                medcount = parseFloat(beforetaxCount) * parseFloat(medNum);\r\n                unemcount = parseFloat(beforetaxCount) * parseFloat(unemNum);\r\n                workcount = parseFloat(beforetaxCount) * parseFloat(workNum);\r\n                givecount = parseFloat(beforetaxCount) * parseFloat(giveNum);\r\n            }\r\n\r\n            if (parseFloat(beforetaxCount) > parseFloat(providentfundBase)) {\r\n                providentfundcount = parseFloat(providentfundBase) * parseFloat(providentfundNum);\r\n            } else {\r\n                providentfundcount = parseFloat(beforetaxCount) * parseFloat(providentfundNum);\r\n            }\r\n        }\r\n\r\n        // 保险总费用\r\n        var totalInsuranceFee = parseFloat(oldcount) + parseFloat(medcount) + parseFloat(unemcount) + parseFloat(workcount) + parseFloat(givecount);\r\n        // 公积金费用 \r\n        var totalProvidentfundFee = providentfundcount;\r\n\r\n        // 下面的钱 交税\r\n        console.log(this.data.marking);\r\n        var otherFee = parseFloat(beforetaxCount) - parseFloat(totalInsuranceFee) - parseFloat(totalProvidentfundFee) - parseFloat(this.data.marking) - parseFloat(specialitemCount);\r\n        \r\n        if (parseFloat(otherFee) <= 3000 && parseFloat(otherFee) > 0) {\r\n            privateFee = parseFloat(otherFee) * 0.03;\r\n            plusFee = 0;\r\n        }\r\n        if (parseFloat(otherFee) <= 12000 && parseFloat(otherFee) > 3000) {\r\n            privateFee = parseFloat(otherFee) * 0.1;\r\n            plusFee = 210;\r\n        }\r\n        if (parseFloat(otherFee) <= 25000 && parseFloat(otherFee) > 12000) {\r\n            privateFee = parseFloat(otherFee) * 0.2;\r\n            plusFee = 1410;\r\n        }\r\n        if (parseFloat(otherFee) <= 35000 && parseFloat(otherFee) > 25000) {\r\n            privateFee = parseFloat(otherFee) * 0.25;\r\n            plusFee = 2660;\r\n        }\r\n        if (parseFloat(otherFee) <= 55000 && parseFloat(otherFee) > 35000) {\r\n            privateFee = parseFloat(otherFee) * 0.3;\r\n            plusFee = 4410;\r\n        }\r\n        if (parseFloat(otherFee) <= 80000 && parseFloat(otherFee) > 55000) {\r\n            privateFee = parseFloat(otherFee) * 0.35;\r\n            plusFee = 7160;\r\n        }\r\n        if ( parseFloat(otherFee) > 80000) {\r\n            privateFee = parseFloat(otherFee) * 0.45;\r\n            plusFee = 15160;\r\n        }\r\n\r\n        var result = {};\r\n        \r\n        result.insuranceCount = totalInsuranceFee;\r\n        result.providentfundCount = totalProvidentfundFee;\r\n        result.providentfundNum = parseFloat(providentfundNum) * 100;\r\n        result.money = parseFloat(beforetaxCount) - parseFloat(totalInsuranceFee) - parseFloat(totalProvidentfundFee) - parseFloat(privateFee) + parseFloat(plusFee);\r\n        result.privateFee = privateFee - parseFloat(plusFee);\r\n        result.specialitemCount = specialitemCount;\r\n        result.oldNum = parseFloat(oldNum) * 100;\r\n        result.medNum = parseFloat(medNum) * 100;\r\n        result.unemNum = parseFloat(unemNum) * 100;\r\n        result.workNum = parseFloat(workNum) * 100;\r\n        result.giveNum = parseFloat(giveNum) * 100;\r\n\r\n        result.oldcount = parseFloat(oldcount);\r\n        result.medcount = parseFloat(medcount);\r\n        result.unemcount = parseFloat(unemcount);\r\n        result.workcount = parseFloat(workcount);\r\n        result.givecount = parseFloat(givecount);\r\n\r\n        wx.setStorage({\r\n            key: 'result',\r\n            data: result,\r\n            success:function(){\r\n                wx.navigateTo({\r\n                    url: '../calculation/calculationResult',\r\n                })\r\n            }\r\n        })\r\n        \r\n    },\r\n\r\n})把计算好的结果放在result对象中 通过wx.setStorage 放在缓存中，传到下一个页面。最后展示出来。"}
{"title": "django与小程序实现登录验证功能 ", "author": "Rolan", "pub_time": "2019-2-20 00:12", "article_content": "之前用小程序做项目，因为后台使用的java开发，一切顺利，但切换成django做RESTful API接口时，在登陆注册时一直出现问题，网上搜索，借助一个网友的回答，找到了一种可行的解决方案，现记录如下。具体流程用户点击小程序页面上的登录授权认证通过微信自带的认证获取code调取登录接口，将code传入后台后台拿到code调用微信接口获取openid等用户信息后台将openid作为用户名，若存在则去校验用户信息，否则以此用户名创建新用户，密码随机生成将校验结果或者创建信息返回给微信小程序端根据返回的信息完成用户登录校验django的用户权限认证django有一套自己的完善用户模型，由于Django Auth自带的User模型字段有限，我们需要对其进行拓展(直接使用也可以)nickname = models.CharField(verbose_name=u'昵称',max_length=50, blank=True)\r\nuser_avatar =  models.ImageField(verbose_name=u'用户头像', upload_to='image/%Y/%m/%d', default=u'image/default.png', max_length=500)\r\nuser_email = models.EmailField(verbose_name=u'用户邮箱',max_length=254)\r\nuser_phone = models.BigIntegerField(verbose_name=u'手机号', null=True,blank=True)\r\nuser_birthday = models.DateField(verbose_name=u'出生日期', default = timezone.now)\r\nuser_sex = models.CharField(verbose_name=u'性别',max_length=6,choices=(('male','男'),('female','女')),default='male')\r\nuser_address = models.CharField(verbose_name=u'地址',max_length=550, blank=True,null=True)\r\nsignature = models.CharField(verbose_name=u'个性签名',max_length=550, blank=True,null=True)\r\n复制代码用户接口序列化from rest_framework import serializers\r\n\r\nclass UserSerializer(serializers.ModelSerializer):\r\nclass Meta:\r\n    model = User\r\n    fields = \"__all__\"\r\n复制代码登陆接口设计class UserLogin(APIView):\r\n    def post(self,request):\r\n        params = request.data\r\n        userName = get_openid(params.get('code'))\r\n        userInfo = params.get('userinfo')\r\n        try:\r\n            user = User.objects.get(username = userName)\r\n        except Exception as e:\r\n            user = None\r\n        if user:\r\n            # 更新用户信息\r\n            user = User.objects.get(username = userName)\r\n        else:\r\n            #注册新用户\r\n            user = User.objects.create_user(username=userName,password=random_str(10))    \r\n        #手动生成JWT\r\n        # 手动生成token验证\r\n        jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER\r\n        jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER\r\n        payload = jwt_payload_handler(user)\r\n        token = jwt_encode_handler(payload)\r\n\r\n        ret = {'code': '00000', 'msg': None,'data':{}}\r\n        \r\n        ret['msg'] = '授权成功'\r\n        ret['data'] = {\r\n            'token': token,\r\n            'user_id': user.id,\r\n            'nickname': user.nickname\r\n        }\r\n        return JsonResponse(ret)\r\n复制代码解析code获取openidclass OpenidUtils(object):\r\n    def __init__(self, jscode):\r\n        self.url = \"https://api.weixin.qq.com/sns/jscode2session\"\r\n        self.appid = APPID\r\n        self.secret = SECRET\r\n        self.jscode = jscode    # 前端传回的动态jscode\r\n\r\n    def get_openid(self):\r\n        url = self.url + \"?appid=\" + self.appid + \"&secret=\" + self.secret + \"&js_code=\" + self.jscode + \"&grant_type=authorization_code\"\r\n        r = requests.get(url)\r\n        openid = r.json()['openid']\r\n        return openid\r\n复制代码小程序的登陆验证具体登录流程可以查阅官方文档。function getWXUserInfo() {\r\n    const login = promisify(wx.login);\r\n    const getUserInfo = promisify(wx.getUserInfo);\r\n\r\n    return new Promise(function (resolve, reject) {\r\n        _wxLogin();\r\n        function _wxLogin() {\r\n            login().then(function (res) {\r\n                getUserInfo().then(function (r) {\r\n                    let userInfo = r;\r\n                    userInfo.code = res.code;\r\n                    try {\r\n                        wx.setStorageSync('userInfo', userInfo);\r\n                    } catch (e) {\r\n                        console.log(e)\r\n                    }\r\n                    if (userInfo && userInfo.code && userInfo.iv) {\r\n                        resolve(userInfo);\r\n                    }\r\n                    else {\r\n                        reject('wx login fail');\r\n                    }\r\n                }).catch(function (error) {\r\n                    reject(error);\r\n                });\r\n            }).catch(function (error) {\r\n                reject(error);\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\n//登录接口验证\r\ngetWXUserInfo().then(function (data) {\r\n    var result = {\r\n        code: 0,\r\n        data: {}\r\n    };\r\n    var params = {\r\n        'code':data.code,\r\n        'userinfo':data.userInfo\r\n    }\r\n    wx.request({\r\n        url: '/api/login',\r\n        data: params,\r\n        dataType: 'json',\r\n        method: 'POST',\r\n        success: function (response) {\r\n            // 返回成功\r\n            if (response.data && response.data.code == '00000') {\r\n                try {\r\n                    var resData = {\r\n                        custNo: data.user_id,\r\n                        nickname: data.nickname\r\n                    };\r\n                    result.code = 0;\r\n                    result.data = resData;\r\n                    resolve(result);\r\n                }\r\n                catch (e) {\r\n                    console.warn(result)\r\n                    // 登录失败\r\n                    result.code = 2;\r\n                    resolve(result);\r\n                }\r\n            }\r\n            else {\r\n                // 获取 customNum 失败\r\n                console.warn(result)\r\n                result.code = 1;\r\n                result.data = 'get customNum fail';\r\n                resolve(result);\r\n            }\r\n        }\r\n    })\r\n}\r\n复制代码"}
{"title": "小程序 setData 为什么不能频繁设置 ", "author": "Rolan", "pub_time": "2019-2-20 00:25", "article_content": "先科普下 setData 做的事情：在数据传输时，逻辑层会执行一次 JSON.stringify 来去除掉 setData 数据中不可传输的部分，之后将数据发送给视图层。同时，逻辑层还会将 setData 所设置的数据字段与 data 合并，使开发者可以用 this.data 读取到变更后的数据。因此频繁调用，视图会一直更新，阻塞用户交互，引发性能问题。但频繁调用是常见开发场景，能不能频繁调用的同时，视图延迟更新呢？参考 Vue，我们能知道，Vue 每次赋值操作并不会直接更新视图，而是缓存到一个数据更新队列中，异步更新，再触发渲染，此时多次赋值，也只会渲染一次。于是有网友就给出了这套方案的实现方法：let newState = null\r\nconst asyncSetData = ({\r\n    vm,\r\n    newData,\r\n}) => {\r\n    newState = {\r\n        ...newState,\r\n        ...newData,\r\n    }\r\n    Promise.resolve().then(() => {\r\n        if (!newState) return\r\n        vm.setData({\r\n            ...newState,\r\n        })\r\n        newState = null\r\n    })\r\n}由于 异步代码会在同步代码执行完后执行 ，因此多次 asyncSetData 的 newData 都会缓存在 newState 中，并在异步的 promise.then 中只 setData 一次。但这个方案会带来新的问题：就是 同步代码会阻塞页面的渲染 。同步代码会阻塞页面的渲染的问题其实在浏览器中也存在，但在小程序中，由于是逻辑、视图双线程架构，因此逻辑并不会阻塞视图渲染，这是小程序的优点，但在这套方案将会丢失这个优点。鱼与熊掌不可兼得也！参考资料终极蛇皮上帝视角之微信小程序之告别 setData , 佯真愚, 2018年08月12日"}
{"title": "微信小程序自定义组件的关键记录 ", "author": "Rolan", "pub_time": "2019-2-20 00:41", "article_content": "我们在往常用vue或者是react编程的时候，最常用最常见的一个词就是组件，在小程序开发中，组件也是很nice的，毕竟谁也不想把1+1 = 2每一个页面写一遍。本篇文章适合知道小程序基本开发的手足，总结一些自己在开发小程序组件的过程需要注意的点，有写的不对的地方还请指指教。1. 基本配置新建组件就跟新建页面一样，还是js、json、wxml、wxss四个文件，这里需要注意的有四点。一、或许很多人在新建组件的时候右键直接新建page，这样就会在app.json的配置文件中的pages下面，根据路径多加一项，需要注意的是，这一项不像是页面，删掉也没关系。二、新建组件之后需要在组件的配置文件json中添加component: true字段； 需要在引用组件的配置文件中添加usingComponents字段来定义组件的名字和路径【可以直接用/+app.json中自动生成的，以免路径找不到】三、新建的组件如果是直接一键生成的，那么这个时候js文件中的还是page({...生命周期等执行函数})，所以这个时候需要我们把这些换成组件需要的component({...组件需要的对象})2.组件样式关于样式，就是我们的css了，至于里面的slot，无非就是一个插槽，而模版文件中数据绑定等我们都可以按照页面中的来实现，需要注意的是选择器和样式污染问题一、选择器在编写组件的时候，不能使用id选择器(#a)、属性选择器（[a]）和标签名选择器，建议统一使用class 子选择器只能用于view组件，和其子节点之间，其余的不建议使用 比如text > text 继承样式的话 font还有color这种样式继承，会从组件外继承到组件内部 除继承样式之外，app.wxss中的样式，组件所在页面的样式对组件内部是无效的其实呢，我们只用class选择器就好了。。。二、外部样式定义组件定义好了之后，在使用的时候，如果我忽然在调用页面加一个class控制样式，想加一个class怎么办呢？ 在组件内部的js文件中配置externalClasses：['xxx']，这样在外部引用的时候，可以直接使用这里定义的，毕竟单节点上面，同一节点同时使用普通样式和外部样式的时候，优先级会出现错乱，所以这能很好的避免这种情况 我们前面说了，自定义组件内部样式，是不会受到外部样式的影响的，除非是全局的标签或者是options配置中添加assGlobalClass字段三、样式配置3.component构造器 其实这里的构造器都是制定组件重的属性、数据、方法等等，定义的字段可以参考官方文档，我这里不多做累述，把容易混淆的点拿出来对比一下。properties: 组件的对外属性 data: 组件的内部数据 组件生命周期：生命周期有优先级，一般情况下直接当作普通方法，但是如果需要优先级的时候，可以写到lifetimes对象里面组件生命周期：4.组件事件组件的事件，我们和vue差不多的写法，会有一个methods统一来管理。但是我们通常有两种类型1. 组件内部调用的方法。和普通一样就好了，无非就是完全在组件内部自己玩，不和外部页面进行数据通信，请求也是自己完成\r\n复制代码2. 和父组件或者页面有数据通信的方法。我们在vue中需要使用到自组件向父组件传递消息，有一种方法就是this.$emit('...', msg)\r\n但是我们在小程序中也需要这种场景 【监听事件】：组件间通信的主要方式之一\r\n复制代码组件内部// wxml\r\n        <view bindtap=\"onHandle\"></view>\r\n        // js\r\n        methods: {\r\n            onHandle() {\r\n                .....\r\n                this.triggerEvent('eventName', detailMsg)\r\n            }\r\n    }\r\n\r\n复制代码"}
{"title": "微信小程序特殊字符转义方法——&转义&amp;等等 ", "author": "Rolan", "pub_time": "2019-2-20 00:53", "article_content": "在我编写公司小程序的过程中，有一次在网页端添加了一张图片，结果在小程序端访问失败了，究其原因，竟然是因为该图片名称中有一个“&”符号，网页端添加后，自动转义成了“&amp;”存储到了数据库。当然，这种格式如果是在HTML去访问图片地址，会自动在转义成“&”，但是小程序的WXML并没有这种功能，所以这就需要我们在小程序端自行操作进行转义了。 首先，明确一下会自动转义存储的常用的特殊字符有哪些：如果是在<text>标签中显示文本内容，可以直接通过设置decode=‘true’的属性进行转义。 但因为我是在<image>标签中访问，所以小程序中没有便捷方法可以转义，写了一个死方法——replace.js，如下：//替换URL中特殊字符\r\nfunction replaceSpecialChar(url) {\r\n  url = url.replace(/&quot;/g, '\"');\r\n  url = url.replace(/&amp;/g, '&');\r\n  url = url.replace(/&lt;/g, '<');\r\n  url = url.replace(/&gt;/g, '>');\r\n  url = url.replace(/&nbsp;/g, ' ');\r\n  console.log(\"转义字符\", url);\r\n  return url;\r\n}\r\nmodule.exports = {\r\n  replaceSpecialChar: replaceSpecialChar\r\n}需要用到的时候，在页面对应的js里面调用该方法：var replace = require(\"../../utils/replace.js\");\r\nPage({\r\n    ..............\r\n    url = replace.replaceSpecialChar(res.data.url)\r\n}） 这样就能访问到图片啦~~~"}
{"title": "小程序的诞生 ", "author": "Rolan", "pub_time": "2019-2-21 00:06", "article_content": "大家坐稳，我要开始装逼了。说好要讲小程序系列，替埋头苦干低调做事的开发哥哥们多讲讲小程序的故事吧。小程序与 WebViewWebView 的飞速发展随着公众号的出现和繁荣，WebView 的使用频率也越来越高。不少的企业或是小商家、外包公司开始做 H5 页面，各式各样的 H5 活动页、小商城、小测试、小游戏满天飞。H5 的劣势也很明显，体验太渣，甚至还不能获取很多底层 APP 拥有的功能。微信团队也因此提供了一些 JS-SDK 给 Web 开发使用，包括拍摄、录音、语音识别、二维码、地图、支付、分享等能力。从此，Web 开发者可以使用到微信的原生能力，去完成一些之前做不到或者难以做到的事情。体验不足的 WebView相信大多数人都经历过这样的糟糕体验——白屏。没错，就是这货：这样的体验直到今天还会出现，有些甚至连加载中的字样都没有。打开一个 WebView 通常会经历以下几个阶段：交互无反馈到达新的页面，页面白屏页面基本框架出现，但是没有数据；页面处于 loading 状态出现所需的数据除了白屏，影响 Web 体验的问题还有缺少操作的反馈，主要表现在两个方面：页面切换的生硬和点击的迟滞感。如果从程序上观察，WebView 启动过程大概分为以下几个阶段：对于一些有经验的 Web 开发者而言，会使用一些 SPA 的框架，来模拟客户端原生的页面切换过渡，同时使用缓存、CSS 反馈交互、直出页面等技术，来改善体验。但并不是所有开发者都有精力和能力去做这么多优化，而作为一个平台，优化用户体验也是平台责任的一部分。小程序的出现曾经有较长一段时间，我都以为小程序是类似 Weex、React Native 这些框架一样，最终呈现的是原生应用。直到开始写小程序，一些疑惑开始不断冒出来：为什么 CSS 样式的编写跟普通 Web 几乎一摸一样呢？才发现，小程序最终的呈现是 WebView，同时夹杂着一些原生组件。所以，小程序到底做了什么，使得体验比正常 WebView 好太多呢？我们先来对比下，常见的 Web 和 Native 的区别：关于最后一点的管控性，其实作为一个平台这是必须具备的能力，不然平台被滥用，对公众或是平台自身都不是什么好事情。就像现在很多云服务的 COS，也开始管控起来，包括域名绑定、备案等，一是防止有心人士使用平台做些不好的事情，二是对平台自身的保护（防止被封禁等）。在这样的需求和期待中，小程序诞生了。小程序是期望的产物使用 WebView 开发，门槛低，可云端更新。不同于 RN、Weex 这些框架，原生组件的开发、样式调整等都和 Web 有太多的不同。对于一个前端开发来说，开发成本较高、调试效率低，若不小心掉到坑里，都不知道该怎么爬出来。使用 WebView，可最大化前端开发的优势，同时异步加载的方式，也允许开发者进行在线的版本更新和 BUG 修复。通过提供基础能力、原生组件结合等方式，提升用户体验。小程序框架提供了完整的基础库，通过微信内置基础库、双线程渲染等方式，提升了小程序启动的体验。同时，开发者可以借用原生组件、API 等能力，做很多普通页面开发做不到的事情，用户也能以此获得原生应用般的体验。通过平台发布、审核、下架、封禁等能力，具备对小程序的管控能力。小程序框架提供了云端更新的能力，通过代码上传、审核等方式，增强了对开发者的管控能力。保护用户的同时，也保护了平台，以及平台中的其他开发者。双线程（逻辑层和渲染层分开），隔离 DOM、BOM 能力，提升体验的同时，可保证 WebView 安全性。双线程的模式，使得页面渲染和逻辑代码的加载分开，降低了页面卡壳的可能性。同时，由于逻辑层被隔离 DOM 和 BOM 对象，无法获取渲染层的内容，也在一定程度上保护了用户的数据安全。打开小程序的新世界二维码扫描、搜索、分享、推送等各种方式，都可以打开一个小程序。依靠轻量无需安装、体验优秀、管控严格、方便快捷等各种优势，小程序给用户打开了一个通向新世界的大门。而对于开发者，开发成本低、能力齐全、可快速迭代这样的开发模式，又基于大体量的用户数，几乎是无法拒绝的。齐备的底层基础库、自带优化后的体验性能，使得开发者可以专注于业务逻辑的开发，各司其职，一起把产品做好。参考《WebView性能、体验分析与优化》《小程序开发指南》结束语用心做好一个产品，在如今乱糟糟的社会里其实也不容易呢。而要做一个优秀的作品，需要有很清晰的方向，即使需要不断探索，也不会迷失方向吧。技术什么的，只要方向正确，总是有办法解决的。后面章节我们也来讲讲小程序的底层框架和设计吧。查看Github有更多内容噢：https://github.com/godbasin"}
{"title": "手把手教你在小程序项目中配置Gulp ", "author": "Rolan", "pub_time": "2019-2-21 00:14", "article_content": "如果是做原生小程序开发，你是否想过在你的小程序项目中也加入一些工程的东西？本文将手把手教你在小程序中配置一些工程化的东西，基于我自身的痛点，目前有 支持Less 、 支持路径别名 、 图片自动压缩，上传七牛 、 打包加入Eslint检查 这么几个功能，后期有遇到其他需要再更新。在小程序项目中我目前用的是 Gulp 。为啥不用热门的webpack？因为我觉得对于小程序项目来说gulp足够了，关键是配置非常简单，流式管理简单明了，不了解Gulp的大家可以去官网看看。需要提醒的是，以下举例的gulpfie基于 gulp 4.0 ，配置上与之前的版本略有不同，不过变化不大。详细的大家可以点 这里 去看看。项目结构gulpfile.js 我们放在根目录下，初始长这样const { src, dest, parallel, watch, series } = require('gulp');\r\n\r\nfunction defaultTask(cb) {\r\n  // place code for your default task here\r\n  cb();\r\n}\r\n\r\nexports.default = defaultTask\r\n接下来我们将一个任务一个任务往里面添加。支持Less由于平时项目中习惯了用CSS 预处理语言，wxss的原始css 写法让我写起项目来很难受。我个人比较习惯使用 Less ，习惯使用sass的大家自己找一下相关插件替换一下就行。gulp中处理less的插件是 gulp-less ，gulp-less把文件处理完成后我们还需要把文件名改成 .wxss 所以我们还需要一个重命名插件，这里用的是 gulp-rename 。gulpfile.js如下：const { src, dest, parallel, watch, series } = require('gulp');\r\nconst Path = require('path');\r\nconst Less = require('gulp-less');\r\nconst Rename = require('gulp-rename');\r\n\r\nconst path = {\r\n    lessPath: ['src/**/*.less'],\r\n};\r\n\r\nfunction wxss() {\r\n    return src(path.lessPath, { base: 'src/' })\r\n        .pipe(Less())\r\n        .pipe(Rename({\r\n            extname: '.wxss',\r\n        }))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nexports.default = series(wxss);\r\n需要注意的是上面的 src() 在第二个参数传入了 {base: 'src/'} ，至于原因嘛，跟我们配的匹配less文件路径 src/**/*.less 有关。感兴趣的同学可以结合 Explaining Globs 看看，这里我不细说。当然如果你想对wxss进行压缩可以使用 gulp-csso 。const { src, dest, parallel, watch, series } = require('gulp');\r\nconst Path = require('path');\r\nconst Less = require('gulp-less');\r\nconst Rename = require('gulp-rename');\r\nconst Csso = require('gulp-csso');\r\nconst GulpIf = require('gulp-if');\r\n\r\nconst path = {\r\n    lessPath: ['src/**/*.less'],\r\n};\r\n\r\nfunction wxss() {\r\n    return src(path.lessPath, { base: 'src/' })\r\n        .pipe(Less())\r\n        .pipe(GulpIf(process.env.NODE_ENV === 'production', Csso()))\r\n        .pipe(Rename({\r\n            extname: '.wxss',\r\n        }))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nexports.default = series(wxss);\r\n支持路径别名在项目中，如果应用文件路径过深过长，不仅开发者写起来费劲，还容易出错且代码观赏性很差。小程序中路径别名我们用 gulp-wechat-weapp-src-alisa ，支持在 .wxml 、 .wxss/less 、 .js 中使用。const { src, dest, parallel, watch, series } = require('gulp');\r\nconst Path = require('path');\r\nconst Less = require('gulp-less');\r\nconst Rename = require('gulp-rename');\r\nconst Csso = require('gulp-csso');\r\nconst GulpIf = require('gulp-if');\r\nconst Alias = require('gulp-wechat-weapp-src-alisa');\r\n\r\n\r\n// 匹配文件路径\r\nconst path = {\r\n    lessPath: ['src/**/*.less'],\r\n    jsPath: ['src/**/*.js'],\r\n    copy: ['src/**/*.wxml', 'src/**/*.json', 'src/**/*.wxs'],\r\n};\r\n\r\n// 路径拼接\r\nfunction _join(dirname) {\r\n    return Path.join(process.cwd(), 'src', dirname);\r\n}\r\n\r\n// 引用路径别名配置\r\nconst aliasConfig = {\r\n    '@Libs': _join('libs'),\r\n    '@Utils': _join('utils'),\r\n    '@Components': _join('components'),\r\n    '@Style': _join('style'),\r\n    '@Images': _join('images'),\r\n};\r\n\r\nfunction wxss() {\r\n    return src(path.lessPath, { base: 'src/' })\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(Less())\r\n        .pipe(GulpIf(process.env.NODE_ENV === 'production', Csso()))\r\n        .pipe(Rename({\r\n            extname: '.wxss',\r\n        }))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction js() {\r\n    return src(path.jsPath)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\n// 针对wxs,wxml,json文件直接复制\r\nfunction copy() {\r\n    return src(path.copy)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nexports.default = series(wxss， js);\r\n使用效果.jsimport * as Utils from '@Utils/base';\r\n// require('@Libs/WXPage/index');\r\n\r\n// 编译后\r\nimport * as Utils from '../../utils/base';\r\n// require('libs/WXPage/index');\r\n.less// index.less\r\n@import '@Style/variables.less';\r\n\r\n.bg {\r\n  background-image: url('@Images/32821027.jpgg');\r\n}\r\n.usermotto {\r\n    margin-top: 200px;\r\n    color: @txt-highlight;\r\n}\r\n\r\n// 编译后\r\n.bg {\r\n  background-image: url('../../images/32821027.jpg');\r\n}\r\n.usermotto {\r\n  margin-top: 200px;\r\n  color: #FD7622;\r\n}\r\n.wxml<!--logs.wxml-->\r\n<import src=\"@Utils/index.wxs\" />\r\n\r\n<image  src=\"@Images/32821027.jpg\" mode=\"cover\"></image>\r\n\r\n// 编译后\r\n<import src=\"../../utils/index.wxs\" />\r\n<image  src=\"../../images/32821027.jpg\" mode=\"cover\"></image>\r\n图片自动压缩，上传七牛由于小程序对代码包有限制，每1KB空间对小程序项目都十分珍贵，而且从用户体验来说，过大的代码包对首次进入小程序的用户来说下载时间会过长。基于这些原因我们几乎不会选择把图片放在小程序代码包中，那就只能上传图片服务器了。上传图片之前需要对图片进行压缩，可能有些通许是通过手动来做这部分工作的，其实可以用工具来的嘛。压缩图片用的插件是 gulp-imagemin , 我的图片是上传到 七牛 ,对应的插件是 gulp-qiniu-utils 。接下来我们在gulpfile中添加图片相关任务const { src, dest, parallel, watch, series } = require('gulp');\r\nconst Path = require('path');\r\nconst Less = require('gulp-less');\r\nconst Rename = require('gulp-rename');\r\nconst Csso = require('gulp-csso');\r\nconst GulpIf = require('gulp-if');\r\nconst Alias = require('gulp-wechat-weapp-src-alisa');\r\nconst ImageMin = require('gulp-imagemin');\r\nconst UrlPrefixer = require('gulp-url-prefixer');\r\nconst Qiniu = require('gulp-qiniu-utils');\r\n\r\n// 匹配文件路径\r\nconst path = {\r\n    lessPath: ['src/**/*.less'],\r\n    jsPath: ['src/**/*.js'],\r\n    copy: ['src/**/*.wxml', 'src/**/*.json', 'src/**/*.wxs'],\r\n};\r\n\r\n// 七牛相关配置\r\nconst qiniuOptions = {\r\n    ak: 'ac key',\r\n    sk: 'sk key',\r\n    zone: 'Zone_z0', // 空间对应存储区域（华东：z0，华北：z1，华南：z2，北美：na0）\r\n    bucket: 'hynal-com', // 七牛对应空间\r\n    upload: {\r\n        dir: './dist/images', // 上传本地目录\r\n        // prefix: 'test/', // 上传时添加的前缀，可省略\r\n        except: /\\.(html|js)$/, // 上传时不上传文件的正则匹配\r\n    },\r\n    remote: {\r\n        url: 'https://*****.com', // 七牛空间域名\r\n        prefix: {\r\n            default: 'test/', // 七牛空间默认前缀，如果下面三个相同可省略\r\n            remove: 'test/', // 七牛空间删除前缀\r\n            prefetch: 'test/', // 七牛空间预取前缀\r\n            refresh: 'test/', // 七牛空间刷新前缀\r\n        },\r\n    },\r\n};\r\n\r\nconst urlPrefix = {\r\n    prefix: 'https://cdn.liayal.com/dist',\r\n    tags: ['image'],\r\n};\r\n\r\n// 路径拼接\r\nfunction _join(dirname) {\r\n    return Path.join(process.cwd(), 'src', dirname);\r\n}\r\n\r\n// 引用路径别名配置\r\nconst aliasConfig = {\r\n    '@Libs': _join('libs'),\r\n    '@Utils': _join('utils'),\r\n    '@Components': _join('components'),\r\n    '@Style': _join('style'),\r\n    '@Images': _join('images'),\r\n};\r\n\r\nfunction wxss() {\r\n    return src(path.lessPath, { base: 'src/' })\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(Less())\r\n        .pipe(UrlPrefixer.css(urlPrefix))\r\n        .pipe(GulpIf(process.env.NODE_ENV === 'production', Csso()))\r\n        .pipe(Rename({\r\n            extname: '.wxss',\r\n        }))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction js() {\r\n    return src(path.jsPath)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction imagemin() {\r\n    return src(path.images)\r\n        .pipe(ImageMin())\r\n        .pipe(dest('dist/images'));\r\n}\r\n\r\n\r\nconst images = series(imagemin, (cb) => {\r\n    const qiniu = new Qiniu(qiniuOptions);\r\n    qiniu.upload();\r\n    cb();\r\n});\r\n\r\n// 针对wxs,wxml,json文件直接复制\r\nfunction copy() {\r\n    return src(path.copy)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(UrlPrefixer.html(urlPrefix))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nexports.default = series(wxss， js， images);\r\n上面我们还添加了一个 UrlPrefixer() 流，这个是把我们项目中引用的图片替换成上传七牛后的地址，需要配合七牛对应配置来设定。如：// 替换前\r\n<image  src=\"@Images/32821027.jpg\" mode=\"cover\"></image>\r\n\r\n// 替换后\r\n<image  src=\"https://cdn.liayal.com/dist/images/32821027.jpg\" mode=\"cover\"></image>\r\n打包加入Eslint检查打包时加入Eslint检查可以让我们提早发现一些由代码引发问题，也方便推行代码规范。下面我们在js任务中加入 gulp-eslintconst { src, dest, parallel, watch, series } = require('gulp');\r\nconst Path = require('path');\r\nconst Less = require('gulp-less');\r\nconst Rename = require('gulp-rename');\r\nconst Csso = require('gulp-csso');\r\nconst GulpIf = require('gulp-if');\r\nconst Alias = require('gulp-wechat-weapp-src-alisa');\r\nconst ImageMin = require('gulp-imagemin');\r\nconst UrlPrefixer = require('gulp-url-prefixer');\r\nconst Qiniu = require('gulp-qiniu-utils');\r\nconst ESLint = require('gulp-eslint');\r\n\r\n// 匹配文件路径\r\nconst path = {\r\n    lessPath: ['src/**/*.less'],\r\n    jsPath: ['src/**/*.js'],\r\n    copy: ['src/**/*.wxml', 'src/**/*.json', 'src/**/*.wxs'],\r\n};\r\n\r\n// 七牛相关配置\r\nconst qiniuOptions = {\r\n    ak: 'ac key',\r\n    sk: 'sk key',\r\n    zone: 'Zone_z0', // 空间对应存储区域（华东：z0，华北：z1，华南：z2，北美：na0）\r\n    bucket: 'hynal-com', // 七牛对应空间\r\n    upload: {\r\n        dir: './dist/images', // 上传本地目录\r\n        // prefix: 'test/', // 上传时添加的前缀，可省略\r\n        except: /\\.(html|js)$/, // 上传时不上传文件的正则匹配\r\n    },\r\n    remote: {\r\n        url: 'https://*****.com', // 七牛空间域名\r\n        prefix: {\r\n            default: 'test/', // 七牛空间默认前缀，如果下面三个相同可省略\r\n            remove: 'test/', // 七牛空间删除前缀\r\n            prefetch: 'test/', // 七牛空间预取前缀\r\n            refresh: 'test/', // 七牛空间刷新前缀\r\n        },\r\n    },\r\n};\r\n\r\nconst urlPrefix = {\r\n    prefix: 'https://cdn.liayal.com/dist',\r\n    tags: ['image'],\r\n};\r\n\r\n// 路径拼接\r\nfunction _join(dirname) {\r\n    return Path.join(process.cwd(), 'src', dirname);\r\n}\r\n\r\n// 引用路径别名配置\r\nconst aliasConfig = {\r\n    '@Libs': _join('libs'),\r\n    '@Utils': _join('utils'),\r\n    '@Components': _join('components'),\r\n    '@Style': _join('style'),\r\n    '@Images': _join('images'),\r\n};\r\n\r\nfunction wxss() {\r\n    return src(path.lessPath, { base: 'src/' })\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(Less())\r\n        .pipe(UrlPrefixer.css(urlPrefix))\r\n        .pipe(GulpIf(process.env.NODE_ENV === 'production', Csso()))\r\n        .pipe(Rename({\r\n            extname: '.wxss',\r\n        }))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction js() {\r\n    return src(path.jsPath)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(ESLint())\r\n        .pipe(ESLint.format())\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction imagemin() {\r\n    return src(path.images)\r\n        .pipe(ImageMin())\r\n        .pipe(dest('dist/images'));\r\n}\r\n\r\n\r\nconst images = series(imagemin, (cb) => {\r\n    const qiniu = new Qiniu(qiniuOptions);\r\n    qiniu.upload();\r\n    cb();\r\n});\r\n\r\n// 针对wxs,wxml,json文件直接复制\r\nfunction copy() {\r\n    return src(path.copy)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(UrlPrefixer.html(urlPrefix))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nexports.default = series(wxss， js， images);\r\n效果大概是这样的也可以通过 eslint.failOnError() 或者 eslint.failAfterError() 在编译报错时中断编译。END最后完善一下gulpfile, 添加监测任务，添加一个clean任务const { src, dest, parallel, watch, series } = require('gulp');\r\nconst Path = require('path');\r\nconst Less = require('gulp-less');\r\nconst Rename = require('gulp-rename');\r\nconst Csso = require('gulp-csso');\r\nconst GulpIf = require('gulp-if');\r\nconst Alias = require('gulp-wechat-weapp-src-alisa');\r\nconst ImageMin = require('gulp-imagemin');\r\nconst UrlPrefixer = require('gulp-url-prefixer');\r\nconst Qiniu = require('gulp-qiniu-utils');\r\nconst ESLint = require('gulp-eslint');\r\nconst Clean = require('gulp-clean');\r\n\r\n// 匹配文件路径\r\nconst path = {\r\n    lessPath: ['src/**/*.less'],\r\n    jsPath: ['src/**/*.js'],\r\n    copy: ['src/**/*.wxml', 'src/**/*.json', 'src/**/*.wxs'],\r\n};\r\n\r\n// 七牛相关配置\r\nconst qiniuOptions = {\r\n    ak: 'ac key',\r\n    sk: 'sk key',\r\n    zone: 'Zone_z0', // 空间对应存储区域（华东：z0，华北：z1，华南：z2，北美：na0）\r\n    bucket: 'hynal-com', // 七牛对应空间\r\n    upload: {\r\n        dir: './dist/images', // 上传本地目录\r\n        // prefix: 'test/', // 上传时添加的前缀，可省略\r\n        except: /\\.(html|js)$/, // 上传时不上传文件的正则匹配\r\n    },\r\n    remote: {\r\n        url: 'https://*****.com', // 七牛空间域名\r\n        prefix: {\r\n            default: 'test/', // 七牛空间默认前缀，如果下面三个相同可省略\r\n            remove: 'test/', // 七牛空间删除前缀\r\n            prefetch: 'test/', // 七牛空间预取前缀\r\n            refresh: 'test/', // 七牛空间刷新前缀\r\n        },\r\n    },\r\n};\r\n\r\nconst urlPrefix = {\r\n    prefix: 'https://cdn.liayal.com/dist',\r\n    tags: ['image'],\r\n};\r\n\r\n// 路径拼接\r\nfunction _join(dirname) {\r\n    return Path.join(process.cwd(), 'src', dirname);\r\n}\r\n\r\n// 引用路径别名配置\r\nconst aliasConfig = {\r\n    '@Libs': _join('libs'),\r\n    '@Utils': _join('utils'),\r\n    '@Components': _join('components'),\r\n    '@Style': _join('style'),\r\n    '@Images': _join('images'),\r\n};\r\n\r\nfunction wxss() {\r\n    return src(path.lessPath, { base: 'src/' })\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(Less())\r\n        .pipe(UrlPrefixer.css(urlPrefix))\r\n        .pipe(GulpIf(process.env.NODE_ENV === 'production', Csso()))\r\n        .pipe(Rename({\r\n            extname: '.wxss',\r\n        }))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction js() {\r\n    return src(path.jsPath)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(ESLint())\r\n        .pipe(ESLint.format())\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction imagemin() {\r\n    return src(path.images)\r\n        .pipe(ImageMin())\r\n        .pipe(dest('dist/images'));\r\n}\r\n\r\n\r\nconst images = series(imagemin, (cb) => {\r\n    const qiniu = new Qiniu(qiniuOptions);\r\n    qiniu.upload();\r\n    cb();\r\n});\r\n\r\n// 针对wxs,wxml,json文件直接复制\r\nfunction copy() {\r\n    return src(path.copy)\r\n        .pipe(Alias(aliasConfig))\r\n        .pipe(UrlPrefixer.html(urlPrefix))\r\n        .pipe(dest('dist'));\r\n}\r\n\r\nfunction clean() {\r\n    return src('dist/*', { read: false })\r\n        .pipe(Clean());\r\n}\r\n\r\n\r\nwatch(path.lessPath, wxss);\r\nwatch(path.jsPath, js);\r\nwatch(path.copy, copy);\r\nwatch(path.images, images);\r\n\r\nexports.default = series(clean, parallel(copy, wxss, js, images));\r\n整个项目我放在github  gulp-wechat-weapp"}
{"title": "理解小程序的安全与管控 ", "author": "Rolan", "pub_time": "2019-2-14 00:23", "article_content": "作为一个平台，管控和安全是很有必要性的。虽然说这些是开发自己需要进行防范的，但是平台如果能解决，也算是皆大欢喜了。双线程到底解决了什么先给小程序团队的双线程设计鼓个掌，关于双线程大家也可以回顾下《小程序的底层框架》。H5 的隐患要知道，Web 技术是非常开放灵活的，开发者可以利用 JavaScript 脚本随意地操作 DOM，这是会带来以下的问题：随意地跳转网页，改变界面上的任意内容开发者可以利用 JavaScript 脚本随意地跳转网页，或是改变界面上的任意内容。当然，恶意攻击者也能利用这种便利。获取页面数据小程序也提供可一种可以展示敏感数据的组件，<open-data>能展示包括用户昵称、头像、性别、地理位置等信息（无需用户授权）。如果开发者可以操作 DOM，意味着他们可以随意拿到用户的敏感信息。常见的前端漏洞开发者们普遍重视的安全漏洞，在前端常见的有 XSS 和 CSRF，XSS 是通过注入 JavaScript 脚本的方式来达到特定目的，而 CSRF 则是利用了 cookie。XSS 在双线程的设计中就被过滤了，而 CSRF 会在后面讲到。难以实现的管控为了解决管控与安全问题，小程序需要禁用掉：危险的 HTML 标签或者相关属性，如外跳 url 的 a 标签危险的 API，如操作界面的 API、动态运行脚本的 API如果要一个一个禁止，JavaScript 的灵活性以及浏览器接口的丰富性，会导致很容易遗漏一些危险的接口。并且浏览器内核在不断更新，或许下一版本会新增一个可能会在这套体系下产生漏洞的接口，无法完全避免。安全的逻辑层要怎么彻底解决这些问题呢？给大家点提示：没错，就是沙箱环境。通过提供一个纯 JavaScript 的解释执行环境，这个环境没有浏览器相关接口，当然也不用担心操作 DOM、跳转等问题了。在 iOS 下是用内置的 JavaScriptCore 框架，在安卓下是 JsCore 环境（旧版是腾讯 x5 内核提供，新版是 v8 提供）。一起来回顾下小程序的双线程长什么样子：客户端系统有 JavaScript 的解释引擎，则可以创建一个单独的线程去执行 JavaScript，这个环境下只执行有关小程序业务逻辑的代码。界面渲染相关的任务呢，就丢到 webview 线程里面，通过逻辑层代码去控制渲染哪些界面。把开发者的 JS 逻辑代码放到单独的线程去运行，因为不在 Webview 线程里，所以这个环境没有 Webview 任何接口，自然的开发者就没法直接操作 DOM，也就没法动态去更改界面或者抓取页面数据。同时小程序不支持动态载入脚本，XSS 漏洞自然也无缝可钻。审核机制的管控审核机制，故事要从公众号讲起了。WebView的飞速发展当年随着公众号的出现和繁荣，WebView 的使用频率也越来越高。不少的企业或是小商家、外包公司开始做 H5 页面，各式各样的 H5 活动页、小商城、小测试、小游戏满天飞。当微信中的 WebView 逐渐成为移动 Web 的一个重要入口时，微信就有相关的 JS API 了。2015年初，微信发布了一整套网页开发工具包，开放了拍摄、录音、语音识别、二维码、地图、支付、分享、卡券等几十个API，称之为 JS-SDK。到这个时候，web开发者可以使用到微信的原生能力，去完成一些之前做不到或者很难做到的事情。难管控的 JSSDK由于使用 WebView 和 JSSDK 的人越来越多，微信上越来越多干坏事的人，有人做假红包，有人诱导分享，有伪造一些官方活动，他们会利用 JSSDK 的分享能力变相的去裂变分享到各个群或者朋友圈。由于 JSSDK 是根据域名来赋予 api 权限的，运营人员封了一个域名后，他们立马用别的域名又继续做坏，注册一个新的域名的成本是很低的。小程序的审核机制为了保证小程序的质量，以及符合相关的规范，小程序的发布是需要经过审核的。经过审核的小程序才能对外发布，同时在出现问题时，小程序会被下架停用。另外，每个微信小程序需要事先设置一个通讯域名，小程序只可以跟指定的域名与进行网络通信，包括普通 HTTPS 请求、上传文件、下载文件和 WebSocket 通信，参考框架-网络。这些通讯域名，也都必须要求通过备案。同时，小程序必须使用 HTTPS 发起网络请求。请求时系统会对服务器域名使用的 HTTPS 证书进行校验，如果校验失败，则请求不能成功发起。这些种种的限制和管理模式，都进一步保障了用户的数据和隐私安全。安全的登录机制想必在座的各位前端开发者，都清楚 CSRF 安全漏洞。危险的 cookie跨站请求攻击（CSRF），简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。通常的罪魁祸首则是浏览器的 cookie 登录态。除了检查 Referer 字段来防范，更有效的一种方式是使用 token。小程序也是这么做的。小程序登录小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。参考官方时序图：在小程序中调用wx.login()，能拿到一个code作为用户登录凭证（有效期五分钟）。在开发者服务器后台，开发者可使用code换取openid和session_key等信息（code只能使用一次）。可靠的 code假设现在有个接口，请求 https://test.com/getUserInfo?id=1 拉取到微信用户 id 为 1 在我们业务侧的个人信息，那么黑客就可以通过遍历所有的 id，把整个业务侧的个人信息数据全部拉走，会给业务带来很大的安全风险。由于code 5 分钟后会过期，如果黑客要冒充一个用户的话，那他就必须在 5 分钟内穷举所有的身份证 id，然后去开发者服务器换取真实的用户身份。而code在成功换取一次信息之后也会立即失效，即便凭证code生成时间还没过期。显然，黑客要付出非常大的成本才能获取到一个用户信息，同时，开发者服务器也可以通过一些技术手段检测到5分钟内频繁从某个 ip 发送过来的登录请求，从而拒绝掉这些请求。需要保护的 AppSecret开发者的后台就拿到了前边wx.login()所生成的微信登录凭证code，此时就可以拿这个code到微信服务器换取微信用户身份。微信服务器为了确保拿code过来换取身份信息的人就是刚刚对应的小程序开发者，到微信服务器的请求要同时带上AppId和AppSecret。AppId和AppSecret是微信鉴别开发者身份的重要信息，AppId是公开信息，泄露AppId不会带来安全风险，但是AppSecret是开发者的隐私数据不应该泄露，开发者需要好好保护。参考《小程序开发指南》结束语作为一个开放的平台，小程序在提供微信加持、体验加持的能力给开发者使用的同时，也替用户和开发者做了很多安全性上的保障。或许有人说，这是牺牲了开发者的开放性换来的，而我认为这样才是个有灵魂的平台。"}
{"title": "解剖小程序的 setData ", "author": "Rolan", "pub_time": "2019-2-14 00:32", "article_content": "小程序的双线程，之前也有详细讲过了。而双线程的设计，使得逻辑层和渲染层无法直接进行数据传输。那双线程的渲染机制、通信机制，setData 的出现、工作原理、使用建议等，应该要怎么去理解呢？无处不在的 setData几乎每个开发者都会用到setData，要是在复杂的页面中，写了很多的setData，然后我们会发现页面真的是延迟严重，甚至卡顿、假死。官方在性能优化中有提到：避免频繁的去 setData。避免每次 setData 都传递大量新数据。后台态页面进行 setData。但是到底是为什么呢？setData的出现、设计方案是怎样的，又为何要这么设计呢？一切都还是要从双线程说起。小程序的虚拟 DOM双线程的难题我们知道，小程序的双线程设计，主要为了管控安全，避免操作 DOM。（可参考《小程序的底层框架》）把开发者的 JS 逻辑代码放到单独的线程去运行，因为不在 Webview 线程里，所以这个环境没有 Webview 任何接口，自然开发者就没法直接操作 DOM，也就没法动态去更改界面。但是，这样就产生了新的问题。没法操作 DOM，那用户交互需要界面变化的话怎么办呢？模板数据绑定模版数据绑定的方案，已经成为前端框架中最基础的功能。数据绑定的过程其实不复杂：解析语法生成 AST。根据 AST 结果生成 DOM。将数据绑定更新至模板。浏览器会把 HTML 解析成一棵树，最后渲染出来。整个界面是对应着一棵 DOM 树。其实浏览器页面的 DOM 结构树，也是 AST 的一种，把 HTML DOM 语法解析并生成最终的页面。而模板引擎中常用的，则是将模板语法解析生成 HTML DOM。而最容易引发性能问题的，主要是第三点。而关于数据更新的解决方案，React 首先提出了虚拟 DOM 的设计，而现在也基本被大部分框架吸收，小程序也不例外。虚拟 DOM 机制说到数据更新的 Diff，更多的则是Diff + 更新模板这样一个过程。虚拟 DOM 解决了常见的局部数据更新的问题，例如数组中值位置的调换、部分更新。一般来说计算过程如下：用JS对象模拟DOM树。一个真正的DOM元素非常庞大，拥有很多的属性值。而其中很多的属性对于计算过程来说是不需要的，所以我们的第一步就是简化 DOM 对象。我们用一个 JavaScript 对象结构表示 DOM 树的结构。比较两棵虚拟DOM树的差异。当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异。通常来说这样的差异需要记录，最后得到一组差异记录。把差异应用到真正的DOM树上。对差异记录要应用到真正的 DOM 树上，例如节点的替换、移动、删除，文本内容的改变等。小程序里，由于无法直接操作 DOM，主要也是通过数据传递的方式来进行相关的模版更新。模版绑定的机制、数据更新的机制，都可以参照上面的说明，想更具体理解也可以参考《前端模板引擎》。那么既然不在一个线程，数据的通信是怎么做的呢？小程序的数据通信与渲染机制双线程通信方式小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程。 逻辑层和渲染层的通信会经由微信客户端（Native）做中转，逻辑层发送网络请求也经由 Native 转发 ，小程序的通信模型如图：当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。所以我们的setData函数将数据从逻辑层发送到视图层，是异步的。有了线程之间的通信，我们来看看小程序的渲染机制。双线程渲染机制双线程的渲染，其实是结合了前面的一系列机制（模版绑定、虚拟 DOM、线程通信），最后整合的一个执行步骤。1. 通过模版数据绑定和虚拟 DOM 机制，小程序提供了带有数据绑定语法的 DSL 给到开发者，用来在渲染层描述界面的结构。就是我们常见的这些：123<view> {{ message }} </view><view wx:if=\"{{condition}}\"> </view><checkbox checked=\"{{false}}\"> </checkbox>噢，这里顺便吐个槽，wx:if竟然不支持[].indexOf(xx) > -1等等相关的函数运算（摔！）。2. 小程序在逻辑层提供了设置页面数据的 api。不用问就是setData了：123this.setData({  key: value})setData函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的this.data的值（同步）。3. 逻辑层需要更改界面时，只要把修改后的 data 通过 setData 传到渲染层。传输的数据，会转换为字符串形式传递，故应尽量避免传递大量数据。4. 渲染层会根据前面提到的渲染机制重新生成 VD（虚拟 DOM）树，并更新到对应的 DOM 树上，引起界面变化。原生组件的出现原生组件的出现，其实与 setData 的机制也有那么点关系，那么就当题外话一块补充下。频繁交互的性能我们知道，用户的一次交互，如点击某个按钮，开发者的逻辑层要处理一些事情，然后再通过 setData 引起界面变化。这样的一个过程需要四次通信：渲染层 -> Native（点击事件）。Native -> 逻辑层（点击事件）。逻辑层 -> Native（setData）。Native -> 渲染层（setData）。在一些强交互的场景（表单、canvas等），这样的操作流程会导致用户体验卡顿。引入原生组件前面也说过，小程序是 Hybrid 应用，除了 Web 组件的渲染体系（上面讲到），还有由客户端原生参与组件（原生组件）的渲染。引入原生组件主要有 3 个好处：绕过 setData、数据通信和重渲染流程，使渲染性能更好。扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力。体验更好，同时也减轻 WebView 的渲染工作。比如像地图组件（map）这类较复杂的组件，其渲染工作不占用 WebView 线程，而交给更高效的客户端原生处理。而原生组件的渲染过程：组件被创建，包括组件属性会依次赋值。组件被插入到 DOM 树里，浏览器内核会立即计算布局，此时我们可以读取出组件相对页面的位置（x, y坐标）、宽高。组件通知客户端，客户端在相同的位置上，根据宽高插入一块原生区域，之后客户端就在这块区域渲染界面。当位置或宽高发生变化时，组件会通知客户端做相应的调整。简单来说，就是 原生组件在 WebView 这一层只需要渲染一个占位元素，之后客户端在这块占位元素之上叠了一层原生界面。有利必有弊，原生组件也是有限制的：最主要的限制是一些 CSS 样式无法应用于原生组件由于客户端渲染，原生组件的层级会比所有在 WebView 层渲染的普通组件要高参考setData《小程序开发指南–6.3 原生组件》结束语总而言之，这一节内容主要是围绕 setData 展开，包括双线程的渲染机制、通信机制，setData 的出现（逻辑层通知渲染层）、工作原理（evaluateJavascript 字符串传递）、使用建议（setData 交互性能）、性能优化（原生组件出现）。小程序乍一看是简单的双线程设计，但仔细研究就会发现设计过程中也遇到了不少问题，不断探索解决才有了现在的美好样子。我们在开发过程中会踩的一些坑，其实在理解原理之后便很容易懂了。现在再来看，官方在性能优化中说到的优化建议，你都能深刻理解了吗？"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "article_content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "微信小程序 - 弹出键盘遮挡住输入框解决方案 ", "author": "Rolan", "pub_time": "2018-11-22 00:23", "article_content": "在开发微信小程序的时候遇到，输入用户名或者手机号以及地址，手机键盘调起来，会把输入框遮挡。如图：以上两张图是自己工作中遇到的，此处不要着急，一个属性帮你搞定。cursor-spacing：指定光标与键盘的距离，单位px或rpx，默认为px。取 input 距离底部的距离和 cursor-spacing 指定的距离的最小值作为光标与键盘的距离微信小程序开发文档api:https://developers.weixin.qq.com/miniprogram/dev/component/input.htmlhttps://developers.weixin.qq.com/miniprogram/dev/component/textarea.html最终呢，就解决输入框被遮挡问题喽！源：https://my.oschina.net/hp2017/blog/1819169?from=singlemessage&isappinstalled=0不要在该奋斗的年纪选择去偷懒，只有度过一段连自己都被感动了的日子，才会变成那个最好的自己."}
{"title": "微信小程序消息通知-打卡考勤 ", "author": "Rolan", "pub_time": "2018-11-30 00:21", "article_content": "微信小程序消息通知-打卡考勤效果:稍微改一下js就行,有不必要的错误,我就不改了,哈哈!index.js//index.js\r\nconst app = getApp()\r\n// 填写微信小程序appid\r\nvar appid = '';\r\n// 填写微信小程序secret  \r\nvar secret = '';\r\nPage({\r\n  // 页面数据\r\n  data: {\r\n    access_token: '',\r\n    openid: '',\r\n  },\r\n\r\n  // 表单请求\r\n  formRequst: function (e) {\r\n    var that = this;\r\n    // 登录\r\n    wx.login({\r\n      success: res => {\r\n        // 调用接口获取登录凭证（code）\r\n        console.log(\"获取code 成功\", res.code);\r\n        var code = res.code;\r\n        // 获取openId\r\n        wx.request({\r\n          url: 'https://api.weixin.qq.com/sns/jscode2session?appid=' + appid + '&secret=' + secret + '&grant_type=authorization_code&js_code=' + code,\r\n          header: {\r\n            'content-type': 'application/json' //默认值\r\n          },\r\n          success: function (res) {\r\n            console.log(\"获取openid 成功\", res.data.openid);\r\n            var openid = res.data.openid;\r\n            that.setData({\r\n              openid: openid\r\n            })\r\n            // wx.setStorageSync(\"openid\", openid)\r\n\r\n            // 获取 access_token\r\n            wx.request({\r\n              url: 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=' + appid + '&secret=' + secret,\r\n              method: 'GET',\r\n              header: {\r\n                'content-type': 'application/json' //默认值\r\n              },\r\n              // 成功\r\n              success: function (res) {\r\n                console.log(\"获取小程序 access_token 成功\", res.data.access_token);\r\n                that.setData({\r\n                  access_token: res.data.access_token\r\n                })\r\n\r\n                // 上上一步\r\n              },\r\n              // 失败\r\n              fail: function (err) {\r\n                console.log(\"获取小程序 access_token 失败\", err);\r\n              }\r\n            })\r\n\r\n            // 上一步\r\n          },\r\n          fail: function (err) {\r\n            console.log(\"获取openid 失败\", err);\r\n          }\r\n        })\r\n      }\r\n    })\r\n  },\r\n  // 提交表单\r\n  formSubmit: function (e) {\r\n    console.log('form发生了submit事件，携带数据为：', e.detail.value);\r\n    console.log('form发生了submit事件，携带数据为：', e.detail.formId);\r\n\r\n\r\n    var that = this;\r\n    // 发送模板消息\r\n    wx.request({\r\n      url: 'https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=' + that.data.access_token,\r\n      data: {\r\n        // openid\r\n        \"touser\": wx.getStorageSync(\"openid\"),\r\n        // 模板消息的id\r\n        \"template_id\": \"\",\r\n        // \"form_id\": \"FORMID\",\r\n        \"form_id\": e.detail.formId,\r\n        data: {\r\n          \"keyword1\": {\r\n            \"value\": \"2018.10.10\"\r\n          },\r\n          \"keyword2\": {\r\n            \"value\": \"小红\"\r\n          }\r\n        },\r\n        \"emphasis_keyword\": \"keyword1.DATA\"\r\n      },\r\n      method: 'POST',\r\n      // 成功\r\n      success: function (res) {\r\n        var data = res.data;\r\n        console.log(\"sendTemplateMessage 成功\", data);\r\n        wx.showToast({\r\n          title: '发送成功',\r\n          icon: 'success'\r\n        })\r\n      },\r\n      // 失败\r\n      fail: function (err) {\r\n        console.log(\"sendTemplateMessage 失败\", err);\r\n      }\r\n    })\r\n  },\r\n\r\n\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n    // this.formSubmit();\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面初次渲染完成\r\n   */\r\n  onReady: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面显示\r\n   */\r\n  onShow: function () {\r\n    this.formRequst();\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面隐藏\r\n   */\r\n  onHide: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面卸载\r\n   */\r\n  onUnload: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 页面相关事件处理函数--监听用户下拉动作\r\n   */\r\n  onPullDownRefresh: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 页面上拉触底事件的处理函数\r\n   */\r\n  onReachBottom: function () {\r\n\r\n  },\r\n\r\n  /**\r\n   * 用户点击右上角分享\r\n   */\r\n  onShareAppMessage: function () {\r\n\r\n  }\r\n})index.wxml\r\n<!--index.wxml-->\r\n<view class='page'>\r\n  <!-- 标题 -->\r\n  <view class='title'>\r\n    <text>考勤打卡</text>\r\n  </view>\r\n  <form class=\"text\" report-submit=\"true\" bindsubmit='formSubmit' bindreset='formReset'>\r\n    <!-- 考勤填表 -->\r\n    <input name=\"date\" placeholder='日期' class='input'></input>\r\n    <input name=\"name\" placeholder='姓名' class='input'></input>\r\n    <!-- 按钮设置 -->\r\n    <view class='btn'>\r\n      <button form-type='submit' type='primary'>提交</button>\r\n      <button form-type='reset' type='primary'>重置</button>\r\n    </view>\r\n  </form>\r\n</view>index.wxss\r\n/**index.wxss**/\r\n\r\n.page {\r\n  margin: 0rpx 50rpx 50rpx 50rpx;\r\n  font-size: 50rpx;\r\n  background-color: lavender;\r\n}\r\n\r\n.title {\r\n  text-align: center;\r\n}\r\n\r\n.input {\r\n  margin: 0rpx 0rpx 50rpx 0rpx;\r\n  width: 100%;\r\n}\r\n\r\n.btn {\r\n  display: flex;\r\n  flex-direction: row;\r\n}往后余生，唯独有你简书作者：达叔小生90后帅气小伙，良好的开发习惯；独立思考的能力；主动并且善于沟通简书博客： https://www.jianshu.com/u/c785ece603d1结语下面我将继续对 其他知识 深入讲解 ，有兴趣可以继续关注小礼物走一走 or 点赞"}
{"title": "论如何进行小程序自定义组件的单元测试 ", "author": "Rolan", "pub_time": "2018-12-11 00:25", "article_content": "前言\r\n自从小程序自定义组件和 npm 功能面世之后，组件化和开源思想逐步开始萌芽了。我们可以将一些通用的部件，如自定义导航栏之类的封装到一个自定义组件中，然后借由 npm 平台开源出去给其他开发者使用，这样可以省去很多劳动。相信各位开发老爷们应该或多或少都有过使用开源包的经历，但是在使用前，这个开源包得能赢取我们的信任，一个很重要的指标就是单元测试通过率和覆盖率。\r\n但是因为小程序独特的运行环境和不完全开源的基础款，使得对小程序自定义组件的单元测试稍微有点困难。目前市面上无论是 vue 还是 react，这些组件化框架都有一套完善的单元测试解决方案，但是对于小程序自定义组件来说却寥寥无几，因此这个工具集—— miniprogram-simulate 便应运而生了。\r\n痛点\r\n闲话不多说，我们先看下小程序的运行机制：\r\n\r\n可以看出，小程序自定义组件是渲染与逻辑脱离，想在逻辑层拿到渲染的结果进而进行对比测试是很难办到的。而且目前小程序的环境并不开放，想要完整构造模拟出小程序的运行环境也不太科学。另外我们这边只是需要对小程序的自定义组件做单元测试，对于小程序中很多非自定义组件相关的功能可以不考虑，而且在性能上也不那么苛求，所以一个思路是调整底层运行机制，将双线程合并为一个线程，将 wxml、wxss 的解析器改成纯 js 实现。\r\n实现\r\n只是有思路还不够，在实现过程中还是有一些坎的。比如要如何比较好的模拟出小程序自定义组件的各种特性和功能呢？自己实现也不是不行，问题在于维护的成本，如果小程序自定义组件实现了一个功能，测试工具还得更新一下。另外如果在实现上略有差池的话，可能小程序端的一个小调整对于测试工具都可能是伤筋动骨式的改造。所以这里直接将小程序自定义组件的最核心模块—— exparser 从基础库中抽离出来。\r\nexparser 是自定义组件系统的内核，是一个完整独立的模块，不依赖于基础库中其他模块。它完全脱离于小程序的 api 和运行机制体系，所以无论是单线程还是双线程机制都可以使用。exparser 提供的是自定义组件系统最底层的接口，测试工具将其进行二次封装成自定义组件测试环境。如果基础库有关于自定义组件的更新，如果是底层改造，则直接更新 exparser 模块即可；如果只是外层改造，那基本上是暴露接口层面的调整，也不必作太多大范围的调整。\r\n\r\nPS：目前虽然 exparser 已经发布到 npm，但是仍然只是混淆压缩后到代码，属于半开源状态，不建议开发者直接使用。\r\n\r\n使用\r\nminiprogram-simulate 本是自定义组件脚手架 miniprogram-custom-component 中的一部分，现单独抽离出来，方便开发者们作更多的使用选择（脚手架中默认使用 jest 来搭配使用，直接使用此工具集则可以搭配其他想要使用的测试框架，比如 mocha 等）。\r\n下述只简单介绍下用法，首先安装此工具集：\r\nnpm install --save-dev miniprogram-simulate\r\n复制代码然后此工具集必须搭配其他测试框架和 jsdom 来使用，比如 jest。因为 jest 内置有 jsdom，所以也就不需要额外安装 jsdom 了，以下面一个自定义组件作为例子：\r\n<!-- 自定义组件：comp.wxml -->\r\n<view class=\"index\">{{prop}}</view>\r\n复制代码/* 自定义组件：comp.wxss */\r\n.index {\r\n  color: green;\r\n}\r\n复制代码// 自定义组件 comp.js\r\nComponent({\r\n  properties: {\r\n    prop: {\r\n      type: String,\r\n      value: 'index.properties'\r\n    },\r\n  },\r\n})\r\n复制代码这是一个极其简单的自定义组件，之后我们便可开始在 comp.test.js 里编写测试用例。\r\n起步\r\n加载和渲染自定义组是最基础的功能：\r\n// 自定义组件 comp 的测试用例：comp.test.js\r\nconst path = require('path')\r\nconst simulate = require('miniprogram-simulate')\r\n\r\ntest('comp', () => {\r\n  const id = simulate.load(path.join(__dirname, './comp')) // 此处必须传入绝对路径\r\n  const comp = simulate.render(id) // 渲染成自定义组件树实例\r\n\r\n  const parent = document.createElement('parent-wrapper') // 创建父亲节点\r\n  comp.attach(parent) // attach 到父亲节点上，此时会触发自定义组件的 attached 钩子\r\n\r\n  expect(comp.querySelector('.index').dom.innerHTML).toBe('index.properties') // 测试渲染结果\r\n  // 执行其他的一些测试逻辑\r\n  \r\n  comp.detach() // 将组件从父亲节点中移除，此时会触发自定义组件的 detached 生命周期\r\n})\r\n复制代码获取数据\r\n可以获取自定义组件的数据：\r\ntest('comp', () => {\r\n    // 前略\r\n\r\n    // 判断组件数据\r\n    expect(comp.data).toEqual({\r\n        a: 111,\r\n    })\r\n})\r\n复制代码更新数据\r\n可以更新自定义组件的数据：\r\ntest('comp', () => {\r\n    // 前略\r\n\r\n    // 更新组件数据\r\n    comp.setData({\r\n        a: 123,\r\n    })\r\n})\r\n复制代码获取子组件\r\n可以获取自定义组件的子组件：\r\ntest('comp', () => {\r\n    // 前略\r\n\r\n    const childComp = comp.querySelector('#child-id')\r\n    expect(childComp.dom.innerHTML).toBe('<div>child</div>')\r\n})\r\n复制代码触发事件\r\n可以模拟触发自定义组件的事件：\r\ntest('comp', () => {\r\n    // 前略\r\n\r\n    comp.dispatchEvent('touchstart') // 触发组件的 touchstart 事件\r\n    childComp.dispatchEvent('tap') // 触发子组件的 tap 事件\r\n})\r\n复制代码至此，应该能大概了解到这个工具集的用途。这些只是简单的使用介绍，本文只是个引子，更多详细的用法请移步到 github 仓库上查阅。\r\n尾声\r\n要想判断一个自定义组件的质量如何，其中最简单的方法就是看单元测试的表现，想要别人使用你的自定义组件，质量把关很重要，目前 miniprogram-simulate 已经实现了最基本的功能，其他功能也在尽力施工中，有什么好的建议或者使用上遇到什么问题也可以提 issue。如果好评请 star 噢~"}
{"title": "微信小程序自定义数字键盘|仿支付宝、微信支付数字软键盘 ", "author": "Rolan", "pub_time": "2018-12-17 23:03", "article_content": "前几天有开发过一个html5仿支付宝、微信支付数字键盘，在某些特定场景下自定义数字键盘应用还是蛮广泛的，比如 小程序商城系统 需要零钱支付 ,会员卡支付，心想着微信小程序没有内部数字键盘组件，这样输入密码就需要自己做一个自定义软键盘了。于是就在之前插件的基础上试着开发出了这个小程序wcKeyboard数字键盘插件。可以自定义输入最大值限制，当输入超过最大值时候，会有警告提示：还可以自定义键盘背景色 style: ' background: xxx; '，最好设置background颜色较浅为佳：小程序数字键盘插件内置手机号码验证，当type:'tel'时，输入手机号码为11位会自动检测是否合法：当配置type:'pwd'， 则为密码键盘，可设置密码位数 len: 6可以随意切换微信键盘、支付宝键盘 skin: wechat/alipay 两种皮肤风格：init: function () {console.log('初始化');var that = this, opt = that.opts;// 处理传参__this.setData({  __options: {    isCloseCls: null,    __idx: __idx,    isShowPopup: true,    //中间值    kbVal: '', //设置调试默认值    err: false, //键盘错误信息提示    debug: opt.debug,    id: opt.id,    type: opt.type,    len: opt.len,    complete: opt.complete,    max: opt.max,    style: opt.style,    skin: opt.skin,    ok: opt.ok,    oninput: opt.oninput,    shade: opt.shade,    shadeClose: opt.shadeClose,    opacity: opt.opacity,    anim: opt.anim  }});opt.show && opt.show.call(this);this.__idx = __idx++;that.callback();},callback: function () {console.log('事件处理');var that = this, opt = that.opts;// 清除上一个timerclearTimeout(util.timer[that.__idx - 1]);delete util.timer[that.__idx - 1];/*  * 键盘处理函数事件 ---------------------------------------*/// 错误提示function chkErr(cls, str){  __this.setData({ '__options.err': [cls, str] });  setTimeout(function(){    __this.setData({ '__options.err': false });  }, 2500);}// 键盘值检测function chkVal(text){  if (text.indexOf('.') != -1 && text.substring(text.indexOf('.') + 1, text.length).length == 3) {    return;  }  if (text == '0') {    return;  }  // 输入最大值限制  if (opt.max) {    if (parseInt(text) >= opt.max && text.indexOf('.') == -1) {      chkErr(\"error\", \"最大限制值：\" + opt.max.toFixed(2));      return;    }  }  // 输入手机号码判断  if (opt.type && opt.type == 'tel') {    var tel = text, _len = parseInt(tel.length), reg = /^0?1[3|4|5|8|7][0-9]\\d{8}$/;    if (_len > 11) return;    if (_len == 11) {      if (!reg.test(tel)) {        chkErr(\"error\", \"手机号码格式有误！\");      } else {        chkErr(\"success\", \"验证通过！\");      }      typeof opt.complete == \"function\" && opt.complete.call(this, text);    }  }  // 输入密码长度判断  if (opt.type && opt.type == 'pwd') {    var _len = parseInt(text.length);    if (_len > opt.len) return;    if (_len == opt.len) {      typeof opt.complete == \"function\" && opt.complete.call(this, text);    }  }  return true;}// 键盘值输出function setVal(text){  __this.setData({ '__options.kbVal': text });  typeof opt.oninput == \"function\" && opt.oninput.call(this, text);}// 处理数字1-9__this.tapNum = function(e){  var kbval = this.data.__options.kbVal, text = e.currentTarget.dataset.text;  var val = kbval + text;  if (!chkVal(val)) return;  setVal(val);}// 处理小数点__this.tapFloat = function(e){  var kbval = this.data.__options.kbVal, text = e.currentTarget.dataset.text;  if(kbval == '' || kbval.indexOf('.') != -1){    return;  }  var val = kbval + text;  setVal(val);}// 处理数字0__this.tapZero = function(e){  var kbval = this.data.__options.kbVal, text = e.currentTarget.dataset.text;  var val = kbval + text;  if (!chkVal(val)) return;  setVal(val);}// 处理删除__this.tapDel = function(e){  var val = this.data.__options.kbVal.substring(0, this.data.__options.kbVal.length - 1);  setVal(val);}// 处理确定按钮事件__this.tapSure = function(e){  var kbval = this.data.__options.kbVal;  typeof opt.ok == \"function\" && opt.ok.call(this, kbval);}/*  ---------------------------------------*/// 点击遮罩层关闭__this.shadeTaped = function (e) {  if (!opt.shadeClose) return;  exportAPI.close(that.__idx);}// 点击键盘xclose按钮关闭__this.xcloseTaped = function(e){  exportAPI.close(that.__idx);}// 处理销毁函数opt.end && (util.end[that.__idx] = opt.end);}微信键盘布局view模板： class=\"ul\">     class=\"li kb-limit nbor {{err[0]}}\">{{err[1]}}     class=\"li kb-pwd nbor\" wx:if=\"{{type&&type=='pwd'}}\"> class=\"keyboard__panel-pwd\"> class=\"kb-pwdlbl\" wx:for=\"{{len}}\" wx:key=\"index\"> type=\"password\" maxlength=\"1\" value=\"{{kbVal[index]}}\" disabled />     class=\"li kb-result nbor\" style=\"display:{{debug ? 'block' : 'none'}};\">{{kbVal}}     class=\"li kb-xclose nbor\" bind:touchstart=\"xcloseTaped\"> src=\"/utils/component/wcKeyboard/img/icon__kb-xclose.png\" mode=\"aspectFit\">     class=\"li kb-number nbor\" data-text=\"1\" bind:tap=\"tapNum\">1     class=\"li kb-number\" data-text=\"2\" bind:tap=\"tapNum\">2     class=\"li kb-number\" data-text=\"3\" bind:tap=\"tapNum\">3     class=\"li kb-number nbor\" data-text=\"4\" bind:tap=\"tapNum\">4     class=\"li kb-number\" data-text=\"5\" bind:tap=\"tapNum\">5     class=\"li kb-number\" data-text=\"6\" bind:tap=\"tapNum\">6     class=\"li kb-number nbor\" data-text=\"7\" bind:tap=\"tapNum\">7     class=\"li kb-number\" data-text=\"8\" bind:tap=\"tapNum\">8     class=\"li kb-number\" data-text=\"9\" bind:tap=\"tapNum\">9     class=\"li kb-float nbor {{type=='tel' || type=='pwd' ? 'disabled' : ''}}\" data-text=\".\" bind:tap=\"tapFloat\">.     class=\"li kb-zero\" data-text=\"0\" bind:tap=\"tapZero\">0     class=\"li kb-del\" bind:tap=\"tapDel\">×支付宝键盘布局view模板： class=\"ul\">     class=\"li kb-limit nbor {{err[0]}}\">{{err[1]}}     class=\"li kb-pwd nbor\" wx:if=\"{{type&&type=='pwd'}}\"> class=\"keyboard__panel-pwd\"> class=\"kb-pwdlbl\" wx:for=\"{{len}}\" wx:key=\"index\"> type=\"password\" maxlength=\"1\" value=\"{{kbVal[index]}}\" disabled />     class=\"li kb-result nbor\" style=\"display:{{debug ? 'block' : 'none'}};\">{{kbVal}}     class=\"kb-flexbox flexbox\">       class=\"kb-one flex1\">         class=\"li kb-number nbor\" data-text=\"1\" bind:tap=\"tapNum\">1         class=\"li kb-number\" data-text=\"2\" bind:tap=\"tapNum\">2         class=\"li kb-number\" data-text=\"3\" bind:tap=\"tapNum\">3         class=\"li kb-number nbor\" data-text=\"4\" bind:tap=\"tapNum\">4         class=\"li kb-number\" data-text=\"5\" bind:tap=\"tapNum\">5         class=\"li kb-number\" data-text=\"6\" bind:tap=\"tapNum\">6         class=\"li kb-number nbor\" data-text=\"7\" bind:tap=\"tapNum\">7         class=\"li kb-number\" data-text=\"8\" bind:tap=\"tapNum\">8         class=\"li kb-number\" data-text=\"9\" bind:tap=\"tapNum\">9         class=\"li kb-float nbor {{type=='tel' || type=='pwd' ? 'disabled' : ''}}\" data-text=\".\" bind:tap=\"tapFloat\">.         class=\"li kb-zero\" data-text=\"0\" bind:tap=\"tapZero\">0         class=\"li kb-xclose\" bind:touchstart=\"xcloseTaped\"> src=\"/utils/component/wcKeyboard/img/icon__kb-xclose2.png\" mode=\"aspectFit\">             class=\"kb-two\">         class=\"li kb-del\" bind:tap=\"tapDel\"> src=\"/utils/component/wcKeyboard/img/icon__kb-del.png\" mode=\"aspectFit\">         class=\"li kb-sure\" bind:tap=\"tapSure\">确定"}
{"title": "用微信小程序云开发做一个错误日志 ", "author": "Rolan", "pub_time": "2018-12-28 00:43", "article_content": "为什么要用云开发做错误日志：我司没有测试，所以产品上线的话比较多不确定性云开发业务并不稳定，且有限制，所以不建议直接用做整个小程序的后台开发。做错误日志并不会影响小程序的流程出bug后，难定位问题，尤其是线上错误如果叫后端小伙伴给接口记录错误，总是不方便，还是自己动手丰衣足食尝鲜基于以上的原因，在小程序云开发刚出来没多久，我就开始着手在我的小程序上尝试构建一个错误日志:一般用一门新技术的第一步，你需要先浏览一下小程序云开发的官方文档：https://developers.weixin.qq....初始化环境然后你需要一个小程序，一个小程序开发工具：新建一个空白的小程序后，点击左上角的云开发按钮，初始化一个云开发的环境我这里给它取名叫error-storage。当然我是因为之后我的小程序也不太可能会用到云开发做后台，所以可以浪费一个环境命名。如果你是要用云开发做后台业务的话。那么还是按照微信推荐，一个做测试一个做正式，命名也尽量规范一点。然后它的环境限制也是我们目前不拿它当主要后端脚本的主要原因之一。ok，点击确定就创建了一个云开发后台了。然后我们回到代码。我们需要写后端脚本记录错误信息，那么根据云开发的文档，我们需要修改project.config.json给他配置一下小程序代码放在哪里，后端代码放在哪里。以下是我的配置:我把小程序文件都放在了根目录下的client文件夹内，而云函数的文件则都放在了根目录的server文件夹的cloudFunctions里那么现在我们的目录结构是这样的。我们需要手动移动一下我们的小程序代码。注意这里project.config.json是在根目录现在先添加一个数据库集合，打开云开发控制台，点击数据库。添加一个叫errors的集合编写接收错误的云函数然后我们先开始写接收错误的云函数用微信开发工具打开代码，然后点击目录树上面的cloudFunctiions目录，新建一个云函数，我们将它取名叫做errorHandler然后写上我们的代码逻辑// 云函数入口文件\r\nconst cloud = require('wx-server-sdk');\r\n\r\ncloud.init();\r\n\r\nconst db = cloud.database();\r\nconst errorCllection = db.collection('errors');\r\n\r\nfunction addError(data) {\r\n  return errorCllection.add({\r\n    data: {\r\n      ...data,\r\n      createTime: Date.now()\r\n    }\r\n  });\r\n}\r\n\r\n// 云函数入口函数\r\nexports.main = async event => {\r\n  event.openid = event.userInfo.openId;\r\n  delete event.userInfo;\r\n  await addError(event);\r\n  return true;\r\n};\r\n这面这段代码很简单就是将小程序端传过来的错误写进数据库里面，错误信息是什么由小程序端决定，它仅仅只是将所有数据丢进数据库去而已保存字后再次右键cloudFunctions选择上传并部署。那么我们的服务端就基本搞定了。（好简单啊）写小程序端的错误处理函数首先，根据教程，我们要在app.js里面做云能力初始化在app.js的第一行添加代码try {\r\n  wx.cloud.init({ // 云开发初始化\r\n    env: '云环境id',\r\n    traceUser: true\r\n  });\r\n} catch(err) {}给它加上catch是因为防止出现一些错误导致app.js运行失败，那简直是灾难吧！这里的env是你的云环境id，那么在哪里拿呢，在这里然后我们在client/utils文件夹里面添加一个处理错误的模块吧名字就叫 error.jsconst { config } = require('./config.js');\r\n\r\nglobal.onError = function (message, showModal = true) {\r\n  return function (error) {\r\n    wx.hideLoading();\r\n    if (showModal) {\r\n      wx.showModal({\r\n        title: '错误',\r\n        content: error.msg || message,\r\n        // 这里的error.msg是因为与后端约定如果有什么错误，则带一个msg的描述\r\n        // 而message则是传入进来备用的错误信息\r\n        confirmText: '返回首页',\r\n        cancelText: '继续操作',\r\n        success: res => {\r\n          if (res.confirm) {\r\n            // 重新加载首页\r\n            wx.switchTab({\r\n              url: '/pages/index/index'\r\n            });\r\n          } else {\r\n            // 取消就不管了\r\n          }\r\n        }\r\n      });\r\n    }\r\n    // 上传到小程序云数据库\r\n    try {\r\n      let userInfo = getApp().globalData.userInfo,\r\n        systemInfo = wx.getSystemInfoSync(),\r\n        page = getCurrentPages();\r\n      // 只有不在开发工具上触发的才上报\r\n      if (systemInfo.platform !== 'devtools') {\r\n        wx.getNetworkType({\r\n          success: res => {\r\n            wx.cloud.callFunction({\r\n              name: 'errorHandler',\r\n              data: {\r\n                username: userInfo.nickName,\r\n                uid: userInfo.id,\r\n                clientType: systemInfo.model,\r\n                systemInfo: JSON.stringify(systemInfo),\r\n                pageRoute: page[page.length - 1].route,\r\n                message: error.msg || message,\r\n                version: config.version,\r\n                networkType: res.networkType,\r\n                errorTime: new Date(),\r\n                error: typeof error === 'object' ? JSON.stringify(error) : String(error)\r\n              }\r\n            });\r\n          }\r\n        });\r\n      }\r\n    } catch(err) {}\r\n    console.error('程序发生错误:\\n', '时间:\\n', new Date(), '\\n错误信息:\\n', message, '\\nvvvvvvvvvvvvvv\\n', error);\r\n  };\r\n};\r\n如上，除了错误信息之外，还储存了系统信息，网络类型，最顶部的页面路由，错误时间，用户信息，版本号等(这里我加了个config.js用以储存版本号，版本描述等信息)用try catch包起来也是为了防止触发错误导致死循环并且为了方便使用，我将其直接挂载到global。不喜欢全局变量的童鞋可以选择export出去再引用并且在触发错误的时候弹出一个提示框提示错误了。错误处理函数的使用那么接下来就是对这个方法的使用了，首先我们要监听app.js的onError方法，小程序页面逻辑出现错误都会到这个方法内request('./utils/error.js'); // 别忘了引入error.js\r\nApp({\r\n    onError: global.onError('程序发生错误') // 这里返回接受错误的函数的闭包，并且传入的'程序发生错误'则是未知错误发生时的提示语\r\n});\r\n而其他的应用基本是应用到在promise的错误监听上，由于promise中的错误不会被app.js的onError接收到，所以我们需要在每个promise的catch中使用global.onError这也是我为什么将onError挂载global的原因，因为基本每个页面都会用到，所以每个页面去引用的话很麻烦例子:demo.jsPage({\r\n    onLoad() {\r\n        wx.showLoading();\r\n        this.requestList()\r\n            .then(res => {\r\n                // 做一些事情\r\n            })\r\n            .catch(global.onError('获取列表数据失败!'));\r\n    },\r\n    requestList() {\r\n        return new Promise((resolve, reject) => {\r\n            wx.request({\r\n                url: 'https://mock.com/aaa',\r\n                success: resolve,\r\n                fail: reject\r\n            });\r\n        });\r\n    }\r\n});那么，到现在，基本上已经完成了，愉快的开发，再也不担心出现完全没有头绪的错误啦最后贴一张我收集到的错误吧。但是有些字段我做了调整最后还是要吐槽一下微信本身它自己的bug有点多。实在是很无奈的"}
{"title": "小程序云开发实战 --云数据库 ", "author": "Rolan", "pub_time": "2019-1-7 00:52", "article_content": "以前一直是使用关系型数据库，第一次使用NoSQL，跟大家分享一下我有限的使用心得，希望对像我一样初使用NoSQL的开发者有所帮助。首先说说微信小程序云开发里集成的这个NoSQL，官方并没有说明是哪种NoSQL数据库，但从开发文档和暴露的API，还有官方论坛里的讨论来看应该是一个简化版的MongoDB。需要指出的是微信小程序关于云数据库的开发文档非常的简略，对于像我这样没有太多NoSQL经验的用户，很多时候需要参考MongoDB的相关文档。接下来重点谈谈我在使用这个NoSQL云数据库时最不适应的一个痛点----文档级别的原子操作。我们经常要使用到原子操作，来避免当多个用户同时对同一个field（字段）编辑时发生冲突。我在使用前其实最担心的痛点是有无schema的区别，但是使用下来发现我挺习惯，也挺喜欢无schema的，后文再详说。现在具体来看看MongoDB只支持document（文档）级别的原子操作。对于我来说，这个限制鼓励我尽量把所有关系都放在一个document里。对此我一开始是有点抗拒的，对于从关系型数据库过来的人特别不习惯。而更让我苦恼的是微信小程序云开发集成的这个云数据库是一个简化版MongoDB，只提供了非常有限的原子操作指令（command）。对于一些常用的document级别原子操作，我必须构想自己的解决办法，而没有提供直接对应的command。以下是两个我在实际开发中遇到的这类问题及我的解决办法：1.应用场景：对于一个视频，我需要一个叫total_likes的field（字段），当有用户点击“喜欢”时该field递增1，当有用户取消“喜欢”时该field递减1。痛点：小程序云数据库只提供了递增指令的原子操作，没有提供递减指令。const _ = db.command\r\ndb.collection('video').doc('video-id').update({\r\n  data: {\r\n    total_likes: _.inc(1)\r\n  }\r\n})解决办法：要实现递减的原子操作，只需在递增指令里传入负数，如data: {\r\n  total_likes: _.inc(-1)\r\n}\r\n2.应用场景：对于一个线上课程，我需要一个叫subscribers的field（字段）来记录有多少人订阅了该课程。当有用户点击“订阅”时该字段需记录该用户的id，名字及头像；当有用户取消“订阅”时需把该用户从subscribers字段里删除。痛点：我们很自然的会想到用数组（Array）数据类型来维护subscribers这个字段，虽然小程序云数据库提供了一些针对数组的原子操作，如push，pop，shift和unshfit，可是无法实现取消订阅这个场景的原子操作。解决办法：弃用Array转而使用对象（object）数据类型来维护subscribers这个字段。最终的数据看起来会是这样的：{\r\n    \"subscribers\": {\r\n        \"userID-1\": {\r\n            \"name\": \"小明\",\r\n            \"avatar\": \"https://avatar-1.com\"\r\n        },\r\n        \"userID-2\": {\r\n            \"name\": \"小红\",\r\n            \"avatar\": \"https://avatar-2.com\"\r\n        },\r\n        \"userID-3\": {\r\n            \"name\": \"小李\",\r\n            \"avatar\": \"https://avatar-3.com\"\r\n        },\r\n        ...\r\n    }\r\n}当有用户订阅时的原子操作：const subscriber = \"subscribers.\" + user.id;\r\ndb.collection('class').where({\r\n  _id: 'classID',\r\n}).limit(1).update({\r\n  data: {\r\n    [subscriber]: {\r\n      avatar: user.avatar,\r\n      name: user.name,\r\n    }\r\n  }\r\n})当有用户取消订阅时的原子操作：const subscriber = \"subscribers.\" + user.id;\r\ndb.collection('class').doc('classID').update({\r\n  data: {\r\n    [subscriber]: _.remove()\r\n  }\r\n})前文说到我很喜欢无schema，因为它非常适合快速迭代开发。而且由于云数据库使用的是类似JSON的数据结构，对于全栈开发者，基本上可以实现由前端来定义数据结构。这样的开发流程非常适合小团队，不需要庞大的并行开发，突出沟通效率和对产品需求的随机应变。顺带一提的是微信小程序云开发能力是从基础库2.2.3开始支持的，但如果要支持所有版本的基础库，可以在 app.json / game.json 中增加字段 \"cloud\": true本系列第一章：小程序云开发实战系列01--云环境设置《Meetup丨活动报名组局》是我最近开发的一个活动报名预约工具小程序，这个系列文章主要来自我在开发这款小程序时的一些体会心得。感兴趣的小伙伴可以扫下面的二维码进入我的小程序。"}
{"title": "微信小程序自定义组件实现 tabBar、navBar ", "author": "Rolan", "pub_time": "2019-1-15 00:17", "article_content": "最近App项目要将其中一个模块抽出来做成小程序，\r\n功能包含 ：底部的Tab栏，顶部的标题栏\r\n这里选择自定义的原因有两点：\r\n\r\nnarBar 微信原生不支持设置返回图标，且在 Android 上标题是居左显示，在 iOS 上是居中显示。\r\n底部的 tabBar 不支持点击跳页面，图标布局不支持超过 tabBar 的高度。\r\n\r\n下面两张图是简单实现的效果。\r\n\r\n实现分析\r\n源码地址\r\n\r\n实现分析\r\n\r\n以上效果我也是参考的网上例子来实现，可看该效果原作的分析。或者看看下面我的理解。\r\n\r\n微信小程序自定义组件\r\n\r\n官方文档地址 developers.weixin.qq.com/miniprogram…\r\n\r\n文档中说明了自定义组件\r\n\r\n可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用。\r\n也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。\r\n\r\n创建自定义组件\r\n在最新的开发工具中已经支持直接创建组件了，创建一个 components目录，然后在创建一个组件对于的目录，例如这里创建的是tabbar目录，然后在该目录点击鼠标右键选择新建Component，输入组件名称即可，例如这里输入的是tabbar。\r\n\r\n组件模板和样式\r\n\r\n官方文档 developers.weixin.qq.com/miniprogram…\r\n\r\n类似于页面，自定义组件拥有自己的wxml 模板和 wxss 样式\r\n在组件模板中可以提供一个<slot>节点，用于承载组件引用时提供的子节点。这个<slot>节点相当于组件占位符。\r\n\r\n默认情况wxml中只支持一个<solt>节点，可以设置支持多个<solt>节点：\r\n\r\n布局编写好之后就开始设置样式了，在页面中可以通过wxss来定义，也可以通过设置组件的class名称，然后再调用该组件的 wxss中定义样式。\r\n\r\n\r\n组件的wxss默认是不支持app.wxss样式的，但是可以像设置多<slot>一样，进行设置：\r\n\r\n模板数据绑定\r\n\r\n通过调用 Component构造器时可以指定组件的属性、数据、方法等。developers.weixin.qq.com/miniprogram…\r\n\r\nComponent({\r\n  // 详细使用看文档\r\n  behaviors: [],\r\n\r\n  properties: {\r\n    myProperty: { // 属性名\r\n      type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）\r\n      value: '', // 属性初始值（可选），如果未指定则会根据类型选择一个\r\n      observer(newVal, oldVal, changedPath) {\r\n        // 属性被改变时执行的函数（可选），也可以写成在methods段中定义的方法名字符串, 如：'_propertyChange'\r\n        // 通常 newVal 就是新设置的数据， oldVal 是旧数据\r\n      }\r\n    },\r\n    myProperty2: String // 简化的定义方式\r\n  },\r\n  data: {}, // 私有数据，可用于模板渲染\r\n\r\n  lifetimes: {\r\n    // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\r\n    attached() { },\r\n    moved() { },\r\n    detached() { },\r\n  },\r\n\r\n  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\r\n  attached() { }, // 此处attached的声明会被lifetimes字段中的声明覆盖\r\n  ready() { },\r\n\r\n  pageLifetimes: {\r\n    // 组件所在页面的生命周期函数\r\n    show() { },\r\n    hide() { },\r\n    resize() { },\r\n  },\r\n\r\n  methods: {\r\n    onMyButtonTap() {\r\n      this.setData({\r\n        // 更新属性和数据的方法与更新页面数据的方法类似\r\n      })\r\n    },\r\n    // 内部方法建议以下划线开头\r\n    _myPrivateMethod() {\r\n      // 这里将 data.A[0].B 设为 'myPrivateData'\r\n      this.setData({\r\n        'A[0].B': 'myPrivateData'\r\n      })\r\n    },\r\n    _propertyChange(newVal, oldVal) {\r\n\r\n    }\r\n  }\r\n\r\n})\r\n复制代码在上面的代码中我们可以通过properties和setData结合实现动态设置数据，在methods中可以定义方法，用于给外部调用，也就是组件间的通信。\r\n组件间通信\r\n\r\n可以通过triggerEvent或者直接获取组件this.selectComponent示例来调用方法和属性。\r\n\r\n\r\ntriggerEvent\r\n父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。\r\n\r\n\r\n\r\n开始使用组件\r\n在页面的json文件中配置组件的路径，如下：\r\n{\r\n  \"usingComponents\": {\r\n    \"navbar\": \"/components/navbar/index\",\r\n    \"tabbar\": \"/components/tabbar/tabbar\"\r\n  }\r\n}\r\n复制代码在页面的wxml布局中添加，如下：\r\n// 引入组件\r\n<navbar navbar-data='{{nvabarData}}'></navbar>\r\n// 内容\r\n<view class=\"home-page\">\r\n  <view style='margin-top: {{height}}px;margin-bottom:10px;'></view>\r\n</view>\r\n// 引入组件\r\n<tabbar tabbar=\"{{tabbar}}\"></tabbar>\r\n复制代码自定义 tabBar 组件分析\r\n\r\n看文章顶部原作者的分析。下面介绍一些坑。\r\n\r\n\r\n\r\n虽然在组件的js文件中已经设置了tabbar 但是在app.json中还是需要配置tabbar，详细配置可看文章顶部github链接。\r\n\r\n\r\n在页面的onload中还需要再设置一次\r\n\r\n\r\nwx.hideTabBar({\r\n    })\r\n复制代码因为从分享页面点击左上角的首页图标回到首页会出现两个tabbar，所以在首页还需要再隐藏一次tabbar.\r\n\r\n注意路径问题，新版的开发工具components文件应该在miniprogram下，和pages为同级，否则在引入组件的路径中可能会出错。\r\n\r\n自定义 navBar 组件分析\r\n小程序中分享出去的页面是没有返回按钮的，为了用户能够再次回到我们的小程序中，我们在 navbar 上自定义了一个返回按钮和返回首页的按钮。\r\n这里通过小程序的场景值和使用一个全局的变量share来判断是否是从分享页面进来。在 app.js中做了处理：\r\n// 判断是否由分享进入小程序\r\n    if (options.scene == 1007 || options.scene == 1008) {\r\n      this.globalData.share = true\r\n    } else {\r\n      this.globalData.share = false\r\n    };\r\n复制代码为了适配顶部的高度，在wxml布局中还动态设置了一个margin-top的高度，这个高度通过获取系统的状态栏高度得到。\r\n getSystemInfo: function () {\r\n    let t = this;\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        // 获取高度\r\n        t.globalData.height = res.statusBarHeight;\r\n      }\r\n    });\r\n  },\r\n复制代码然后在页面的data中设置组件的数据和状态栏的高度：\r\ndata: {\r\n    // 组件所需的参数\r\n    nvabarData: {\r\n      showCapsule: 0, //是否显示左上角图标   1表示显示    0表示不显示\r\n      title: '让故事发生', //导航栏 中间的标题\r\n    },\r\n    // 此页面 页面内容距最顶部的距离\r\n    height: app.globalData.height * 2 + 20,\r\n    // tabbar\r\n    tabbar: {},\r\n  },\r\n复制代码原作者在实现图标的显示和隐藏部分逻辑和我的预期不一致，我想实现的是从分享页面进入才显示左上角的返回首页图标，正常也就只显示返回按钮。修改点后的wxml如下：\r\n      <view bindtap='_navback' wx:if='{{!share}}'>\r\n        <image src='/images/back.png' mode='aspectFill' class='back-pre'></image>\r\n      </view>\r\n// 这里把 share 取反去掉\r\n      <view class='navbar-v-line' wx:if='{{share}}'></view>\r\n// 这里把  share 取反去掉\r\n      <view bindtap='_backhome'  wx:if='{{share}}'>\r\n        <image src='/images/icon/icon_home.png' mode='aspectFill' class='back-home'></image>\r\n      </view>\r\n复制代码本文完~，喜欢就点个赞呗"}
{"title": "微信小程序-锚点定位 ", "author": "Rolan", "pub_time": "2019-1-25 00:32", "article_content": "引言：在商品详情页面，一般会有商品图显示、商品主要信息、评价、商品详情等，这时候最好是在最上面加上导航，点击导航定位到对应的页面位置，比如京东的商品详情页面对于一般的PC端网页，只需要使用 <a href=\"#element_Id\"> ，然后在地址栏最后加上#element_Id，就能很方便的跳转到该元素的位置。那么，微信小程序该怎样解决呢？解决思路查找微信小程序的开发文档，发现可以使用scroll-view组件中的属性scroll-into-view实现重点将page的高度设置为100%；导航下面的内容部分必须用 <scroll-view> 包起来设置scroll-view的高度=屏幕的高度-导航的高度设置scroll-view的属性 scroll-into-view=\"{{toView}}\"设置scroll-view的属性 scroll-y=\"true\"设置锚点 <view id=\"position1\">注意：第4、5步不能换位置，一定是scroll-into-view在scroll-y的前面上代码WXNL<view class=\"navigateBox\">\r\n    <view @tap=\"toViewClick\" data-hash=\"productBox\" class=\"title {{toView=='productBox' ? 'checked':''}}\">\r\n      <image wx:if=\"{{toView=='productBox'}}\" src=\"../images/position.jpg\"/>商品</view>\r\n    <view @tap=\"toViewClick\" data-hash=\"commentBox\" class=\"title {{toView=='commentBox' ? 'checked':''}}\">\r\n      <image wx:if=\"{{toView=='commentBox'}}\" src=\"../images/position.jpg\"/>评价</view>\r\n    <view @tap=\"toViewClick\" data-hash=\"infoBox\" class=\"title {{toView=='infoBox' ? 'checked':''}}\">\r\n      <image wx:if=\"{{toView=='infoBox'}}\" src=\"../images/position.jpg\"/>详情</view>\r\n</view>\r\n\r\n<scroll-view style=\"height:{{winHeight}}\" scroll-into-view=\"{{toView}}\" scroll-y=\"true\">\r\n    <view id=\"productBox\">商品图</view>\r\n    <view id=\"commentBox\">商品评价</view>\r\n    <view id=\"infoBox\">商品详情</view>\r\n</scroll-view>\r\n复制代码JSdata = {\r\n    winHeight: '100%',\r\n    toView: 'productBox',//锚点跳转的ID\r\n}\r\nonLoad(){\r\n    let that = this;\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        //屏幕的宽度/屏幕的高度 = 微信固定宽度(750)/微信高度\r\n        that.winHeight = res.windowHeight-(res.windowWidth*90/750)+'px';//90为导航的告诉80+10(margin-bottom)\r\n      }\r\n    });\r\n}\r\nmethods = {\r\n    toViewClick: function (e) {\r\n      this.toView = e.target.dataset.hash;\r\n    }\r\n}\r\n复制代码WXSS<style lang=\"less\">\r\n\r\n  page{\r\n    height: 100%;\r\n  }\r\n\r\n  .navigateBox{\r\n    background: #fff;\r\n    height: 80rpx;\r\n    padding: 0 100rpx;\r\n    margin-bottom: 10rpx;\r\n\r\n    .title{\r\n      margin: 20rpx 46rpx;\r\n      float: left;\r\n      font-size: 27rpx;\r\n      width: 60rpx;\r\n      padding-left: 30rpx;\r\n    }\r\n\r\n    image{\r\n      width: 30rpx;\r\n      height: 30rpx;\r\n      margin-left: -30rpx;\r\n    }\r\n\r\n    .checked{\r\n      color: #f73c3c;\r\n    }\r\n  }\r\n复制代码"}
{"title": "小程序从手动埋点到自动埋点 ", "author": "Rolan", "pub_time": "2019-1-25 00:52", "article_content": "前言\r\n小程序由于封闭性较强，要像web应用一样实现灵活的数据收集，会有一定难度。目前开源的埋点SDK，一般采用手动埋点的方式，这种方式有较强的侵入型，为了解决这个问题就有了该文章。\r\n手动埋点\r\n以腾讯移动分析的SDK为例，如果要记录埋点信息，只要插入一句代码即可\r\n// 例如，记录搜索行为\r\nsearch(keyword) {\r\n   if (keyword) {\r\n       ...业务代码\r\n   }\r\n   mta.Event.stat(\"ico_search\", {\"query\":keyword});\r\n}\r\n复制代码示例代码看起来是比较简洁的，但是埋点需要收集的数据往往不是单一的，复杂的埋点代码插入业务代码，会影响代码的阅读体验，而且埋点代码散落在各个地方，不方便管理。\r\n由于手动埋点必须插入到函数中，有时候我们为了获取页面某一元素点击信息，产生了一种叫无业务相关埋点，简单来说就是你的函数定义，就只有埋点代码，当这种埋点频繁出现，代码会被严重污染。\r\n// wxml\r\n<view bindtap=\"track\">这只是一个展示view</view>\r\n\r\n//js \r\ntrack() {\r\n  mta.Event.stat(\"eleClick\", {\"name\":xxxxx});\r\n}\r\n复制代码另外，由于PM会频繁调整埋点信息，而埋点是一个繁琐又无聊的工作，基于Don't Repeat Yourself 原则，手动埋带要不得。\r\n总结以上，手动埋点有下列问题\r\n\r\n影响代码的阅读体验\r\n埋点代码散落在各个地方，不方便管理\r\n代码会被污染\r\n埋点是一个繁琐又无聊的工作\r\n\r\n自动埋点\r\n实现思路：监听用户点击-->读取埋点配置JOSN，判断是否需要上报--> 上报数据\r\n1、小程序监听用户点击行为\r\nweb应用监听用户点击行为是比较容易，但是小程序没有提供Dom的事件监听，不过我们可以通过事件冒泡的方式捕获。\r\n// web监听页面点击\r\ndocument.addEventListener('click',(e) => {console.log(e)})\r\n\r\n// 小程序监听页面点击，用户的点击行为都会执行elementTracker方法\r\n<view catchtap='elementTracker'>\r\n  <view class='buy-now'>\r\n     <button bindtap='buy' animation=\"{{scaleAnim}}\">立即购票</button>\r\n  </view>\r\n</view>\r\n复制代码2、判断点击位置是否落在监听元素中\r\n假设需要监听用户是否点击class为buy-now元素，可以通过获取buy-now元素长宽，定位和点击位置坐标判断是否出现重叠，以判断是否被点击。\r\n/**\r\n * 判断点击是否落在目标元素\r\n * @param {Object} clickInfo 用户点击坐标\r\n * @param {Object} boundingClientRect 目标元素信息\r\n * @param {Object} scrollOffset 页面位置信息\r\n * @returns {Boolean}\r\n */\r\nexport const isClickTrackArea = function (clickInfo, boundingClientRect, scrollOffset) {\r\n    if (!boundingClientRect) return false;\r\n    const { x, y } = clickInfo.detail; // 点击的x y坐标\r\n    const { left, right, top, height } = boundingClientRect;\r\n    const { scrollTop } = scrollOffset;\r\n    if (left < x && x < right && scrollTop + top < y && y < scrollTop + top + height) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n复制代码3、通过配置表声明埋点\r\n为了解决代码入侵问题，可以将所有埋点信息统一管理，通过配置表的方式，除了方便管理，以后还可以做到动态配置，在服务端配置完毕下发到客户端。\r\nconst tracks = {\r\n  path: 'pages/film/detail',\r\n  elementTracks: [\r\n    {\r\n      element: '.buy-now',  // 声明需要监听的元素\r\n      dataKeys: ['film.filmId'], // 声明需要获取Data下的哪些数据\r\n    },\r\n  ]\r\n};\r\n复制代码4、对页面函数埋点\r\n有些场景我们除了对页面元素点击埋点，还要对页面函数进行埋点，例如用户下拉刷新的时候，可以对原方法进行包装，插入埋点代码。\r\n rewritePage() {\r\n    const originPage = Page;\r\n    Page = (page) => {\r\n      Object.keys(page).forEach((methodName) => {\r\n       // 执行埋点逻辑\r\n        typeof page[methodName] === 'function' && this.recordPageFn(page, methodName);\r\n      });\r\n      // 执行原Page对象\r\n      return originPage(page);\r\n    };\r\n  }\r\n复制代码最后\r\n完整的代码已经封装成SDK了，可以快速集成到项目\r\ngithub.com/zhengguoron…"}
{"title": "分享一款拥有历史搜索记录的微信小程序搜索框--wx-search-have-history ... ", "author": "Rolan", "pub_time": "2019-1-28 00:12", "article_content": "wx-search-have-history一款拥有历史搜索记录的微信小程序搜索框wx-search-have-history使用前提：使用此组件需要依赖小程序基础库 2.2.1 或以上、及开发者工具 1.02.1808300 或以上，同时依赖开发者工具的 npm 构建。具体详情可查阅微信小程序 npm 支持文档。使用效果1、 通过输入进行搜索2、清除单个（全部）历史搜索记录3、点击历史搜索记录进行搜索PS：若想要获得上图中的效果，可参考 test/demo 中的例子实现。使用方法1、 安装 wx-search-have-historynpm install --save wx-search-have-history2、 在需要使用 wx-search-have-history 的页面 page.json 中添加 wx-search-have-history 自定义组件配置{\r\n  \"usingComponents\": {\r\n    \"searchHaveHistory\": \"wx-search-have-history\"\r\n  }\r\n}3、 WXML 文件中引用 wx-search-have-history：调用history组件的同时，需要在调用wx-search-have-history的页面page.js绑定事件接收搜索值（bind:searchEvent=\"searchEvent\"），且须在searchEvent函数里调用wx.hideLoding()，可参考 test/demo/pages/index/index.js 中的例子。<searchHaveHistory id=\"history\"\r\n    bind:searchEvent=\"searchEvent\">\r\n</searchHaveHistory>wx-search-have-history的属性介绍如下：在调用组件的时候，id必须填写且唯一。因为此id作为本地缓存的key值。注意事项在调用wx-search-have-history的页面page.js需绑定事件接收搜索值（bind:searchEvent=\"searchEvent\"），且须在searchEvent函数里调用wx.hideLoding(),可参考 test/demo/pages/index/index.js 中的例子。项目地址：github传送门这是我第一次尝试，如有不当或需改进之处，请君指出，感谢万分！！！"}
{"title": "小程序第三方框架对比 ( wepy / mpvue / taro ) ", "author": "Rolan", "pub_time": "2019-1-28 00:23", "article_content": "众所周知如今市面上端的形态多种多样，手机Web、ReactNative、微信小程序, 支付宝小程序, 快应用等,每一端都是巨大的流量入口，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。但面对目前市面上成熟的小程序第三方框架如何针对自己的需求进行选择也是一个麻烦事,本文针对当前市面上的三大转译框架进行一个综合对比,希望能对大家的技术选择有所帮助,如有哪里不妥的地方希望指正;在这里我通过对目前已开源的三种常用小程序框架做一个综合对比, 还有一个叫nanchi的基于react的小程序转译框架,由于没来的及研究暂不做比较;WEPY tencent.github.io/wepy/docume…腾讯团队开源的一款类vue语法规范的小程序框架,借鉴了Vue的语法风格和功能特性,支持了Vue的诸多特征，比如父子组件、组件之间的通信、computed属性计算、wathcer监听器、props传值、slot槽分发，还有很多高级的特征支持：Mixin混合、拦截器等;WePY发布的第一个版本是2016年12月份，也就是小程序刚刚推出的时候，到目前为止，WePY已经发布了52个版本, 最新版本为1.7.2;MpVue mpvue.com/mpvue/#-htm…美团团队开源的一款使用 Vue.js 开发微信小程序的前端框架。使用此框架，开发者将得到完整的 Vue.js 开发体验，同时为 H5 和小程序提供了代码复用的能力。mpvue在发布后的几天间获得2.7k的star,上升速度飞起,截至目前为止已经有13.7k的star;Tarotaro.aotu.io/京东凹凸实验室开源的一款使用 React.js 开发微信小程序的前端框架。它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用 JSX 语法，让代码具有更丰富的表现力，使用 Taro 进行开发可以获得和 React 一致的开发体验。,同时因为使用了react的原因所以除了能编译h5, 小程序外还可以编译为ReactNative;生命周期同为vue规范的mpvue和wepy的生命周期和各种方法不尽相同wepywepy生命周期基本与原生小程序相同,再此基础上糅合了一些vue的特性; 对于WePY中的methods属性，因为与Vue中的使用习惯不一致，非常容易造成误解，这里需要特别强调一下：WePY中的methods属性只能声明页面wxml标签的bind、catch事件，不能声明自定义方法，这与Vue中的用法是不一致的。 `import wepy from 'wepy';export default class MyPage extends wepy.page { // export default class MyComponent extends wepy.component { customData = {} // 自定义数据customFunction () {}  //自定义方法\r\n\r\nonLoad () {}  // 在Page和Component共用的生命周期函数\r\n\r\nonShow () {}  // 只在Page中存在的页面生命周期函数\r\n\r\nconfig = {};  // 只在Page实例中存在的配置数据，对应于原生的page.json文件\r\n\r\ndata = {};  // 页面所需数据均需在这里声明，可用于模板数据绑定\r\n\r\ncomponents = {};  // 声明页面中所引用的组件，或声明组件中所引用的子组件\r\n\r\nmixins = [];  // 声明页面所引用的Mixin实例\r\n\r\ncomputed = {};  // 声明计算属性（详见后文介绍）\r\n\r\nwatch = {};  // 声明数据watcher（详见后文介绍）\r\n\r\nmethods = {};  // 声明页面wxml中标签的事件处理函数。注意，此处只用于声明页面wxml中标签的bind、catch事件，自定义方法需以自定义方法的方式声明\r\n\r\nevents = {};  // 声明组件之间的事件处理函数\r\n复制代码}`mpvuempvue 除了 Vue 本身的生命周期外，还兼容了小程序生命周期，这部分生命周期钩子的来源于微信小程序的 Page， 除特殊情况外，不建议使用小程序的生命周期 钩子。简单示例taro与react生命周期完全相同列表渲染在列表渲染上三者也分别有不同的应用方法wepy当需要循环渲染WePY组件时(类似于通过wx:for循环渲染原生的wxml标签)，必须使用WePY定义的辅助标签mpvue使用v-for与vue一致,只是需要注意一点，嵌套列表渲染，必须指定不同的索引！taro的列表循环用法基本与react相同,有一点需要注意,在 React 中，JSX 是会编译成普通的 JS 的执行，每一个 JSX 元素，其实会通过 createElement 函数创建成一个 JavaScript 对象（React Element），因此实际上你可以这样写代码 React 也是完全能渲染的：但是 Taro 中，JSX 会编译成微信小程序模板字符串，因此你不能把 map 函数生成的模板当做一个数组来处理。当你需要这么做时，应该先处理需要循环的数组，再用处理好的数组来调用 map 函数。例如上例应该写成：事件处理mpvue目前全支持小程序的事件处理器,引入了 Vue.js 的虚拟 DOM ，在前文模版中绑定的事件会被挂在到 vnode 上，同时 compiler 在 wxml 上绑定了小程序的事件，并做了相应的映射，所以你在真实点击的时候通过 runtime 中 handleProxy 通过事件类型分发到 vnode 的事件上，同 Vue 在 WEB 的机制一样，所以可以做到无损支持。同时还顺便支持了自定义事件和 $emit 机制事件映射表，左侧为 WEB 事件，右侧为 小程序 对应事件**click** : 'tap',<br>\r\n**touchstart**: 'touchstart',<br>\r\n**touchmove**: 'touchmove',<br>\r\n**touchcancel**: 'touchcancel',<br>\r\n**touchend**: 'touchend',<br>\r\n**tap**: 'tap',<br>\r\n**longtap**: 'longtap',<br>\r\n**input**: 'input',<br>\r\n**change**: 'change',<br>\r\n**submit**: 'submit',<br>\r\n**blur**: 'blur',<br>\r\n**focus**: 'focus',<br>\r\n**reset**: 'reset',<br>\r\n**confirm**: 'confirm',<br>\r\n**columnchange**: 'columnchange',<br>\r\n**linechange**: 'linechange',<br>\r\n**error**: 'error',<br>\r\n**scrolltoupper**: 'scrolltoupper',<br>\r\n**scrolltolower**: 'scrolltolower',<br>\r\n**scroll**: 'scroll'<br>\r\n复制代码踩坑注意(官方文档)：列表中没有的原生事件也可以使用例如 bindregionchange 事件直接在 dom 上将bind改为@ @regionchange,同时这个事件也非常特殊，它的 event type 有 begin 和 end 两个，导致我们无法在handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 <map @regionchange=\"functionName\" @end=\"functionName\" @begin=\"functionName\">小程序能力所致，bind 和 catch 事件同时绑定时候，只会触发 bind ,catch 不会被触发，要避免踩坑。事件修饰符 .stop 的使用会阻止冒泡，但是同时绑定了一个非冒泡事件，会导致该元素上的 catchEventName 失效！ .prevent 可以直接干掉，因为小程序里没有什么默认事件，比如submit并不会跳转页面 .capture 支持 1.0.9 .self 没有可以判断的标识 .once 也不能做，因为小程序没有 removeEventListener, 虽然可以直接在 handleProxy 中处理，但非常的不优雅，违背了原意，暂不考虑其他 键值修饰符 等在小程序中压根没键盘，所以。。。wepy事件绑定区别于vue,根据原生小程序事件提供了语法优化绑定事件bindtap=\"click\" 替换为 @tap=\"click\"，取消冒泡原catchtap=\"click\"替换为@tap.stop=\"click\"。捕获监听事件capture-bind:tap=\"click\" 替换为 @tap.capture=\"click\"，中断捕获监听capture-catch:tap=“click\"替换为 @tap.capture.stop=\"click\"。Taro 元素的事件处理和 DOM 元素的很相似。但是有一点语法上的不同:Taro 事件绑定属性的命名采用驼峰式写法，而不是小写。 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串 (DOM 元素的写法)。 例如，传统的微信小程序模板：Taro 中稍稍有点不同：在 Taro 中另一个不同是你不能使用 catchEvent 的方式阻止事件冒泡。你必须明确的使用 stopPropagation。例如，阻止事件冒泡你可以这样写：request请求wepy对wx.request做了接受参数的修改,值得一提的是它提供了针对全局的intercapter拦截器拦截器taro对request进行了二次封装,可以使用Taro.request(OBJECT)发起网络请求，支持 Promise 化使用。mpvue没有对request做特殊优化,与原生相同,可以自己根据需要进行封装"}
{"title": "小程序点睛之三：才不是你想的那种组件 ", "author": "Rolan", "pub_time": "2019-1-28 00:37", "article_content": "小程序点睛系列写到第三篇，我才在昨夜临睡前想到这个名字。官方文档讲过的东西我不重复，我只在你会写的基础上，帮你画上点睛一笔。这一篇，是我与小程序鏖战半年苦心孤诣的成果，满满干货。自定义组件从基础库 1.6.3 开始支持，用来抽象功能组件，以便在多个页面复用。如果你有 React 或 Vue等前端类库的开发经验，对自定义组件一定不会陌生。小程序吸收了 Vue 的模板语法， React 的状态管理方式，再加上 Web Component 的 Shadow DOM 残缺版本，总之就是一边抄一点，形成了独具特色的小程序风格组件。这使得你之前在其它类库上获得的经验不能完全适用。接下来，我们就一起聊聊小程序组件的奇技淫巧。JavaScript 部分小程序将组件数据分为父组件传递来的 properties 和自身持有的 data ，这点与主流前端框架类似，我们重点关注 properties 。组件的 property 接收 type 、 value 、 observer 三个参数type: 属性类型，目前支持 String , Number , Boolean , Object , Array , null从 .wxml 传递过来的值到 .js 之前会先经过类型转换。如果想传递混合类型值（如既可能是String 也可能是 Number 的值），可以将 type 设置为 null ，可以避免默认的类型转换。value: 默认值如果不设置 value 的值，那该 property 的默认值就是其类型的零值。对应如下：String => ''\r\nNumber => 0\r\nBoolean => false\r\nObject => {}\r\nArray => []\r\nnull => null\r\n复制代码observer: 属性被改变后执行的函数由于小程序自身不支持 watch ，故而无法监听 data 中某一项的改变。但与 React 不同的是，组件的 properties 在组件运行时会被整合入 data 中，通过 this.data 获取，并且可以调用 this.setData 改动 properties 的值。 因此可以将需要监听的 data 放于 properties 中，利用 observer 监听。同时，为表示其为内部状态，建议以下划线（_）开头，且不再外部设置其值。observer 还可以用来减少 .wxml 模板的重复代码。例如父组件传递了一个 source 对象，要求组件显示其姓名与年龄// component.js\r\nComponent({\r\n    properties: {\r\n        source: Object,\r\n    }\r\n})\r\n复制代码<!-- component.wxml -->\r\n<view>{{ source.name }}</view>\r\n<view>{{ source.age }}</view>\r\n复制代码利用 observer 可以写成// component.js\r\nComponent({\r\n    properties: {\r\n        source: {\r\n            type: Object,\r\n            observer(val) {\r\n                this.setData(val)\r\n            }\r\n        }\r\n    }\r\n})\r\n复制代码<!-- component.wxml -->\r\n<view>{{ name }}</view>\r\n<view>{{ age }}</view>\r\n复制代码这对体量较大的组件犹为有效。同时，将 source 封装为 behavior ，可以最大限度的减少冗余代码// sourceBehavior.js\r\nexport default Behavior({\r\n\tproperties: {\r\n        source: {\r\n            type: Object,\r\n            observer(val) {\r\n                this.setData(val)\r\n            }\r\n    }\r\n  }\r\n})\r\n\r\n// component.js\r\nimport sourceBehavior from 'path/to/sourceBehavior.js'\r\n\r\nComponent({\r\n    behaviors: [sourceBehavior]\r\n})\r\n复制代码WXML 部分.wxml 模块与 Vue 模板大同小异，唯一值得了解的是由于小程序不完全实现了 Shadow DOM ，Vue 中 <template> 标签只能有一个根节点的限制是不存在的。因此在大多数情况下，你都不需要给 .wxml 额外添加根节点。<!-- good.wxml -->\r\n<view>{{ name }}</view>\r\n<view>{{ age }}</view>\r\n\r\n<!-- bad.wxml -->\r\n<view>\r\n\t<view>{{ name }}</view>\r\n    <view>{{ age }}</view>\r\n</view>\r\n复制代码WXSS 部分inherit 关键字我们可以通过将属性值设置为 inherit 来有效减少代码冗余。如果你想保持节点属性与父节点一致，就应当使用这个关键字。回想一下 小程序点睛之二：小程序使用 Iconfont 的正确姿势 ，默认 Iconfont 下载的 CSS 文件中定义了 .iconfont 类的字体大小为 16px ，如果你不想每次更新改动这一值，那么可以在组件样式表中添加.iconfont {\r\n    font-size: inherit;\r\n}\r\n复制代码组件样式表的优先级要高过外部引入的样式表，所以原本的 font-size: 16px 就会被覆盖， .iconfont 的字体大小就会跟其父节点一致。注意：这里 .iconfont 的父节点并不是逻辑上的父节点，而是 shadow-root 。:host 选择器你可以在开发者工具中看到每个自定义组件的 shadow-root ，其默认是行内元素，你可以在组件样式表中通过 :host 选择器修改它的样式:host {\r\n    display: block;\r\n    background: red;\r\n}\r\n复制代码外部样式表所有的属性都是直接作用在 shadow-root （而非模板中的根节点）上，例如<!-- iconfont.wxml -->\r\n<text class=\"iconfont icon-{{icon}}\"></text>\r\n\r\n<!-- page.wxml -->\r\n<iconfont class=\"icon\" icon=\"upload\"></iconfont>\r\n复制代码/* page.wxss */\r\n.icon {\r\n    color: green;\r\n}\r\n\r\n/* iconfont.wxml */\r\n.iconfont {\r\n    color: red;\r\n}\r\n复制代码你会发现图标的颜色是红色而不是绿色。因为 .icon 是样式作用于 shadow-root ， .iconfont 是其子节点，继承其 color 属性，但由于 .iconfont 优先级更高，所以颜色是为红色。优先级关系为 :host 选择器 < 外部样式 < 子节点样式。利用这个特点，配合 CSS 变量，可以达到意想不到的效果。CSS 变量现阶段支持各浏览器的支持度并不高，版本稍旧的浏览器就会遇到问题。但小程度已经完全支持了这个特性。由于小程序使用了 Shadow DOM ，因此在组件内是无法使用全局定义的样式类的。 但是 ，CSS 是可继承并且是全局可用的。因此，我们可以将常用的样式定义在 app.wxss 内，并在任意页面或组件内使用/* app.wxss */\r\npage {\r\n    --primary-color: #aabbcc;\r\n    --accent-color: #ddeeff;\r\n    --spacing: 32rpx;\r\n}\r\n\r\n/* other.wxss */\r\n.component {\r\n    background: var(--primary-color);\r\n    padding: var(--spacing);\r\n}\r\n复制代码如此，你只需要对 app.wxss 稍作修改，就可以改变整个小程序样式。除此之外，我们还可以利用这个特性，优化组件定义。例如，我们需要一个圆形组件，常规的做法是定义相等的宽高，再设定 border-radius: 50% 。我们来看看高级的写法/* circle.wxss */\r\n:host {\r\n    /* 默认直径为 32rpx */\r\n    --diameter: 32rpx;\r\n    \r\n    width: var(--diameter);\r\n    height: var(--diameter);\r\n    border-radius: 50%;\r\n}\r\n\r\n/* outer.wxss */\r\n.circle {\r\n    /* 将 circle 组件的直径设置为 64rpx */\r\n    --diameter: 64rpx;\r\n}\r\n复制代码还记得我刚刚说的优先级规则吗？外部样式的优先级高于 :host 选择器，因此 circle 组件的直径会被设置为 64rpx 。不只如此，通过自定义属性，我们还可以修改嵌套较深的组件样式<!-- component.wxml -->\r\n<view class=\"this\">\r\n\t<view class=\"is\">\r\n    \t<view class=\"a\">\r\n        \t<view class=\"embed-component\"></view>\r\n        </view>\r\n    </view>\r\n</view>\r\n复制代码/* component.wxss */\r\n:host {\r\n    --embed-color: red;\r\n}\r\n\r\n.embed-component {\r\n    color: var(--embed-color);\r\n}\r\n\r\n/* outer.wxss */\r\n.component {\r\n    --embed-color: blue;\r\n}\r\n复制代码Bingo，借助 CSS 属性，我们获得了改动后代节点样式的能力。你大可以说同样的功能使用 externalClasses 或者 addGlobalClass 也可以做到。但是对于组件来说，外部传入的样式可知，处理起来心智负担更小，更符合 高内聚，低耦合 的标准。同时，建议将可改动的自定义 CSS 变量以注释的形式写在 component.js 中，方便其他人理解你的组件。用 em 而不是 rpx为了保持组件可扩展性，应当尽可能的使用 em 作为字体大小单位。我之前用一个小程序解析markdown 的组件库，其中将所有字体大小都写死为 rpx ，例如/* markdown.wxss */\r\n.h1 {\r\n    font-size: 32rpx;\r\n}\r\n\r\n.h2 {\r\n    font-size: 28rpx;\r\n}\r\n\r\n.h3 {\r\n    font-size: 24rpx;\r\n}\r\n复制代码如此固然能实现需求，但却失去了外部改变字体大小的能力。作为一个组件，应该适应更多的可能性，改为 em 作为字体大小单位就能很好的解决这一问题.h1 {\r\n    font-size: 2em;\r\n}\r\n\r\n.h2 {\r\n    font-size: 1.8em;\r\n}\r\n\r\n.h3 {\r\n    font-size: 1.4em;\r\n}\r\n复制代码数值仅为举例大胆使用新特性小程序对 CSS 3 新特性的支持比较完善， vw ， vh ， flex ， calc ，CSS variables 等等只要你想到，你可以大胆地使用，完全不需要考虑兼容性问题，这简直就是前端梦寐以求的试验田。所以，好好学习，大胆使用吧！后记写了这么多，自己都忘了要写些什么。本来是准备日更的，但是这两天一直在忙社保的事。刚刚从公司离职，办理灵活就业人员耽误了不少时间。感谢各位耐心阅读至此，这都是我工作半年以来的经验之谈，希望可以对你们有一点帮助。如果你也想发布小程序的组件， 官方模板 虽不失为一个选择，但我也要强推一下我写的脚手架工具 tacer ，只需一行 npx tarcer wx-component 就可以开始你的项目了哦！小程序点睛系列还剩下一篇，最后一篇，我们单纯聊 JavaScript ，关注我哟。"}
{"title": "微信小程序---分包加载（SUBPACKAGES）及报错 ", "author": "Rolan", "pub_time": "2019-1-30 00:36", "article_content": "某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。分包很简单，具体步骤如下：在app.json中，创建subPackages，root表示分包A的根目录（eg.跟pages同级目录），pages中的页面就是分包A的子目录。 注意：这里有一点要注意，经常出现这个问题“pages *** 不应该在分包 subPackages[*] 中” 我们如果通过编辑器右键添加page的话，主包中会自动加入page路径，此时我们再去创建新的分包如果没有去掉主包路径就会报错。解决方案就是去掉主包中的路径就可以了 {\r\n  \"pages\": [\r\n    \"pages/success/success\",\r\n    \"pages/fail/fail\"\r\n  ],\r\n  \"window\": {\r\n    \"backgroundTextStyle\": \"light\",\r\n    \"navigationBarBackgroundColor\": \"#f37938\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\": \"white\"\r\n  },\r\n  \"tabBar\": {\r\n    \"color\": \"#999999\",\r\n    \"selectedColor\": \"#f37938\",\r\n    \"borderStyle\": \"black\",\r\n    \"backgroundColor\": \"#ffffff\",\r\n    \"font-size\": \"50rpx\",\r\n    \"list\": [\r\n      {\r\n        \"pagePath\": \"tabbar/xxx/xxx\",\r\n        \"iconPath\": \"../../images/icon_home.png\",\r\n        \"selectedIconPath\": \"../../images/icon_home2.png\",\r\n        \"text\": \"首页\"\r\n      },\r\n      {\r\n        \"pagePath\": \"tabbar/xxx/xxx\",\r\n        \"iconPath\": \"../../images/icon_mine.png\",\r\n        \"selectedIconPath\": \"../../images/icon_mine2.png\",\r\n        \"text\": \"我的\"\r\n      }\r\n    ]\r\n  },\r\n  \"subPackages\": [\r\n    {\r\n      \"root\": \"A/\",\r\n      \"pages\": [\r\n        \"index/index\",\r\n        \"form/form\"\r\n      ]\r\n    },\r\n    {\r\n      \"root\": \"B/\",\r\n      \"pages\": [\r\n        \"index/index\",\r\n        \"form/form\"\r\n      ]\r\n    }\r\n  ]\r\n}"}
{"title": "微信小程序点击列表添加 去除属性 ", "author": "Rolan", "pub_time": "2019-1-30 00:42", "article_content": "首先说一下场景：我所循环的数据是对象数组，设置了一个属性当作标记，通过这个标记的值判断是否给改元素添加样式wxml：<view>\r\n      <view wx:for=\"{{list}}\" wx:key=\"num\" class=\"list\" >\r\n        <text bindtap='changColor'  data-index='{{index}}' class='{{item.check?\"text-active\":\"\"}}' >| {{item.message}}</text>\r\n      </view>\r\n</view>js：/*　　这里获取list是一个数组对象　　tomorrow: [　　　　{　　　　　　thing: '吃饭',　　　　　　check: false　　　　},　　　　{　　　　　　thing: '睡觉',　　　　　　check: false　　　　},　　　　{　　　　　　　thing: '打豆豆',　　　　　　check: false　　　　}　　]*/changColor: function (e) {\r\n    let index = e.currentTarget.dataset.index\r\n    let arrs = this.data.list;  \r\n    if (arrs[index].check == false) {\r\n      arrs[index].check = true;\r\n    } else {\r\n      arrs[index].check = false;\r\n    }\r\n    this.setData({\r\n      list: arrs\r\n    })\r\n  },核心在于修改对象属性check的值，然后在元素渲染是根据值进行样式的添加"}
{"title": "微信更新小程序“桌面式”入口，生态竞争愈发激烈 ", "author": "Rolan", "pub_time": "2019-1-31 00:01", "article_content": "2019年1月9日-10日，一年一度的微信公开课PRO在广州保利博览馆举行，微信官方在现场公布了小 程序 的最新数据：2018年，微信小程序开发者增加了80%，微信小程序人均周使用的次数增长72%、涵盖200+行业，创造了5000亿+商业价值，服务1000亿+人次，交易金额增长超过6倍，小程序已经深入到了我们生活的方方面面。2019年1月31日，阿拉丁小程序统计平台（aldwx.com）和阿拉丁指数（aldzs.com）共同发布了2019年1月小程序TOP100榜单和1月热点事件盘点。从榜单中我们不难发现，1月小程序生态继续保持健康快速发展，阿拉丁小程序平台创始人&CEO史文禄也对此表示：“‘我的小程序’桌面式入口更新后，给了小程序更多曝光的机会，也会进一步培养用户的认知和使用习惯，用户会慢慢养成从这里获取信息和服务的习惯，小程序的留存必然会得到提高。而且，这也会给中长尾的小程序更多被使用的机会，以此活跃整个小程序池子拉高绝对值。从1月榜单中可以看出视频类小程序快速兴起，用户在小程序中观看短视频的习惯逐步养成，同时有更多的细分行业出现在榜单中，小程序行业分布日趋多元化。”l 微信更新小程序“桌面式”入口1月份微信又做了一次重要更新，在本次发布的7.0.3版本中对首页“小程序下拉菜单栏”进行升级，由之前的下拉后显示“最近使用的小程序”和“我的小程序”两行，变成类似手机系统的全屏展示“我的小程序”则最多可展示50个小程序。对于这次更新，阿拉丁小程序平台创始人&CEO史文禄表示：这标志着小程序的发展进入第三阶段，会推动小程序爆发增长，未来3个月也会推动整个行业的发展，小程序作为一种新的形式，可能承载用户未来五年甚至十年获取信息和服务的场景。它会进一步打通微信的账号体系，连接公众号、支付等服务形成的闭环，而且会建立更强的壁垒和门槛。l 微信小游戏升级未成年人保护能力微信小游戏团队正式升级未成年人保护能力，与腾讯成长守护平台共建“成长守护”体系。小游戏全面接入“成长守护平台”之后，家长可以及时了解到未成年人游戏及消费动态。这一能力将为许多家庭提供有效的游戏行为管理手段和亲子沟通途径。l 微信公众平台小程序信息里现「小程序简称」项开发者可登录微信公众平台小程序-> 设置-> 基本信息-> 小程序简称-> 修改-> 通过管理员扫码验证后即可进入修改页面。小程序发布前有2 次修改机会，发布后仍有一年2 次的修改机会。开发者通过编辑简称，便于用户记忆和识别小程序，有利于用户更顺畅的触达小程序。l 支付宝小程序能力释放1月7日，支付宝宣布在首页腰封位置新增小程序收藏固定入口。用户只要下拉支付宝首页，就能唤出小程序收藏栏，直接启用收藏的小程序服务，以及支付宝小程序支持小程序互相跳转和5项运营推广工具：收藏后专享、推广助手、收藏有礼、分享有礼、会员有礼。本月支付宝赋能小程序动作不断，主要集中在扶持小程序运营者推广能力以及使用户触达小程序的入口更浅。l 阿拉丁1月TOP100榜单发布①1月，由于春运来临，购买火车票类小程序用户量都出现大幅增长，如智行火车票进入榜单前十，携程、高铁管家等也出现大幅增长。②1月上榜的小程序行业分布进一步均衡，TOP100榜单中游戏与网络购物、生活服务小程序的数量占比差距缩小。③视频类小程序快速兴起，用户在小程序中观看短视频的习惯逐步养成。④随着春节的到来，网络购物类小程序将逐步回落，游戏、视频、社交等小程序有望迎来又一轮 高峰 。l 榜单更新率保持在30%以上1月TOP100榜单的更新率为32%，头部小程序继续保持较高的更新速度。新上榜的小程序中游戏数量最高为14个，另外视频类小程序有5个为新上榜。相比12月掉榜的小程序中游戏数量也最多，达到22个。大部分小游戏依然难以持续保持较高的用户访问，用户在小游戏中迁移速度较快，因此小游戏开发者需要加大产品创意，增加小游戏的耐玩度，从而提升用户粘性。除此以外，本次内容发布中还包括2019年1月小程序融资事件，1月网络购物类小程序融资金额仍占据首位，社区团购小程序“邻邻壹”获得3000万美元融资。而服务商“即速应用”和军事内容资讯小程序“军武次位面”也分别获得5000万人民币融资。2018年，微信创造就业岗位超2200万个，其中小程序拉动就业超过180万，较去年增长近80%。随着微信生态日益壮大，围绕小程序、公众平台、企业微信、微信支付聚集了大量开发者、运营者、服务商等生态合作伙伴。未来，阿拉丁小程序统计平台（aldwx.com）和阿拉丁指数（aldzs.com）将会持续开展小程序榜单的综合发展指数研究，从定量的角度勾画出小程序的发展图景，全面展现小程序的现在和未来、常态和创新，推动和引领小程序生态的健康发展。"}
{"title": "微信小程序如何调用后台service的简单记录 ", "author": "Rolan", "pub_time": "2019-1-31 00:24", "article_content": "写在前头，本篇文章简单记录一下，在前后端分离的微信小程序应用中，前端访问后台service的实现思路，没有过多涉及技术实现方面。先上一张官网的图片，它很清楚的讲明了要在后台service为每一个小程序用户提供登录信息需要做哪些事情。用户拿到了后台给的登录凭据，访问后台service。静默授权与非静默授权先来讲讲这两个概念， 静默授权，顾名思义，这授权动作对于用户来说是感知不到的， 小程序端悄咪咪得就做了。因此，没有知会用户的授权方式拿到的信息也是不太重要的。但是，静默授权是开始重要的一步，因为它为接下来的动作提供了code。调用静默授权可用小程序提供的 API:wx.login() 。再来讲讲 非静默授权，顾名思义，它的授权是要有明显动静的，而且它是要得到用户认可才可以执行。 API:wx.getUserInfo() ，这个接口要不要用可根据小程序的实际需求来。后台获取openId小程序提供了一个接口 code2session ，拿着我们静默授权获取到的临时登录凭证code再调用一下这个接口就能获取到openId了。注意，这一步是在后台服务器做的。openId是在当前小程序中对用户唯一性的标识。基于OAuth2.0生成token在后台，可以用SpringSecurity的OAuth2.0这一个工具，用openId来生成前端请求后端数据的附带校验信息token。具体是如何实现的笔者也没有深入了解……获取到了这个token后，前端可将其存入webStorage中，每一次调用后台service的时候，就可以利用请求的拦截器在config参数中加入token。后端就可以确定发送请求的用户身份，保证了系统的安全性。总结：以上大致描绘了小程序后台自定义登录态的开发思路。"}
{"title": "微信小程序使用async/await语法 ", "author": "Rolan", "pub_time": "2019-2-11 00:01", "article_content": "1.在微信小程序项目添加package.json文件或者直接npm init.2.在package.json中添加regenerator包和版本`\"devDependencies\": {\"regenerator\":\"0.13.3\"}`3.微信开发者工具-》工具-》npm构建4.在需要使用async/await语法的文件引入regeneratorRuntimeconst regeneratorRuntime = require('regenerator-runtime')5.使用async/await语法lifetimes: {\r\n    attached:async function(){\r\n      // 在组件实例进入页面节点树时执行\r\n     let data= await req(this.properties.apiType);\r\n     console.log(data)\r\n    },\r\n    detached() {\r\n      // 在组件实例被从页面节点树移除时执行\r\n    },\r\n  },需要注意this的指向，比如生命周期如果用箭头函数会丢失this或者直接这样lifetimes: {\r\n    async attached(){\r\n      // 在组件实例进入页面节点树时执行\r\n     let data= await req(this.properties.apiType);\r\n     console.log(data)\r\n    },\r\n    async detached() {\r\n      // 在组件实例被从页面节点树移除时执行\r\n     \r\n    },\r\n  },"}
{"title": "口袋工具之历史上的今天 - 小程序云开发实战 ", "author": "Rolan", "pub_time": "2019-2-11 00:25", "article_content": "本项目是一个基于云开发的小程序。本文选取项目中的一个页面 -- 历史上的今天 来做一个云开发的分享，会涉及云函数和云数据库。由于是实战项目，关于小程序的基础知识请移步官方文档，本文不再赘述。项目地址github.com/GoKu-gaga/t…项目预览微信搜索： 口袋工具y扫一扫：前期遇到的问题数据来源： 没有数据，寸步难行呀如何解决数据来源编写爬虫将需要的数据爬取并保存下来找一些提供数据的平台，如阿凡达数据、聚合数据等等。由于本人偷懒，所以选择第二种方式，并最终选择了聚合数据平台API。项目开始新建项目新建项目，配置好名称、目录、AppID等信息，后端服务选择 小程序·云开发 ，点击新建。关于AppID: 请自行修改为你注册的小程序AppID。点击新建即可完成项目初始化，得到一个云开发模板：目录结构：+-- cloudfunctions|[指定的环境]  // 存放云函数的目录\r\n  +-- miniprogram                 // 小程序代码编写目录\r\n  |-- README.md                   // 项目描述文件\r\n  |-- project.config.json         // 项目配置文件\r\n复制代码新建云开发环境点击左上角菜单项 云开发点击创建资源环境，环境名称及环境ID请自行设置：点击确定即可完成创建编写云函数1. 新建云函数在目录 cloudfunctions 上右键新建云函数，填入新建云函数的名称（如 todayInHistory ）回车或失去焦点即会自动创建并上传。2. 安装依赖云函数目前执行环境仅支持node，所以需要使用js来编写云函数的逻辑。 在控制台中进入该云函数的目录，执行npm i -S axios\r\n复制代码本项目使用 axios 来执行请求的发送，可以使用其他如 request-promise 等等的库来替换3. 编写云函数新建 config.js 文件，添加代码如下：exports.key = YOUR_JUHE_KEY // 在聚合数据平台申请的key\r\nexports.baseUrl = 'http://v.juhe.cn/todayOnhistory/queryEvent.php'\r\n复制代码打开 index.js 文件，编写代码：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\nconst axios = require('axios')\r\n\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\n// 聚合数据\r\nconst { baseUrl, key } = require('./config')\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  const {\r\n    month,\r\n    day\r\n  } = event\r\n \r\n  const resp = await axios.get(baseUrl, {\r\n    params: {\r\n      key,\r\n      date: `${month}/${day}`\r\n    }\r\n  }).then(res => {\r\n    return res.data\r\n  })\r\n\r\n  return resp.result\r\n}\r\n复制代码编写页面1. 新建页面在开发小程序的过程中，新建一个页面是很常见的操作，有两个非常方便的方式在 app.json 文件中，在pages项添加我们需要的页面路径，直接保存即可。如：\"pages\": [\r\n  \"pages/today-in-history/index\"\r\n]\r\n复制代码在 pages 目录下新建目录 today-in-history ，在新建的目录上右键 -> 新建page， 填入名称如 index , 回车即可完成页面下四个文件的创建2. 编写 index.wxml<!--pages/today-in-history/index.wxml-->\r\n<view class=\"container\">\r\n  <view class=\"header full-width\">\r\n    <view>{{year}}年{{month}}月{{day}}日</view>\r\n  </view>\r\n  <view class=\"content full-width\">\r\n    <view class=\"list-view\">\r\n      <block wx:for=\"{{list}}\" wx:key=\"index\">\r\n        <navigator url=\"{{'/pages/history-detail/index?id=' + item.e_id}}\" class=\"list-item\">\r\n          <view class=\"item-title\">{{item.title}}</view>\r\n          <view class=\"item-date\">{{item.date}}</view>\r\n        </navigator>\r\n      </block>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码3. 编写 index.js// pages/today-in-history/index.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    year: 1990,\r\n    month: 1,\r\n    day: 1,\r\n    list: []\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function() {\r\n    const now = new Date();\r\n    const year = now.getFullYear();\r\n    const month = now.getMonth() + 1;\r\n    const day = now.getDate();\r\n    this.setData({\r\n      year,\r\n      month,\r\n      day\r\n    });\r\n    this.doGetList();\r\n  },\r\n\r\n  /**\r\n   * 执行数据获取\r\n   */\r\n  doGetList: function() {\r\n    const {\r\n      month,\r\n      day\r\n    } = this.data;\r\n    wx.cloud.callFunction({\r\n        name: 'todayInHistory',\r\n        data: {\r\n          month,\r\n          day\r\n        }\r\n      }).then(res => {\r\n        let list = res.result.reverse();\r\n        this.setData({\r\n          list\r\n        });\r\n      })\r\n      .catch(console.error)\r\n  }\r\n})\r\n复制代码4. 编写 index.wxss/* pages/today-in-history/index.wxss */\r\n.container {\r\n  padding-bottom: 20rpx;\r\n  background-color: #E8D3A9;\r\n}\r\n\r\n.header {\r\n  display: flex;\r\n  justify-content: space-around;\r\n  align-items: center;\r\n  height: 80rpx;\r\n  color: #FFF;\r\n}\r\n\r\n.content {\r\n  flex: 1;\r\n}\r\n\r\n.list-view {\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  padding: 0 20rpx;\r\n}\r\n\r\n.list-item {\r\n  display: flex;\r\n  flex-direction: column;\r\n  border-radius: 10rpx;\r\n  padding: 16rpx 0;\r\n  box-sizing: border-box;\r\n  margin-top: 20rpx;\r\n  background-color: #fff;\r\n  text-align: center;\r\n  box-shadow: 1px 1px 5px 1px rgb(207, 207, 207);\r\n}\r\n\r\n.item-title {\r\n  font-size: 36rpx;\r\n  padding: 10rpx 16rpx;\r\n  color: #262626;\r\n  line-height: 48rpx;\r\n}\r\n\r\n.item-date {\r\n  font-size: 24rpx;\r\n  height: 30rpx;\r\n  line-height: 30rpx;\r\n  border-top: 2rpx solid #eee;\r\n  padding: 10rpx 16rpx 0;\r\n  color: #595959;\r\n  margin-top: 6rpx;\r\n}\r\n复制代码补充项目中也使用了部分的有赞的小程序组件库vant-weapp由于聚合数据平台API非会员调用次数有限（100次/天），明显是不太够用的。因此，我们可以考虑在请求到数据时，将数据存在云数据库中，其实也就实现了一个类似爬虫的功能啦。流程如下：代码实现：修改 cloudfunctions/todayInHistory/index.js// ... 省略其他无需改动的代码\r\nexports.main = async(event, context) => {\r\n  const {\r\n    month,\r\n    day\r\n  } = event\r\n\r\n  const ret = await db.collection('todayInHistory').where({\r\n    date: `${month}/${day}`\r\n  }).get()\r\n\r\n  if (ret.data.length > 0) {\r\n    return ret.data[0].result\r\n  }\r\n\r\n  const resp = await axios.get(baseUrl, {\r\n    params: {\r\n      key,\r\n      date: `${month}/${day}`\r\n    }\r\n  }).then(res => {\r\n    return res.data\r\n  })\r\n  \r\n  await db.collection('todayInHistory').add({\r\n    data: {\r\n      date: `${month}/${day}`,\r\n      result: resp.result\r\n    }\r\n  })\r\n\r\n  return resp.result\r\n}\r\n复制代码以上即为 历史上的今天 页面的数据获取及展示，其他页面使用到云开发的模式基本大同小异。结语目前只开发了两个小功能 历史上的今天 和 周公解梦 ，后续会继续开发新的功能，希望可以做成一个小工具集合，这也是 口袋工具 这个名称的由来。感谢各位读者的阅读，由于本人水平有限，文章中如有错误或不妥之处，请不吝赐教！如果你喜欢这篇文章或是这个项目，不妨进去点个Star支持下 today 。"}
{"title": "小程序页面动态配置实现 ", "author": "Rolan", "pub_time": "2019-2-11 11:04", "article_content": "小程序可以根据管理后台配置动态更新展示内容，如实现下面新鲜事栏目图片的来源的可配置，点击跳转url的可配置。实现方案1后端创建一个map结构的数据表，表结构如下：2 管理后台根据不同业务设定不同的key和value，更新数据库如key：ad1url value：a.png如果需要更新页面图片，只需更新ad1url对应的value3 小程序根据对应业务key获取对应的配置项，更新页面显示技术栈后端接口服务：SpringBoot Mybatis MySql管理后台：vue前端：小程序代码实现后端接口为了保证key的唯一性，key在数据库设置为unique属性，新增和更新功能通过以下sql语句实现，主要通过replace into实现配置项的唯一@Insert(\"<script>\"  +\r\n         \"REPLACE INTO `rental`.`t_config`(`key`, `value`) VALUES\" +\r\n         \"<foreach\" +\r\n         \" collection=\\\"list\\\" item=\\\"item1\\\" index=\\\"index\\\"  separator=\\\",\\\">\" +\r\n         \"(#{item1.key}, #{item1.value})\" +\r\n         \"</foreach>\" +\r\n       \"</script>\")\r\n @Options(useGeneratedKeys = true, keyProperty = \"configId\", keyColumn = \"configId\")\r\n复制代码api设计一开始想通过传如list数据给后端实现配置项的批量插入功能，发现后端数据一直接受不到，故而退而求其次，通过json字符串实现vue（网络库使用axios）调用后端接口@ApiOperation(value = \"新增或更新配置列表\")\r\n@RequestMapping(value = \"/add_or_update_config_list\", method = RequestMethod.POST, \r\n                produces =    MediaType.APPLICATION_JSON_UTF8_VALUE)\r\npublic ResponseBean<String> addOrUpdateConfigList(String list) {\r\n    long result =  configService.batchInsertOrUpdate(JSONObject.parseArray(\r\n        list,Config.class));\r\n    ......\r\n}\r\n复制代码管理平台管理平台用vue开发，网络框架采用axios，列表数据通过json字符串传递给后端let config1 = {key: \"ad1Url\", value: this.formData.ad1Url};\r\nlet config2 = {key: \"ad2Url\", value: this.formData.ad2Url};\r\nlet config3 = {key: \"adClick1\", value: this.formData.adClick1};\r\nlet config4 = {key: \"adClick2\", value: this.formData.adClick2};\r\nlet configList = [config1, config2, config3, config4];\r\nlet result = await addConfigList({list: JSON.stringify(co\r\nnfigList)});\r\n......\r\n复制代码小程序小程序调用后端接口返回所有配置项，具体业务根据具体业务key获取配置项getConfigList: function () {\r\n    var that = this;\r\n    wx.request({\r\n      url: constant.HOST + '/config/get_config_list',\r\n      method: 'GET',\r\n      header: {\r\n        'content-type': 'application/json'\r\n      },\r\n      complete: function (res) {\r\n  \r\n      },\r\n      success: function (res) {\r\n        console.log(\"config list response:\" + JSON.stringify(res));\r\n        that.setData({ configList: res.data.data});\r\n      }\r\n    });\r\n },\r\n     \r\ngoAd1: function(){\r\n    wx.navigateTo({\r\n      url: '/pages/webview/webview?url=' + this.data.configList.adClick1\r\n    })\r\n},\r\n\r\n复制代码总结这个功能我在自己的小程序开发过程中设计的页面配置实现思路，主要遇到了两个小问题：1 如果保证key的唯一性 2 前后端批量数据的传输问题；希望能给遇到同样问题的小伙伴一些启示，如果有更好的方案，欢迎一起讨论。"}
{"title": "微信小程序 TypeScript 尝试 ", "author": "Rolan", "pub_time": "2019-2-12 00:08", "article_content": "自从去年开始在项目里写了一段时间 Javascript 后，感觉没有类型检查的语言还是不太适合我，所以一直想尝试下 TypeScript，然而由于项目庞大，人员协作问题，一时半会没办法切成 TypeScript。正好最近有小程序的需求和小程序去年 11 月开始官方支持了 TypeScript，所以拿来练练手。\r\nWhy TypeScript？\r\n大概是我这半年写的 Swift 比较多，而 Swift 中的静态类型和协议是我很喜欢的特性。正好 TypeScript 为 JavaScript 带来了静态类型和接口。\r\n可选的静态类型\r\n“动态类型一时爽，代码重构火葬场“，对于我这种极度喜欢重（xia）构（gai）代码的人来说，JavaScript 毫无类型提示，类型全靠命名猜测是极度不友好的。而 TypeScript 加上了灵活的类型系统，不仅可以编码期检查，还能增强代码的可读性，并提供了 any 类型进行缓冲。\r\n接口\r\n接口和协议，只是不一样的叫法而已，Java、C#、TypeScript 叫 Interface，Swift、Kotlin 叫 Protocol，就是一种规则声明。项目中，和后端接口数据交互，页面传递数据，数据持有，方法代理的地方，有了接口就会更加方便，易重构。TypeScript 的 Interface + JavaScript 简单的对象就让数据构建变得简单又不容易出错。\r\n小程序对 TypeScript 的支持\r\nTypeScript 有一个很重要的东西，就是 d.ts 文件。d.ts 文件其实相当于 C 系语言里面的 .h 头文件，声明了对外暴露的方法和属性。而小程序官方对 TypeScript 的支持，意味着官方会维护小程序本身 API 的 d.ts 文件，也就是 typing 库，这样当 API 发生变动时，就可以即时变更。\r\n使用也很简单，更新微信开发者工具到最新版，在创建新项目时选择 TypeScript 模板。\r\n\r\n创建后，我们可以看到项目里带上了 typings 库，以及 TypeScript 的配置文件 tsconifg。之后，保存时就不会自动编译了，要点击小程序工具栏的编译按钮才可以。\r\n这里有一个坑，笔者电脑安装的 TypeScript 版本是 3.2.2 版本。编译时会被找不到全局类型 CallableFunction 和 NewableFunction。\r\n\r\n解决方法也很简单，到 node_modules 路径下的 TypeScript 包的 bin 目录下，lib.es5.d.ts 文件里面把这两个类型的 Interface 拷贝到，小程序 typing 目录下的 lib.wa.es6.d.ts 里面就可以了。小程序模板里这个文件应该是拷贝 TypeScript 官方的，但没有随着官方升级而改变。\r\n事件\r\n视图的事件，对应的类型笔者在 typings 中并没有看到有 Interface 定义，所以只能暂时用 any，然后自己再用\r\nas 转一下 event 携带的数据的类型。\r\nPage&Data\r\n每个 Page 对象，在 typing 里是这么定义的。\r\ndeclare const Page: Page.PageConstructor\r\n\r\ninterface PageConstructor {\r\n    <D extends IAnyObject, T extends IAnyObject & PageInstance>(\r\n      options: PageInstance<D, T> & T\r\n    ): void\r\n  }\r\n复制代码也就是说，它支持 D 和 T 两个范型。这两个范型是什么呢？小程序里，Page 是这么写的。\r\nPage({});\r\n复制代码也就是说，options 参数就是一个 PageInstance，范型也被传入了。\r\ninterface PageInstance<D extends IAnyObject = any, T extends IAnyObject = any> extends PageInstanceBaseProps<D>\r\n复制代码PageInstance 里面定义了 Page 声明周期的方法，而且继承自 PageInstanceBaseProps，并将范型 D 传入。\r\ninterface PageInstanceBaseProps<D extends IAnyObject = any> {\r\n    data?: D\r\n    //...\r\n}\r\n复制代码所以这个 D 范型，其实就是 data 的类型接口。因为 data 不是必须实现的，所以这里是可选型 ？。\r\n那么 T 是什么呢？\r\nT extends IAnyObject & PageInstance\r\n复制代码T 其实就是对 PageInstance 的拓展，PageInstance 是 Page 的实例接口，那么 T 其实就是在 Page 里面 this 的类型接口了，也就是说，需要在 Page 里新增的方法和属性，都在 T 里定义。\r\n所以，对于一个普通页面我们可以声明两个接口，一个代表 data， 一个代表 page，举个例子。\r\ninterface IIntroPage {\r\n\tnextButtonTap(event: any): void;\r\n    isLoading: boolean;\r\n}\r\n\r\ninterface IIntroData {\r\n    test: string;\r\n}\r\n\r\nPage<IIntroData, IIntroPage>({\r\n    isLoading: false,\r\n\tnextButtonTap(event: any) {\r\n        this.isLoading = true;\r\n\t}\r\n});\r\n复制代码如果这个页面不需要 data 或者不需要扩展 page，用 IAnyObject 代替 D 或者 T 即可。\r\ninterface PageInstanceBaseProps<D extends IAnyObject = any> {\r\n    data?: D\r\n    setData?<K extends keyof D>(\r\n      data: D | Pick<D, K> | IAnyObject,\r\n      callback?: () => void\r\n    ): void\r\n}\r\n复制代码同时，由于 setData 和 data 都被声明为可选项，使用时需要加上！，this.setData!({}) 和 this.data!。\r\n其他就没什么了，用上 TypeScript 之后，官方的 API 都可以直接看参数和返回值的类型，再也不用去查文档猜测类型了。\r\n调用 JavaScript\r\n为 JavaScript 编写一个简单的 .d.ts 文件，将需要调用的类和方法暴露出来。详情见如何编写一个d.ts文件。\r\n最后\r\n虽然笔者用了 TypeScript 不久，但严格的检查的确让我在增删改接口字段能快速全局重构，而且方法调用联想，API 查看也方便了不少。小程序对 TypeScript 的支持日常使用开发是没有什么问题了，就是官方的文档指引比较少。"}
{"title": "微信小程序-wepy-侧滑删除组件，支持自定义内容区在 ", "author": "Rolan", "pub_time": "2019-2-14 00:04", "article_content": "在最近的微信小程序开发过程中需要用到侧滑删除的功能，微信小程序官方是没有提供这样的组件，再加上我们的微信小程序使用的是wepy组件开发框架开发的，wepy也没有提供这样的组件，之前也在github上搜索这方面的组件，没有发现合适的，当时只发现了一个开源的: github.com/GeoffZhu/we… 只不过该组件功能单一已经被作者废弃了，无奈自己动手撸了一个侧滑删除组件，现在把它开源出来吧。传送门: github.com/hu670014125…Requirementswepy: \"^1.7.3\"支持功能和特点自定义内容区域：支持之定义内容区域，组件内使用 slot占位。自定义滚动高度：可以自定义scroll-view的高度，默认为屏幕的高度。自定义menu ：如果默认的menu样式不喜欢可以自定义，也可以显示或者隐藏指定的menu。左右滑动：支持左右滑动也可以设置只左右或者右滑。效果如下：如何使用目前支持两种使用模式：1.page页面模式优点：可定制化高，扩展性强。\r\n缺点：集成复杂，代码复用性差。复制代码2.component 组件模式优点：集成简单，代码复用性强，减少包的大小。\r\n缺点：可定制到低。复制代码不建议使用page页面模式，下面详细介绍component 组件模式的使用如何使用// 导入组件\r\nimport SwipeDeleteView from '@/components/wepy-swipe-delete-view'\r\n\r\n// 声明组件\r\n\r\n components = {\r\n      swipeDelete: SwipeDeleteView\r\n    }\r\n    \r\n  // 引用组件\r\n  <template>\r\n  <swipeDelete :list.sync=\"list\">\r\n      <view class=\"item\">{{item.userName}}</view>\r\n    </swipeDelete>\r\n  </template>复制代码配置如下：<swipeDelete   :list.sync=\"list\"\r\n               :scrollHeight=\"scrollHeight\"\r\n               @deleteTap.user=\"deleteTap\"\r\n               @deleteLongTap.user=\"deleteLongTap\"\r\n               @editTap.user=\"editTap\"\r\n               @editLongTap.user=\"editLongTap\"\r\n               @addTap.user=\"addTap\"\r\n               @addLongTap.user=\"addLongTap\"\r\n               @markTap.user=\"markTap\"\r\n               @markLongTap.user=\"markLongTap\">复制代码每个点击事件或者长按事件都会返回两个参数methods = {\r\n      deleteTap(view, item) {\r\n        console.log(item)\r\n        view.deleteItem()\r\n      },\r\n      deleteLongTap(view, item) {\r\n        console.log(item)\r\n        wx.showModal({\r\n          title: '提示',\r\n          content: '确定要删除吗？',\r\n          success: function (res) {\r\n            if (res.confirm) {\r\n              view.deleteItem()\r\n            } else {\r\n              view.closeItem()\r\n            }\r\n          }\r\n        })\r\n      }\r\n   }复制代码view ：view 是SwipeDeleteView对象的本身，可以通过view来做一些其他操作，如:删除当前的itemitem : item 就是当前操作的原始数据，可以通过item获取真正需要的数据当前SwipeDeleteView对外暴露的函数有：如果在使用的过程中遇到什么问题可以告诉我，我及时修复。邮箱：hu670014125@163.com"}
{"title": "用vue重构小程序踩坑之旅(1) --- 微信sdk验签 ", "author": "Rolan", "pub_time": "2019-2-14 00:15", "article_content": "问题:验签失败　　惨景:用微信sdk实现h5页面的分享,且每个页面分享内容需要自定义.坑1:在Android和ios的系统中,同一个页面Android验签成功,ios验签失败解决方案:因为在使用vue的router时 ios复制出来的页面地址永远都是xxxx.com 而Android系统则是xxx.com/index,这就是照成验签失败的原因;　　查阅解决方案:　　https://www.jianshu.com/p/a470403de789　　大佬写的很详细坑2:某一页面Android验签失败,ios验签成功; --- 脑壳疼解决方案:　　在填埋了坑1后,ios就基本不用考虑单页面验签,但是在某页面中发现Android 验签失败,查出原因是因为url中拼接了中文的埋点.(做小程序跳转时 一般都会加到query中)　　vue中是会把query拼接到url上.建议吧这些数据后期用vuex来保存,(emmm,vue菜鸟,没测过此方案)　 invalid signature签名错误坑3:调用微信sdk的分享接口时,ios成功分享,Android分享失败解决方案(应急解决):　　微信jssdk 1.4使用新的2个分享接口: wx.updateAppMessageShareData 和 wx.updateTimelineShareData 不知道为什么 用了新的接口后就会产生以上问题,所以目前解决方案就是　　用旧的接口wx.onMenuShareTimeline(即将废弃);---脑壳又疼了"}
{"title": "微信小程序之scroll-view的flex布局问题 ", "author": "Rolan", "pub_time": "2019-1-16 00:03", "article_content": "关于微信小程序的scroll-view组件，第一次写的时候是直接在scroll-view中用了一层容器包裹子元素，然后用了flex布局，并且是用了组件来实现的横向滚动，后面有提出改进，但是不记录下，就发现过了几天，就有点懵了1.效果图2.在scroll-view里加一层容器，使用flex布局实现这里用flex布局实现的话，就要用组件的形式wxss文件.scrollView{\r\n  padding: 0 20rpx;\r\n  white-space: nowrap;\r\n  box-sizing: border-box;\r\n}\r\n.item{\r\n  display: inline-block;\r\n  margin-right: 20rpx;\r\n  width: calc(100% / 3);\r\n  height: 100rpx;\r\n  background: #ff00ff;\r\n}\r\n\r\n.scrollView1{\r\n  display: flex;\r\n  margin-top: 40rpx;\r\n  padding: 0 20rpx;\r\n  width: 100%;\r\n  flex-wrap: nowrap;\r\n  box-sizing: border-box;\r\n}\r\n.item1{\r\n  margin-right: 20rpx;\r\n  width: calc(100% / 3);\r\n  height: 100rpx;\r\n  background: #ff00ff;\r\n}\r\n.scrollView2{\r\n  margin-top: 40rpx;\r\n  padding: 0 20rpx;\r\n  width: 100%;\r\n  box-sizing: border-box;\r\n}\r\n.itemContainer{\r\n  display: flex;\r\n  width: 100%;\r\n  flex-wrap: nowrap;\r\n}\r\n.scrollItem{\r\n  margin-right: 20rpx;\r\n}\r\n\r\n.scrollView3{\r\n  margin-top: 40rpx;\r\n  padding: 0 20rpx;\r\n  width: 100%;\r\n  box-sizing: border-box;\r\n}\r\n.item3{\r\n  margin-right: 20rpx;\r\n  /* width: calc(100% / 3); */\r\n  width: 240rpx;\r\n  height: 100rpx;\r\n  background: #aa22dd;\r\n}wxml文件<!-- 要想使用flex布局实现横向滚动，就要在scroll-view里加一层容器包裹，并且使用子组件才会出现滚动效果 -->\r\n<scroll-view scroll-x class=\"scrollView2\">\r\n  <view class=\"itemContainer\">\r\n    <block wx:for=\"{{4}}\" wx:key=\"{{index}}\">\r\n      <view-item class=\"scrollItem\" />\r\n    </block>\r\n  </view>\r\n</scroll-view>子组件里就一个view标签，可以自己直接写3.直接使用display：inline-blockwxml文件<scroll-view scroll-x class=\"scrollView\">\r\n  <block wx:for=\"{{4}}\" wx:key=\"{{index}}\">\r\n    <view class=\"item\"></view>\r\n  </block>\r\n</scroll-view>4.自己的理解scroll-view不可以直接使用flex布局，使用flex布局会使得他不会按照预想的那样横向排列、滚动要使用flex布局则要麻烦一点如果直接使用flex布局，不用子组件的话，则会被挤成一排正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）"}
{"title": "微信小程序商品筛选，侧方弹出动画选择页面 ", "author": "Rolan", "pub_time": "2019-1-16 00:21", "article_content": "微信小程序商品筛选，侧方弹出动画选择页面，在一点点的零碎的时间里面写出来的代码，和前两篇效果结合出来的。点击按钮的同时，要实现这两个功能的叠加。小程序动画animation向左移动效果：https://www.jianshu.com/p/1cdf36070205小程序点击按钮出现和隐藏遮罩层：https://www.jianshu.com/p/1193bf63a87d效果是这样的:demo是这样的： wxml<view class=\"\">  <view class=\"animation-button\" bindtap=\"translate\">筛选</view>  <view class=\"float {{isRuleTrue?'isRuleShow':'isRuleHide'}} \">    <view class=\"animation-element\" animation=\"{{animation}}\">      <view class='use'>        <view class='iconuse'>用途</view>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">全部</li>          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">豪华发烧型</li>          <li>疯狂游戏型</li>          <li>商务办公型</li>        </ul>        <ul class=\"useage\">          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>      </view>      <!-- 价格 -->      <view class='use'>        <view class='iconprice'>价格</view>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">全部</li>          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">豪华发烧型</li>          <li>疯狂游戏型</li>          <li>商务办公型</li>        </ul>        <ul class=\"useage\">          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>      </view>      <view class='buttom'>      <view class=\"animation-reset\" >重置</view>      <view class=\"animation-button\" bindtap=\"success\">完成</view>      </view>    </view>  </view></view>wxss.isRuleShow {  display: block;}.isRuleHide {  display: none;}.float {  height: 100%;  width: 100%;  position: fixed;  background-color: rgba(0, 0, 0, 0.5);  z-index: 2;  top: 0;  left: 0;  /* margin-top:80rpx; */}.iconuse {  margin-left: 11rpx;}.iconprice {  margin-left: 11rpx;}.animation-element {  width: 580rpx;  height: 1175rpx;   background-color: #ffffff;   border: 1px solid #f3f0f0;  position: absolute;  right: -572rpx;}.useage {  height: 40rpx;}.useage li {  width: 177rpx;  margin: 12rpx 7rpx;  height: 70rpx;  line-height: 70rpx;  display: inline-block;  text-align: center;  border: 1px solid #f3f0f0;  border-radius: 15rpx;  font-size: 30rpx;}.buttom{  position: fixed;  bottom: 0;}.animation-reset{float: left; line-height: 2;  width: 260rpx;  margin: 15rpx 12rpx;  border: 1px solid #f3f0f0;  text-align: center;}.animation-button{float: left; line-height: 2;  width: 260rpx;  margin: 15rpx 12rpx;  border: 1px solid #f3f0f0;  text-align: center;}jsPage({  onReady: function () {    this.animation = wx.createAnimation()  },  translate: function () {    this.setData({      isRuleTrue: true    })    this.animation.translate(-245, 0).step()    this.setData({ animation: this.animation.export() })  },  success: function () {    this.setData({      isRuleTrue: false    })    this.animation.translate(0, 0).step()    this.setData({ animation: this.animation.export() })  },  tryDriver: function () {    this.setData({      background: \"#89dcf8\"    })  }})ok完成了，今天再说一点，有人问我关于技术博客日更的事情，一来是参加了简书的日更活动，不想断开，二来是一路走来，能看见自己每天学习到的知识点和解决的问题，所以才会感到很充实，不会觉得自己每天在空空度日。如果你也想坚持一件事情，可以私聊我，我们相互监督，互相帮助，让自己变得更好。原文作者：祈澈姑娘 技术博客：https://www.jianshu.com/u/05f416aefbe1 90后前端妹子，爱编程，爱运营，爱折腾。 坚持总结工作中遇到的技术问题，坚持记录工作中所所思所见，对于博客上面有不会的问题，可以加入qq群聊来问我：473819131。"}
{"title": "小程序----page级别的骚操作之禁用页面滚动 ", "author": "Rolan", "pub_time": "2019-1-16 00:24", "article_content": "page级别的骚操作之禁用页面滚动在做小程序项目的时候，遇到了这么一个问题。那就是希望能够动态的设置页面的滚动与否。 然鹅，官方提供的page级别的api操作里面显然是没有的。 首先，我们要知道的一点是小程序的每个页面的根元素为page，在对应的xxx.wxss中我们可以对其样式进行调整。    page{      background: #000;      color: #fff;    }书归正传，那么怎么动态的设置页面的滚动与否呢？在wxml的布局里面使用一个最外层view组件包含其它内容    <view class=\"test_page {{isScroll?'hidden':''}}\">        <view class=\"test_modal first_modal\">我是第一屏</view>        <view class=\"test_modal second_modal\">我是第二屏</view>        <button class=\"btn\" bind:tap=\"bindScrollStatus\">点我控制滚动</buttton>    </view>    page{      background: #000;      height: 100%;      color: #fff;    }    .test_page{        width: 100%;        height: 100%;    }    .hidden{        overflow: hidden;    }    .test_modal{        height: 100%;    }    .first_modal{        background: red;    }    .second_modal{        background: green;    }    .btn{        position: fixed;        width: 100%;        height: 88rpx;        bottom: 0;        display: flex;        align-items: center;        justify-content: center;        background: #0099ff;        font-size: 36rpx;        color: #fff;    }    Page({        data:{            isScroll:true        },        bindScrollStatus(){            this.setData({                isScroll: !this.data.isScroll            })        }    })可滚动时不可滚动时至此小程序----page级的骚操作之动态设置页面滚动篇结束。 此种方法只能算是hack的一种手段。相对应的可能会失去一些其它api的使用。希望官方能够提供对应的api为最好（--_--）。此处作为抛砖引玉，有更好的处理方法还请指教。如果对你觉得本章不错，请不要吝啬给个赞呗!"}
{"title": "微信小程序组件化的解决方案 ", "author": "Rolan", "pub_time": "2019-1-17 00:14", "article_content": "从小程序基础库版本1.6.3 开始，小程序支持简洁的组件化编程。查看自己使用的小程序基础库版本，可以通过在开发者工具右侧点击详情查看最基本的组件小程序的组件，其实就是一个目录，该目录需要包含4个文件：xxx.jsonxxx.wxmlxxx.wxssxxx.js声明一个组件首先需要在 json 文件中进行自定义组件声明（将 component 字段设为 true 可这一组文件设为自定义组件）{ \"component\": true}\r\n复制代码其次，在要引入组件的页面的json文件内，进行引用声明{  \r\n    \"usingComponents\": {   \r\n      \"component-tag-name\": \"path/to/the/custom/component\"  \r\n    }\r\n}\r\n复制代码component-tag-name 字段是自定义的组件名称后面的是组件路径，注意是相对路径，不能是绝对路径这样，在主页面就可以使用了。相比于vue的组件引入，小程序的方案更简洁。vue组件引入是需要 import 之后，同时在 components 里面注册，而小程序的组件只需要在 .json 里面注册，就可以在 wxml 里面使用。使用slot和vue 相同，小程序也有slot概念。单一slot在组件模板中可以提供一个 <slot> 节点，用于承载组件引用时提供的子节点。// 主页面内，<addlike>是组件\r\n<addlike item=\"item\" my_properties=\"sssss\">   \r\n\t<text>我是被slot插入的文本</text>\r\n</addlike> \r\n\r\n// addlike 组件\r\n<view class=\"container\">    \r\n\t<view>hello, 这里是组件</view>    \r\n\t<view>hello, {{my_properties}}</view>    \r\n\t<slot></slot>\r\n</view> \r\n\r\n// 渲染后\r\n<view class=\"container\">    \r\n\t<view>hello, 这里是组件</view>    \r\n\t<view>hello, {{my_properties}}</view>    \r\n\t<text>我是被slot插入的文本</text>\r\n</view>\r\n复制代码多个slot如果需要在组件内使用多个slot， 需要在组件js中声明启用：Component({\r\n  options: {\r\n    multipleSlots: true // 在组件定义时的选项中启用多slot支持\r\n  },\r\n  properties: { /* ... */ },\r\n  methods: { /* ... */ }\r\n})\r\n复制代码使用：// 主页面\r\n<addlike item=\"item\" my_properties=\"sssss\">\r\n    // 在普通的元素上加入 slot 属性，指定slotname, 就可以变成子元素的slot了\r\n    <text slot=\"slot1\">我是被slot1插入的文本</text>\r\n    <text slot=\"slot2\">我是被slot2插入的文本</text>\r\n</addlike>\r\n \r\n// 子页面\r\n<view class=\"container\">\r\n    <view>hello, 这里是组件</view>\r\n    <view>hello, {{my_properties}}</view>\r\n    <slot name=\"slot1\"></slot>\r\n    <slot name=\"slot2\"></slot>\r\n</view>\r\n复制代码Component构造器刚才我们说了，一个组件内应该包括js, wxml, wxss, json 四个文件。wxml 相当于是 HTML，wxss 相当于是 css, 那么js 里面应该写什么呢？微信官方提供的案例中：Component({\r\n \r\n  behaviors: [],\r\n \r\n  properties: {\r\n   \r\n  },\r\n  data: {}, // 私有数据，可用于模版渲染\r\n \r\n  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\r\n  attached: function(){},\r\n  moved: function(){},\r\n  detached: function(){},\r\n \r\n  methods: {\r\n    onMyButtonTap: function(){\r\n     \r\n    },\r\n    _myPrivateMethod: function(){\r\n     \r\n    },\r\n    _propertyChange: function(newVal, oldVal) {\r\n \r\n    }\r\n  }\r\n})\r\n复制代码里面调用了一个Component构造器。Component构造器可用于定义组件，调用Component构造器时可以指定组件的 属性、数据、方法 等。具体 Component里面可以放什么东西，如下所示：组件与数据通信组件化必然要涉及到数据的通信，为了解决数据在组件间的维护问题，vue, react，angular 有不同的解决方案。而小程序的解决方案则简洁很多。主页面传入数据到组件properties相当于vue的props，是传入外部数据的入口。// 主页面使用组件\r\n<a add_like=\"{{add_like}}\">\r\n</a>\r\n \r\n// 组件a.js 内\r\nComponent({\r\n    properties:{\r\n        add_like:{\r\n            type:Array,\r\n            value:[],\r\n            observer:function(){\r\n                \r\n            }\r\n        }\r\n    }\r\n})\r\n复制代码注意： 传入的数据，不管是简单数据类型，还是引用类型，都如同 值复制 一样（ 和红宝书里面描述js函数参数传入是值复制还不一样，红宝书里面的意思是：简单数据类型直接复制数值，引用类型复制引用，也就是说在函数内修改参数对象的属性，会影响到函数外对象的属性 ）。如果是Vue的props， 则可以通过 .sync 来同步，而在小程序子组件里面，调用this.setData()修改父组件内的数据，不会影响到父组件里面的数据, 也就是说，子组件 property 的修改，仿佛和父组件没有任何关系。那么，如果是在子组件内修改父组件的数据，甚至是修改兄弟组件内的数据，有没有简单的方法呢？下面会有讲到组件传出数据到主页面和vue类似，组件间交互的主要形式是自定义事件。组件通过 this.triggerEvent() 触发自定义事件，主页面在组件上 bind:component_method=\"main_page_mehod\" 来接收自定义事件。其中， this.triggerEvent() 方法接收自定义事件名称外，还接收两个对象， eventDetail 和 eventOptions 。// 子组件触发自定义事件\r\nontap () {\r\n    // 所有要带到主页面的数据，都装在eventDetail里面\r\n\tvar eventDetail = {\r\n\t\tname:'sssssssss',\r\n\t\ttest:[1,2,3]\r\n\t}\r\n\t// 触发事件的选项 bubbles是否冒泡，composed是否可穿越组件边界，capturePhase 是否有捕获阶段\r\n\tvar eventOption = {\r\n\t\tcomposed: true\r\n\t}\r\n\tthis.triggerEvent('click_btn', eventDetail, eventOption)\r\n}\r\n \r\n// 主页面里面\r\nmain_page_ontap (eventDetail) {\r\n    console.log(eventDetail)\r\n    // eventDetail\r\n    // changedTouches\r\n    // currentTarget\r\n    // target\r\n    // type\r\n    // ……\r\n    // detail   哈哈，所有的子组件的数据，都通过该参数的detail属性暴露出来\r\n}\r\n\r\n复制代码组件之间数据通信和vue提出的vuex的解决方案不同，小程序的组件间的通讯简单小巧。你可以和主页面与组件通讯一样，使用自定义事件来进行通讯，当然更简单方便的方法，是使用小程序提供的relations.relations 是Component 构造函数中的一个属性，只要两个组件的relations 属性产生关联，他们两个之间就可以捕获到对方，并且可以相互访问，修改对方的属性，如同修改自己的属性一样。Component({\r\n   relations:{\r\n    './path_to_b': {                 // './path_to_b'是对方组件的相对路径\r\n        type: 'child',               //  type可选择两组：parent和child、ancestor和descendant\r\n        linked:function(target){  }  // 钩子函数，在组件linked时候被调用 target是组件的实例，\r\n        linkChanged: function(target){}\r\n        unlinked: function(target){}\r\n        }\r\n    },\r\n})\r\n复制代码比如说，有两个组件如代码所示：// 组件a slot 包含了组件b\r\n<a>    \r\n  <b></b>\r\n</a>\r\n复制代码他们之间的关系如下图所示：两个组件捕获到对方组件的实例，是通过 this.getRelationNodes('./path_to_a')方法。既然获取到了对方组件的实例，那么就可以访问到对方组件上的data, 也可以设置对方组件上的data, 但是不能调用对方组件上的方法。// 在a 组件中\r\nComponent({\r\n    relations:{\r\n        './path_to_b': {\r\n            type: 'child',\r\n            linked:function(target){  }  // target是组件b的实例，\r\n            linkChanged: function(target){}\r\n            unlinked: function(target){}\r\n        }\r\n    },\r\n    methods:{\r\n        test () {\r\n            var nodes = this.getRelationNodes('./path_to_b')\r\n            var component_b = nodes[0];\r\n            \r\n            // 获取到b组件的数据\r\n            console.log(component_b.data.name)\r\n            \r\n            // 设置父组件的数据\r\n            // 这样的设置是无效的\r\n            this.setData({\r\n                component_b.data.name:'ss'\r\n            })\r\n            // 需要调用对方组件的setData()方法来设置\r\n            component_b.setData({\r\n                name:'ss'\r\n            })\r\n        }\r\n    }\r\n})\r\n \r\n// 在b 组件里面\r\nComponent({\r\n    relations:{\r\n        './path_to_a': {                      //注意！必须双方组件都声明relations属性\r\n            type:'parent'\r\n        }\r\n    },\r\n    data: {\r\n        name: 'dudu'\r\n    }\r\n})\r\n复制代码注意：1. 主页面使用组件的时候，不能有数字，比如说 <component_sub1> 或 <component_sub_1>，可以在主页面的json 里面设置一个新名字{\r\n    \"usingComponents\":{\r\n        \"test_component_subb\": \"../../../components/test_component_sub2/test_component_sub2\"\r\n    }\r\n}\r\n复制代码relations 里面的路径，比如说这里：是对方组件真实的相对路径，而不是组件间的逻辑路径。如果relations 没有关联，那么 this.getRelationNodes 是获取不到对方组件的本组件无法获取本组件的实例，使用this.getRelatonsNodes('./ path_to_self ') 会返回一个nulltype 可以选择的 parent 、 child 、 ancestor 、 descendant现在我们已经可以做到了两个组件之间的数据传递，那么如何在多个组件间传递数据呢？如上图所示，同级的组件b 和同级的组件c , b 和 c 之间不可以直接获取，b可以获取到a， c 也可以获取到a，而a可以直接获取到 b 和 c。所以，如果想获取到兄弟元素，需要先获取到祖先节点，然后再通过祖先节点获取兄弟节点我在 组件b 里面，我需要先找到 祖先组件a 的实例，然后用 祖先组件a 的实例的 getRelationNodes 方法获取到 组件c 的实例。看见没？恐怕我们又要写一大堆重复性的代码了。幸好，微信小程序还提供了behavior 属性, 这个属性相当于 mixin，很容易理解的，是提高代码复用性的一种方法。思路：假设目前有三个组件，组件a, 组件b, 组件c， 其中组件b和组件c是兄弟组件，组建a是b和c的兄弟组件。为了减少代码的重复性，我们把获取父组件的方法，和获取兄弟组件的方法封装一下，封装在 behavior 的 methods 中。只要是引入该behavior的组件，都可以便捷的调用方法。实现：新建一个behavior文件，命名无所谓，比如说relation_behavior.js// 在 get_relation.js 文件里面\r\nmodule.exports = Behavior({\r\n\tmethods:{\r\n\t    // 获取父组件实例的快捷方法\r\n\t\t_parent () {\r\n\t\t\t// 如果根据该路径获取到acestor组件为null，则说明this为ancesor\r\n\t\t\tvar parentNode =  this.getRelationNodes('../record_item/record_item')\r\n\t\t\tif (parentNode&&parentNode.length !== 0) {\r\n\t\t\t\treturn parentNode[0]\r\n\t\t\t} else {\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\t\t},\r\n\t\t// 获取兄弟组件实例的快捷方法\r\n\t\t_sibling(name) {\r\n\t\t\tvar node = this._parent().getRelationNodes(`../${name}/${name}`)\r\n\t\t\tif (node &&node.length > 0) {\r\n\t\t\t\treturn node[0]\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n})\r\n复制代码然后在组件b, 和 组件c 上引入该behavior，并且调用方法，获取父组件和兄弟组件的实例// 组件b中\r\nvar relation_behavior = require('./path_to_relation_behavior')\r\nComponent({\r\n    behaviors:[relation_behavior],\r\n    methods:{\r\n        test () {\r\n            // 获得父组件的实例\r\n            let parent = this._parent()\r\n            \r\n            // 访问父组件的数据d\r\n            console.log(parent.data.name)\r\n            \r\n            // 修改父组件的数据\r\n            parent.setData({\r\n                name: 'test1'\r\n            })\r\n            \r\n            // 获得兄弟组件的实例\r\n            let sibling = this._sibling('c')\r\n            \r\n            // 访问兄弟组件的数据\r\n            console.log(sibling.data.name)\r\n            \r\n            // 修改兄弟组件的数据\r\n            sibling.setData({\r\n                name:\"test\"\r\n            })\r\n        }\r\n    }\r\n})\r\n \r\n// 组件c中\r\nvar relation_behavior = require('./path_to_relation_behavior')\r\nComponent({\r\n    behaviors:[relation_behavior],\r\n    methods:{\r\n        test () {\r\n            // 获得父组件的实例\r\n            let parent = this._parent()\r\n            \r\n            // 访问父组件的数据d\r\n            console.log(parent.data.name)\r\n            \r\n            // 修改父组件的数据\r\n            parent.setData({\r\n                name: 'test1'\r\n            })\r\n            \r\n            // 获得兄弟组件的实例\r\n            let sibling = this._sibling('b')\r\n            \r\n            // 访问兄弟组件的数据\r\n            console.log(sibling.data.name)\r\n            \r\n            // 修改兄弟组件的数据\r\n            sibling.setData({\r\n                name:\"test\"\r\n            })\r\n        }\r\n    }\r\n})\r\n复制代码同时需要注意，c和b两个组件，从relations属性的角度来说，是a的后代组件。但是组件b和组件c 所处的作用域, 都是主页面的作用域，传入的property都是主页面的property，这样就保证了组件数据的灵活性。relations 像一个隐形的链子一样把一堆组件关联起来，关联起来的组件可以相互访问，修改对方的数据，但是每一个组件都可以从外界独立的获取数据。看了这么多理论的东西，还是需要一个具体的场景来应用。比如说，我们有个一个分享记录图片心情的页面，当用户点击【点赞】的按钮时候，该心情的记录 点赞按钮会变红，下面的一栏位置会多出点赞人的名字。如果不通过组件化，很可能的做法是 修改一个点赞按钮，然后遍历数据更新数据，最后所有记录列表的状态都会被重新渲染一遍。如果是通过组件化拆分：把点赞的按钮封装为 组件b , 下面点赞人的框封装为 组件c, 每一个心情记录都是一个 组件a下面是代码实现// 在主页面内\r\n<view wx:for='{{feed_item}}'>\r\n    <a item='{{item}}'>\r\n        <b></b>\r\n        <c></c>\r\n    </a>\r\n<view>\r\n \r\n \r\n// 在组件a内\r\nvar behavior_relation = require('../../relation_behavior.js)  //这里引入上文说的Behavior\r\nComponent({\r\n    behaviors:[behavior_relation],\r\n    relations:{\r\n        '../b/b':{\r\n            type: 'descendant'\r\n        }\r\n    }\r\n})\r\n \r\n// 在组件b内\r\nvar behavior_relation = require('../../relation_behavior.js)  //这里引入上文说的Behavior\r\nComponent({\r\n    behaviors:[behavior_relation]\r\n    relations:{\r\n        '../a/a':{\r\n            type: 'ancestor'\r\n        }\r\n    },\r\n    data: {\r\n        is_like: false  //控制点赞图标的状态\r\n    },\r\n    methods:{\r\n        // 当用户点赞的时候\r\n        onClick () {\r\n            //  修改本组件的状态\r\n            this.setData({\r\n                is_like: true\r\n            })\r\n            // 修改 c 组件的数据\r\n            this._sibling('c').setData({\r\n                likeStr: this._sibling('c').data.likeStr + '我' \r\n            })\r\n        }\r\n    }\r\n})\r\n \r\n// 在组件c内\r\nvar behavior_relation = require('../../relation_behavior.js)  //这里引入上文说的Behavior\r\nComponent({\r\n    behaviors:[behavior_relation],\r\n    relations:{\r\n        '../a/a':{\r\n            type: 'ancestor'\r\n        }\r\n    },\r\n    data:{\r\n        likeStr:'晓红，小明'\r\n    }\r\n})\r\n复制代码这样，组件b 可以修改组件c中的数据。同时，组件b 和 组件c 又可以通过 properties 和 事件系统，和主页面保持独立的数据通信。"}
{"title": "手把手教你用Taro框架写一个图像处理类微信小程序 ", "author": "Rolan", "pub_time": "2019-1-17 00:32", "article_content": "18年年中的时候，笔者所在的公司让我们开发一款微信小程序（马卡龙玩图）。主要的玩法是用户上传一张人像照片，图片经过后端的AI算法处理后识别出人物，将人物和周围环境进行分割（俗称抠图）；前端将返回的抠像进行样式处理，包括设置大小位置旋转等；通过预设（或自定义上传）的一些主题场景以及点缀的贴纸或滤镜，用户对这些元素进行移动或缩放，可以衍生出很多好玩的修图玩法，比如更换动态背景，合成带有音频的动态视频等（文末有微信二维码）。开发初期，当时可选的成熟的微信小程序框架只有wepy，经过开发实践发现，wepy在多层嵌套列表渲染，组件化支持等方面体验不是很友好。后面美团的技术团队开源了一款基于vue的小程序框架mpvue，经过体验后感觉上，虽然在组件化上体验和vue别无差异，但是在性能上并不占优势。直到某天有位朋友拉我进了一个Taro的开发群，原来京东的前端团队也在开发一款基于React规范的小程序框架，由于当时笔者担心Taro尚处早期，功能上也许不足抑或bug，迟迟没有入手。直到最近更新到1.2.4的版本，群里有道友不吝溢美之词进行了一波安利，所以笔者决定对项目的部分模块进行了重构，发现Taro确实在开发体验和性能上都得到了非常好的提高，在此向taro的贡献者致以崇高的敬意。本着开源的精神，笔者也将此次重构的demo源码以及心得体会和大家一起分享。需求分析用户上传的人像经过抠图处理后，将展示在作图区，同时展示的元素还有背景图片，可动或固定的贴纸。为了获取更好的用户视觉体验，每个场景下，通过预设人像和贴纸的大小和位置（参数为作图区域的百分比等）。人像和贴纸需支持单指和双指手势操作来改变大小和位置等样式，因此可以将人像和贴纸都封装为Sticker的组件，子组件Sticker向页面父组件传递手势操作变更后的样式参数，触发父组件setState来刷新,最终通过传递props到子组件来控制样式。关于Sticker组件的一些细节还包括：贴纸组件具有激活状态（点击当前组件显示控制器，而其他组件则隐藏）；切换场景后，要缓存之前用户的操作，当切回到原先的场景时，则恢复到该场景下用户最后的操作状态。用户点击保存后，将作图区的所有元素按照层级大小进行排序，然后通过微信提供的canvas接口进行绘制，最终返回所见即所得的合成美图。准备工作根据Taro的文档，安装CLI工具以及创建项目模板，建议选择Typescript开发方式。项目目录简要分析下项目结构Taro-makaron-demo\r\n├── dist                   编译结果目录\r\n├── config                 配置目录\r\n|   ├── dev.js             开发时配置\r\n|   ├── index.js           默认配置\r\n|   └── prod.js            打包时配置\r\n├── src                    源码目录\r\n|   ├── assets             静态资源\r\n|   |   ├── images         图片\r\n|   ├── components         组件\r\n|   |   ├── Sticker        贴纸组件\r\n|   |   ├── ...            其他组件\r\n|   ├── model              Redux数据流\r\n|   |   ├── actions        \r\n|   |   ├── constants        \r\n|   |   ├── reducers        \r\n|   |   ├── store        \r\n|   ├── pages              页面文件目录\r\n|   |   ├── home           首页\r\n|   |   |   ├── index.js   index 页面逻辑\r\n|   |   |   └── index.css  index 页面样式\r\n|   |   ├── dynamic        作图页\r\n|   |   |   ├── index.js   index 页面逻辑\r\n|   |   |   └── index.css  index 页面样式\r\n|   ├── services           服务\r\n|   |   ├── config.ts      全局配置\r\n|   |   ├── api.config.ts  api接口配置\r\n|   |   ├── http.ts        封装的http服务\r\n|   |   ├── global_data.ts 全局对象\r\n|   |   ├── cache.ts       缓存服务\r\n|   |   ├── session.ts     会话服务\r\n|   |   ├── service.ts     基础服务或业务服务\r\n|   ├── utils              公共方法\r\n|   |   ├── tool.ts        工具函数\r\n|   ├── app.css            项目总通用样式\r\n|   └── app.js             项目入口文件\r\n└── package.json\r\n复制代码核心代码分析sticker贴纸组件贴纸组件相较其他展示型组件，涉及手势操作，大小位置计算等，所以稍显复杂。// 使用\r\nclass Page extends Component {\r\n    state = {\r\n        foreground: { // 人像state\r\n          id: 'foreground', // id\r\n          remoteUrl: '', // url\r\n          zIndex:2, // 层级\r\n          width:0, // 宽\r\n          height:0, // 高\r\n          x: 0, // x轴偏移量\r\n          y:0, // y轴偏移量\r\n          rotate: 0, // 旋转角度\r\n          originWidth: 0, // 原始宽度\r\n          originHeight: 0, // 原始高度\r\n          autoWidth: 0, // 自适应后的宽度\r\n          autoHeight: 0, // 自适应后的高度\r\n          autoScale: 0, // 相对画框缩放比例\r\n          fixed: false, // 是否固定\r\n          isActive: true, // 是否激活\r\n          visible: true, // 是否显示\r\n        }\r\n    }\r\n    render () {\r\n        reuturn <Sticker \r\n                    ref=\"foreground\"\r\n                    url={foreground.remoteUrl}\r\n                    stylePrams={foreground}                \r\n                    framePrams={frame}\r\n                    onChangeStyle={this.handleChangeStyle}\r\n                    onImageLoaded={this.handleForegroundLoaded}\r\n                    onTouchstart={this.handleForegroundTouchstart}\r\n                    onTouchend={this.handleForegroundTouchend}\r\n              />\r\n    }\r\n}\r\n\r\n// 组件定义\r\nclass Sticker extends Component {\r\n...\r\n    render() {\r\n        const { url, stylePrams } = this.props\r\n        const { framePrams } = this.state\r\n        const styleObj = this.formatStyle(this.props.stylePrams)\r\n        return (\r\n          <View \r\n            className={`sticker-wrap ${stylePrams.fixed ? 'event-through' : ''} ${(stylePrams.visible && stylePrams.width > 0) ? '' : 'hidden' }`}\r\n            style={styleObj}\r\n          > \r\n            <Image \r\n              src={url} \r\n              mode=\"widthFix\" \r\n              style=\"width:100%;height:100%\"\r\n              onLoad={this.handleImageLoaded} // 图片加载后将原始尺寸信息通知给父组件\r\n              onTouchstart={this.stickerOntouchstart} \r\n              onTouchmove={this.throttledStickerOntouchmove} // touchmove比较频繁，需要节留\r\n              onTouchend={this.stickerOntouchend}/>\r\n            <View className={`border ${stylePrams.isActive ? 'active' : ''}`}></View>\r\n            <View className={`control ${stylePrams.isActive ? 'active' : ''}`}\r\n              onTouchstart={this.arrowOntouchstart} \r\n              onTouchmove={this.throttledArrowOntouchmove}\r\n              onTouchend={this.arrowOntouchend}\r\n            >\r\n              <Image src={scale} mode=\"widthFix\" style=\"width:50%;height:50%\"/>\r\n            </View>\r\n          </View>\r\n        )\r\n    }\r\n}\r\n\r\n复制代码缓存服务 缓存服务对提高性能非常有帮助，比如canvas绘图需要图片是本地图片，可以通过数据字典的方式将图片的远程地址和下载到本地的地址进行一一对应，节省了大量的网络资源和时间// services/cache.ts 缓存服务\r\nfunction Cache (name) {\r\n  this.name = name\r\n}\r\nCache.prototype = {\r\n  set: function (key, value) {\r\n    this[key] = value\r\n    return this[key]\r\n  },\r\n  get: function (key) {\r\n    return this[key]\r\n  },\r\n  clear: function () {\r\n    // 清空\r\n    Object.keys(this).forEach(v => {\r\n      this[v] = null\r\n    })\r\n  }\r\n}\r\n\r\nexport const createCache = (name:string) => {\r\n  return new Cache(name)\r\n}\r\n// 使用\r\nimport {createCache} from '../../services/cache'\r\nclass Page extends Component {\r\n  cache = {\r\n    source: createCache('source'),\r\n  }\r\n  // 下载照片并存储到本地\r\n  downloadRemoteImage = async (remoteUrl = '') => {\r\n    const cacheKey = `${remoteUrl}_localPath`\r\n    const cache_source = this.cache['source']\r\n    let localImagePath = ''\r\n    if (cache_source.get(cacheKey)) {\r\n      // 有缓存\r\n      return cache_source.get(cacheKey)\r\n    } else {\r\n      try {\r\n        const result = await service.base.downloadFile(remoteUrl)\r\n        localImagePath = result.tempFilePath\r\n      } catch (err) {\r\n        console.log('下载图片失败', err)\r\n      }\r\n    }\r\n    return cache_source.set(cacheKey, localImagePath)\r\n  }\r\n}\r\n\r\n复制代码性能优化避免频繁setState由于微信小程序逻辑层和视图层各自独立，两边的数据传输是靠转换后的字符串。因此当setData频率过快，内容庞大时，会导致阻塞。由于本项目又涉及很多的手势操作，touchmove事件的频率很快，所以项目早期时候，在安卓系统下卡顿十分明显。优化方式有：通过做函数节流，降低setData频次；将页面无关的数据不要绑定到data上，而是绑定到组件实例上（牺牲运算效率换取空间效率）。使用微信的自定义组件，也是一个很大的提升因素，个人认猜测可能是自定义组件内部data的改变不会导致其他组件或页面的data更新。项目早期采用的是wepy框架，由于历史局限性（当时微信还未公布自定义组件方案），所以效率问题一直很是头疼。好在Taro框架通过编译的方式完美的支持了这个方案。归并setState例如，当图片加载，获取到原始尺寸后，需要计算出该图片在当前场景下的预设尺寸和位置。必须先计算出自适应后的宽高，然后才能计算出预设的偏移量。因此可以将尺寸和位置参数都计算完毕后，再调用setState更新视图，这样不仅降低了频次，同时也解决了图片闪烁的bug.利用缓存前面有提到过利用缓存模块来存储组件状态或资源信息，在此不再赘述。心得Taro框架采取的是一种编译的方式，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动小程序、H5、React-Native 等），因此可以在性能上与各个平台保持一致。而mpvue的方案则是修改vue的runtime，将vue 实例与小程序 Page 实例建立关联以及生命周期的绑定。私以为，这种通过映射的方式可能会导致通信效率上的降低，并且vue和微信又各自独立迭代，后期的协调也越来越费劲，所以个人感觉上，还是Taro的方案略胜一筹。个人薄见，还请海涵。"}
{"title": "微信小程序 - 富文本图片宽度自适应 ", "author": "Rolan", "pub_time": "2019-1-17 00:42", "article_content": "引言：在微信小程序里，比如商品展示页面的商品详情会有图片展示，PC端设置的商品详情是PC端的宽度，所以在小程序里图片会显示不全，这时就应该做相应的处理，使小程序里图片显示正确\r\n\r\n思路\r\n把图片的宽度改为手机屏幕对应的宽度\r\n微信小程序需要知道的知识\r\n需要知道微信小程序里有自己的宽度标准，单位为rpx；\r\n针对所有不同尺寸的浏览器，微信小程序里规定屏幕宽为750rpx；\r\n解决\r\nWXML\r\n<view class='html_detail'>\r\n    <rich-text nodes='{{artical}}'></rich-text>\r\n</view>\r\n复制代码WXS\r\ndata={artical:''}\r\n\r\nasync onLoad(){\r\n    const json = await api.getDetail();\r\n    if(json !== null){\r\n        this.artical = util.formatRichText(json.detail.description);\r\n    }\r\n}\r\n复制代码若artical里只有图片，并且图片没有设置style和宽度/高度\r\nutil.js\r\nfunction formatRichText(html){\r\n    let newContent= html.replace(/\\<img/gi, '<img style=\"max-width:100%;height:auto;display:block;\"');\r\n    return newContent;\r\n}\r\n\r\nmodule.exports = {\r\n    formatRichText\r\n}\r\n复制代码若artical里包含多种标签\r\nutil.js\r\n/**\r\n * 处理富文本里的图片宽度自适应\r\n * 1.去掉img标签里的style、width、height属性\r\n * 2.img标签添加style属性：max-width:100%;height:auto\r\n * 3.修改所有style里的width属性为max-width:100%\r\n * 4.去掉<br/>标签\r\n * @param html\r\n * @returns {void|string|*}\r\n */\r\nfunction formatRichText(html){\r\n    let newContent= html.replace(/<img[^>]*>/gi,function(match,capture){\r\n        match = match.replace(/style=\"[^\"]+\"/gi, '').replace(/style='[^']+'/gi, '');\r\n        match = match.replace(/width=\"[^\"]+\"/gi, '').replace(/width='[^']+'/gi, '');\r\n        match = match.replace(/height=\"[^\"]+\"/gi, '').replace(/height='[^']+'/gi, '');\r\n        return match;\r\n    });\r\n    newContent = newContent.replace(/style=\"[^\"]+\"/gi,function(match,capture){\r\n        match = match.replace(/width:[^;]+;/gi, 'max-width:100%;').replace(/width:[^;]+;/gi, 'max-width:100%;');\r\n        return match;\r\n    });\r\n    newContent = newContent.replace(/<br[^>]*\\/>/gi, '');\r\n    newContent = newContent.replace(/\\<img/gi, '<img style=\"max-width:100%;height:auto;display:block;margin-top:0;margin-bottom:0;\"');\r\n    return newContent;\r\n}\r\n\r\nmodule.exports = {\r\n    formatRichText\r\n}"}
{"title": "小程序：无限自动滚动的Gallery ", "author": "Rolan", "pub_time": "2019-1-17 00:53", "article_content": "遇到一个需求，需要在小程序内实现自动轮播的画廊效果，如果是网页版的话有大量现成的库可以用，但小程序找了一圈没找到有类似的库，只好自己想办法了。\r\n在踩了多个坑之后找到最简单的方法，就是用CSS animation来实现，但缺点就是不能手动拖动。\r\n先贴一下效果图\r\n\r\n第一步 html\r\n因为要无限滚动，所以放完在最后一个图之后需要切换回第一个图。为了让用户感知不到这个切换过程，需要将最开始图片复制后末尾，小程序里把wx:for复制一遍就行了，注意要修改wx:key的值，避免重复。\r\n为啥是复制全部图片呢，主要是因为keyframes的值不能动态设置，复制全部后只需要将end进度值设置为-50%即可。\r\n<view class=\"series\">\r\n    <view\r\n        style=\"animation: {{duration}}ms scroll-animation linear infinite;width: {{seriesWidth*2}}rpx\"\r\n        class=\"images\">\r\n        <view class=\"row\" wx:for=\"{{productSeries}}\" wx:key=\"{{index}}\">\r\n            <image\r\n                wx:for=\"{{item}}\"\r\n                wx:for-item=\"img\"\r\n                wx:for-index=\"imgIndex\"\r\n                wx:key=\"{{img + imgIndex}}\"\r\n                src=\"{{img}}\"\r\n            ></image>\r\n            <image\r\n                wx:for=\"{{item}}\"\r\n                wx:for-item=\"img\"\r\n                wx:for-index=\"imgIndex\"\r\n                wx:key=\"{{img + imgIndex}}-extra\"\r\n                src=\"{{img}}\"\r\n            ></image>\r\n        </view>\r\n    </view>\r\n</view>\r\n复制代码第二步 css\r\nCSS动画很简单，让gallery转动到-50%的时候跳回0%，并设置infinite。使用style而非class的原因是画廊总长不确定，动画的时长根据图片数量来设置。width也是需要动态设置，自动计算的width会有问题。\r\n.series {\r\n    overflow: hidden;\r\n    .images {\r\n        min-width: 100%;\r\n        .row {\r\n            white-space: nowrap;\r\n            line-height: 1;\r\n            &:last-child {\r\n                transform: translateX(-100rpx);\r\n            }\r\n        }\r\n        image {\r\n            width: 180rpx;\r\n            height: 180rpx;\r\n            margin: 0 10rpx 8rpx 0;\r\n        }\r\n    }\r\n}\r\n@keyframes scroll-animation {\r\n        from {\r\n            transform: translateX(0);\r\n        }\r\n        to {\r\n            transform: translateX(-50%);\r\n        }\r\n    }\r\n复制代码第三步 js\r\n我们还需要通过js计算动画时长和view的长度，数字190是image width + margin-right的值。最后要再减一次margin-right的原因我也不确定，但不减这个值的话动画最后会有一点卡顿的感觉，显得不太流畅，希望有大佬解答一下原理。\r\ndata = {\r\n    productSeries: [\r\n        [\r\n            '/images/house1.png',\r\n            '/images/house2.png',\r\n            '/images/house3.png',\r\n            '/images/house2.png',\r\n            '/images/house3.png',\r\n            '/images/house4.png'\r\n        ],\r\n        [\r\n            '/images/house1.png',\r\n            '/images/house2.png',\r\n            '/images/house3.png',\r\n            '/images/house2.png',\r\n            '/images/house3.png',\r\n            '/images/house4.png'\r\n        ]\r\n    ],\r\n    speed: 40,\r\n    seriesWidth: 400,\r\n    duration: 60000\r\n}\r\nonShow() {\r\n    if (this.productSeries[0].length > 4) {\r\n        this.seriesWidth = 190 * this.productSeries[0].length - 10\r\n        this.duration = Math.floor(this.seriesWidth / this.speed * 1000)\r\n    } else { // 当一行图片太少时就没必要加动画了\r\n        this.seriesWidth = null\r\n        this.duration = 0\r\n    }\r\n}\r\n复制代码"}
{"title": "小程序--语音合成tts 对接多平台（讯飞，思必驰，百度） ", "author": "Rolan", "pub_time": "2019-1-21 00:54", "article_content": "小程序功能特点文本转语音多平台多发音人可选可调语速可提供音频下载良心产品无广告小程序码\r\n\r\n已对接在线语音识别服务\r\n\r\n思必驰dui平台 (超过40个免费可选发音人)\r\n讯飞开放平台 (5个免费可选发音人)\r\n百度语音(4个免费发音人可选)\r\n\r\n小程序截图\r\n\r\n服务端主要代码\r\nclass TTSController extends Controller {\r\n  async tts () {\r\n    let params = this.ctx.query\r\n    let result = null\r\n    // 根据plat参数来调用不同的接口\r\n    if (params.plat === 'xf') {\r\n      result = await this.ctx.service.xftts.getTts(params)\r\n    } else if (params.plat === 'baidu') {\r\n      result = await this.ctx.service.baidutts.getTts(params)\r\n    } else {\r\n      result = await this.ctx.service.aispeechtts.getTts(params)\r\n    }\r\n    // 设置response的类型，这样客户端接收到的就是一个文件流\r\n    this.ctx.response.type = 'audio/mpeg'\r\n    this.ctx.body = result\r\n  }\r\n}\r\n复制代码小程序客户端template代码（使用的mpvue）\r\n<template>\r\n  <div class=\"container\">\r\n    <div class=\"preview\">\r\n      <textarea :class=\"textAreaFocus? 'focus' : ''\" \r\n      auto-height @focus=\"bindTextAreaFocus\" \r\n      @blur=\"bindTextAreaBlur\" placeholder=\"请输入文本\" \r\n      v-model=\"text\"  maxlength=\"256\"/>\r\n    </div>\r\n    <div class=\"setting\">\r\n      <picker @change=\"bindPlatChange\" v-model=\"platIndex\" range-key=\"name\" :range=\"platArr\">\r\n        <div class=\"item\">\r\n          <div class=\"label\">选择平台</div>\r\n          <div class=\"value voice\">\r\n            {{platArr[platIndex].name}}\r\n          </div>\r\n        </div>\r\n      </picker>\r\n      <picker @change=\"bindPickerChange\" v-model=\"index\" range-key=\"name\" :range=\"array\">\r\n        <div class=\"item\">\r\n          <div class=\"label\">选择发音人</div>\r\n          <div class=\"value voice\">\r\n            {{array[index].name}}\r\n          </div>\r\n        </div>\r\n      </picker>\r\n      <div class=\"item speed\">\r\n        <div class=\"label\">调节语速</div>\r\n        <div class=\"value\">\r\n          <slider @change=\"onSpeedChange\" :value=\"speedObj.default\" :step='speedObj.step' activeColor=\"#6F8FFF\" :min=\"speedObj.min\" :max=\"speedObj.max\" show-value />\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <div style=\"height: 140rpx;\">\r\n      <div class=\"btn-group\">\r\n        <div class=\"item\"><button @click=\"audioPlay\" type=\"main\">播放合成语音</button> </div>\r\n        <div class=\"item\"> <button @click=\"audioDownload\" type=\"submain\">复制链接下载</button> </div>\r\n      </div>\r\n    </div>\r\n    <div class=\"desc\">\r\n      说明：tts是英文 text to speech的缩写，即文本转语音技术\r\n      <contact-button \r\n        type=\"default-light\"\r\n        session-from=\"weapp\">联系客服\r\n      </contact-button>\r\n    </div>\r\n  </div>\r\n</template>\r\n复制代码script 代码\r\n<script>\r\nimport voiceIdArray from './voiceIdArray'\r\n\r\nexport default {\r\n\r\n  data () {\r\n    return {\r\n      array: voiceIdArray.aispeech,\r\n      platArr: [{id: 'xf', name: '科大讯飞'}, {id: 'aispeech', name: '思必驰'}, {id: 'baidu', name: '百度'}],\r\n      platIndex: 1,\r\n      index: 26,\r\n      text: `改革春风吹满地，吹满地，春风吹满地。\\n中国人民真争气，真争气，人民真争气。\\n这个世界太疯狂，耗子都给猫当伴娘。\\n齐德隆，齐东强。\\n齐德隆的咚得隆咚锵。`,\r\n      voiceId: 'lili1f_diantai',\r\n      speed: 1,\r\n      textAreaFocus: false,\r\n      audioCtx: null,\r\n      ttsServer: 'https://tts.server.com',\r\n      audioSrc: '',\r\n      downloadUrl: '',\r\n      xfSpeedObj: {\r\n        min: 0,\r\n        max: 100,\r\n        default: 50,\r\n        step: 1\r\n      },\r\n      aispeechSpeedObj: {\r\n        min: 0.7,\r\n        max: 2,\r\n        default: 1,\r\n        step: 0.1\r\n      },\r\n      baiduSpeedObj: {\r\n        min: 0,\r\n        max: 9,\r\n        default: 5,\r\n        step: 1\r\n      },\r\n      speedObj: {}\r\n    }\r\n  },\r\n  watch: {\r\n    platIndex (newVal, oldVal) {\r\n      if (newVal === 2) {\r\n        this.array = voiceIdArray.baidu\r\n        this.index = 0\r\n        this.speedObj = this.baiduSpeedObj\r\n      }\r\n      if (newVal === 1) {\r\n        this.array = voiceIdArray.aispeech\r\n        this.index = 26\r\n        this.speedObj = this.aispeechSpeedObj\r\n      }\r\n      if (newVal === 0) {\r\n        this.array = voiceIdArray.xf\r\n        this.index = 0\r\n        this.speedObj = this.xfSpeedObj\r\n      }\r\n    }\r\n  },\r\n  onShareAppMessage () {\r\n    return {\r\n      title: '文本转语音服务，多发音人可选'\r\n    }\r\n  },\r\n  methods: {\r\n    onSpeedChange (e) {\r\n      this.speedObj.default = e.target.value\r\n    },\r\n    bindPlatChange (e) {\r\n      this.platIndex = e.target.value * 1\r\n    },\r\n    bindPickerChange (e) {\r\n      this.index = e.target.value\r\n    },\r\n    getAudioSrc () {\r\n      if (this.text === '') {\r\n        return false\r\n      }\r\n      const speed = this.speedObj.default\r\n      const voiceId = this.array[this.index].id\r\n      const plat = this.platArr[this.platIndex].id\r\n      return encodeURI(`${this.ttsServer}/tts?plat=${plat}&voiceId=${voiceId}&speed=${speed}&text=${this.text}`)\r\n    },\r\n    getDownloadUrl () {\r\n      const plat = this.platArr[this.platIndex].id\r\n      const voiceId = this.array[this.index].id\r\n      wx.showLoading({\r\n        title: '加载中'\r\n      })\r\n      wx.request({\r\n        url: 'https://tts.server.com/getdownloadurl',\r\n        data: {\r\n          plat: plat,\r\n          voiceId: voiceId,\r\n          speed: this.speedObj.default,\r\n          text: this.text\r\n        },\r\n        header: {\r\n          'content-type': 'application/json' // 默认值\r\n        },\r\n        success (res) {\r\n          wx.hideLoading()\r\n          wx.setClipboardData({\r\n            data: res.data.short_url,\r\n            success (res) {\r\n              wx.showToast({\r\n                title: '链接已复制请用浏览器下载(ios端无法下载)',\r\n                icon: 'none',\r\n                duration: 3000\r\n              })\r\n            }\r\n          })\r\n        }\r\n      })\r\n    },\r\n    audioPlay () {\r\n      this.audioCtx.src = this.getAudioSrc()\r\n      if (!this.audioCtx.src) {\r\n        wx.showToast({\r\n          title: '请先输入文本',\r\n          icon: 'none',\r\n          duration: 2000\r\n        })\r\n        return false\r\n      }\r\n      wx.showLoading({\r\n        title: '加载中'\r\n      })\r\n      this.audioCtx.play()\r\n    },\r\n    audioDownload () {\r\n      this.getDownloadUrl()\r\n    },\r\n    bindTextAreaBlur (e) {\r\n      this.textAreaFocus = false\r\n      this.text = e.target.value\r\n    },\r\n    bindTextAreaFocus () {\r\n      this.textAreaFocus = true\r\n    }\r\n  },\r\n\r\n  created () {\r\n    this.speedObj = this.aispeechSpeedObj\r\n  },\r\n  mounted () {\r\n    this.audioCtx = wx.createInnerAudioContext()\r\n    this.audioCtx.onEnded((res) => {\r\n      wx.hideLoading()\r\n    })\r\n    this.audioCtx.onPlay((res) => {\r\n      wx.hideLoading()\r\n    })\r\n    wx.showShareMenu({\r\n      withShareTicket: true\r\n    })\r\n  }\r\n}\r\n</script>\r\n复制代码接口对接过程中，百度的是最方便的因为有sdk可以直接使用，讯飞的最麻烦需要自己做参数加密，思必驰dui的虽然没提供SDK但是文档写的比较详细对接过程也很方便快速。\r\n目前无法解决的就是，小程序内无法直接下载的问题，只能提供链接，然后用户自己打开浏览器进行下载（iPhone似乎无解）。"}
{"title": "经验总结--我的小程序开发和进化之路 ", "author": "Rolan", "pub_time": "2019-1-22 00:12", "article_content": "从接触小程序开始，到现在大大小小做了差不多有五六个小程序项目了，小项目的只有几个页面，大的项目有几十个页面。此篇文章是对之前项目的一个总结，项目的脚手架，开发框架和后期的优化是一个逐渐进化完善的过程，如果你打算开发小程序或者已经在开发小程序，相信这些经验对你会有一定的帮助。脚手架小程序开发者工具可以直接编写小程序的，但是开发工具就像武士手中的剑，多年磨炼，已经达到人剑合一了，突然换把武器，那势必影响杀敌效率，所以使用自己熟悉的开发工具还是很有必要的。本人所在的公司基本都是中小型公司，项目开发周期都很短，前期的准备工作最多也就几天时间，所以自己去撸一套脚手架然后用于项目开发，难度比较大，在网上找优质的资源是最好的选择。大佬justjavac的开源项目 微信小程序开发资源汇总 ，涵盖了大量的优质小程序开发资源，在此推荐一波。当然，脚手架的选择也是视项目而定的，如果只有几个页面的项目，搞一套很重的工具未免有点画蛇添足了。我们的做法是小项目，直接撸，大点的项目选用网络上的优质资源+自己改写。17年的电商项目，模块不多，采用的脚手架比较简单，使用gulp监听文件改动，实时编译，支持ES6+语法。脚手架地址18年中旬的电商项目，到了新的公司，当时选用了WePY进行开发，特性简单介绍下：类Vue的开发风格组件化开发（WePY出来的时候，小程序还不支持组件）支持加载外部NPM包(小程序原生也支持)使用babel编译，支持ES6/7的语法针对原生API进行优化详细介绍请点击WePY文档进行查看，后续框架选择上也会提到，差点被这框架害惨了。最近的一个地产项目，也是下一个项目打算使用的， weapp-start ，上文提到的小程序开发资源汇总中也有提到，特性如下：支持 npm 包引入支持 promise, async/await 等最新语法支持多种编译器，如 pug/less/stylus支持 ESlint支持本地 mock 数据支持一键生成项目，组件模版支持发布前资源压缩支持自定义插件多种工具，加速开发项目的地址为 weapp-start ，其中 weapp-plugin-require（分析依赖，导入第三方 npm） ，存在问题，window操作系统会出现路径错误，我已修复，并给作者提了PR，但作者并没有修复这个问题，如果有同学要用到这个脚手架，请下载我修改好的文件进行替换， 下载地址 。另推荐我根据weapp-start搭建的环境，目录结构为：├── README.md                 // 说明文档\r\n├── dist                      // 编译后的代码，用小程序开发工具打开此文件夹\r\n├── mock.js                   // 模拟数据的文件\r\n├── package-lock.json\r\n├── package.json\r\n├── project.config.json       // 项目配置文件\r\n├── src                       // 项目代码都在这个文件夹下\r\n│   ├── app.js                // 等同于小程序根目录下的app.js\r\n│   ├── app.json              // 等同于小程序根目录下的app.json\r\n│   ├── app.wxss              // 等同于小程序根目录下的app.wxss\r\n│   ├── assets                // 项目中使用到的静态资源\r\n│   │   └── images\r\n│   │       ├── example\r\n│   │       └── tab\r\n│   ├── components            // 公用的组件\r\n│   ├── page                  // 存放小程序的各个页面文件\r\n│   │   ├── example           // example 页面\r\n│   │   │   ├── components    // example页面中的组件\r\n│   │   │   ├── index.js\r\n│   │   │   ├── index.json\r\n│   │   │   ├── index.wxml\r\n│   │   │   ├── index.wxss\r\n│   │   │   ├── services      // example页面中接口\r\n│   │   │   ├── template      // example页面中的模板\r\n│   │   │   └── wxs           // example页面中的wxs文件\r\n│   │   ├── globalStore.js    // 全局共享的数据\r\n│   │   └── test\r\n│   │       ├── index.js\r\n│   │       ├── index.json\r\n│   │       ├── index.wxml\r\n│   │       └── index.wxss\r\n│   ├── template              // 公用的模板\r\n│   └── utils                 // 公用的方法或工具\r\n│       ├── config.js         // 全局的一些配置信息\r\n│       ├── create.js         // 状态管理插件\r\n│       ├── mitt.js           // 状态管理插件\r\n│       ├── obaa.js           // 状态管理插件\r\n│       ├── util.js           // 公用方法\r\n│       ├── wxRequest.js      // 封装的小程序请求数据方法\r\n│       └── wxapi.js          // 对小程序api进行Promise封装\r\n└── weapp.config.js           // 对脚手架的配置文件\r\n复制代码项目地址为 点击查看 ，觉得有用的请Star或者fork哟。当然，网上也有很多优秀的脚手架，大家可以根据自己的需要选择哟。小程序开发框架17年的项目并没有使用开源的框架，直接使用原生小程序写的，开发过程印象中并没有很多的坑，只记得当时用到了一个富文本的插件， wxParse ，现在已5000多个Star了，虽然现在小程序有了富文本组件 rich-text ，但在最近的项目中还是用了这个插件，因为后端的兄弟说，他们不能将html转成 rich-text 需要的数据格式，后端是java的，有使用这个组件的同学，麻烦下面留个言，我要去鄙视后端一下。前文提到自己在项目开发过程中使用过WePY框架，那么下面我就简单列一下现在比较火热的三大小程序框架WePY，mpvue和Taro的特性，然后着重说下WePY：mpvue（美团）彻底的组件化开发能力：提高代码复用性完整的 Vue.js 开发体验方便的 Vuex 数据管理方案：方便构建复杂应用快捷的 webpack 构建机制：自定义构建策略、开发阶段 hotReload支持使用 npm 外部依赖使用 Vue.js 命令行工具 vue-cli 快速初始化项目H5 代码转换编译成小程序目标代码的能力taro （京东）React 语法风格支持使用 npm/yarn 安装管理第三方依赖。持使用 ES7/ES8 甚至更加新的 ES 规范，一切都可自行配置。持使用 CSS 预编译器，例如 Sass 等。持使用 Redux 进行状态管理。持使用 Mobx 进行状态管理。程序 API 优化，异步 API Promise 化等等。WePY （腾讯）上文已列出，此处不再赘述三大框架分别是国内三家大佬的前端团队产物，印象中mpvue和taro都是18年下半年出来的，WePY出来的最早，几乎和小程序同步。mpvue拥抱了vue，taro拥抱了react，WePY握住了vue的手，mpvue和taro都没有用过，我们只是开发个小程序，不用做到H5和RN共用一套代码，所以18年中开发的一个电商小程序选择了WePY，毕竟腾讯的产物，亲儿子。后来了解到，是腾讯的儿子没错，不过是养子，WePY本来是腾讯内部一员工的个人项目，后来腾讯团队看这个项目不错，就由官方来维护了，由此带来了一些问题，曾在掘金看到过对WePY作者的专访（好像是专访，文章我找不到了），作者自己也承认，WePY前期的一些核心代码存在的缺陷，后期很难修复了，像脏检查机制，据说2.0会有很大的改变。贴一张WePY其中的一个 Issue ，我们当时的心情和他是一样一样的，不过我们不用重构了，项目死掉了，哈哈哈哈（悲凉的笑）自己曾经写过一篇 wepy+weappx开发小程序遇到的坑以及解决方案 ，文中列举了开发过程中遇到的一些问题和解决方式，在此就不赘述了，想了解的同学可以点击查看。如果你要问我开发小程序选择那个框架合适？我只能给出一个建议，根据需求来定，如果只是单纯的想做个小程序，就不要用框架了，小程序的语法目前已经很完善了，何必要去学习两套语法呢，出了问题，又改不动他们框架，一句话概括下就是， 小程序原生有的问题他们肯定有，原生没的问题，他们可能给你造出来 。当然，如果有写一套代码适用H5和RN,那么可以考虑下mpvue和taro，作者更新很频繁，有团队维护，至于能不能提高效率，还得看需求，我们现在是不会选用任何框架了，小程序已经玩的很熟，没必要再折腾了。小程序开发建议在开发过程中，我们总结了一些感觉比较好的开发实践，在此奉献一波，大佬别笑哈。目录结构上文中脚手架第三项中贴出的目录结构，是目前我们觉得比较好的一种形式（参照umi项目的建议），按页面组织代码，将一个页面所需要的内容放在同一个文件夹，方便日后的维护和有类似页面开发时候的复制，存在公用组件的时候，放到外部的文件夹中，当一个项目大了以后，这种目录结构，真的很方便。组件的层级组件的层级真的不能太深，2层最好，不能超过3层，之前项目有的封装组件过度，层级太深，后期维护，根据数据传递一层层的去找代码，简直不要太爽（反话）。状态管理目前小程序能用的状态管理框架也是比较多的，Redux，Mobx，还有基于Redux二次开发的像weappx，都很好，在这推荐两个自己用过和打算用的，使用过的 weappx ，打算用的 omi-mp-create ，项目比较小可以不用，大项目还是用上吧，都放到global中，不好维护。频繁setData的功能放到组件中电商项目中，少不了类似倒计时这种功能的，像这种需要频繁setData操作的功能，应该单独放到一个组件中，为啥呢？当你setData的时候，小程序会有一个遍历监听了data数据方法的过程，比如当你setData的时候，小程序wxs中的函数都会执行，在我上文提到自己的脚手架中有这个例子 weapp-quick-start ，感兴趣的可以测试一下。使用WXS小程序对js表达式的支持并不是很好，当然，就算可以，我也曾见过这样的代码<block wx:if=\"{{drawgift.giftDetail.virtualGoods.length>1||((drawgift.giftDetail.realGoods.length>0||drawgift.giftDetail.couponGoods.length>0)&&drawgift.giftDetail.virtualGoods.length>0)}}\">\r\n\r\n复制代码把这些判断的逻辑放到wxs中，统一维护岂不是美哉。还有一点，官方说在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍，所以，能用还是要用起来的。控制包的大小，分包加载等不用的包，别偷懒，统统删掉，至于分包加载等，推荐看下这篇文章，我就不啰嗦了 微信小程序：一些运行细节及针对性的优化策略"}
{"title": "Hybrid小程序混合开发之路 - 数据交互 ", "author": "Rolan", "pub_time": "2019-1-23 00:34", "article_content": "很多应用在原生界面中混杂着HTML界面记得xp时代的QQ，有些界面偶尔会弹出熟悉的js错误对话框，还能右键弹出熟悉的IE6的右键菜单，伪装的挺好，差点没认出来，现在的QQ就不知道了。美团、淘宝这些拥有几乎无限界面的手机App，顶部进度条一亮，这是一个H5 没谁了！Electron！好嗨哟~数据交互使用了HTML作界面，那么和原生程序之间的数据交互基本上是少不了的~（仅仅当做浏览器性质来用的就算了）~。如原生程序要控制H5界面变化，就需要由原生程序传出数据到H5。如H5界面用户点击动作触发涉及原生程序业务逻辑的调用，就需要由H5传入数据到原生程序。这两种数据传输组合在一起就成了交互。在自行嵌入浏览器内核、Electron都可以有自己的接口实现，Android、水果~（滑稽，本文与此物种无关，下同）~都有成熟的解决方案。小程序\" style=\"font-size: 21px; line-height: 1.5; margin: 1.3rem 0rem; border-bottom: 3px solid rgb(0, 102, 153); color: rgb(47, 47, 47); font-family: Roboto, \"Hiragino Sans GB\", \"Microsoft Yahei\", \"WenQuanYi Micro Hei\", SimSun, Tahoma, Arial, Helvetica, STHeiti; background-color: rgb(255, 255, 255);\">Hybrid App 与 Hybrid 小程序Hybrid App并非一定是和H5的混合开发，但本文所说的专指H5。同一界面，编写一次代码，就能同时运行在Android、水果、浏览器之上，说没有诱惑力是假的。小程序并非一定指的的某家的小程序，但本文所说的专指微信小程序。拥有一个强大的流量入口，嗯，就只这一点 ~（看好PWA）~。自从微信小程序开放了webview，和Hybrid App就有了共性，然后生了个“Hybrid 小程序”，是我一个人这么叫吗？我不管，我就要叫！然鹅，开发者对小程序底层的话语权几乎为0，小程序给什么我们就吃什么，嗯，真香。虽然提供了webview，但未提直接的供交互手段（记得要双向才能算交互吗，单向传递数据一边玩球）。似乎Hybrid之路已然折戟。Hybrid 小程序数据交互终极手段，合理合法！注：发现有人采用的是websocket来实现的数据交互，原生小程序和H5都通过服务器来中转数据，点评：这也是个好办法。数据传入基本原理：H5使用wx.miniProgram.navigateTo传递数据给小程序原生程序代码。数据传出基本原理：通过改变webview src中的hash，来实现无刷新数据传入原生小程序。最初开放webview时可用，后面有版本不行了，改变src中任意字符会导致重新加载界面，神奇的是现在又恢复了改变hash不会刷新。升级版：通过改变后台webview src中的hash，实现数据传入我们后台页面，不管有没有重新加载，hash始终能被我们的H5代码接收（而且省去了处理url变化的问题）。然后由后台页面传输数据给前台页面。实战举个支付吧，点击H5内的支付按钮，执行完业务逻辑，支付条件准备完毕，现在需要调起微信支付。小程序启动小程序启动。启动Response.wxml，webview加载后台页面。启动Main.wxml，保留Response.wxml后台页面在后台运行，前台主界面加载页面。启动完毕。开始支付主界面请求jssdk wx.miniProgram.navigateTo接口向Request.wxml界面发起请求，path中携带请求数据。Request.wxml原生程序接收到请求，发现支付请求并不需要保留界面，立马返回上一个界面(前台主界面)；然后后台继续处理支付请求，调起微信支付。前台主界面H5此时应该是在等待Request.wxml的响应结果，并且微信已经弹出支付功能。用户支付完成，Request.wxml残留代码收到支付响应结果，立马通知Response.wxml修改后台页面src中的hash，响应结果数据包含在其中。后台页面监听到hash change事件，或 页面刚刚加载完毕事件。从hash中拿到响应数据。后台页面把响应数据写入localStroage，前台页面监听到localStroage数据。成功得到支付响应数据。问题缺陷第2步虽然立即返回了，但还是会有一个短暂的界面切换动画，不过这种数据交互本来就是重量级的，也不可能频繁调用，Android和水果都是一样的，所以用户体验就是这么可观。改变webview src hash产生的行为是不可预测的 ，任性的版本，如果会刷新页面，延迟会比较大，甚至导致两次调用之间相互覆盖结果。应用案例笔者最近开发的小程序《祝福贺卡助手》，主功能采用的纯web网页，底层和微信小程序的数据交互就是本文介绍的这套模式。有2个比较重要的交互接口，一个是获取用户数据、另外一个是调起分享；当然还有一堆其他辅助类的接口。扫码体验网页版：小程序版：界面和功能开发一遍，网页、小程序通吃~ 这就是Hybrid小程序的魅力！围绕着小程序《祝福贺卡助手》的开发和审核上线过程，对于其中一些有趣的东西，我会分享出来。下篇内容预告：Hybrid小程序混合开发之路 - H5录音和水果的对抗。"}
{"title": "以小程序为例，学习如何将异步回调接口 Promise 化 ", "author": "Rolan", "pub_time": "2019-1-23 00:42", "article_content": "前言\r\nES6 标准的 Promise 解决了 Javascript 代码中比较常见的回调地狱问题，搭配 async/await 可以用同步的方式写异步逻辑，大大提高了开发效率。\r\n但是至今仍有很多库没有实现 Promise 化的接口，其中就包括微信小程序的 api。\r\n为了不向恶势力妥协，写出风格统一的代码，我们有必要了解何为 Promise。\r\n本文假定读者有一定 JavaScript 基础，同时了解 Promise 的基本用法。\r\n回调接口\r\n异步回调接口指的是通过传递函数来处理异步方法调用，一般有两种方式。\r\n\r\n\r\n小程序方式\r\n分别传递成功和失败的回调以处理两种不同情况\r\nwx.showToast({\r\n  title: 'Hello, world',\r\n  success: () => console.log('success'),\r\n  fail: () => console.log('failure'),\r\n})\r\n复制代码\r\n\r\nMongoDB 方式\r\n传递一个以 error 为首参数的回调用以鉴别是否调用成功\r\ndb.find({ name: 'Idan Loo' }, (err, data) => {\r\n  if (err) {\r\n    // err 是调用失败的原因\r\n    console.log(err)\r\n    return\r\n  }\r\n  // data 就是异步传递回来的参数\r\n  console.log(data)\r\n})\r\n复制代码\r\n\r\n两种方式各有千秋，这里仅讨论微信方式，MongoDB 方式的接口 Promise 化相信各位可以举一反三。\r\nPromise 化\r\n简单实现\r\n以 showToast 为例\r\nconst showToast = option =>\r\n  new Promise((resolve, reject) => \r\n    wx.showToast({...option,\r\n      success: resolve,\r\n      fail: reject,\r\n    })\r\n  )\r\n\r\nshowToast({ title: 'Hello, Promise' })\r\n  .then(() => console.log('success'))\r\n  .catch(() => console.log('failure')) \r\n复制代码你已经知道了如何 Promise 化小程序的接口，现在你只需要重复上面的代码，将所有你需要用到的接口改为 Promise 的即可。\r\n高级一点的实现\r\n复制粘贴一把梭虽然快，但是作为一名程序员，自然应该追求更简洁的实现。\r\n通过观察，小程序所有的异步接口都采用了相同的形式，并且都位于 wx 对象中，故我们可以抽象出通用的 promisify 方法用以 Promise 化小程序的接口\r\nconst promisify = name => option => \r\n  new Promise((resolve, reject) =>\r\n    wx[name]({...option,\r\n      success: resolve,\r\n      fail: reject,\r\n    })\r\n  )\r\n\r\nconst showToast = promisify('showToast')\r\nconst request = promisify('request')\r\n复制代码现在只需一行代码，就可以 Promise 化小程序的接口，赶紧把之前写的丑陋的回调代码改过来吧！\r\n更高级的实现\r\n如果你跟我一样，代码洁癖到上述代码都接受不了的话，那恭喜你，通过 Proxy 可以更好的实现我们的目标。\r\nconst pro = new Proxy(wx, {\r\n  get(target, prop) {\r\n    return promisify(prop)\r\n  }\r\n})\r\n\r\npro.showToast({ title: 'Hello, world' }).then(...)\r\npro.request({ url: 'https://github.com' }).then(...)\r\n复制代码在 promisify 方法的基础上，给 wx 对象加了个代理，现在你可以像使用 wx 对象一样使用 pro，并且所有的异步方法都变成了 Promise 形式的！\r\n无需实现\r\n最好的实现就是交给别人实现，正好我已经把前文中的代码打包上传, minapp-promise，不足 1k，开箱即用。\r\n能看到这里着实不易，希望你们能给我点个赞，顺便在 GitHub 给我个星星就更好了。\r\n手机码字，如有错漏，万望斧正。"}
{"title": "小程序使用 Iconfont 的正确姿势 ", "author": "Rolan", "pub_time": "2019-1-24 00:12", "article_content": "现如今移动设备分辨率不胜枚举，传统的标量图标要分别导出 1 倍图、2 倍图、3 倍图等以适应高分辩率设备。这无疑大大增加了设计师和客户端开发的工作量。矢量图以其无损缩放的优点，在图标方面有着极大的优势。Iconfont 是由阿里推出，功能强大且图标内容很丰富的矢量图标库，提供矢量图标下载、在线存储、格式转换等功能，几乎国内成了矢量图标库的事实标准。每个 Iconfont 项目都可以生成一个远程 .css 文件，下文以 //at.alicdn.com/t/font_883452_bqb4vsc7km8.css 为例。你可以查阅教程了解如何生成 .css 文件。正常 Iconfont 的使用流程是在 HTML 的 head 标签中引入样式文件，然后通过类名调用图标<html>\r\n    <head>\r\n        <link href=\"//at.alicdn.com/t/font_883452_bqb4vsc7km8.css\" />\r\n    </head>\r\n    <body>\r\n        <!-- 这是一个名为 plus 的 icon -->\r\n        <i class=\"iconfont icon-plus\"></i>\r\n    </body>\r\n</html>\r\n复制代码不幸的是小程序不支持引入外部 css 文件，为此我寻遍网络，竟没有找到 Iconfont 在小程序中的正确用法。本文根据我在实践经验所得，是我目前能找到在小程序中使用 Iconfont 最简的方法。引入虽然小程序不支持引入外部样式表，但 .wxss 文件本质上就是 .css 文件，因此我们可以将 Iconfont 的样式表保存到本地的 .wxss 中。下载 at.alicdn.com/t/font_883452_bqb4vsc7km8.css 至 /iconfont.wxss ，并在 app.wxss中引入@import \"/iconfont.wxss\";\r\n复制代码在 .wxml 文件中使用<text class=\"iconfont icon-plus\"></text>\r\n复制代码现在应该可以在开发者工具中看到你想要的图标了。解决了基本的使用问题之后，我们发现，由于小程序组件内部有独立的类作用域，因此在 app.wxss 中引入的 .iconfont 和 .icon-plus 并不能在自定义组件内生效，所以你需要在所有需要用到 Iconfont 的组件内，分别引入 iconfont.wxss 。组件化如果你看过我之前的文章，应该知道我对冗余代码深恶痛绝。自定义组件就是解决重复引入的手段。"}
{"title": "微信小程序-flex布局中align-items和align-self区别 ", "author": "Rolan", "pub_time": "2019-1-24 00:24", "article_content": "首先看看菜鸟教程中关于align-items和align-self的定义align-items：align-items 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。（对齐弹性盒的各项元素）align-self：align-self 属性定义flex子项单独在侧轴（纵轴）方向上的对齐方式。（对齐弹性对象元素内的某个项）从定义上可以看出是对齐”目标“上存在差异，这样看上去似乎不太便于理解/*index.wxml*/\r\n<view class=\"container\">\r\n\r\n  <view class=\"item\" style='order:/4'>\r\n      1\r\n  </view>\r\n\r\n\r\n  <view class=\"item\">\r\n      2\r\n  </view>\r\n  \r\n  <view class=\"item  i3\">\r\n      3\r\n  </view>\r\n \r\n  <view class=\"item\">\r\n       4\r\n  </view>\r\n\r\n  \r\n\r\n\r\n</view>/*index.wxss*/\r\n.container{\r\n  height: 100px;\r\n  width: 100%;\r\n  background-color: green;\r\n  display: flex;\r\n  /* flex-direction: column; */\r\n  flex-direction: row;\r\n  flex-flow: wrap;\r\n\r\n  justify-content:space-between;  \r\n  align-items: flex-start;\r\n}\r\n.item{\r\n  width: 100rpx;\r\n  height: 100rpx;\r\n  background-color: yellow;\r\n  border: 1px solid white;\r\n\r\n\r\norder: 3;\r\n}\r\n.i3{\r\n  display: flex;\r\n  align-items: flex-end;\r\n  /* flex-grow: 1; */\r\n  order: 1;\r\n}这里用align-items显示的结果如图，可以看到此时文字是在下方，而色块并没到下方如果将代码align-items换为align-self，整个块都以从下往上的方式排列了，而数字的位置仍然是在左上角"}
{"title": "微信小程序地图(map)组件点击(tap)获取经纬度 ", "author": "Rolan", "pub_time": "2019-1-9 00:23", "article_content": "微信小程序中使用地图(map)组件，通过点击(tap)获取经纬度，按照官方的回应，暂时是没法做到的，从地图组件API多有残缺判断，怀疑是个实习生干的...做个变通，适用性有限，请大家参考。基本思路就是在地图上铺满一层marker，从而通过点击marker获得经纬度。<map id=\"map\" longitude=\"102.324520\" latitude=\"40.099994\" scale=\"4\" bindcontroltap=\"controltap\"polygons=\"{{polygons}}\" bindregionchange=\"regionchange\" markers=\"{{markers}}\"bindmarkertap=\"markertap\" show-location style=\"width: 100%; height: 700px;\"></map>const app = getApp()\r\n\r\nconst markersize = 30\r\n\r\nfunction range(start, edge, step) {\r\n  for (var ret = [];\r\n    (edge - start) * step > 0; start += step) {\r\n    ret.push(start);\r\n  }\r\n  return ret;\r\n}\r\n\r\nfunction markers(northeast, southwest, scale, width, height) {\r\n\r\n  const markerslng = (northeast.longitude - southwest.longitude) * markersize / width\r\n  const markerslat = (northeast.latitude - southwest.latitude) * markersize / height\r\n\r\n  const maxlon = northeast.longitude\r\n  const minlon = southwest.longitude\r\n  const maxlat = northeast.latitude\r\n  const minlat = southwest.latitude\r\n\r\n  const lons = range(minlon, maxlon, markerslng)\r\n  const lats = range(minlat, maxlat, markerslat)\r\n\r\n  let _markers = []\r\n  lons.forEach((lon, i) => {\r\n    lats.forEach((lat, j) => {\r\n      _markers.push({\r\n        id: lon + ',' + lat,\r\n        latitude: lat,\r\n        longitude: lon,\r\n        iconPath: '/marker.png',\r\n        alpha: 0.1, //将图片设置为透明,通过开发者工具看不出效果,但真机是有效果的\r\n        width: markersize,\r\n        height: markersize\r\n      })\r\n    })\r\n  })\r\n  return _markers\r\n}\r\n\r\nPage({\r\n  data: {\r\n    polygons: [],\r\n    controls: [{\r\n      id: 1,\r\n      position: {\r\n        left: 0,\r\n        top: 300 - 50,\r\n        width: 50,\r\n        height: 50\r\n      },\r\n      clickable: true\r\n    }],\r\n    markers: []\r\n  },\r\n  createMarkers() {\r\n\r\n    this.mapCtx = wx.createMapContext('map')\r\n    const query = wx.createSelectorQuery()\r\n    const map = query.select('#map').boundingClientRect()\r\n\r\n    let that = this\r\n\r\n    that.mapCtx.getRegion({\r\n      success(res1) {\r\n        that.mapCtx.getScale({\r\n          success(res2) {\r\n            query.exec((res) => {\r\n              let width = res[0].width;\r\n              let height = res[0].height;\r\n              let _markers = markers(res1.northeast, res1.southwest, res2.scale, width, height)\r\n              that.data.markers = _markers\r\n              that.setData(that.data)\r\n            })\r\n          }\r\n        })\r\n      }\r\n    })\r\n  },\r\n  regionchange(e) {\r\n    this.createMarkers()\r\n  },\r\n  markertap(e) {\r\n    console.log(e.markerId)\r\n  },\r\n  controltap(e) {\r\n    console.log(e.controlId)\r\n  },\r\n  onReady(e) {\r\n    this.createMarkers()\r\n  }\r\n})效果如图"}
{"title": "小程序开发采的几个坑 ", "author": "Rolan", "pub_time": "2019-1-8 00:16", "article_content": "上个月参与了助力小程序的开发，其中也遇到了一些小程序开发过程之中的问题。getMenuButtonBoundingClientRect获取菜单按钮（右上角胶囊按钮）的布局位置信息。坐标信息以屏幕左上角为原点。如果我们使用的是自定义导航模式（ navigationStyle: 'custom' ），一般则需要通过此函数来获取菜单按钮的信息：此函数从官方文档上看是同步的，但是经过实际中发现，它可能是异步的。经常有的时候会获取不到相应的 bottom、top 等信息。video 组件的全屏问题经过测试发现，小程序的 video 组件会在进入全屏播放，然后退出全屏的过程中黑屏。重现步骤： 1.视频进行全屏播放 2.拉动进度条播放 3.页面显示加载中时，点击小屏播放 4.页面显示黑屏，并且卡住不动，一直无法播放经过确认，是微信官方的 Bug：低版本 IOS 兼容性问题因为小程序底层也是通过 webview 来渲染，所以有一些通用的兼容性问题要注意。 比如IOS9、IOS10下面的绝对定位（absolute、fixed）必须要有多个定位(left / top)，如果只写一个定位，比如只写一个 top: 0; ，你会发现在开发者工具和 IOS11以上真机是可以显示的，但是在低版本上却无法显示。"}
{"title": "微信小程序之构建 ", "author": "Rolan", "pub_time": "2019-1-8 00:27", "article_content": "由于小程序更新迭代速度很快，而且我们的技术栈是 react 全家桶，所以在对比 wepy 和 mpvue 之后，我们选择了直接使用原生小程序。对比图如下：当然直接使用原生的有个显然的缺点：没有了构建。不过这没有关系，缺什么补上即可。需要构建做什么一般来说，我们需要构建主要是用来做这些工作：ES6/7 转 ES5、NPM 包管理、组件化、 CSS 预编译、图片压缩、打包合并等。而这些能力除了CSS 预编译和图片压缩之外，其他的功能小程序默认已经提供了。所以一个小巧的小程序构建只需要支持CSS 预编译和图片压缩即可。Gulp 构建方案既然只涉及到一些任务的处理，那么使用 gulp 是最合适不过的了。对于 CSS 预编译，有 gulp 对应的 sass、less、postcss 插件可选；对于图片压缩，可以使用 gulp 的 imagemini 插件，再装上各种图片的格式对应的压缩库即可。一般来说，运行构建命令，我们都会从一个源目录（src）到一个目标目录（dev/dist），但是小程序的 NPM 能力是不允许 node_modules 在根目录之外的，这就有了冲突。总不能跑个任务拷贝整个 node_modules 到目标目录吧。既然不能使用从一个源目录（src）到一个目标目录（dev/dist），那就只好在源目录就地解决了。源目录解决方案对于图片来说，压缩完了直接替换原图是没什么问题的。对于 CSS 预编译来说，如使用 postcss，从 CSS 文件到 WXSS 文件比较好解决。但是又引出了两个新问题：CSS 文件最好是不要打包发布。最好避免误修改 WXSS 文件，而是直接修改 CSS 文件。第一个我们可以在项目配置文件中设置上传代码的时候过滤 CSS 文件；第二个我们可以在 VSCode 编辑器中隐藏 WXSS 文件，避免误操作。To Base64既然有了构建，当然希望还能把一些缺失的能力补上。如 background 不支持本地图片。对于这个 postcss 也有相关的插件能解决：background-image\r\n代码配置最后贴上相关的代码配置。gulpfile.jsconst gulp = require('gulp');\r\nconst rename = require('gulp-rename');\r\nconst runSequence = require('run-sequence');\r\nconst postcss = require('gulp-postcss');\r\nconst imagemin = require('gulp-imagemin');\r\nconst cache = require('gulp-cache'); // 使用缓存\r\n\r\nconst src = './miniprogram';\r\n\r\n// 使用postcss\r\ngulp.task('css', () => {\r\n  return gulp.src(`${src}/**/*.css`)\r\n    .pipe(postcss())\r\n    .pipe(rename((path) => {\r\n      path.extname = '.wxss';\r\n    }))\r\n    .pipe(gulp.dest((file) => {\r\n      return file.base; // 原目录\r\n    }));\r\n});\r\n\r\ngulp.task('img', () => {\r\n  // 修改你要压缩的图片地址\r\n  return gulp.src(`${src}/**/*.{png,jpe?g,gif,svg}`)\r\n    .pipe(cache(imagemin([\r\n      imagemin.gifsicle({ interlaced: true }),\r\n      imagemin.jpegtran({ progressive: true }),\r\n      imagemin.optipng({ optimizationLevel: 4 }),\r\n      imagemin.svgo({\r\n        plugins: [\r\n          { removeDimensions: true }, // 如果有 viewbox 则不需要 width 和 height\r\n        ],\r\n      }),\r\n    ])))\r\n    .pipe(gulp.dest((file) => {\r\n      return file.base; // 压缩到原目录\r\n    }));\r\n});\r\n\r\ngulp.task('watch', () => {\r\n  gulp.watch(`${src}/**/*.css`, ['css']);\r\n});\r\n\r\ngulp.task('dev', ['css'], () => {\r\n  runSequence('watch');\r\n});postcss.config.jsconst path = require('path');\r\n\r\nmodule.exports = {\r\n  parser: 'postcss-scss',\r\n  plugins: {\r\n    'postcss-partial-import': {\r\n      path: [path.resolve(__dirname, 'src')],\r\n    },\r\n    'postcss-font-base64': {}, // font to base64\r\n    'postcss-advanced-variables': {},\r\n    'postcss-nested': {},\r\n    'postcss-extend-rule': {},\r\n    'postcss-color-function': {},\r\n    'postcss-url': {\r\n      url: 'inline', // inline image to base64\r\n    },\r\n  },\r\n};"}
{"title": "微信小程序复选框实现 多选一功能 ", "author": "Rolan", "pub_time": "2019-1-24 00:32", "article_content": "功能实现界面data: {\r\n    checkboxItems: [\r\n      { name: '全天(1-8节)', value: 'allday' },\r\n      { name: '上午(1-4节)', value: 'am' },\r\n      { name: '下午(5-8节)', value: 'pm' },\r\n      { name: '晚上(晚自习)', value: 'night' },\r\n    ]\r\n  }  想要实现的功能 四个复选框中只能选一个，且选中另一个会取消其余选中,且能保存选择的value值JS代码实现checkboxChange: function (e) {\r\n    var that = this;\r\n    let checkboxValues=null;\r\n    let checkboxItems = this.data.checkboxItems, values = e.detail.value\r\n    for (var i = 0, lenI = checkboxItems.length; i < lenI; ++i) {\r\n      if(checkboxItems[i].value==values[values.length-1]){\r\n        checkboxItems[i].checked=true;\r\n        checkboxValues = checkboxItems[i].value;\r\n      }\r\n      else{\r\n        checkboxItems[i].checked = false;\r\n      }\r\n    }\r\n    console.log(checkboxValues)\r\n    that.setData({ checkboxItems, checkboxValues })\r\n  }  前端代码 <view class=\"weui-cells weui-cells_after-title\">\r\n      <checkbox-group class=\"weui-flex\" bindchange=\"checkboxChange\">\r\n        <label class=\"weui-cell weui-check__label weui-flex__item\" wx:for=\"{{checkboxItems}}\" wx:key=\"value\">\r\n          <checkbox class=\"weui-check\" value=\"{{item.value}}\" checked=\"{{item.checked}}\" />\r\n          <view class=\"weui-cell__hd weui-check__hd_in-checkbox\">\r\n            <icon class=\"weui-icon-checkbox_circle\" type=\"circle\" size=\"23\" wx:if=\"{{!item.checked}}\"></icon>\r\n            <icon class=\"weui-icon-checkbox_success\" type=\"success\" size=\"23\" wx:if=\"{{item.checked}}\"></icon>\r\n          </view>\r\n          <view class=\"weui-cell__bd\">{{item.name}}</view>\r\n        </label>\r\n      </checkbox-group>\r\n    </view>对应的CSS样式是WeUI"}
{"title": "微信小程序登录那些事 ", "author": "Rolan", "pub_time": "2019-1-9 00:06", "article_content": "最近团队在开发一款小程序，都是新手，一边看文档，一边开发。在开发中会遇到各种问题，今天把小程序登录这块的流程整理下，做个记录。\r\n小程序的登录跟平时自己APP这种登录验证还不太一样，多了一个角色，那就是微信服务器。\r\n\r\n根据微信官方提供的登录流程时序图可以清楚的了解小程序登录需要多少个步骤，下面我们来总结下：\r\n\r\n小程序启动，通过wx.login()获取code\r\n开发者服务器需要提供一个登录的接口，参数就是小程序获取的code\r\n登录接口收到code后，调用微信提供的接口进行code的验证\r\n得到验证结果，成功后能得到一个session_key和openid\r\n生成一个自定义的key, 将session_key和openid跟自定义的key关联起来\r\n将自定义的key返回给小程序\r\n每次请求都带上key, 后端根据key获取openid识别当前用户身份\r\n\r\n首先code是微信给的，如果你随意生成code去验证肯定是无效的，只有微信给的code才有效。code传到开发者自己的服务后，再去问微信：\r\nHi 哥们，我这个code是有效的还是无效的啊？\r\n微信会告诉你是有效还是无效，有效的情况下还会给你一个用户的标识，也就是openid，同时还会有一个session_key，也就是会话的key。session_key的有效期默认是2小时，当用户一直在使用小程序的话会自动刷新，这个是由微信这边来维护的。\r\n注意：\r\n\r\n会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。\r\n临时登录凭证 code 只能使用一次\r\n\r\n所以我们要为session_key创建别名，这个别名关联的哪个用户只有我们自己知道，唯一需要做的工作就在这块。\r\n我推荐2种方式来做关联：\r\n第一种：\r\n随机生成key, 关联openid，存入redis中，当请求带入key，直接从redis中获取openid得到当前用户信息，这个其实也就是我们自己去维护了会话信息\r\n第二种：\r\n采用JWT生成token，将openid绑定到token中，将token返回给小程序，请求的时候带上token，通过解析token得到用户信息。\r\n下面我们以第二种方式来进行讲解，会贴上部分代码：\r\n小程序中在app.js中的onLaunch方法中增加获取code方法，并且调用后端的登录接口获取token:\r\nwx.login({\r\n      success: function (res) {\r\n        var code = res.code;\r\n        if (code) {\r\n          console.log('app启动获取用户登录凭证：' + code);\r\n          let params = { \"code\": code };\r\n          let result = config.requestHttp(config.url.userLogin, 'POST', params)\r\n          result.then(res => {\r\n            let data = res.data\r\n            if (data.code == 200) {\r\n              wx.setStorageSync(\"login_token\", data.data.token);\r\n            }\r\n          }).catch(err => {\r\n            console.log(err)\r\n          });\r\n        } else {\r\n          console.log('获取用户登录态失败：' + res.errMsg);\r\n        }\r\n      }\r\n})\r\n复制代码userLogin接口则根据小程序的code去调用微信接口验证：\r\n// 小程序获取SessionKey接口地址\r\nString loginUrl = \"https://api.weixin.qq.com/sns/jscode2session\";\r\nString url = loginUrl + \"?appid=%s&secret=%s&grant_type=%s&js_code=%s\";\r\nurl = String.format(url, appid, appSecret, grantType, param.getCode());\r\nString result = restTemplate.getForObject(url, String.class);\r\nMap<String, Object> map = JsonUtils.toBean(Map.class, result);\r\n// 请求成功\r\nif (map.containsKey(\"session_key\")) {\r\n\tString openid = map.get(\"openid\").toString();\r\n    // 第一次保存到用户表，生成JWT TOKEN返回\r\n}\r\n复制代码小程序端需要将 wx.request()封装成一个通用的方法，所有跟后台交互都用这个方法来调用接口，我们可以在这个方法中设置登录之后获取的Token。这样每次请求都会将Token塞到请求头中，我们在网关中就可以获取这个Token进行解析验证。\r\n//请求封装\r\nfunction requestHttp(url, method, data) {\r\n  //请求头设置\r\n  var header = {\r\n    Authorization: wx.getStorageSync(\"login_token\")\r\n  }\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: config.home_config + url,\r\n      data: data,\r\n      header: header,\r\n      method: method,\r\n      success: (res => {\r\n        if (res.data.code === 200) {\r\n          resolve(res)\r\n        } else {\r\n          reject(res)\r\n        }\r\n      }),\r\n      fail: (res => {\r\n        reject(res)\r\n      })\r\n    })\r\n  })\r\n}\r\n复制代码Zuul中进行验证：\r\n  RequestContext ctx = RequestContext.getCurrentContext();\r\n  HttpServletRequest request = ctx.getRequest();\r\n  String token = request.getHeader(\"Authorization\");\r\n  if (StringUtils.isBlank(token)) {\r\n    \t\tctx.setSendZuulResponse(false);\r\n            ctx.set(\"isSuccess\", false);\r\n            ctx.setResponseBody(JsonUtils.toJson(Response.fail(\"非法请求【缺少Authorization】\", ResponseCode.NO_AUTH_CODE)));\r\n            ctx.getResponse().setContentType(\"application/json; charset=utf-8\");\r\n            return null;\r\n  }\r\n    \r\n  // 验证Token是否有效\r\n  JWTResult jwResult = JWTUtils.checkToken(token);\r\n  if (!jwResult.isStatus()) {\r\n    \t\tctx.setSendZuulResponse(false);\r\n            ctx.set(\"isSuccess\", false);\r\n            ctx.setResponseBody(JsonUtils.toJson(Response.fail(jwResult.getMsg(), jwResult.getCode())));\r\n            ctx.getResponse().setContentType(\"application/json; charset=utf-8\");\r\n            return null;\r\n   }\r\n   ctx.addZuulRequestHeader(\"loginUserId\", jwResult.getUid());\r\n   return null;\r\n复制代码验证成功后将用户ID设置到请求头中，传递给后端服务使用。\r\n使用JWT必然有一个问题是Token的失效问题，我这边失效时间设置的为2个小时，正常的话用户打开小程序，使用不可能连续超过2个小时，登录的逻辑是在app.js中做的，只要下次进去token就会重新申请。不过这个也可以调整，比如稍微长一点。\r\n核心就是用户的认证交给了微信，只要微信告诉我们认证成功了，我们就可以自己接管会话信息了。"}
{"title": "微信小程序练手 demo 之天气小程序总结(流水账) ", "author": "Rolan", "pub_time": "2019-1-9 00:32", "article_content": "想大致了解微信小程序的基础结构，加上之前没有写过 MVVM 结构，也借此了解一下，由于之前写过天气的 demo，这次也用比较熟悉的天气预报作为实现的功能，所使用的接口是和风天气，利用到的 API 有 实况天气， 多日天气预报， 逐小时天气预报， 生活指数， 当然实际上还有空气质量、历史天气等其他数据，此处使用几个作为展示。微信小程序开发之前需要注册微信公众平台，在 微信小程序 · 简易教程 处有详细的步骤，注册完下载微信开发者工具，填写申请完开发者账号以后的 AppID(在 mp.weixin.com 开发 -> 开发设置 中查看)，然后直接选择 创建 QuickStart 项目 (刚开始没看清楚选成云开发了，后来才发现跟教程的不太对，之后再接触云开发吧……)，然后到以下的图片界面：每个页面的结构基本由 xx.js xx.wxml xx.wxss xx.json 构成，类似 HTML + CSS + JavaScript，自己体会与后者不同的是：wxml 类似于 HTML，但是小程序规定了所能使用的组件(构成页面的基本单位)，有 view ，button，web-view等等，此外还使用自定义组件，自定义组件需要在 json 文件中先声明，再写 wxml 模板，js 中注册，详细步骤在 微信小程序 · 自定义组件。在写这个天气 demo 时只用到了小程序提供的基础组件，自定义组件还需要进一步了解，wxss 类似于 CSS，只是在选择器中做了很多限制，例如子选择器a > b，后代选择器a b，是不可用的，提倡直接使用 .classjs 与 JavaScript 类似，只是执行环境不同，不需要像浏览器端，写document window等内置对象，语法是相似的，只要稍微熟悉一下就可以了json 配置页面功能，如果写过 Chrome 的扩展的话，应该很熟悉了，就跟manifest.json类似，小程序里可以配置权限，是否全局开启下拉刷新，是否禁止上下滚动等等大致看了一遍文档以后，开始以 quickstart 项目为模板写上自己的代码，页面布局如下：于是以上面的结构分好各块代码，每块使用一个 view包括，内部按内容再细分，其中，每小时天气预报与多日天气预报由于信息过多，采用 scroll-view 展示，以滑动的形式浏览全部数据。实况天气中数据不是很多，直接的分块的 view中把各个组件写上，并写上对应的数据绑定变量，每小时、多日、生活指数中，由于是多个类似的数据，采用 view wx:for的形式，获取数据后循环渲染。样式的部分，每小时、多日天气预报的样式使用 item { flex: 1 }使每一小块均匀分布，生活指数分两列显示，容器 flex 布局，flex-wrap 设置为 wrap，给每个 item 设置 { width: 50%; }。然后就是编写 js，在进入小程序以后，首先利用微信的请求定位，获取到对应的经纬度，再通过 腾讯位置服务 转换为具体的地理位置显示，再把获取到的地理位置作为参数向和风天气发出请求，得到响应以后获得响应的数据，其中一部分数据需要经过处理简化，然后保存到 page.data，同时视图层渲染对应的数据获取到的天气数据中，日期是包含年份的，通常看天气的信息有月日即可，于是在获得响应的数据以后先对日期的部分进行处理：for (let i = 0; i < he.daily_forecast.length; i++) { // 去掉日期中的年份\r\n            res.data.daily_forecast[i].date = res.data.daily_forecast[i].date.slice(5)\r\n}然后再进行 setData 操作在大致基本功能完成后，实况天气的上方新加了一个 input，用于手动输入城市查询那个城市的天气，手动输入查询的城市不经过微信定位，直接把输入的内容作为参数向天气接口查询，成功则显示对应的城市及具体的天气，如果查询的城市有误，则弹出 toast 提示查询失败。在手动查询城市天气完以后，清空 input 的内容，因此需要在 input 的组件中加上 value={{inputValue}}，查询完以后把 page.data.inputValue 值置为空。另外，在真机体验时发现如果网络不好，会加载得很慢，等待时间会很长，数据一直显示不了，于是在进入小程序时先加载一个 loading，在请求成功时去掉 loading，优化用户体验。添加了下拉刷新，首先在 json 中设置 \"enablePullDownRefresh\": true，然后在 js 中写对应的函数即可onPullDownRefresh: function() { \r\n    getWeather()\r\n}关于腾讯位置服务的使用，首先下载相关的 js sdk，然后在微信公众平台的开发设置中设置 request 合法域名，添加 https://apis.map.qq.com(同样地，所用到的天气 API 的地址也是如此)，然后引入 js sdk 并实例化就可以使用了// 引入SDK核心类\r\nvar QQMapWX = require('../../libs/qqmap-wx-jssdk.js');\r\nPage({\r\n    onLoad: function () {\r\n            // 实例化API核心类\r\n            qqmapsdk = new QQMapWX({\r\n                key: '申请的key'\r\n            });\r\n        },\r\n    onShow: function () {\r\n            qqmapsdk...\r\n    }\r\n})整个小程序 demo 的过程中，没遇到太大的困难，大概也是因为写的是比较简单的练手项目而已，很多小程序的功能还没用到，例如多个页面之间的数据传递，路由，插件等等，还需要进一步学习。另外，微信开发者工具有时候会出现打不了中文的情况，搜了一下是个常见的 bug，需要重启微信开发者工具。调试工具中无法查看伪元素样式也有点不方便，希望之后微信开发者工具能改进这方面，这样的话体验能够能好。另外附上我的微信小程序 demo，可以扫码体验一下(图标自己瞎画的晴天娃娃)，由于还需要优化，体验不佳的话还请谅解"}
{"title": "2019微信公开课PRO开讲 小程序发布两周年最新重磅数据 ", "author": "Rolan", "pub_time": "2019-1-10 00:08", "article_content": "腾讯科技讯 1月9日消息，2019微信公开课PRO在广州正式启动。作为微信团队每年与各行合作伙伴的重要“约会”，本届微信公开课PRO版聚焦“同行”：小程序、小游戏、微信支付和企业微信4大产品线在现场晒出过去一年的“成绩单”，并在现场发布“优质小程序计划”、“小游戏创意鼓励计划”等新措施。活动现场，微信团队还介绍了未来新的“同行者”：微信智言对话系统、Hardcoder等全新产品与能力，全景展现微信生态在产业互联网的布局与未来同行计划。所有这些都强烈展示出微信对生态建设的态度和To B业务拓展的决心。此外，微信团队在现场发布的《2018微信数据报告》再现了微信过去一年的发展足迹：报告显示，目前微信与WeChat合并与活跃账户数达10.82亿；消息日发送次数450亿，较去年增长18%；音视频通话次数达4.1亿次，较去年增长100%。在出行、零售、餐饮、公共服务领域，2018年每月支付人数都较去年有了较大幅度的增长，从社交到商业，微信已经深入到了我们生活的方方面面。本届微信公开课PRO版上分享的同行伙伴也迎来史上最全阵容：覆盖零售、餐饮、政务民生、交通、教育、时尚生活等多领域，用超过40个案例分享了他们如何利用微信的能力，加速迈入移动互联网下半场的经验。林肯中国作为2019微信公开课PRO的特约合作伙伴，为部门VIP演讲嘉宾提供了接送车队支持，并在VIP嘉宾签到入口处进行了豪华的车队展示。服务超1000亿人次，2岁的小程序年交易增长超过600%迎来2岁生日的小程序如今不仅是亿万用户的“新国民工具”，越来越多的开发者的加入也让小程序更加明确了自己的商业路径：官方数据显示，小程序已覆盖超过200个细分行业，服务超过1000亿人次用户，年交易增长超过600%，创造了超过5000亿的商业价值。“小程序的数量很重要，这是丰富场景的基石，但小程序的好坏也同样重要，我们希望让用户用上更好的小程序，”在2019微信公开课PRO现场，小程序团队正式宣布将在2019年上线小程序评分体系及“优质小程序计划”，帮助用户更好的发现、使用优质的小程序。小程序团队希望通过开放更多的能力及助力措施，做好各行各业的助手：开发者方面，小程序团队将提供系列能力和支持，帮助更多开发者将能力变为价值：2019年，小程序团队将上线“大家都在用”、小程序搜索、全新的附近的小程序等能力，给予开发者更多的曝光机会；同时降低开发门槛、提供小程序助手、物流相关的助手和接口，帮助开发者更容易开发出好的小程序；并通过开发者社区、服务平台进一步加强与开发者的关系。同时，在2019微信公开课PRO上，腾讯云宣布推出总价值超过10亿元的“小程序o云开发”资源扶持计划，对超过一百万小程序开发者提供免费云开发资源扶持，全面助力开发者打造优秀小程序。在行业方面，小程序团队将陆续推出更精准的行业解决方案、为行业提供数据分析及运营方案，以及提供包括激励视频、插屏广告、个人小程序变现等全新的盈利方式，让行业用户可以更快获得商业支持。小游戏继续鼓励创意，欲孵化更多千万盈利级小游戏如何让小游戏更有创意，更好玩？2018年，小游戏平台启动了“创意鼓励计划”，持续完善运营环境及开发环境，帮助开发者更好地发挥自己的创意。2019年，平台一方面将延续2018年分成优惠策略，推出更便捷的资金经营流转方案，同时也会开拓新的商业模式，为创意小游戏提供资金支持及政策倾斜，让更多小游戏发挥其价值。“小游戏的本质是创意，”2018年，微信小游戏团队曾在《致小游戏开发者的一封信》中，鼓励开发者通过创意为用户带来更多优质的小游戏产品。小游戏上线1年来，共有超过10万的开发者加入到小游戏生态中，截至目前，优质小游戏活跃用户次日留存率高达60%，七日留存率达54%，其中，10款优质小游戏安卓内购月流水实现了千万盈利、11款小游戏广告月流水过千万。如何孵化出更多盈利大户？小游戏团队在活动现场公布了全新的小游戏解决方案，平台还将从研发架构、玩法内容、测试发布以及用户体验等层面，多方位帮助开发者优化小游戏启动性能及开发效率，为用户提供更优质的游戏体验。针对新上线小游戏面临的用户获取难问题，小游戏团队最新推出“新游种子用户”计划，通过两个阶段为新游戏提供不同程度的扶持。第一阶段，新游将获得随机分配的“种子用户”，帮助新游利用初始用户进行运营和传播扩散；第二阶段，针对高品质小游戏进一步提供“种子用户”，帮助优质小游戏加快增长。微信支付化身智慧化工具，帮更多企业平滑切入产业互联网“未来还将持续通过智慧化工具帮助企业提升经营效能，从‘人货场‘的数字化改造、消费链升级、数字化工具等方面切入，帮助更多行业实现从消费互联网到产业互联网的升级，” 微信支付团队在活动现场表示。过去一年，微信支付秉持极致开放的原则，为合作伙伴提供了基础支付工具、商户营销工具、商户管理工具、质量运营工具等助力，并通过与腾讯其他智慧化能力的结合，帮助合作伙伴实现了用户行为消费链的全面升级。以零售为例，商家可以借助以微信支付为核心的数字化能力实现精准发券、扫码购、智慧收银、电子会员识别、无感停车、“到家”等服务。去年11月，天虹就与微信支付合作打造了首家智慧零售标杆店，以到家、扫码购、人脸支付等服务及基础，打造全流程数字化零售场景体验，实现门店数字化率高达85%，自助化率达到50%，不仅让用户购物更加智慧，也帮助天虹实现了更高效率的销售转化。活跃用户新增120%，企业微信成50+行业专属内外连接器在腾讯产业互联网战略中，企业微信是一个重要的工具，通过解决企业沟通壁垒、管理隔阂、信息数据难以沉淀等问题，帮助企业打通内外部资源连接，快速实现企业运营管理的数字化转型。目前，企业微信已经覆盖了超过50个行业，新增企业100%，活跃用户新增120%。2018年，与微信的互通成为企业微信发展的重要节点。越来越多的企业通过企业微信连接微信生态，并打通了企业支付、小程序、客户服务等能力，实现企业无缝触达与管理微信侧的客户，帮助企业从连接员工、连接组织，延伸到连接消费者。长安汽车用企业微信连接上千家经销商,将上下游的问题反馈处理时间从原来的平均2.13天缩短至0.13天,效率提升了1538%,直接解决了企业上下游协作的问题；德邦物流的团队管理者,一键发起上千人的跨部门大群,轻松实现高效对接。随着企业微信能力的不断迭代，服务商在生态中所扮演的角色越来越重要，企业微信对服务商合作伙伴始终秉持开放、共赢的原则。目前，企业微信生态中拥有超过14000个服务商，开放了201个接口，让服务商可以通过接口帮助企业连接内外部人员、连接应用、小程序、硬件，真正实现帮贡数字化、移动化升级。企业微信团队表示，2019年，企业微信还将进一步下沉行业解决方案，深化连接概念并落地到具体的功能，触及到细分领域的每一环,以独特的方式连接产业、服务产业、也服务于人。微信生态更“硬”了：微信“智言”+Hardcoder全新发布，万物互联更近了除了对微信商业生态的解读，微信团队还在活动现场带来了更“硬核”的分享。以人工智能、语音识别为核心的微信智言对话系统“小微”在2019微信公开课PRO正式亮相。通过整合小程序、QQ音乐、企鹅FM、即时通讯等生态能力及第三方生态内容，让用户通过耳机、音箱等设备连接“小微”即可获得全方位的智能服务。微信智言对话系统还面向开发者提供了硬件SDK和云端AP的一键式款速接入，降低开发者的门槛，目前，微信智言对话系统技术方案已经应用于百余款硬件产品。除此以外，微信团队还在现场发布了“Hardcoder性能优化框架”，通过“Hardcoder”开发者可以更轻松地优化程序，突破性能。截至目前，Hardcoder微信用户覆盖量已经超过了2亿。2018年，微信创造就业岗位超2200万个，其中小程序拉动就业超过180万，较去年增长近80%。随着微信生态日益壮大，围绕小程序、公众平台、企业微信、微信支付聚集了大量开发者、运营者、服务商等生态合作伙伴，微信也始终在与这些合作伙伴同行，共创价值。"}
{"title": "mpvue开发大型体育项目及总结记 ", "author": "Rolan", "pub_time": "2019-1-8 00:07", "article_content": "最近接到上头的指示，要做一个体育类的小程序，并且要在元旦之前上线一版，看了下时间，距离元旦只有一个多月，而且除去测试的时间和双休，最多只有三个星期，时间相当的紧迫，而且需求文档都更新到1.3了，这也就意味着安卓和ios的版本迭代已经到了1.3了，而我们小程序要在三个星期内开发完1.0-1.3版本的功能，所以我们的时间相当的紧迫，看了下需求文档和原型图，我整个人大吃一惊，有100多个页面，我顿时懵逼了，产品经理更我说；你们只需做三个模块，最后一个模块不用做，我看了一下最后一个模块，有10几个页面，除去10几个页面还有90多个呀，页面还好，最难的是需求文档的业务逻辑呀，而且这个项目的难度比中小型电商项目类的要难的多，交互相当的频繁和复杂，怎么办呢，一句话，凉拌，毕竟这是boss要求做的项目，只好硬着头皮往下做，不得不从。技术选型因小程序页面多，切交互频繁，如果用原生开发的话，时间来不急，而且页面的交互很多，这样原生小程序就显得那么的吃力了，最终我将技术选型放在了，wepy和mpvue这两个框架上，wepy框架是微信官方维护的，兼容性和扩展性很好，mpvue是美团旗下的，我最终选择了mpvue，原因是mpvue的语法跟Vue的语法是一样的，而且我们的前端同学都会Vue，所以选择mpvue是最好的选择，于是看了一下mpvue的文档和注意点，最终搭建了小程序的项目结构，将任务安排了下去，于是开启了加班的苦日子....技术点1-小程序，安卓，iOS三端数据信息同步，免登陆因项目中的登录方式含有微信登录，所以三端协商，如果用户是微信登录的话，三端统一取， unionid 这个字段，这时肯定有同学要问；为什么不取 openid ，如果做过小程序的人一定知道openid是唯一的标识，微信小程序有一个，那么在安卓，iOS他们也都有自已的openid标识，所以这样是不能达到三端数据信息同步，免登陆的效果的，微信官方介绍了6种获取 unionid 的方法,我们项目最终采用了解密获取的方法，官方文档。import {AchieveOpenid} from '@/http/api.js';\r\n    let that=this;\r\n    wx.login({\r\n        async success(resCode){\r\n            const cache=await AchieveOpenid({    //openid,内部服务器=》腾讯获取到了openid\r\n                code:resCode.code\r\n            });\r\n            that.openid=cache.result.unionid;\r\n            wx.setStorageSync('openId',that.openid);\r\n        }\r\n    })\r\n复制代码注意：这个方法是官方中的wx.login+code2Session方法，也确实可以获取unionid，但是天有不测风云呀，测试组的人员测出了unionid不存在的情况，而且还有几个账号也出现了这种问题，那么我们就开始找原因，最终我们发现，如果用户没有关注过任何的公众号，微信是不会给他返回unionid的，我们找到原因之后，马上换了另外一种方法，那就是解码的方式，也是我们最终的方法。<button class='openpage-authorize' \r\n            open-type=\"getUserInfo\" \r\n            lang=\"zh_CN\" \r\n            @getuserinfo=\"onGotUserInfo\">\r\n    </button>\r\n复制代码//注意我这里只列举解码的代码，有些代码省略了，请熟知。\r\n   import WXBizDataCrypt from \"@/utils/cryptojs/RdWXBizDataCrypt.js\"   //引用解码\r\n    methods:{\r\n         deCode(encryptedData,iv,sessionKey){\r\n         let wxObj=null,data=null;\r\n             wxObj= new WXBizDataCrypt('wx3ea59bf3ff3a9bb8', sessionKey);\r\n             data= wxObj.decryptData(encryptedData,iv);\r\n            this.openid=data.unionId;\r\n            wx.setStorageSync('openId',data.unionId);\r\n        },\r\n        onGotUserInfo(e) {   //通过按钮触发getuserinfo\r\n            if(e.mp.detail.userInfo){\r\n                this.deCode(e.mp.detail.encryptedData,e.mp.detail.iv,this.sessionKey);\r\n            }else{\r\n                toast('请再次授权');\r\n            }\r\n        },\r\n    }\r\n复制代码最终我们可以通过上面的代码获取 unionId ， 解码地址下载 , 注意：解码这一步最好放在服务端解码，不要放在客户端解码，这样会造成信息泄露.....技术点2-在小程序中使用canvas我们可以看到上面两个项目中的案例图片，他们是用canvas画的，第一个是采用微信官方的api，wx.createCanvasContext 不懂得同学可以自已去看 微信官方文档，代码如下const ctx = wx.createCanvasContext('myCanvas');\r\n            ctx.setLineCap('round')\r\n            var gradient1=ctx.createLinearGradient(0,0,170,0);\r\n            gradient1.addColorStop(\"0\",\"#FFF956\");\r\n            gradient1.addColorStop(\"1.0\",\"#FF6C00\");\r\n            var gradient2=ctx.createLinearGradient(0,0,170,0);\r\n            gradient2.addColorStop(\"0\",\"#8156FE\");\r\n            gradient2.addColorStop(\"1.0\",\"#3AFFF1\");\r\n            ctx.setLineWidth(4);\r\n            ctx.beginPath();\r\n            ctx.arc(50, 50, 30,0.75*Math.PI,0.25*Math.PI,false);\r\n            ctx.setStrokeStyle('#4e4f59');\r\n            ctx.stroke()\r\n            ctx.beginPath();\r\n            ctx.arc(50, 50, 38,0.75*Math.PI,0.25*Math.PI,false);\r\n            ctx.setStrokeStyle('#4e4f59');\r\n            ctx.stroke();\r\n            //胜\r\n            ctx.beginPath();\r\n            ctx.arc(50, 50, 30,0.75*Math.PI,(((winarc*1.5+0.75)%2)==0?2:((winarc*1.5+0.75)%2))*Math.PI,false);\r\n            ctx.setStrokeStyle(gradient1)\r\n            ctx.stroke()\r\n            //负\r\n            ctx.beginPath();\r\n            ctx.arc(50, 50, 38,0.75*Math.PI,(((failarc*1.5+0.75)%2)==0?2:((failarc*1.5+0.75)%2))*Math.PI,false)\r\n            ctx.setStrokeStyle(gradient2);\r\n            ctx.stroke()\r\n            ctx.setTextAlign('center');\r\n            ctx.setFontSize(16);\r\n            ctx.setFillStyle('#fff');\r\n            ctx.setTextBaseline('middle');\r\n            ctx.fillText('战绩', 50, 50);\r\n            ctx.draw()\r\n复制代码注意点：如果canva的数据是异步的话，一定要在数据加载完成之后，在让它渲染到视图层中去，如果不这样做的话，canvas会数据不同步，具体的做法可以加一个开关，如下..<canvas canvas-id=\"myCanvas\" class=\"index-header-data-circle-canvas\" v-if='on'></canvas>\r\n复制代码data(){\r\n       return {\r\n           on:false\r\n       }\r\n   }\r\n   async xx(){\r\n        try{\r\n             const data=await xxx();\r\n             this.on=data.code==='000'?true:false;\r\n        }catch (error) {}\r\n   }\r\n   //注意：以上代码只是模拟，仅供查考。\r\n复制代码技术点3-图片上传转化base64图片上传微信小程序给我们提供了api, wx.chooseImage ，上传简单，关键是如何转化base64位呢，我们的舒同学用了如下的写法，看着确实没什么问题，用临时路径作为一个请求的url，把数据返回格式设置成arraybuffer，这个也确实是个办法，在微信开发工具里面也是ok的，但是天有不测风云呀，在真机上请求报错了，那么这种方法pass掉。wx.chooseImage({\r\n      success:res=>{\r\n            wx.request({\r\n                  url:url,\r\n                  responseType: 'arraybuffer', //最关键的参数，设置返回的数据格式为arraybuffer\r\n                  success:res=>{\r\n                        let base64 = wx.arrayBufferToBase64(res.data); \r\n                      }\r\n           })\r\n})\r\n复制代码针对上面的问题，仔细的看了下微信官方文档，最终找到了一个代码少，简单的方法， wx.getFileSystemManager() 这个api可以解决我们上面的问题，微信官方文档，代码如下wx.chooseImage({\r\n                count: 1,\r\n                sizeType: ['original', 'compressed'],\r\n                sourceType: ['album', 'camera'],\r\n                success:(res)=>{\r\n                     wx.getFileSystemManager().readFile({\r\n                                filePath:res.tempFilePaths[0],  //选择图片返回的相对路径\r\n                                encoding: 'base64', \r\n                                success: res => {  \r\n                                     console.log(res.data)\r\n                                }\r\n                    })\r\n                }\r\n              })\r\n复制代码其实除了， wx.getFileSystemManager() 可以解决我们的问题外，还有一种方法，那就是更html5一样的处理方法，通过canvas来画，然后在用canvas的api来转base64， 注意：如果通过canvas来转base64的话，有个bug,那就是在iOS手机上图片会出现旋转90度的问题 小程序可以借鉴 这个同学的方法来解决 ，如果是html5的话可以通过 exif.js 这个库来解决问题。技术点4-对picker的封装小程序中有个picker组件，他支持5中类型，虽然有5中类型但是每个项目的不同，所以对picker的用途就不同，因此我们将对picker进行封装，来达到满足我们项目的需求,我们封装省市，时间日期等组件，我这里就只介绍 省市 组件的封装，其他的组件封装原理同省市组件原理一样的，我这里就不多说了，代码如下。<picker  class=\"pickes\"  mode=\"multiSelector\" \r\n           @change=\"PickerChange\"\r\n           @columnchange=\"PickerColumnChange\" \r\n           :range=\"allList\" \r\n           range-key='provinceName'  \r\n           :value='multiIndex' v-if='show'>\r\n          <div class=\"slot\"></div>\r\n    </picker>\r\n复制代码/**\r\n * @describe 省市选择器\r\n * @rerurn  省，市，省id,市id\r\n */\r\n  import {allCity} from \"@/http/api.js\";\r\n  export default {\r\n      data() {\r\n        return {\r\n            list:[],\r\n            multiIndex: [0, 0], //显示化动的列数\r\n            allList:[],    //存储二维数据\r\n            singleList:[], //存储一维数组\r\n            show:false,    //防止数据没有加载出来\r\n            cityInfo:{},   //存储省，市，省id,市id\r\n        }\r\n      },\r\n      mounted(){\r\n        this.init();\r\n      },\r\n      methods:{\r\n        async init(){   \r\n            try {\r\n                 let child=[],data=null;\r\n                  data=await allCity();  //获取后台返回的城市\r\n                  this.singleList=data.result;\r\n                 child.push(data.result[0]);\r\n                 this.allList.push(data.result,child);\r\n                this.show=true;\r\n            } catch (error) {}\r\n        },\r\n          PickerChange(e) {\r\n             this.cityInfo.provinceId=this.singleList[e.mp.detail.value[0]].provinceId; //省id\r\n             this.cityInfo.provinceName=this.singleList[e.mp.detail.value[0]].provinceName; //省名\r\n             this.cityInfo.cityId=this.singleList[e.mp.detail.value[0]].cityList[e.mp.detail.value[1]].cityId; //城市id\r\n             this.cityInfo.cityName=this.singleList[e.mp.detail.value[0]].cityList[e.mp.detail.value[1]].cityName; //城市名\r\n             this.$emit('cityInfo',this.cityInfo); //将值传给父组件\r\n          },\r\n          PickerColumnChange(e) {\r\n            switch (e.mp.detail.column) {\r\n              case 0:\r\n                this.list = [];\r\n                this.singleList.forEach(item => {\r\n                       if (item.provinceId ==this.singleList[e.mp.detail.value].provinceId) {\r\n                         item.cityList.forEach(item=>{\r\n                           //注意这一步最为重要，给数组添加一个和父对象一样的键值名，这样picker组件可以找的到\r\n                             item.provinceName=item.cityName;  \r\n                         })\r\n                      }\r\n                   });\r\n                this.allList[1]=this.list;\r\n                this.multiIndex[0]=e.mp.detail.value;\r\n                this.multiIndex[1]=0;  //注意这个表示的时选择中省切换的时候，要将省的第一个城市放在第一位\r\n                break;\r\n            }\r\n          },\r\n      }\r\n  }\r\n复制代码技术点5-在小程序使用高德定位因项目中要用到定位功能，而小程序中的的api并不适用项目，所以就选择了高德定位，高德小程序版文档，代码如下//注意我这里只列举定位的代码，有些代码省略了，请熟知。\r\n   \r\n    let _this = this,myAmapFun=null;\r\n     myAmapFun = new amapFile.AMapWX({\r\n        key: \"xxxxx\"   //高德的密钥\r\n    });\r\n    myAmapFun.getRegeo({\r\n        success(data){\r\n            _this.$store.dispatch('cityLocal',data[0].regeocodeData.addressComponent.city);\r\n        },\r\n        fail(err) {\r\n               wx.showModal({\r\n                    title: '提示',\r\n                    content: '定位失败，请手动定位',\r\n                    success (res) {\r\n                        if (res.confirm) {\r\n                        path({url:'/pages/city/main'});\r\n                        }else if (res.cancel) {\r\n                           _this.$store.dispatch('cityLocal','定位失败');\r\n                        }\r\n                    }\r\n                })\r\n        }\r\n    });\r\n复制代码技术点6-对微信小程序节点的运用由于项目用到了城市索引选择功能，所以就采用 wx.createSelectorQuery() 这个api来实现这个功能，代码如下<ul  class=\"slide\">\r\n        <li v-for=\"(item,index) in cityJson.leter\" \r\n            :key=\"index\" \r\n            @tap='touStart(item.letid,item.lettext)'>\r\n            {{item.lettext}}\r\n        </li>\r\n     </ul>\r\n复制代码//注意我这里只列举城市索引选择的代码，有些代码省略了，请熟知。\r\n   onPageScroll(e){\r\n        this.scollTop=e.scrollTop    //同步\r\n    },\r\n    methods:{\r\n         touStart(flag,text){\r\n                 try {\r\n                    wx.createSelectorQuery().select(flag).fields({   //运用微信节点api\r\n                    dataset: true,\r\n                        size: true,\r\n                        rect: true,\r\n                        computedStyle: ['margin', 'backgroundColor']\r\n                        }, (res)=> {\r\n                            wx.pageScrollTo({\r\n                                    scrollTop: this.scollTop+res.top,\r\n                                    duration: 0\r\n                            });\r\n                            this.on=true;\r\n                            this.modalText=text;\r\n                            setTimeout(()=>{\r\n                                  this.on=false;\r\n                            },2000)\r\n                        }).exec() \r\n                 }catch (error) {}\r\n            },\r\n    }\r\n复制代码当然实现上面这个功能也可以用其他的方法，如scroll-view，我这里就不多说了。技术点7-返回上一层页面，刷新页面数据我们可以通过微信中的 wx.navigateBack() 这个api就可以返回上一层页面，但是怎样返回上一层页面并且刷新呢，其实可以通过onShow这个生命周期函数来刷新页面，如果那个页面含有参数的话，最好代码这么写onShow(){\r\n//之所以用try，是因为mpvue官方说，如果要获取地址参数的话，最好在mounted周期里面获取，我们用try可以避免代码终止和报错\r\n     try {   \r\n         let id=this.$root.$mp.query.Id;\r\n         this.init(id);\r\n     }catch (error) {}\r\n}\r\n复制代码结语由于时间的原因，我暂时先介绍这几个在小程序中常见的问题和功能，后面我会陆续介绍，如下技术栈vue的三种ssr方法,以及在项目中的使用react+redux在项目中的使用打造自已的webpack,gulp开发环境koa框架的介绍和使用"}
{"title": "小程序性能优化总结 ", "author": "Rolan", "pub_time": "2019-1-10 00:26", "article_content": "历史总结：小程序倒计时深究小程序实战踩坑之B2B商城项目总结初试小刀自我简历小程序启动加载优化在小程序启动时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。初始化小程序环境是微信环境做的工作,我们只需要控制代码包大小，和通过一些相关的缓存策略控制，和资源控制，逻辑控制，分包加载控制来进行启动加载优化。勾选开发者工具中， 上传时压缩代码（若采用wepy高级版本，自带压缩，请按官网文档采取点击）精简代码，去掉不必要的WXML结构和未使用的WXSS定义。减少在代码包中直接嵌入的资源文件。（比如全国地区库，微信有自带的，在没必要的时候，勿自用自己的库）及时清理无用的资源（js文件、图片、demo页面等）压缩图片，使用适当的图片格式，减少本地图片数量等如果小程序比较复杂，优化后的代码总量可能仍然比较大，此时可以采用分包加载的方式进行优化，分包加载初始化时只加载首评相关、高频访问的资源，其他的按需加载。提前做异步请求，页面最好在onLoad时异步请求数据，不要在onReady时请求启用缓存数据策略，请求时先展示缓存内容，让页面尽快展示，请求到最新数据之后再刷新避免白屏，使用骨架屏等数据通信优化为了提升数据更新的性能，开发者在执行setData调用时，最好遵循以下原则：不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用；数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据；与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下。提升数据更新性能方式的代码示例：Page({\r\n  onShow: function() {\r\n\r\n    // 不要频繁调用setData\r\n    this.setData({ a: 1 })\r\n    this.setData({ b: 2 })\r\n    // 绝大多数时候可优化为\r\n    this.setData({ a: 1, b: 2 })\r\n\r\n    // 不要设置不在界面渲染时使用的数据，并将界面无关的数据放在data外\r\n    this.setData({\r\n      myData: {\r\n        a: '这个字符串在WXML中用到了',\r\n        b: '这个字符串未在WXML中用到，而且它很长…………………………'\r\n      }\r\n    })\r\n    // 可以优化为\r\n    this.setData({\r\n      'myData.a': '这个字符串在WXML中用到了'\r\n    })\r\n    this._myData = {\r\n      b: '这个字符串未在WXML中用到，而且它很长…………………………'\r\n    }\r\n\r\n  }\r\n})事件通信优化视图层会接受用户事件，如点击事件、触摸事件等。当一个用户事件被触发且有相关的事件监听器需要被触发时，视图层会将信息反馈给逻辑层。这个反馈是异步的，会产生延迟，降低延迟的方法有两个：去掉不必要的事件绑定（WXML中的bind和catch），从而减少通信的数据量和次数；事件绑定时需要传输target和currentTarget的dataset，因而不要在节点的data前缀属性中放置过大的数据。渲染优化页面方法onPageScroll使用， 每次页面滚动都会触发，避免在里面写过于复杂的逻辑 ，特别是一些执行重渲染页面的逻辑（另外，可以看我的文章——移动端滚动研究，说明了在滚动的情况下导致的渲染性能低下的各种分析和应付方法总结）在进行视图重渲染的时候，会进行当前节点树与新节点树的比较，去掉不必要设置的数据、减少setData的数据量也有助于提升这一个步骤的性能。"}
{"title": "手摸手聊聊小程序持续集成Jenkins ", "author": "Rolan", "pub_time": "2019-1-10 00:49", "article_content": "本文首发在我的github博客 github.com/Pasoul/blog… ，感兴趣的同学可以点个star，不要迷路哦~\r\n\r\n我们为什么要持续集成？\r\n试想以下两个场景：\r\n场景一：你在开发新功能的时候，同事A找你要小程序体验二维码，于是你只能：\r\ngit stash // 缓存本地修改\r\ngit checkout release // 切换到测试分支\r\nyarn test // 打测试包\r\n... // 预览、切回分支\r\ngit stash pop // 还原本地修改\r\n复制代码然后整理被打断的代码思路，继续coding，暗自吐槽（二维码是有35min过期时间的，一会又得找我了...）\r\n场景二：小程序到了提测日期，恰巧负责开发的你今天请假了，意味着没人可以为测试同学打包，因此耽误了项目进度。\r\n以上两个场景我们发现一个共同的问题，小程序的体验发布太依赖开发者，因为通常只有开发者熟悉微信开发者工具一系列的上传流程，从而导致影响开发进度、发布流程不可控等一系列问题...\r\n\r\n如果小程序可以通过Jenkins集成，将大大解放开发者的生产力，将Jenkins权限收回到测试同学手里，每次发布都需要测试同学执行构建，一定程度上解决发布过程不可控的问题。\r\n小程序持续集成的限制\r\n微信开发者工具目前只支持Mac和Windows环境，可以在单独的Mac mini机器上搭一个Jenkins环境，专门用于打包ios app和小程序。\r\n前期知识储备\r\n除了图形化工具，开发者工具还提供了命令行与 HTTP 服务两种接口供外部调用，开发者可以通过命令行或 HTTP 请求指示工具进行登录、预览、上传等操作。官方文档\r\n我们先尝试使用命令行工具启动并登录微信开发者工具：\r\n命令行工具所在位置：\r\nmacOS: <安装路径>/Contents/MacOS/cli\r\nWindows: <安装路径>/cli.bat\r\n以下示例皆运行在MacOS 10.13.5环境：\r\n如果微信开发者安装在应用程序里面，其中<安装路径>则为 /Applications/wechatwebdevtools.app\r\n启动微信开发者工具\r\n终端执行/Applications/wechatwebdevtools.app/Contents/MacOS/cli -o，结果如下：\r\n\r\n并且开发者工具已经启动：\r\n\r\nps: mac环境下如果是新安装的开发者工具，一定要先打开并通过安全验证。\r\n登录微信开发者工具\r\n终端执行/Applications/wechatwebdevtools.app/Contents/MacOS/cli -l，结果如下：\r\n\r\n扫描二维码后，终端打印login success，并且此时开发者工具已经登录：\r\n\r\n我们尝试使用HTTP 服务预览项目：\r\n在启动和登录开发者工具后，我们需要获取工具运行所在的端口号（端口是不固定的），然后调用http服务预览此项目，执行以下命令获取端口号：\r\nport=$(cat \"/Users/pengyong/Library/Application Support/微信web开发者工具/Default/.ide\")\r\necho \"微信开发者工具运行在${port}端口\"\r\n复制代码假设我的项目地址在：/User/demo，开发者工具开启在55228端口，在浏览器输入http://127.0.0.1:55228/preview?projectpath=/User/demo，可以查看预览二维码\r\n\r\n我们知道开发者可以通过命令行或 HTTP 请求指示工具进行启动、登录、预览等操作，接下来就进入正题：安装和部署Jenkins。\r\n配置Jenkins\r\nJenkins运行依赖java环境，终端输入java -version，看输出是否正确比如：java version \"1.8.0_151\"\r\n一般Mac安装Jenkins有两种方法：\r\n\r\nJenkins官网（jenkins.io/ ）下载安装包，一路Next。\r\nTomcat + War\r\n\r\n这里我推荐第二种安装方式，因为第一种方式会生成一个共享的用户Jenkins，接下来所有构建的操作都是基于Jenkins这个用户的，它的权限与你当前登录的系统用户权限不同，导致构建过程中出现很多问题。\r\n安装Tomcat\r\n\r\n官网下载Tomcat安装包，我下载的是apache-tomcat-8.5.37.tar.gz这个版本，重命名为Tomcat8，放在/Users/用户/Library这个目录下。\r\n将Tomcat的bin路径添加到环境变量中：\r\n\r\nsudo vi ~/.bash_profile\r\nexport PATH=$JAVA_HOME/bin:$PATH:/Users/pengyong/Library/Tomcat8/bin\r\nsource ~/.bash_profile\r\n复制代码\r\n为了避免权限问题，给你的Tomcat/bin/*.sh分配权限\r\n\r\nsudo chmod 755 /Users/pengyong/Library/Tomcat8/bin/*.sh\r\n\r\n查看8080端口是否被占用，使用kill PID解除占用\r\n\r\nlsof -i:8080\r\nkill PID\r\n复制代码\r\n终端输入startup.sh，如果出现下图所示内容，则启动成功\r\n\r\n\r\n\r\n浏览器访问http://localhost:8080/\r\n\r\n\r\n\r\n关闭Tomcat使用shutdown.sh\r\n\r\n至此，Tomcat的安装基本上完成了，接下来安装Jenkins\r\n安装Jenkins\r\n1. 官网下载Jenkins war包，放入你的Tomcat/webapps目录下\r\n\r\n\r\n\r\n浏览器访问http://localhost:8080/jenkins\r\n\r\n\r\n初次访问会让你输入密码，可以根据路径提示获取密码\r\n如果文件提示没有权限无法打开，需要先修改权限，如下：\r\n\r\n\r\n输入密码，点击continue，进入插件安装页面\r\n\r\n\r\n\r\n点击推荐安装，等待安装完成\r\n\r\n\r\n\r\n安装成功后，进入创建Jenkins用户界面，填写完成点击Save and Continue\r\n\r\n\r\n\r\n用户创建完成后进入配置Jenkins URL界面，你可以将其修改成你期望的地址，然后点Save and Finish\r\n\r\n\r\n\r\n到了这个界面，恭喜你设置Jenkins成功，但是我们还差最后一步：重启Jenkins\r\n\r\n\r\n\r\n浏览器访问http://localhost:8080/jenkins/restart(你的jenkins地址+restart)，点击Yes重启\r\n\r\n\r\n有可能页面一直展示loading，你可以尝试直接访问Jenkins主页，如果出现这个页面，Jenkins的安装过程到此结束，你可以创建任务了。\r\n\r\n\r\n插件安装：系统管理 - 插件管理 - 可选插件(Available)\r\n\r\nGit parameter: 能够实现选择指定分支进行构建的功能\r\ndescription setter: 用于生成预览二维码\r\n至此准备工作已完成，让我们开始构建小程序吧。\r\n任务构建-配置\r\n\r\n我们新建一个名为wechat的任务，选择构建一个自由风格的软件项目，点击ok进入到配置界面\r\n\r\n\r\n\r\nGeneral配置选择参数化构建过程\r\n\r\nbuild_type用于选择构建的是开发版、测试版还是生产版的小程序\r\n\r\nbranch用于选择构建的分支（如果没有这个选项，检查Git parameter这个插件有没有安装）\r\n\r\nupload_desc和upload_version两个文本参数分别用于在构建时填写小程序的备注和版本\r\n\r\n\r\n源码管理选择Git，填上仓库地址，分支这里默认是master，改成我们构建时选择的分支（注：本地生成的 id_rsa.pub 添加到git仓库的ssh认证，否则jenkins无法连接git）\r\n\r\n\r\n\r\n构建选择执行shell\r\n\r\n脚本如下，可以按需修改：\r\necho -------------------------------------------------------\r\necho GIT_BRANCH: ${GIT_BRANCH}\r\necho -------------------------------------------------------\r\n# 执行项目构建\r\nyarn install \r\nif [ \"$build_type\" == \"dev\" ]\r\n  then\r\n  yarn run test\r\nelse\r\n  yarn run $build_type\r\nfi\r\n# 打开微信开发者工具\r\n/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -o\r\nport=$(cat \"/Users/pengyong/Library/Application Support/微信web开发者工具/Default/.ide\")\r\necho \"微信开发者工具运行在${port}端口\"\r\nreturn_code=$(curl -sL -w %{http_code} http://127.0.0.1:${port}/open)\r\nif [ $return_code == 200 ]\r\n  then\r\n  echo \"返回状态码200，devtool启动成功！\"\r\nelse\r\n  echo \"返回状态码${return_code}，devtool启动失败\"\r\n  exit 1\r\nfi\r\nif [ \"$build_type\" == \"dev\" ]\r\n  then\r\n  echo \"发布开发版！\"\r\n  # wget -o下载预览二维码，以build_id命名\r\n  /usr/local/bin/wget -O $BUILD_ID.png http://127.0.0.1:${port}/preview?projectpath=/Users/pengyong/.jenkins/workspace/wechat\r\n  echo \"预览成功！请扫描二维码进入开发版！\"\r\nelif [ \"$build_type\" == 'prod' ] || [ \"$build_type\" == \"test\" ] || [ \"$build_type\" == \"test:demo\" ]\r\n  then\r\n  echo \"准备上传！\"\r\n  # 上传到微信平台\r\n  /Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -u $upload_version@/Users/pengyong/.jenkins/workspace/wechat --upload-desc $upload_desc\r\n  echo \"上传成功！请到微信小程序后台设置体验版或提交审核！\"\r\nfi\r\n复制代码\r\n构建后操作选择Set build description（没有则检查description setter插件是否安装）\r\n\r\n\r\n这里使用img标签用于展示构建后的二维码（注：端口号是你jenkins启动的端口，任务名称是我们任务构建这一步填写的名称，这里我们是wechat）:\r\n<img src=\"http://本机ip:端口/job/任务名称/ws/${BUILD_ID}.png\" alt=\"非开发版请到后台预览\" width=\"200\" height=\"200\" /> <a href=\"http://本机ip:端口/job/任务名称/ws/${BUILD_ID}.png\" target=\"_blank\">二维码${BUILD_ID}</a>\r\n至此我们的任务构建配置基本完成了\r\n任务构建-预览小程序\r\n\r\n选择Build with parameters，选择你要构建的类型、分支等参数，这里我们选择的是开发版：\r\n\r\n\r\n\r\n构建完成后发现二维码以文本的形式展示，没有展示图片\r\n\r\n\r\n解决的方法是在系统管理 -> 全局安全配置 -> 标记格式器 -> 选择Safe HTML\r\n\r\n这时预览二维码就出来了，注意二维码是有过期时间的（35min）\r\n\r\n至此预览二维码的构建任务已经完成，我们尝试上传代码到微信平台\r\n任务构建-上传代码\r\n\r\n依然是选择构建类型、分支，不同的是上传代码需要填小程序版本号和项目备注，然后执行构建\r\n\r\n\r\n\r\n到运营平台或开发平台查看提交的版本\r\n\r\n\r\n友情提示\r\n\r\n开发者工具必须在登录状态下进行预览、上传的操作，为了避免账户冲突，可以在Jenkins服务器上使用专门的微信账号进行登录，这个账户要开启开发者和体验者权限，尽量不要使用开发者的账号。\r\n不要直接在官网下载Jenkins安装运行，坑真的很多。\r\n\r\n总结\r\n目前小程序的发布大多还是依赖开发者手动上传，并且小程序持续集成还是有很多问题：开发者工具不支持Linux环境、无法通过命令行生成体验版二维码等等。但是持续集成这个方向还是值得大家研究的，开发和发布要两开花嘛...\r\n参考：\r\n\r\n微信小程序集成 Jenkins\r\nMac Jenkins的安装和使用"}
{"title": "在小程序中集成赞赏 ", "author": "Rolan", "pub_time": "2019-1-11 00:18", "article_content": "好吧，我承认我标题党了，如果你是进来找如何搭建小程序中的支付流程的，请你下车吧~ 这篇文章是介绍个人小程序如何集成赞赏功能的，利用微信小程序提供的支付接口必须具有公司资质才可以。或者你也可以集成有赞，不过会抽取一定的手续费。 言归正传，让我们一步一步来集成赞赏吧，让那些喜欢你的用户也可以打赏你一下。生成一个赞赏码。打开微信，点击右上角加号->收付款->赞赏码，这里你可以进行一些赞赏设置，然后点击保存赞赏码。这样你就拥有了你专属的赞赏码了。获取一个图片地址如果你有服务器或者其他的存储空间，你可以把你的赞赏码上传到你的存储空间，然后拿到图片的htts地址，后面会用到。 如果你没有，那么还可以利用小程序给我们提供的免费的云开发。下面先来说一下如何将图片上传到云存储中。1、打开小程序开发工具，找到云开发后点击，如果你没有开通，则会提示你开通，需要在控制台中开通，路径是：开发->开发者设置->腾讯云。2、开通后再点击云开发，打开控制台，找到存储管理->上传文件,上传上一步你的专属赞赏码图片。上传完成后，就能看到文件了，将fileid字段复制下来，后面会用到。图片预览这一步需要根据实际情况分开来处理了，下面针对上一步说的两种形式一一讲解。1. 使用其他云存储拿到图片的https链接后，在你的小程序wxml添加一个打赏的按钮，然后给按钮添加如下点击事件：wx.previewImage({     urls: ['https://xxxxx/admire-qrcode.jpg'],});写到这里相信大家应该就很清楚了，不错，我们就是利用微信的图片预览功能来加载网络图片。当加载出预览大图二维码后，用户就可以长按识别二维码，弹出微信的识别图中二维码功能，最终跳转到微信自带的赞赏页面，是不是很赞呢~2. 使用云开发存储使用云开发存储的思路是一致的，只不过需要在代码中初始化一些云开发环境。初始化云开发 在app.js中加入如下代码进行初始化：onLaunch: function() {    wx.cloud.init({      traceUser: true    });}添加按钮点击事件 点击事件中传入的url就是第二步获取到的fileid。previewImage: function() {    wx.previewImage({        urls: ['cloud://carutil-007.6361-carutil-007/admire-qrcode.jpg'],    });  },大功告成，最终效果如下图所示。你可以扫描下方的小程序码来体验该功能，在首页最底部有个打赏按钮~"}
{"title": "小程序仿淘宝五级地址选择 ", "author": "Rolan", "pub_time": "2019-1-11 00:29", "article_content": "所有的抽奖都是由后台计算后 <!-- 轮播展示中奖信息区域 -->  <swiper autoplay=\"{{true}}\" interval=\"{{1500}}\" circular=\"{{true}}\" vertical='{{true}}'>    <block wx:for=\"{{prizeInfo}}\" wx:key=\"index\">      <swiper-item>        <view>{{item.name}}{{item.prize}}</view>      </swiper-item>    </block>  </swiper></view><!-- 轮播结束 抽奖转盘 --><view class='turntable' bindtap='doLottery'>  <image class='turntable-bj' style=\"transition:all {{time?time:'3s ease-in'}}; transform:rotate({{transformDeg + 'deg'}}) \" src='../../../img/turntable.png'></image>  <image class='arrow' src='../../../img/arrow.png'>  </image></view>得到的，前台只做动画展示const app = getApp();var index = {  data:{     prizeInfo:[      {        name:'qiphon',        prize:'5元'      },      {        name:'qiphon23423',        prize:'53元'      },      {        name:'qipsdfhon',        prize:'35元'      }    ],    transformDeg:0, // 旋转角度    transition:'all 3s cubic-bezier(0.005, 1.340, 1.000, 0.865)',    time:'999s'  },  onLoad(opt){    console.log(opt)  },  onReady(){    this.animation = wx.createAnimation({      timingFunction:'esse-in-out',      duration:2000    });    this.animationDeg = 360;  },  loadCoupons(){ // 加载获奖信息  欢迎加入全栈开发交流划水交流圈：582735936面向划水1-3年前端人员帮助突破划水瓶颈，提升思维能力  },  doLottery(){ // 抽奖    var _this = this;    if(this.aniRotate)return;    this.aniRotate = true;    this.setData({      transformDeg:this.data.transformDeg + 360*900,      time:'100s ease'    })    setTimeout(function(){      console.log('请求完成'+_this.data.transformDeg) // setTimeout 模拟ajax请求      _this.setData({        transformDeg:-360*4,        time:'3s ease'      })欢迎加入全栈开发交流划水交流圈：582735936面向划水1-3年前端人员帮助突破划水瓶颈，提升思维能力      setTimeout(function(){        console.log('返回结果'+_this.data.transformDeg)        _this.setData({          transformDeg:360*2 + 0,          time:'6s cubic-bezier(0.000, 0.765, 0.000, 0.955)'        })        setTimeout(function(){          _this.aniRotate = false;          wx.showModal({            title:'中奖信息',            content:'恭喜获得奖品'          })        },6000)      },2000)    },3000)  },}Page(index);.top-banner{  background: #fff;  padding:20rpx;}.top-banner swiper{  height: 50rpx;  line-height: 50rpx;}/* 转盘 */.turntable{  position: relative;  width: 100%;  height: 530rpx;}.turntable-bj{  display: block;  margin:0 auto;  width:600rpx;  height: 530rpx;}.turntable .arrow{  position: absolute;  top:0;  right:0;  left:0;  bottom:110rpx;  margin:auto;  width:93.5rpx;  height: 212rpx;}以上就是本文的全部内容，希望对大家的学习有所帮助。"}
{"title": "微信小程序实现换肤功能 ", "author": "Rolan", "pub_time": "2019-1-14 00:08", "article_content": "在手机、电脑使用频率如此高的当下，应用可以更换皮肤，以提升美观性，并减轻屏幕对眼睛的刺激，无疑对用户体验有很大的帮助。\r\n这里闲话少说，先放码出来\r\n\r\n  github地址：我的年目标-微信小程序\r\n演示\r\n扫码即可体验，或搜索“我的年目标”\r\n    \r\n\r\n下面为更换皮肤效果图\r\n \r\n实现功能\r\n要实现如上更换皮肤的效果，有几个思路：\r\n\r\n准备皮肤相关的wxss，引入到app.wxss中，方便每个页面使用；\r\n设置皮肤时，动态改变wxml中元素的类名或id，使页面应用对应的皮肤；\r\n将选中皮肤的值保存在小程序本地缓存中，保证其他页面及下一次打开小程序时，页面展示正确的皮肤；\r\n\r\n下面介绍一些实现的细节\r\nwxml\r\n<view class=\"page\" id='{{skin}}'>  \r\n  <view class=\"container\">\r\n  \t...\r\n  </view>\r\n</view>\r\n复制代码wxml部分比较简单，只需要动态切换id即可，注意因为page无法动态设置背景色，所以这里的最外层需要width: 100%;height: 100%;，否则将无法使皮肤铺满页面。\r\nwxss\r\n/* app.wxss主题颜色 */\r\n\r\n/* 深黑 */\r\n#dark-skin{\r\n  background: #000;\r\n}\r\n#dark-skin .bColor{\r\n  background: #333;\r\n  color: #999;\r\n}\r\n#dark-skin .borderColor{\r\n  border-color:#999;\r\n}\r\n/* 粉红 */\r\n#red-skin{\r\n  background: #f9e5ee;\r\n}\r\n#red-skin .bColor{\r\n  background: #f9e5ee;\r\n  color: #8e5a54;\r\n}\r\n#red-skin .borderColor{\r\n  border-color:#8e5a54;\r\n}\r\n/* 橘黄 */\r\n#yellow-skin{\r\n  background: #f6e1c9;\r\n}\r\n#yellow-skin .bColor{\r\n  background: #f6e1c9;\r\n  color: #8c6031;\r\n}\r\n#yellow-skin .borderColor{\r\n  border-color:#8c6031;\r\n}\r\n...\r\n复制代码写好皮肤对应的颜色样式，直接放入app.wxss中即可，如果样式过多，可以使用单独的wxss文件，方便管理。\r\n@import \"style/skin/dark.wxss\";\r\n复制代码js\r\n存储选中的皮肤值\r\n//wxml\r\n//<view bindtap=\"setSkin\" data-flag='yellow'>橘黄</view> \r\n//bindtap事件函数\r\n  setSkin:function(e){\r\n    var skin = e.target.dataset.flag;\r\n\r\n    this.setData({\r\n      skin: skin + '-skin',\r\n      openSet:false\r\n    })\r\n\r\n    wx.setStorage({\r\n      key: \"skin\",\r\n      data: skin + '-skin'\r\n    })\r\n    app.setSkin(this);\r\n  }\r\n复制代码这里使用setData使页面立即切换id，使用wx.setStorage存储值，app.setSkin是定义在app.js上的公共方法，下面会有介绍\r\n//app.js\r\nApp({\r\n  data: {\r\n  },\r\n  setSkin:function(that){\r\n    wx.getStorage({\r\n     key: 'skin',\r\n     success: function(res) {\r\n       if(res){\r\n         that.setData({\r\n          skin: res.data\r\n        })\r\n         var fcolor = res.data == 'dark-skin' ? '#ffffff' : '#000000',\r\n             obj = {\r\n               'normal-skin':{\r\n                 color:'#000000',\r\n                 background:'#f6f6f6'\r\n               },\r\n               'dark-skin': {\r\n                 color: '#ffffff',\r\n                 background: '#000000'\r\n               },\r\n               'red-skin': {\r\n                 color: '#8e5a54',\r\n                 background: '#f9e5ee'\r\n               },\r\n               'yellow-skin': {\r\n                 color: '#8c6031',\r\n                 background: '#f6e1c9'\r\n               },\r\n               'green-skin': {\r\n                 color: '#5d6021',\r\n                 background: '#e3eabb'\r\n               },\r\n               'cyan-skin': {\r\n                 color: '#417036',\r\n                 background: '#d1e9cd'\r\n               },\r\n               'blue-skin': {\r\n                 color: '#2e6167',\r\n                 background: '#bbe4e3'\r\n               }\r\n             },\r\n           item = obj[res.data],\r\n           tcolor = item.color,\r\n           bcolor = item.background;\r\n\r\n         wx.setNavigationBarColor({\r\n           frontColor: fcolor,\r\n           backgroundColor: bcolor,\r\n         })\r\n\r\n         wx.setTabBarStyle({\r\n           color: tcolor,\r\n           backgroundColor: bcolor,\r\n         })\r\n       }\r\n     }\r\n   })\r\n    }\r\n})\r\n\r\n复制代码app.setSkin提供给所有页面调用，并通过已有的皮肤颜色，设置头部和导航区域的背景及文字颜色。\r\n打开一个普通wxml页面，并设置皮肤\r\nconst app = getApp();\r\n\r\nPage({\r\n  data: {\r\n    skin: 'normal-skin',\r\n  },\r\n  onLoad: function() {\r\n    app.setSkin(this); \r\n  },\r\n  onShow:function(){\r\n    app.setSkin(this); \r\n  }\r\n})\r\n\r\n复制代码在onLoad及onShow触发时设置皮肤，这里的onShow是为了避免重新设置皮肤时，页面还显示上一次的皮肤，由于首次加载会设置两次，onLoad里的app.setSkin其实可以去掉。\r\n至此，一个精美的设置皮肤功能就实现了，小伙伴们快去试一试吧！\r\n\r\n最后\r\n新的2019，新的人生目标，欢迎体验微信小程序“我的年目标”，如有建议，望告知或pull requests，tks 。\r\n\r\n该小程序的其他介绍：\r\n你的年目标实现了吗，记一次开发微信小程序"}
{"title": "微信小程序电商实战-骨架屏实现 ", "author": "Rolan", "pub_time": "2019-1-14 00:15", "article_content": "本文章是一个系列文章，以一个完整的可用于生产的实际项目探索微信小程序开发中我们经常会遇到的问题，希望能提供完美的解决方案，这次是本系列文章的第二篇了，以下列出该系列文章链接。微信小程序及h5，基于taro，zoro最佳实践探索 微信小程序电商实战-登录模块设计 微信小程序电商实战-自定义顶部导航栏工作忙碌，难得有时间继续开发研究这个项目，目前完成了，基础设施开发及首页得开发，话不多说，老规矩，先来看下效果吧骨架屏效果演示.png这是根据页面布局自动生成得骨架屏，目前非常流行的一种提升体验的办法 为了能看到骨架屏的渲染，我调慢了所有接口的响应速度，因此演示响应较慢整体效果还不错吧（沾沾自喜中～）骨架屏的思路骨架屏的实现思路相对较简单，使用方法也很方便 我们知道微信小程序已经开发了选择器功能，可以利用此特性获取到dom节点，为了能让骨架屏组件知道该如何绘制，我们需要做如下约定：约定.skeleton样式类为骨架屏查找绘制节点的根节点 约定.skeleton-square样式类，表示绘制当前节点的骨架节点样式为方形（如商品卡片） 约定.skeleton-circular样式类，表示绘制当前节点的骨架节点为圆形（如logo） 约定.skeleton-cylinder样式类，表示绘制当前节点的骨架节点为长条形（如搜索框） 约定.skeleton-light与.skeleton-dark为块元素背景骨架样式骨架屏的使用首先我们需要引入skeleton组件到页面中，并且在页面根元素上加上.skeleton样式<View className={classNames(styles.home, 'skeleton')}>  {initialize && <ComponentCommonSkeleton />}</View>然后在对应元素中加入不同的样式类，绘制骨架<View className={classNames(styles.hotsale, 'skeleton-light')}>  <View className={styles.header}>    <View className={classNames(styles.title, 'skeleton-square')}>      今日热卖    </View>    <View className={classNames(styles.tip, 'skeleton-square')}>      每日推荐，超值抢购    </View>  </View></View>骨架屏的实现完整的实现逻辑，由于代码较多，不与全部给出，有兴趣的直接去仓库吧skeleton源码 我们来看一下关键代码，如何获取骨架节点// 利用微信小程序的selectorQuery查找相关节点selectAll = selector =>  new Promise(resolve =>    Taro.createSelectorQuery()      .selectAll(selector)      .boundingClientRect()      .exec(res => resolve(res[0])),  )componentDidMount() {  const { selector } = this.props  // 利用微信小程序跨自定义组件选择器`>>>`获取节点信息  Promise.all([    this.selectAll(`.${selector} >>> .${selector}-light`),    this.selectAll(`.${selector} >>> .${selector}-dark`),    this.selectAll(`.${selector} >>> .${selector}-square`),    this.selectAll(`.${selector} >>> .${selector}-circular`),    this.selectAll(`.${selector} >>> .${selector}-cylinder`),  ]).then(([lights, darks, squares, circulars, cylinders]) =>    // 存储节点信息，用于渲染骨架屏    this.setState({      lights,      darks,      squares,      circulars,      cylinders,    }),  )}获取到了相关节点信息，比如width，height，top，left等信息后，便可以利用绝对定位或者fixed绘制骨架了 当然这只能解决常驻组件的获取，对于一些动态组件，比如列表渲染我们该如何处理呢，这里是一个比较麻烦的问题，我们需要在数据还未获取之前，给列表数据设置部分默认数据比如： 设置默认的props或者state，这样项目初始化时便会渲染默认数据，也就可以获取到节点了该项目托管于github，如有需要，请自取weapp-clover，感谢关注，感谢star"}
{"title": "在小程序中使用 React with Hooks ", "author": "Rolan", "pub_time": "2019-1-15 00:11", "article_content": "介绍一下 RemaxRemax 是一个跨多端小程序 React 开发方案，之所以称其为“方案”而非框架是因为这并非一个新的框架，其主要能力就是让 React 能够直接运行在 微信小程序/支付宝小程序/字节跳动小程序/H5（当然这个本来就支持） 等环境。可能会有人要会问 “React 不是早就可以运行在小程序中了么“？本文会介绍一下现如今的一些小程序框架的解决方案，以及为什么我们认为把 React 直接搬进小程序是个更为合理的方案。静态编译类框架由于大多开发者都更熟悉 React 和 Vue 的 API 和语法，加上小程序本身的开发方式确实让人痛苦，于是便有了一些框架来将这些熟悉的语法编译到小程序的 WXML/WXSS/JS 上，其中比较具有代表性的例如 taro，其目标就是让开发者能够用 React 的开发方式编写小程序。而这类框架的实现原理其实并非真的是一个 React 或者类 React 框架，而是把看起来像是 JSX 的模板通过静态编译的方式翻译成小程序自身的模板。这样做的限制非常明显，那就是 JSX 是 JavaScript 的拓展语言（React Blog 写的是 is a syntax extension to JavaScript），而小程序所采用的 WXML 却是一个表达能力非常受限的模板语言，我们不可能完成从一个通用编程语言到模板语言的编译。而静态编译类框架为了做到这一点，采取的方式就是限制开发者的写法，这也是为什么上面称之为看起来像是 JSX 的模板，这也是为什么 taro 对 JSX 的写法做出了诸多限制。这种方案大多声称这些限制并没有限制生产力，或者符合最佳实践等等。然而我们其实都知道这是由于小程序本身的坑造成的，静态编译方案编译的永远都只会是模板语言，而不是 JSX。React Hooks之所以我说这些限制并非基于最佳实践，是因为 React 本身对于 JSX 的定位就 并非模板。JSX is a syntax extension to JavaScript.在最近 React 团队已经向我们介绍了 Hooks，期望可以 functional component 不仅仅可以是无状态组件，也可以是 useState 的。import { useState } from 'react';\r\n\r\nfunction Example() {\r\n  // Declare a new state variable, which we'll call \"count\"\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>You clicked {count} times</p>\r\n      <button onClick={() => setCount(count + 1)}>\r\n        Click me\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\nReact 官方博客提到 Classes confuse both people and machines，我们也明显可以看到基于 function 的组件明显更为简洁，噪声更小，未来 React 社区的方向更是会逐渐从 class component 过渡到 functional component。在这种趋势下，把 JSX 当做模板写，且未来永远也不可能支持 functional component 的方案绝非真的基于最佳实践的选择。在 Remax 中，我们完全可以使用全新的 Hooks API 来开发组件因为 Remax 中的 React 就是 React.js，而 JSX 就是 JavaScript 的超集。上图中使用小程序的原生语法，classname 和 inline style 就只能写成<view class=\"weui-navbar__item {{activeIndex == index ? 'weui-bar__item_on' : ''}}\">\r\n</view>\r\n<view style=\"left: {{sliderLeft}}px; transform: translateX({{sliderOffset}}px); -webkit-transform: translateX({{sliderOffset}}px);\"></view>\r\n而使用 remax 后就可以写成正常的 react：const innerStyle = {\r\n    left: `${sliderLeft}px`,\r\n    transform: `translateX(${sliderOffset}px);`,\r\n    '-webkit-transform': `translateX(${sliderOffset}px)`,\r\n    width: sliderWidth,\r\n  };\r\nconst itemClassName = classnames({\r\n   'weui-navbar__item': true,\r\n    'weui-bar__item_on': activeIndex === index,\r\n});\r\n\r\nreturn <View className={itemClassName}>\r\n    <View style={innerStyle} />\r\n    </View>\r\n实现原理核心部分Remax 的实现原理和基于静态编译的方案有所不同，其核心其实是重新实现了 ReactDOM 的部分。众所周知，React 本身的设计就是支持跨端渲染的，render 部分和 React 的核心逻辑是解耦的（甚至不在一个 npm 包里）。主要的 render 有 ReactDOM（浏览器），ReactDOMServer（服务器端）和 ReactNative。Remax 要做的事情和 ReactNative 要做的事情非常类似，我们重新接管了 ReactDOM 的 render。在原有的 React 页面中，React 在完成 Diff 发现需要修改界面时，又 ReactDOM 把改变 Patch 到页面上。而在小程序中由于我们不能直接修改页面，则由 React 完成 DIFF 后由 Remax 把修改 Patch 到内存中的虚拟 DOM 上，然后再通过小程序自己的虚拟 DOM 最后把改变同步到页面上。在这里我把这个过程说得非常简单，但实际上是有些坑要填的，主要也都是来自于小程序的限制，后续会有新的文章展开来讲。但是这种实现方式使得我们完全可以把 React 的代码放在小程序的环境中运行。工程化工程化很理所当然的用 Webpack 来实现， 除了我们常用的打包等功能外，Webpack 插件也使我们很容易构建一些我们需要的东西出来，例如我们需要在每个 js 入口除了放一个 js 外还需要添加一个 wxml 文件，就可以通过一个很简单的 Webpack 插件来实现。function GeneraeWxmlWebpackPlugin() {\r\n  const content = `<view>...</view>`;\r\n  const apply = (compiler) => {\r\n    const emit = (compilation, cb) => {\r\n      const {\r\n        chunks,\r\n      } = compilation;\r\n      chunks.forEach((item) => {\r\n        compilation.assets[`${item.name}.wxml`] = {\r\n          source: () => content,\r\n          size: () => content.length,\r\n        };\r\n      });\r\n\r\n      cb();\r\n    };\r\n\r\n    if (compiler.hooks) {\r\n      const plugin = { name: 'GeneraeWxmlWebpackPlugin' };\r\n      compiler.hooks.emit.tapAsync(plugin, emit);\r\n    } else {\r\n      compiler.plugin('emit', emit);\r\n    }\r\n  };\r\n\r\n  return {\r\n    apply,\r\n  };\r\n}\r\n跨端这种方案想实现同一套代码跨到 H5 端显然没有什么问题，至于支付宝小程序目前验证了一下可行性也是可行的。项目结构这个项目主要由几块组成@remax/core核心部分，负责 React 组件的 render@remax/cli顾名思义，CLI 工具，用于构建生成相应的小程序项目等工作@remax/components底层 Component，包括诸如 View 等一些基础组件，用于抹平不同环境的差异@remax/ui自带的基础组件库，这部分还待开发，目前只有一两个示例组件由于目前整个项目才刚刚起步，暂时还不能用于生产环境，目前的几个主要开发者（和打算参与的）有 @CodeFalling @bramblex @ahonn @SimplyY目前的 DEMO 可以扫码体验：或者在可以按照 https://github.com/CodeFalling/remax#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B 体验本地 DEMO。如果有人想要参与进来一起开发可以联系我，开发相关的细节文档会陆续更新在 https://github.com/CodeFalling/remax/wiki/%E5%85%A5%E9%97%A8 。讨论群@remax/dev推荐阅读https://reactjs.org/docs/introducing-jsx.htmlhttps://reactjs.org/docs/hooks-intro.htmlReact v16.7 \"Hooks\" - What to Expect"}
{"title": "微信小程序踩坑指南 ", "author": "Rolan", "pub_time": "2018-12-29 00:25", "article_content": "最近因为公司业务一直在做微信小程序的项目，趁此机会将最近踩过的一些坑总结记录下。\r\n微信小程序登陆相关\r\n\r\n\r\n前端调用wx.login()，获取临时登录凭证 code\r\n通过wx.request()将code发给服务器（需要后端创建接口接收code）\r\n后端进行登录凭证校验，入参为(appid,secret,js_code,grant_type)\r\n\r\n\r\n\r\nappid\t\t  小程序唯一标识\r\nsecret\t\t 小程序的 app secret\r\njs_code\t\t 登录时获取的 code\r\ngrant_type\t填写为 authorization_code\r\n\r\n\r\n\r\n登陆凭证校验通过,从微信服务器换取openid和session_key\r\n\r\n\r\nopenid\t用户唯一标识\r\nsession_key\t会话密钥\r\n\r\nopenid 是用户唯一标识，但不建议直接用做后端服务器的各用户标示符。\r\nsession_key 是针对用户数据进行加密签名的密匙。session_key 在文件校验，获取用户具体信息时均需使用\r\n一般为了安全起见，这两个数据都不会发往客户端。\r\n\r\n\r\n\r\n后端将session_key处理之后，返回前端一个处理后的一个字符串作为用户的登陆标识，一般以token的形式。（自定义登陆态与openid session_key相关）\r\n前端接收到token,储存到localStorage中，每次向服务器请求数据的时候带上，作为服务器识别用户的凭证。\r\n后续用户进入小程序时，首先调用 wx.checkSession() 检测登陆态，如果失败，重新发起登陆流程。\r\n\r\n//app.js\r\nconst NOLOGINCODE = 1000003  //未登录\r\nconst SUCCESS = 1000001 //成功\r\nApp({\r\n  onLaunch: function () {\r\n    var loginFlag = wx.getStorageSync('sessionId');\r\n    var that = this;\r\n    if (loginFlag) {\r\n      // 检查 session_key 是否过期\r\n      wx.checkSession({\r\n        // session_key 有效(未过期)\r\n        success: function () {\r\n          var userInfo = wx.getStorageSync('wxUserInfo')\r\n          if (userInfo) {\r\n            that.globalData.hasUserInfo = true\r\n          }\r\n        },\r\n        // session_key 过期\r\n        fail: function () {\r\n          // session_key过期，重新登录\r\n          that.doLogin();\r\n        }\r\n      });\r\n    } else {\r\n      // 无skey，作为首次登录\r\n      this.doLogin();\r\n    }\r\n  },\r\n  doLogin() {\r\n    this.log().then(res => {\r\n      this.$post('/auth', { code: res.code, }, false).then(data => {\r\n        wx.setStorageSync('sessionId', data.sessionId);\r\n      })\r\n    })\r\n  },\r\n  /**\r\n   *微信登录 获取code值,并将code传递给服务器\r\n   * @returns\r\n   */\r\n  log() {\r\n    return new Promise(resolve => {\r\n      wx.login({\r\n        success(res) {\r\n          if (res.errMsg === \"login:ok\") {\r\n            resolve(res)\r\n          } else {\r\n            wx.showToast({\r\n              title: '微信登录失败',\r\n              icon: 'none',\r\n              duration: 1200\r\n            })\r\n          }\r\n        },\r\n        fail() {\r\n          wx.showToast({\r\n            title: '微信登录接口调用失败',\r\n            icon: 'none',\r\n            duration: 1200\r\n          })\r\n        }\r\n      })\r\n    })\r\n  },\r\n  globalData: {\r\n    baseurl: 'https://www.fake.shop'\r\n  }\r\n})\r\n复制代码网络请求封装\r\n\r\n微信小程序中网络请求的api是wx.request(),但是这个请求是个异步回调的形式，每次发请求都要写好长一串，而且如果是嵌套的发请求，就会发现代码写的及其臃肿，所以将其 Promisefy是及其有必要的。\r\n代码如下：\r\n $get(url, data = {}, needToken = true) {\r\n    let SUCCESS = 200\r\n    var that = this\r\n    needToken ? (data.token = wx.getStorageSync('ToKen')) : ''\r\n    return new Promise((resolve, reject) => {\r\n      wx.request({\r\n        url: that.globalData.baseurl + url,\r\n        method: \"GET\",\r\n        header: {\r\n          'content-type': 'application/json'\r\n        },\r\n        data: data,\r\n        success(e) {\r\n          if (e.data.code == SUCCESS) {\r\n            resolve(e.data)\r\n            return\r\n          }\r\n\r\n        },\r\n        fail(e) {\r\n          wx.showModal({\r\n            title: '提示',\r\n            content: '请求失败',\r\n            showCancel: false\r\n          })\r\n          reject(e)\r\n        }\r\n      })\r\n    })\r\n  },\r\n  $post(url, data = {}, needToken = true) {\r\n    let that = this\r\n    let SUCCESS = 200\r\n    let TimeOut = 1000\r\n    var that = this\r\n    needToken ? (data.token = wx.getStorageSync('ToKen')) : ''\r\n    return new Promise((resolve, reject) => {\r\n      wx.request({\r\n        url: that.globalData.baseurl + url,\r\n        method: \"POST\",\r\n        //此处可以根据接口文档设置header头\r\n        // header: { \r\n        //   'content-type': 'application/x-www-form-urlencoded'\r\n        // },\r\n        data: data,\r\n        success(e) {\r\n          if (e.statusCode == SUCCESS) {\r\n            if (e.data.code == SUCCESS) {\r\n              resolve(e.data)\r\n            }\r\n            else {\r\n              reject(e)\r\n              wx.showModal({\r\n                title: '提示',\r\n                content: e.data.msg,\r\n                showCancel: false,\r\n                success: function (res) {\r\n                  if (res.confirm) {\r\n                    if (e.data.code == TimeOut) { //根据实际业务返回的code码判断是否过期\r\n                      // 登录过期\r\n                      that.doLogin();\r\n                    }\r\n                  }\r\n                }\r\n              })\r\n            }\r\n          } else {\r\n            wx.showModal({\r\n              title: '提示',\r\n              content: e.data.error,\r\n              showCancel: false\r\n            })\r\n            reject(e)\r\n          }\r\n        },\r\n        fail(e) {\r\n          console.log(e)\r\n          wx.showModal({\r\n            title: '提示',\r\n            content: '请求失败',\r\n            showCancel: false\r\n          })\r\n          reject(e)\r\n        },\r\n        complete(e) {\r\n        }\r\n      })\r\n\r\n    })\r\n  },\r\n复制代码微信公共号支付（微信浏览器）\r\n\r\n虽然是写小程序踩坑指南，但是在微信内的H5页面支付和小程序内掉起支付还是有相似之处的，顺便记录一下。\r\n应用场景\r\n\r\n已有 H5 商城网站，用户通过消息或扫描二维码在微信内打开网页时，可以调用微信支付完成下单购买的流程。\r\n\r\n准备\r\n\r\n\r\nUnionID:为了识别用户，每个用户针对每个公众号会产生一个安全的 OpenID，如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的 OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个 UnionID\r\n网页授权: 一些复杂的业务场景下，需要以网页的形式提供服务，通过网页授权可以获取用户的openid（注：获取用户的 OpenID 是无需用户同意的，获取用户的基本信息则需用户同意）\r\n微信 JS-SDK：是开发者在网页上通过 JavaScript 代码使用微信原生功能的工具包，开发者可以使用它在网页上录制和播放微信语音、监听微信分享、上传手机本地图片、拍照等许多能力。\r\n\r\n\r\n业务流程时序图\r\n\r\n主要流程\r\n\r\n网页内引入jssdk,主要有两种\r\n\r\n在需要调用 JS 接口的页面引入如下 JS 文件：res.wx.qq.com/open/js/jwe…      JSSDK 使用步骤\r\n模块引入： 直接引入npm包weixin-js-sdk\r\n\r\n\r\nnpm install weixin-js-sdk ;\r\n\r\n\r\n\r\n\r\nvar wx = require('weixin-js-sdk');\r\n\r\n\r\n\r\n\r\n网页授权\r\n\r\n我的理解就是网页授权主要是为了使在微信浏览器里面打开的第三方网页，可以跟微信公共号以及用户的微信相关联的操作，最终获取用户在该公共号下的openid.\r\n网站应用微信登录是基于 OAuth2.0 协议标准构建的微信 OAuth2.0 授权登录系统。获取 openid 分为两步\r\n\r\n前端通过跳转网址获取 code，然后将code发送给后端\r\n后端然后根据 code 获取 openid。\r\n\r\n\r\n\r\n\r\n\r\ncode的获取\r\n\r\n在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的 “开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息” 的配置选项中，修改授权回调域名。本例中回调域名为www.foo.com\r\n业务流程 举例： 支付页面地址： payUrl => \"www.foo.com/pay\"\r\n\r\n要跳转到支付页面时，如果是微信浏览器直接跳转href(办法有很多可以重定向也可以location.href)到 \"open.weixin.qq.com/connect/oau…\"+ appid +\"&redirect_uri=\"+ URLEncoder.encode(payUrl) +\"&response_type=code&scope=snsapi_base&state=123#wechat_redirect\"\r\n系统会自动跳转到 payUrl 并且返回一个参数 code 例如=> \"www.aa.com/pay?code=aa…\"\r\n然后读取下code发送后端就ok了，这个大家应该都会吧。\r\n注：\r\n\r\n\r\n\r\n\r\nURLEncoder.encode(payUrl)是非常有必要的\r\nstate参数：\t用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止 csrf 攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加 session 进行校验\r\n后端获取openid的原因： 因为我是前端，不想搞这个（开玩笑的"}
{"title": "微信小程序获得微信头像和昵称 ", "author": "Rolan", "pub_time": "2018-12-29 00:30", "article_content": "{\r\n  wx.getSetting({\r\n    success: res => {\r\n      if (res.authSetting && res.authSetting['scope.userInfo']) {\r\n        // 已经授权，可以直接调用 getUserInfo 获取头像昵称\r\n        wx.getUserInfo({\r\n          success: function (data) {\r\n            console.log(data.userInfo);\r\n            // {\r\n            //   avatarUrl: '微信头像img文件path'\r\n            //   nickname: '微信昵称'\r\n            // }\r\n          }\r\n        });\r\n      } else {\r\n        this.showShouquan = true; // 打开模态框进行授权\r\n      }\r\n    }\r\n  });\r\n}\r\n<template>\r\n    <div>\r\n        <!-- 这里采用vantui进行弹框，只不过把弹出框的button类型设置成了\"getUserInfo\"，原理就是下面这个button\r\n        <button wx:if=\"{{showShouquan}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfoFromWx\">授权登录</button> -->\r\n        <van-dialog use-slot async-close :show=\"showShouquan\" show-cancel-button confirm-button-open-type=\"getUserInfo\"\r\n            @close=\"cancelShouquan\" @getuserinfo=\"getUserInfoFromWx\">\r\n            <h4 class=\"wx-shouquan-title\">微信授权</h4>\r\n            <p class=\"wx-shouquan-content\">\r\n                xxxxxxx小程序将获得您的微信头像、昵称等公开消息\r\n            </p>\r\n        </van-dialog>\r\n        <div>\r\n</template>    getUserInfoFromWx (e) {\r\n      this.$store.state.user_userinfo = e.mp.detail.userInfo;\r\n      this.showShouquan = false;\r\n    },\r\n    cancelShouquan () {\r\n      this.showShouquan = false;\r\n    },"}
{"title": "微信小程序商品筛选，侧方弹出动画选择页面 ", "author": "Rolan", "pub_time": "2018-12-29 00:32", "article_content": "微信小程序商品筛选，侧方弹出动画选择页面，在一点点的零碎的时间里面写出来的代码，和前两篇效果结合出来的。点击按钮的同时，要实现这两个功能的叠加。 小程序动画animation向左移动效果：https://www.jianshu.com/p/1cdf36070205 小程序点击按钮出现和隐藏遮罩层：https://www.jianshu.com/p/1193bf63a87d效果是这样的:demo是这样的：wxml<view class=\"\">  <view class=\"animation-button\" bindtap=\"translate\">筛选</view>  <view class=\"float {{isRuleTrue?'isRuleShow':'isRuleHide'}} \">    <view class=\"animation-element\" animation=\"{{animation}}\">      <view class='use'>        <view class='iconuse'>用途</view>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">全部</li>          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">豪华发烧型</li>          <li>疯狂游戏型</li>          <li>商务办公型</li>        </ul>        <ul class=\"useage\">          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>      </view>      <!-- 价格 -->      <view class='use'>        <view class='iconprice'>价格</view>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">全部</li>          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">豪华发烧型</li>          <li>疯狂游戏型</li>          <li>商务办公型</li>        </ul>        <ul class=\"useage\">          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>      </view>      <view class='buttom'>      <view class=\"animation-reset\" >重置</view>      <view class=\"animation-button\" bindtap=\"success\">完成</view>      </view>    </view>  </view></view>wxss.isRuleShow {  display: block;}.isRuleHide {  display: none;}.float {  height: 100%;  width: 100%;  position: fixed;  background-color: rgba(0, 0, 0, 0.5);  z-index: 2;  top: 0;  left: 0;  /* margin-top:80rpx; */}.iconuse {  margin-left: 11rpx;}.iconprice {  margin-left: 11rpx;}.animation-element {  width: 580rpx;  height: 1175rpx;   background-color: #ffffff;   border: 1px solid #f3f0f0;  position: absolute;  right: -572rpx;}.useage {  height: 40rpx;}.useage li {  width: 177rpx;  margin: 12rpx 7rpx;  height: 70rpx;  line-height: 70rpx;  display: inline-block;  text-align: center;  border: 1px solid #f3f0f0;  border-radius: 15rpx;  font-size: 30rpx;}.buttom{  position: fixed;  bottom: 0;}.animation-reset{float: left; line-height: 2;  width: 260rpx;  margin: 15rpx 12rpx;  border: 1px solid #f3f0f0;  text-align: center;}.animation-button{float: left; line-height: 2;  width: 260rpx;  margin: 15rpx 12rpx;  border: 1px solid #f3f0f0;  text-align: center;}jsPage({  onReady: function () {    this.animation = wx.createAnimation()  },  translate: function () {    this.setData({      isRuleTrue: true    })    this.animation.translate(-245, 0).step()    this.setData({ animation: this.animation.export() })  },  success: function () {    this.setData({      isRuleTrue: false    })    this.animation.translate(0, 0).step()    this.setData({ animation: this.animation.export() })  },  tryDriver: function () {    this.setData({      background: \"#89dcf8\"    })  }})ok完成了，今天再说一点，有人问我关于技术博客日更的事情，一来是参加了简书的日更活动，不想断开，二来是一路走来，能看见自己每天学习到的知识点和解决的问题，所以才会感到很充实，不会觉得自己每天在空空度日。如果你也想坚持一件事情，可以私聊我，我们相互监督，互相帮助，让自己变得更好。原文作者：祈澈姑娘 技术博客：https://www.jianshu.com/u/05f416aefbe1 90后前端妹子，爱编程，爱运营，爱折腾。 坚持总结工作中遇到的技术问题，坚持记录工作中所所思所见，对于博客上面有不会的问题，可以加入qq群聊来问我：473819131。"}
{"title": "你的年目标实现了吗，记一次开发微信小程序 ", "author": "Rolan", "pub_time": "2019-1-2 00:12", "article_content": "前言：这是笔者第一次开发小程序，此前一直有打算自己做一个，并且能够上线使用，但一直找不到灵感，加上还需要服务器端、数据库等技能，所有一直没能实现。后来偶然看到微信小程序云开发(有点惊艳了，确实挺简便)，再加上一点点想法，于是就开始了小程序云开发之旅。第一步，要做什么东西？鉴于自己的技术水平(捂脸)，还有看到年末很多人都在分享年目标，于是便决定好做一个年目标备忘录，简单方便，且有一些意义。第二步，思考小程序的结构实际开发中，往往需要产品相关的思维导图、原型图等来指导开发，即使做一个小项目，我认为也需要一个良好的构思，以下是小程序的思维导图：第三步，开发阶段以下列举主要页面首页首页实现的功能：通过云函数获取当前用户的openid，并查询用户的今年目标；查询链接附带的id，获取其他用户分享后的目标内容；部分代码如下：// 调用云函数\r\n wx.cloud.callFunction({\r\n  name: 'login',\r\n  data: {},\r\n  success: res => {\r\n    console.log('[云函数] [login] user openid: ', res.result.openid)\r\n    app.globalData.openid = res.result.openid;\r\n    if(!id){\r\n      this.getData();\r\n    }\r\n  },\r\n  fail: err => {\r\n    console.error('[云函数] [login] 调用失败', err)\r\n  }\r\n})\r\n //查询数据库\r\n const db = wx.cloud.database();\r\n db.collection(\"targets\").where({\r\n  _openid: app.globalData.openid,\r\n  date: new Date().getFullYear()\r\n}).get({\r\n  success: res => {\r\n    let data = res.data[0] || {};\r\n\r\n    this.setData({\r\n      id: data._id || '',\r\n      title: data.title || '',\r\n      content: data.content || '',\r\n      flag: false\r\n    })\r\n  }, fail: err => {\r\n    console.log(err)\r\n    this.setData({\r\n      flag: false\r\n    })\r\n  }\r\n})\r\n复制代码列表页列表实现的功能：展示所有该用户添加的目标；左滑可删除，并且增加目标详情、编辑、添加入口；部分代码如下：//获取所有目标\r\nconst db = wx.cloud.database();\r\ndb.collection(\"targets\").where({\r\n  _openid: app.globalData.openid\r\n}).get({\r\n  success: res => {\r\n    this.setData({\r\n      flag: true,\r\n      targetList: res.data, height: height\r\n    })\r\n    app.globalData.targetList = res.data;\r\n  }, fail: err => {\r\n    wx.showToast({\r\n      icon: \"none\",\r\n      title: '查询记录失败',\r\n    })\r\n  }\r\n})\r\n//响应删除\r\nlet id = e.currentTarget.id;\r\nconst db = wx.cloud.database();\r\n\r\ndb.collection(\"targets\").doc(id).remove({\r\n  success: res => {\r\n    wx.showToast({\r\n      title: '删除成功',\r\n    })\r\n  }, fail: err => {\r\n    wx.showToast({\r\n      title: '删除失败',\r\n    })\r\n  }\r\n})\r\n复制代码添加目标添加目标实现的功能：通过picker组件让用户选取年份；可添加/编辑年目标标题、内容；部分代码如下：//新增数据\r\ndb.collection(\"targets\").add({\r\n  data: data,\r\n  success: res => {\r\n    wx.showToast({\r\n      title: '新增成功',\r\n    })\r\n  }, fail: err => {\r\n    wx.showToast({\r\n      title: '新增失败',\r\n      icon: 'none'\r\n    })\r\n  }\r\n})\r\n//编辑数据\r\ndb.collection(\"targets\").doc(data.id).update({\r\n  data: data,\r\n  success: res => {\r\n    wx.showToast({\r\n      title: '修改成功',\r\n    })\r\n  }, fail: err => {\r\n    wx.showToast({\r\n      title: '修改失败',\r\n    })\r\n  }\r\n})\r\n复制代码第四步，最终结果小程序从开发到发布成功，只花了一周时间，不得不赞扬云开发给开发者带来的便利，并且还是免费的，为了表达出开发的顺畅，我特意百度了一张图来体现希望没有想歪哈，这是一张纯粹的过山车图(>▽<)因时间、技术或者环境限制，一些还没有解决的问题：分享到朋友圈功能还没有实现，后续将实现保存当前页为图片，让用户手动分享;使用了textarea标签给用户添加数据，有些简陋，希望小程序尽快出富文本编辑器;虽然工作中经常接触设计图，但对ui设计还是有些无感，以后尽量弥补设计上的不足;小程序云开发数据响应有一些缓慢，据称云开发目前只部署在上海，期待后续优化;最后附上小程序码，微信扫码即可体验(或搜索我的年目标)。另外，祝愿大家都能开发出自己的小程序，并且在新的一年实现自己的人生目标^_^该小程序的github地址： 我的年目标参考文档/文章：微信小程序云开发文档微信小程序开发平台新功能「云开发」快速上手体验微信小程序实现左滑删除-一切没有那么简单微信小程序之云开发——模拟后台增删改查"}
{"title": "一诞小程序总结 ", "author": "Rolan", "pub_time": "2019-1-2 14:48", "article_content": "介绍一诞是一款基于腾讯云的人脸识别、五官定位的圣诞主题小程序。开始做它的初衷是为了简化用户操作，与其他手动添加帽子的小程序形成差别，所见即所得。但是在开发的适合遇到了一些问题，没有完美的方案来根据五官定位API返回的坐标点来准确的给人物戴上帽子。最后无奈之下就加入了圣诞贺卡的功能，弱化了生成头像的功能。小程序全部功能使用云开发，大大减少了一个人的工作量。贺卡功能介绍贺卡是我在初中、小学的时候，圣诞最常送的礼物。小程序的转发恰好是赠送贺卡的最好入口，再加上一些抖音的模式。每个用户转发赠送的贺卡内容都会上传（这里忘记征求用户同意），在主页就可以使用摇一摇的方式来查看下一条贺卡内容，并且可以点赞。五官定位戴帽子五官定位使用的是腾讯云的API，它可以返回五官的坐标，了解更多。这里使用云函数可以快速的拿到返回参数，将坐标点绘制在画布上。安装依赖1npm i --save image-node-sdk云函数调用五官定位API12345678910111213141516171819202122232425// 云函数入口文件const cloud = require('wx-server-sdk')const {ImageClient} = require('image-node-sdk');let AppId = ''; // 腾讯云 AppIdlet SecretId = ''; // 腾讯云 SecretIdlet SecretKey = ''; // 腾讯云 SecretKeyconst imgClient = new ImageClient({  AppId,  SecretId,  SecretKey});cloud.init()// 云函数入口函数exports.main = async(event, context) => {  const url = event.url;  const result = await imgClient.faceShape({    data: {      appid: AppId,      mode: 1,      url,    },  });  return JSON.parse(result.body);}接下来就是根据坐标来准确戴帽子了，但是我能力有限，没有一套比较好的方案，只有在正脸情况下能够准确戴上帽子。帽子也是根据坐标点画出来的，非提前画好的图。如果你有好的想法欢迎联系我（WeChat：tysb7_)总结这款小程序初衷是为了学习使用腾讯云人脸识别API，定位是为了蹭热度。但是时间、推广和能力的原因没能打造成一个爆款。不过在从中收获了许多东西，源码已经上传至GitHub，欢迎大家一起来维护。GitHub: 本文项目仓库WeChat: tysb7_blog: www.tysb7.cnEmail: terry@qiaokr.comSSl: 环洋诚信™"}
{"title": "微信小程序云开发之云函数创建 ", "author": "Rolan", "pub_time": "2019-1-3 00:07", "article_content": "云函数云函数是一段运行在云端的代码，无需管理服务器，在开发工具内编写、一键上传部署即可运行后端代码。小程序内提供了专门用于云函数调用的 API。开发者可以在云函数内使用 wx-server-sdk 提供的 getWXContext 方法获取到每次调用的上下文（appid、openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（openid）。1. 云函数创建根据官网提示，创建一个云函数，命名为 add， 功能是将 a , b 两数相加，步骤如下：在文件夹 cloudfunctions 目录下创建文件夹 add, 编辑add中的index.js文件：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk') \r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  console.log(event)\r\n  console.log(context)\r\n\r\n  const {a, b} = event\r\n  const {OPENID, APPID} = cloud.getWXContext() // 这里获取到的 openId 和 appId 是可信的\r\n  const sum = a + b\r\n\r\n  return {\r\n    OPENID,\r\n    APPID,\r\n    sum\r\n  }\r\n}在小程序中调用这个云函数前，我们还需要先将该云函数部署到云端。在云函数目录上右键，在右键菜单中，我们可以将云函数整体打包上传并部署到线上环境中。2. 云函数调用部署完成后，我们可以在小程序中调用该云函数：//小程序端调用方法\r\nwx.cloud.callFunction({\r\n  // 需要调用的云函数名\r\n  name: 'sum',\r\n  // 传给云函数的参数\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n  success: function(res) {\r\n    console.log(res.result.sum) // 3\r\n  },\r\n  fail: function(err) {\r\n      console.log(err)\r\n  }\r\n})\r\n也可以使用 Promise 调用方式：wx.cloud.callFunction({\r\n  // 云函数名称\r\n  name: 'add',\r\n  // 传给云函数的参数\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n}).then(res => {\r\n    console.log(res.result) // 3\r\n  })\r\n  .catch(console.error)"}
{"title": "干货 | 小程序授权导致你流失50%用户？ ", "author": "Rolan", "pub_time": "2019-1-3 00:12", "article_content": "就是这个东西！导致你流失20%-50%的新用户。作者：楼兰古国来源：楼兰古国(ID:loulan630)本文为作者授权鸟哥笔记发布，转载请联系作者并注明出处。就是这个东西！导致你流失20%-50%的新用户。而市场上，至少一半的小程序开发者，正在进行着错误的授权方式。很多开发者，新用户流失而不自知；或者面对流失，不知怎么办。。。NOW，我们来一一解说，记得准备小本本记录有用的干货。如何看自己家小程序，有没有因为授权而流失，流失了多少？方法：1.当用户登录时（小程序生命周期onload加载时），立即获取Openid；2.授权时将头像昵称等信息存入数据库；3.然后对比数据库里授权用户数和openid数量，授权人数/总用户数；4.另外现在大部分都是要Button按钮唤起的用户授权，可以埋点统计授权按钮点击人数，也是一个参考依据。为什么会因为授权，流失这么多用户呢？猜测原因：1.用户对授权有顾虑，担心泄露隐私（当前部分国人已经开始注重隐私了，腾讯公司也十分在意隐私问题，不将用户基础信息直接开发给开发者。并且还必须要用按钮button触发，将隐私风险转移给开发者）；2.用户还不了解你这个产品的价值，在不知道这个小程序对其是否有用的情况下，用户不愿意暴露自己的隐私。（刚需的牛逼产品，可忽略这条）3.用户进入小程序其实和进入一个网页（一篇微信文章页面），是几乎一样的感觉，很多时候没有授权的准备，没有这个习惯。（和下载APP的感觉，习惯是不一样的，下载APP后有注册的习惯）4.部分老年用户，以及对小程序不熟悉的用户，对授权有恐惧感，不敢随便授权。但是用户授权有时候又是必须的？怎么办？小程序到底要不要授权用户头像昵称等？该怎么授权？什么阶段授权？首先普及一下openid的知识点：小程序拥有openid概念，即用户只要一进入小程序，通过wx.login()接口获取code值，发至后台服务器，可向微信平台获取该用户对自己这个小程序的唯一id，也可成为userid。其后续所有的操作以及数据皆可被记录在这个Id之下。这和app是完全不一样的，app注册之前，没有网络唯一Id。（当然也可以向微信或QQ等索取授权，不过第三方授权是要用户进行操作的，不像 小程序，是用户完全无感知的情况下获取到的Openid。 ）我们再来看一下APP的授权演变，有助于看清小程序未来授权的演变：APP注册授权，从很久以前注册账号+自定义密码，演变到用手机号+短信验证码注册，再演变成微信第三方登陆（有些app需要再验证一下手机号码，而有些甚至不需要授权手机号码）从这个演变过程中，可以看出来是在逐渐的让新用户注册变得简洁（毕竟每个新用户来之不易）此外注意：APP天然没有网络唯一ID  [唯一真实的ID]，所以必须要注册。（至于识别手机码，需考虑手机被盗的情况，非网络上的唯一id）至于有些人说的：不授权的用户不是你的用户，这完全是无稽之谈。每个新用户进来，应该先让他领略你这个应用的魅力所在，功能所在，然后再让用户判断是否留下or离开。而不是让他在授权用户信息这一步导致退却。Userinfo到底有什么用？是不是真的必须要用到，这也是一个很多开发者容易犯的错误。userinfo内包含用户昵称，头像，性别，语言，城市/省份/国家，UnionID。用户头像昵称，可以在会话转发卡片、生成分享海报的时候使用，提高转发会话卡片打开率、图片二维码识别率，能够让每一个分析者带来的用户增多。还可以在个人中心展示头像昵称，提高归属感。（这个其实可以用open-data，可不需授权，直接展示）（在这里多聊一句：非常希望微信提供用户备注名的Open-data功能，在排行榜上可使用，像王者荣耀那样，效果会比头像昵称好很多）性别可以用于数据分析、看那些忠实用户男女比例，可在投放广告的时候进行针对性投放。此外还可以做信息匹配，如婚恋类，给女性提供单身男性信息。城市/省份/国家/语言在排行榜，信息匹配上也大有妙用。unionid常常用在与公众号连接中，如关注公众号获得奖励。如果你的小程序用不到这些，则不需要授权！！！不用去授权的！！！finally，然而鱼与熊掌不可兼得。新用户流失with用户信息获取。该如何取舍，心中掂量掂量。这里建议的方法：1.用户信息在小程序领域并不是必须要获得的。他和保存到相册，收货地址，地理位置等授权是一样的。如果用不到这些头像昵称，性别，城市信息。可以永远不需要获取。2.如果需要用到用户信息，什么时候用到那些数据，什么时候去授权。3.尽量不要在新用户一进入应用的时候就授权，要让新用户体验一下你的产品，用户根据产品对其是否有吸引力来觉得是否留下或离开。而不是授权不授权。但具体要看你的产品了。具体怎么结合进入您的小程序，要自己细细思索了。也可加我 个人微信：loulan0176 （昵称：楼兰古国），共同探讨。"}
{"title": "小程序·云开发初级FAQ ", "author": "Rolan", "pub_time": "2019-1-3 00:29", "article_content": "之前参加过小程序·云开发相关的分享, 在团队内进行了推广, 感觉官方的宣传不够直接, 还是太玄乎了, 这是收集了猫眼娱乐前端工程师的问题, 和相关答疑, 部分问题是和小程序·云开发的同学沟通过的结论主要面向初级前端工程师, 快速了解云开发是怎么回事, 不涉及复杂代码有小程序开发经验理解 server 端基础, 并有少量node.js server端经验1. 小程序云开发是什么?官方文档, 不用着急点, 下面FAQ未提及的可以进来看主要提供两种能力1.1 提供持久存储持久存储是指删除微信或更换手机后, 用户重新打开我们的小程序, 仍旧能让用户看到自己的信息主要通过两种存储容器类mangodb的 数据库存储 , 比如用户提交的文章文件存储 , 比如用户上传的照片1.2 提供简化的server端编程环境云函数简单解释: 在小程序端写上函数名 + 参数, 就能调用远端的一个函数为什么不直接写到小程序端, 而要绕弯子要这样? 最常见的原因是:有些业务逻辑涉及 保密信息 , 不能写在小程序上, 比如: 价格计算, 交易流程有些操作需要 更高的权限 , 比如: 管理员可以删除所有用户的数据.桥接到第三方接口, 小程序https接口域名数量超限, 或者第三方接口不是https接口.2. 直接操作数据库会不会有安全问题云开发的数据库和传统数据库有些区别, 他会自动给每个数据表增加一个 创建人字段 + 表权限设置 , 后续的操作都会基于这些约束, 一般的策略是每个用户只能修改自己创建的信息, 比如自己发的文章每个用户只能读取其他用户的信息, 但不能修改, 比如其他人发的文章每个用户只能读取公共信息, 但不能修改, 比如公告信息, 一般会允许通过管理端修改3. 直接操作文件存储会不会有安全风险类似上一个数据库的权限, 通过 文件创建人 + 文件夹权限设置文件的操作使用服务端生成的唯一ID, 不会被穷举4. 别人会不会调用我的云函数不会, 云函数的网络协议是私有的, 并且有加上数字签名验证这套机制是在微信app内部实现的, 除非微信这套机制被攻破5.云函数是用js写么, 运行环境是什么?是js, 运行环境是nodejs 8.9, 支持async await关键字目前还不支持修改运行环境, 未来应该会支持自选环境6. 使用了云开发, 是不是就不能使用自己的服务端了不是, 两个可以并存, 就当是看起来不一样的异步调用就好// 云开发相关api\r\nwx.cloud.xxxx()\r\n\r\n// 自有服务\r\nwx.request()\r\n复制代码由于是nodejs的运行环境, 所以云函数可以使用http tcp模块, 这样就能通过云函数转发请求到任意域名, 不受小程序端的请求域名限制7. 典型的云函数是什么样的?// 小程序端, 调用\r\nwx.cloud.callFunction({\r\n    name: 'foo',\r\n    data: { a: 1, b: 2 },\r\n    success: function(res) {\r\n        console.log(res.result)\r\n    }\r\n)\r\n\r\n// 云函数, 声明\r\n// cloudfunctionRoot/functions/foo/index.js\r\nexports.main = async function(e, ctx) {\r\n    return e.a + e.b\r\n}\r\n复制代码函数名和目录名对应, 根路径在project.config.json中定义, 详细参考官方文档中的\"我的第一个云函数\"8. 云函数还有什么特殊能力?直接获取用户的openId// index.js\r\nexports.main = (event, context) => {\r\n  return event.userInfo\r\n}\r\n复制代码如要获取用户头像 昵称等信息, 还是需要在小程序端进行授权才行9. 云函数需要我们考虑服务器运维的工作么不需要, 只要开发好上传就行, 运行环境是独立 封闭的, 类 CentOS 7 的环境10. 开发时和线上环境有隔离么提供1个生产环境, 和1个开发环境, 存储和云函数都是独立的这意味着多个开发者并行开发协作可能会有些小麻烦, 同时只能有一套代码在开发环境, 这就只能通过一些工作流程约定, 比如收敛上传权限, 每日自动部署. 应用类似git-flow的分支策略11. 云开发是否提供有定位 地理信息 支付相关业务的支持暂时没有, 这方面的需求还是很强的, 毕竟小程序是提倡线下扫码, 扫码后还是期望能够获取到附近的相关信息, 简单的比如城市 区划, 详细的比如商家小程序云开发的同学目前还在收集这方面的需求12. 什么版本的基础库支持云开发基础库 2.2.3 之后开始支持, 但对于旧版本可以加个配置也能支持app.json/game.json{\r\n  \"cloud\": true\r\n}\r\n复制代码13. 费用呢目前免费, 正在调研计费策略, 可能是按照调用量, 存储量计费结语目前看云开发基本成型, 典型的业务都能覆盖到了, 还有一些周边的东西需要完善比如数据库存储这边的批量操作, 事务的支持, 存储容器还可以在增加一些, 比如消息队列, 其它的杂项如任务调度, 开发者环境隔离, 数据迁移升级另一方面, 作为前端工程师, 技术能力边界的延伸, 并不完全意味着获益, 还包括背景知识成本, 只有学习好这些, 才能驾驭好新的能力, 比如领域建模, 设计模式, 封装和隔离.大家好，我是猫眼娱乐前端技术专家-曹宇，我主要负责猫眼娱乐电影选座交易业务前端, 除了大家能看到的各种 Web 页面, 还有小程序端和供应链端. 同时负责猫眼内部的前端基础设施, 质量保证相关工作。猫眼电影小程序从零发展到票务类别第一, 主要关注点都集中在线上, 这次分享的是一个线上 线下联动的活动, 从开发到上线后遇到的一些有趣的事情, 除了小程序技术的深度应用, 还包括产品 运营层面的思考."}
{"title": "微信小程序解码工具 ", "author": "Rolan", "pub_time": "2019-1-4 00:40", "article_content": "项目地址起因  前段时间想学习微信小程序开发但是又没有什么深厚前端功底，看到很多很好玩的小程序想要做一个类似的学习学习，所以想着借鉴一下现有的小程序。但是苦于没有源码，抓包也没有办法获取源码。  google后知道可以用安卓模拟器安装微信然后安装小程序，然后在文件系统中找到小程序对应的wxapkg文件，拿到压缩包解压后就可以得到小程序源码。  但是压缩包是2进制文件，找了一遍后发现一个现有现有的开源项目可以直接解压小程序压缩包。废话不多说，直接开干～使用源码安装安装golang没有用过golang的人可以直接去官网下载go get github.com/sjatsh/unwxapkgcd ~/go/src/github.com/sjatsh/unwxapkg使用可执行文件下载地址使用unwxapkg -f dest/102.wxapkg图片发自简书App项目地址"}
{"title": "快速小程序开发之微信小程序内嵌 H5 ", "author": "Rolan", "pub_time": "2019-1-4 00:45", "article_content": "今日励志语要接受自己行动所带来的责任而非自己成就所带来的荣耀。前言微信小程序中可以直接运行 web 页面，这一新组件 web-view 的产生，可能直接导致小程序数量迎来一波高峰。本篇博文将从业务选型，微信小程序后台配置，使用 web-view 完成登录业务以及在实战中如何调试一次性带你感受小程序内嵌 H5 的风采，帮你更有底气的使用微信小程序新组件 web-view。技术选择H5 转成小程序方案路线优缺点对比上表是从原有 H5 转相似业务逻辑的微信小程序的方案路线优缺点对比，基于时间的限制以及当前主流多端编译的可靠性考量，最终团队认为通过使用小程序组件 web-view 内嵌 H5 的方式比较适合当前的开发需求。 web-view 的兼容性问题主要是要在基础库在1.6.4+及以上才可以用，而微信官方统计基础库在1.6.4+ 的覆盖率已达 95% 以上，这个指标也符合产品大人的要求，于是便愉快的选择了 web-view 内嵌 H5 的技术方案。H5 和小程序技术对比从上表中可以对比出 H5 相较于小程序的优缺点，方便各位前端大大评估需求。尤为重要的是因为小程序封装的比较严重所以小程序开发的灵活性没有 H5 那么高，这就要我们注意对交互设计的评估。web-view 微信小程序配置系列问题配置域名业务域名中配置的就是小程序以及 H5 和 H5 中引用 iframe 的域名。这里要特别注意的是假如 H5 中有内嵌的 iframe 也要配置进去这里需要服务端的朋友配合一下，将校验文件放置在将要嵌套的业务域名的根目录。所以要注意后端是否可以支持，否则会有各种扯皮的问题选择基础库开发的时候不要忘记配置微信小程序的基础库，注意 web-view 要在基础库1.6.4以上的版本库才能使用H5 中引入微信的 jssdk,其中包含了h5和小程序直接的通讯方法web-view 与小程序的通信官方给出了两种通信方法（如下图所示） 1、postMessage 通信 在 H5 中需要先用 wx.miniProgram.postMessage 接口，把需要分享的信息，推送给小程序。 在用户点击了小程序后退、组件销毁、分享这些特殊事件之后，小程序页面通过 bindmessage 绑定的函数读取 post 信息。 2、设置 web-view 组件的 URL 通信 H5 跳转小程序：toWeixin() {\r\n wx.miniProgram.navigateTo({url: '/pages/myWelfare/myWelfare'});\r\n}小程序跳转 H5： 首先在 .wxml 中引入 web-view 组件<view>\r\n<web-view src=\"{{url}}\" ></web-view>\r\n</view>之后在小程序的 js 文件中设置通过 URL 以问号传参的方式传入参数到 H5 中if(!option.page){\r\n      this.setData({\r\n        url: `${this.data.url}?${test}`\r\n      });\r\n    } else {\r\n      this.setData({\r\n        url: `${this.data.url}${option.page}?${test}`\r\n      });\r\n    }小程序内嵌 H5 登录实例小程序登录实现方案流程图：如上图所示：整个登录的 cookie 的传递经历了四个步骤：在小程序登录后获取到后端传递的 cookie 并保存通过 web-view 中的 url 传递到 H5 中在 H5 中得到传递的值并写到 cookie 中在访问接口的时候带上 cookie 2、从微信小程序响应头中获得 cookie 存到 storage 中：首先在登录页获取到响应头中的登录 cookie 放到 storage 中wx.setStorageSync('cookie', res.header[\"Set-Cookie\"]);在微信小程序中每次请求接口的时候，将 storage 中的 cookie 取出来，放到请求头中，如果传入不正确或者没有传入 cookie 值，后台将返回 errorCode 为 3002 ，此时前端跳转到登录页面。 var headerCookie = wx.getStorageSync('cookie');\r\n   wx.request({\r\n            url: murl,\r\n            data: parameter.data || {},\r\n            header: {\r\n               'Cookie': headerCookie\r\n            },\r\n            method: parameter.method || 'POST',\r\n            success: function(res) {\r\n            if(res.data.code == 3002) {\r\n                    wx.redirectTo({\r\n                        url: '../login/login'\r\n                    })\r\n                } else {\r\n                    parameter.success && parameter.success(res);\r\n                }\r\n\r\n            }3、获得 cookie 并拼接到 URL 中首先在 web-view 页面获取 cookie ,并匹配到需要传递的字段，之后将此字段放到 url 中通过问号传参的方式传递到 H5 中try {\r\n      var value = wx.getStorageSync('cookie');\r\n      if (value) {\r\n        test = value.match(new RegExp(\"(^| )\"+\"jxi-m-sid\"+\"=([^;]*)(;|$)\"))[2] ;\r\n      }\r\n    }url: 'https://www.xxx.com#',\r\n    if(!option.page){\r\n      this.setData({\r\n         //在这里放入传递的字段（如test）\r\n         url: `${this.data.url}?${test}`\r\n      });\r\n    } else {\r\n      this.setData({\r\n         //在这里放入传递的字段,也可以拼接更多的信息（如option.page）\r\n         url: `${this.data.url}${option.page}?${test}`\r\n      });\r\n    }4、获取 cookie 并在 H5 中使用 在 H5 中获取 cookie 值,并带入 cookie ,注意 domain 和 path 的设置，这两个值必须都有：let isDebug = (window.location.href).indexOf('myf') > -1;\r\nlet host = isDebug ? 'jd' : 'jdf';\r\n//获得传递的字段\r\nlet c =window.location.href.split('?')[1];\r\n//设置cookie\r\ndocument.cookie = `jxi-m-sid=${c};domain=${host};path=/`;小程序内嵌 H5 调试解决方案关于调试效果缓存的问题 小程序的更新机制即当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是 5 分钟）会被微信主动销毁。 小程序销毁后再重新启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次销毁后再重新启动时才会应用上。内嵌 H5 调试问题 因为微信小程序开发者工具中并没有提供内嵌 H5 的调试工具，所以我们可以采取以下方法调试在 H5 开发的时候，我们可以在微信小程序开发者工具中找到 web-view 传递给 H5 的 URL 链接将此链接黏贴到浏览器中即可像平时开发 H5 一样调试对于手机端 H5 的测试调试可以在 H5 中引入 vconsole 这个插件来调试程序，他可以让我们看到接口情况以及 H5 中的日志。总结看到这里，我们分别从web-view 技术的优缺点web-view 微信小程序配置系列问题web-view 与小程序的通信小程序内嵌 H5 登录实例小程序内嵌 H5 调试解决方案五个方面梳理了关于微信小程序 webview 组件的使用。 当然，微信小程序组件 web-view 还并不完善，其中很难实现一些特殊的交互，比如返回按钮返回的页面只能是上一级不能是任意自定义的页面等问题，这就需要我们更好的沟通以及规划交互设计，同时反馈并等待微信小程序官方的更新和支持。文章来源：京东设计中心"}
{"title": "微信小程序，实现 watch 属性，监听数据变化 ", "author": "Rolan", "pub_time": "2019-1-7 00:05", "article_content": "在微信小程序实现 watch 属性，监听 data 中的属性，当被监听属性的值改变时，执行我们指定的方法。​​思路Vue 的 computed 和 watch 可以很方便的检测数据的变化，从而做出相应的改变，所以，模仿 vue 肯定是一个不错的选择。与 Vue 一样，我们使用 ES5 的 Object.defineProperty() 方法，劫持对象的 getter/setter ，从而实现给对象赋值时(调用 setter)，执行 watch 对象中相对应的函数，达到监听效果。代码不啰嗦，上代码，真实可用。function observe(obj, key, watchFun, deep, page) {\r\n  let val = obj[key];\r\n\r\n  if (val != null && typeof val === \"object\" && deep) {\r\n    Object.keys(val).forEach((item) => {\r\n      observe(val, item, watchFun, deep, page);\r\n    });\r\n  }\r\n\r\n  Object.defineProperty(obj, key, {\r\n    configurable: true,\r\n    enumerable: true,\r\n    set: function(value) {\r\n      watchFun.call(page, value, val);\r\n      val = value;\r\n\r\n      if (deep) {\r\n        observe(obj, key, watchFun, deep, page);\r\n      }\r\n    },\r\n    get: function() {\r\n      return val;\r\n    }\r\n  });\r\n}\r\n\r\nexport function setWatcher(page) {\r\n  let data = page.data;\r\n  let watch = page.watch;\r\n\r\n  Object.keys(watch).forEach((item) => {\r\n    let targetData = data;\r\n    let keys = item.split(\".\");\r\n\r\n    for (let i = 0; i < keys.length - 1; i++) {\r\n      targetData = targetData[keys[i]];\r\n    }\r\n\r\n    let targetKey = keys[keys.length - 1];\r\n\r\n    let watchFun = watch[item].handler || watch[item];\r\n\r\n    let deep = watch[item].deep;\r\n    observe(targetData, targetKey, watchFun, deep, page);\r\n  });\r\n}\r\n复制代码注意事项：watch 只能监听已存在的属性，数组的 push() ， pop() 等方法并不会触发监听函数。使用import * as watch from \"./watch.js\";\r\n\r\nPage({\r\n  data: {\r\n    name: \"二狗子\"\r\n  },\r\n\r\n  onLoad() {\r\n    watch.setWatcher(this);\r\n  },\r\n\r\n  watch: {\r\n    name: function(newVal, oldVal) {\r\n      console.log(newVal, oldVal);\r\n    }\r\n  }\r\n});\r\n复制代码首先在需要的页面引入在 Page 的 onLoad 钩子设置监听器然后就可以愉快的使用了。"}
{"title": "微信小程序 组件叠加效果（如 Android 中的添加蒙层） ", "author": "Rolan", "pub_time": "2019-1-7 00:21", "article_content": "实现的效果如下：可以看出这是由image组件和text组件叠加到一块组成的蒙层效果。在小程序中实现这个效果主要用到z-index属性和position属性 z-index的使用必须是双方组件都设置了position属性才会生效。 z-index：表示的组件的层级关系，值越小越在最下方。 position：表示组件的位置，这里可以使用的值为fixed，absolute,使用relative不能实现该效果。 position 的可能值如下图：那么这里我们的的蒙版文字是在图片的上方，所以布局样式可以这么写：重点关注 position和z-index即可。这里的line-height: 100px;也很重要，否则蒙层上的文本是不能居中对齐的。布局<view class='item_view'>    <image class='img-class' src='https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=2f3a8c47f4deb48fef64a98c9176514c/78310a55b319ebc4658560bf8526cffc1e171612.jpg'></image>    <text class='text_num'>+3</text>  </view>样式.item_view{  margin-top: 100px;  text-align: center;  align-items: center;  justify-content: center;}.img-class{  width: 100px;  height: 100px;  z-index: -1;  position: fixed;}.text_num{  width: 100px;  height: 100px;  line-height: 100px;  background: rgb(99, 99, 105);  opacity: 0.5;  font-size: 14px;  color: rgb(248, 248, 244);  z-index: 100;  position: fixed;}本文完，欢迎你的喜欢、或者留言和我讨论~"}
{"title": "微信小程序发送短信验证码完整实例 ", "author": "Rolan", "pub_time": "2019-1-7 00:36", "article_content": "微信小程序注册完整实例，发送短信验证码，带60秒倒计时功能，无需服务器端。效果图:代码:index.wxml<!--index.wxml-->\r\n<view class=\"container\">\r\n  <view class='row'>\r\n     <input placeholder='请输入姓名' bindinput='bindNameInput'/> \r\n  </view>\r\n  \r\n  <view class='row'>\r\n     <input placeholder='请输入手机号' bindinput='bindPhoneInput'/> \r\n  </view>\r\n  <view class='row'>\r\n     <input placeholder='请输验证码' bindinput='bindCodeInput' style='width:70%;'/> \r\n     <button class='codeBtn' bindtap='getCode' hidden='{{hidden}}' disabled='{{btnDisabled}}'>{{btnValue}}</button>\r\n  </view>\r\n  <view>\r\n     <button class='save' bindtap='save' >保存</button>\r\n  </view>\r\n  \r\n</view>\r\nindex.js//index.js\r\nvar zhenzisms = require('../../utils/zhenzisms.js');\r\n//获取应用实例\r\nconst app = getApp();\r\n \r\nPage({\r\n  data: {\r\n    hidden: true,\r\n    btnValue:'',\r\n    btnDisabled:false,\r\n    name: '',\r\n    phone: '',\r\n    code: '',\r\n    second: 60\r\n  },\r\n  onLoad: function () {\r\n    \r\n  },\r\n  //姓名输入\r\n  bindNameInput(e) {\r\n    this.setData({\r\n      name: e.detail.value\r\n    })\r\n  },\r\n  //手机号输入\r\n  bindPhoneInput(e) {\r\n    console.log(e.detail.value);\r\n    var val = e.detail.value;\r\n    this.setData({\r\n      phone: val\r\n    })\r\n    if(val != ''){\r\n      this.setData({\r\n        hidden: false,\r\n        btnValue: '获取验证码'\r\n      })\r\n    }else{\r\n      this.setData({\r\n        hidden: true\r\n      })\r\n    }\r\n  },\r\n  //验证码输入\r\n  bindCodeInput(e) {\r\n    this.setData({\r\n      code: e.detail.value\r\n    })\r\n  },\r\n  //获取短信验证码\r\n  getCode(e) {\r\n    console.log('获取验证码');\r\n    var that = this;\r\n    zhenzisms.client.init('https://sms_developer.zhenzikj.com', 'appId', 'appSecret');\r\n    zhenzisms.client.send(function (res) {\r\n      if(res.data.code == 0){\r\n        that.timer();\r\n        return ;\r\n      }\r\n      wx.showToast({\r\n        title: res.data.data,\r\n        icon: 'none',\r\n        duration: 2000\r\n      })\r\n    }, '15801636347', '验证码为:3322');\r\n    \r\n  },\r\n  timer: function () {\r\n    let promise = new Promise((resolve, reject) => {\r\n      let setTimer = setInterval(\r\n        () => {\r\n          var second = this.data.second - 1;\r\n          this.setData({\r\n            second: second,\r\n            btnValue: second+'秒',\r\n            btnDisabled: true\r\n          })\r\n          if (this.data.second <= 0) {\r\n            this.setData({\r\n              second: 60,\r\n              btnValue: '获取验证码',\r\n              btnDisabled: false\r\n            })\r\n            resolve(setTimer)\r\n          }\r\n        }\r\n        , 1000)\r\n    })\r\n    promise.then((setTimer) => {\r\n      clearInterval(setTimer)\r\n    })\r\n  },\r\n  //保存\r\n  save(e) {\r\n    console.log('姓名: ' + this.data.name);\r\n    console.log('手机号: ' + this.data.phone);\r\n    console.log('验证码: ' + this.data.code);\r\n \r\n     //省略提交过程\r\n  }\r\n})\r\nindex.wxss/**index.wxss**/\r\npage{\r\n  height: 100%;\r\n  width: 100%;\r\n  background: linear-gradient(#5681d7, #486ec3);\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n.container{\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: space-around;\r\n  width: 90%;\r\n  margin: 50rpx auto;\r\n}\r\n \r\n.row{\r\n  position: relative;\r\n  height: 80rpx;\r\n  width: 100%;\r\n  border-radius: 10rpx;\r\n  background: #fff;\r\n  margin-bottom: 20rpx;\r\n  padding-left: 20rpx;\r\n  box-sizing: border-box;\r\n}\r\n.row input{\r\n  width: 100%;\r\n  height:100%;\r\n}\r\n.codeBtn{\r\n  position: absolute;\r\n  right: 0;\r\n  top: 0;\r\n  color: #bbb;\r\n  width: 30%;\r\n  font-size: 26rpx;\r\n  height: 80rpx;\r\n  line-height: 80rpx;\r\n}\r\n.subBtn{\r\n  width: 200rpx;\r\n  height: 80rpx;\r\n  background: #fff;\r\n  color: #000;\r\n  border-radius: 50rpx;\r\n  line-height: 80rpx;\r\n}\r\n完整下载: 下载详情参考: http://smsow.zhenzikj.com/doc..."}
{"title": "小程序绑定事件跳转的三种方法 ", "author": "Rolan", "pub_time": "2018-12-18 00:27", "article_content": "1:wx.navigateTo ;保留当前页面（有返回按钮)效果：demo示例：wxml:<view bindtap=\"bindViewTap\" class=\"up\">   我要绑定事件来跳转了</view>js:Page({  data: {  },  //事件处理函数  bindViewTap: function() {    wx.navigateTo({      url: '../site/site'    })  },  onLoad: function() {  },})wxss:.up {  height: 80rpx;  line-height: 80rpx;  background:#44b0fc;  color: #fff;  text-align: center;}2:wx.redirectTo；关闭当前页面(无返回按钮)wxml和样式同上 js:Page({  data: {  },  //事件处理函数  bindViewTap: function() {    //2:关闭当前页面(无返回按钮)    wx.redirectTo({      url: '../site/site'    })  },  onLoad: function() {},})3：wx.switchTab；跳转到tabBar页面（底部导航）遇到第一种wx.navigateTo 不跳转问题的时候（大多数是因为想要跳的界面是对应底部的导航，所以没有反应；这个时候，就需要用到这种方法了） js:Page({  data: {},  //事件处理函数  bindViewTap: function() {    //3:跳转到tabBar页面（底部导航）    //这种方法通常  是遇到wx.navigateTo 不跳转问题的时候（大多数是跳的底部的导航，所以没有反应）    wx.switchTab({      url: '../me/me'    })  },  onLoad: function() {},})原文作者：祈澈姑娘；技术博客：https://www.jianshu.com/u/05f416aefbe190后前端妹子，爱编程，爱运营，爱折腾。 坚持总结工作中遇到的技术问题，坚持记录工作中所所思所见，欢迎大家一起探讨交流。"}
{"title": "小程序使用 async await ", "author": "Rolan", "pub_time": "2018-12-18 00:44", "article_content": "实践的方式如下：\r\n\r\n\r\n第一个问题： 虽然小程序不支持，但是我们可以引入js库啊。双手奉上facebook的开源库regenerator 下载'packages/regenerator-runtime'这个路径下的runtime.js，放到自己小程序项目下的utils或者lib文件夹下。\r\n\r\n\r\n第二个问题： Async跟Await的用法\r\n\r\n\r\nAsync - 定义异步函数(async function someName(){...})\r\n\r\n自动把函数转换为 Promise\r\n当调用异步函数时，函数返回值会被 resolve 处理\r\n异步函数内部可以使用 await\r\n\r\n\r\n\r\nAwait - 暂停异步函数的执行 (var result = await someAsyncCall();)\r\n\r\n当使用在 Promise 前面时，await 等待 Promise 完成，并返回 Promise 的结果\r\nawait 只能和 Promise 一起使用，不能和 callback 一起使用\r\nawait 只能用在 async 函数中\r\n\r\n\r\n\r\nimport regeneratorRuntime from '../../utils/runtime.js'\r\n\r\nonLoad: function() {\r\n    this.initData();\r\n  },\r\n\r\n  async initData(){\r\n\tawait this.initMyData();//请求接口1\r\n\tawait this.initTodayData();//请求接口2\r\n  }\r\n\r\n  initMyData:function(){\r\n\tconsole.log('开始请求1')\r\n\t........\r\n\t//回调函数的方法内写\r\n\tconsole.log(\"完成请求1\")\r\n\t\r\n\t\r\n}\r\n\r\n  initTodayData:function(){\r\n\tconsole.log('开始请求2')\r\n\t........\r\n\t//回调函数的方法内写\r\n\tconsole.log(\"完成请求2\")\r\n}"}
{"title": "微信小程序下载照片（显示进度条） ", "author": "Rolan", "pub_time": "2018-12-21 00:21", "article_content": "一、downloadTask/UploadTask理解\r\n\r\ndownloadTask\r\n\r\n\r\n一个可以监听下载进度变化事件，以及取消下载任务的对象\r\n\r\n本质：对象\r\n功能一：监听下载进度变化\r\n功能二：取消下载任务\r\n\r\n\r\n\r\n\r\nUploadTask\r\n\r\n\r\n一个可以监听上传进度变化事件，以及取消上传任务的对象\r\n\r\n本质：对象\r\n功能一：监听上传进度变化\r\n功能二：取消上传任务\r\n\r\n\r\n\r\n1.1、监听下载进度变化事件downloadTask.onProgressUpdate((res) => {\r\n  console.log('下载进度', res.progress)\r\n  console.log('已经下载的数据长度', res.totalBytesWritten)\r\n  console.log('预期需要下载的数据总长度', res.totalBytesExpectedToWrite)\r\n})\r\n复制代码1.2、取消监听下载进度变化事件DownloadTask.offProgressUpdate(function callback)\r\n复制代码1.3、 监听 HTTP Response Header 事件DownloadTask.onHeadersReceived(function callback)\r\n复制代码1.4、 取消监听 HTTP Response Header 事件DownloadTask.offHeadersReceived(function callback)\r\n复制代码1.5、中断下载任务DownloadTask.abort()\r\n复制代码二、downloadFile 下载文件理解本质：方法功能：下载文件资源到本地返回值：downloadTask对象success 返回的两个参数tempFilePath临时文件路径。如果没传入 filePath 指定文件存储路径，则下载后的文件会存储到一个临时文件stringstatusCode开发者服务器返回的 HTTP 状态码numberwx.downloadFile({\r\n  url: 'https://example.com/audio/123', \r\n  header:'', //HTTP 请求的 Header，Header 中不能设置 Referer\r\n  filePath:'',//指定文件下载后存储的路径\r\n  success(res) {\r\n    // 只要服务器有响应数据，就会把响应内容写入文件并进入 success 回调\r\n    //业务需要自行判断是否下载到了想要的内容\r\n    if (res.statusCode === 200) {\r\n      wx.saveImageToPhotosAlbum({\r\n        filePath: res.tempFilePath\r\n      })\r\n    }\r\n  },\r\n  fail(err){\r\n      console.log(err)\r\n  },\r\n  complete(res){\r\n      console.log(res)\r\n  }\r\n})\r\n复制代码三、saveImageToPhotosAlbum 理解功能：保存图片到系统相册wx.saveImageToPhotosAlbum({\r\n  filePath:'',\r\n  success(res) { \r\n      \r\n  }，\r\n  fail(err){\r\n      \r\n  },\r\n  complete(res){\r\n      \r\n  }\r\n})\r\n复制代码四、代码展示/**\r\n   * [downloadPhoto 下载照片]\r\n   */\r\n  downloadPhoto (e) {\r\n    let imgUrl = e.currentTarget.dataset.src\r\n    // 下载监听进度\r\n    const downloadTask = wx.downloadFile({\r\n      url: imgUrl,\r\n      success: function (res) {\r\n        console.log(res)\r\n        if (res.statusCode === 200) {\r\n          wx.saveImageToPhotosAlbum({\r\n            filePath: res.tempFilePath,\r\n            success: function (res) {\r\n              wx.showToast({\r\n                title: '保存图片成功'\r\n              })\r\n            },\r\n            fail: function (res) {\r\n              wx.showToast({\r\n                title: '保存图片失败'\r\n              })\r\n            }\r\n          })\r\n        }\r\n      }\r\n    })\r\n    downloadTask.onProgressUpdate((res) => {\r\n      if (res.progress === 100) {\r\n        this.setData({\r\n          progress: ''\r\n        })\r\n      } else {\r\n        this.setData({\r\n          progress: res.progress + '%'\r\n        })\r\n      }\r\n    })\r\n  },\r\n复制代码"}
{"title": "Taro 1.2：将已有微信小程序转换为多端应用 ", "author": "Rolan", "pub_time": "2018-12-21 00:32", "article_content": "在距离Taro 1.1 发布 之后一个月，经历了 500 多次提交和 17 个预览版本的迭代之后，我们有信心在今天发布 Taro 1.2 正式版。Taro 1.2 比起 Taro 1.1 和其它的小程序开发框架，增加了许多首次在小程序框架上实现的功能，这些功能包括但不限于：微信小程序转多端应用就像博客大战时代博客服务商提供了「搬家」工具一样，Taro 现在也提供了「搬家」工具让你方便地入驻 Taro 社区。转换原有微信小程序应用非常简单，只需要安装 Taro 命令行工具，定位到待转项目根目录，运行命令：$ taro convert\r\n复制代码Taro 就会把转换好的代码生成在根目录下的 taroConvert 文件夹。转换后的代码是高可读性的 JSX 代码，没有额外的庞大组件库开销。你可以轻易地进行二次开发，或者直接将这些代码通过taro build 命令生成任意 Taro 已经支持平台的应用。我们已经尝试使用 taro convert 成功转换了四个 GitHub 上最热门的开源微信小程序应用，它们转换之后都表现良好：EastWorld/wechat-app-mall ★5000+ - 微信小程序商城tumobi/nideshop-mini-program ★3000+ - 基于 Node.js + MySQL 开发的开源微信小程序商城RebeccaHanjw/weapp-wechat-zhihu ★1000+ - 仿知乎jectychen/wechat-v2ex ★400+ - V2EXtaro convert 不仅仅能支持转换微信小程序应用，它还能转换微信小程序第三方组件。例如 wxParse 经过 taro convert 编译之后还能突破原有只能解析 11 层 HTML 嵌套的限制，理论上可以解析无限层 HTML 嵌套。更多详情可以访问文档 nervjs.github.io/taro/docs/t… 了解更多。字节跳动（头条）小程序支持作为一个「多端统一开发框架」，Taro 当然也不会放过字节跳动小程序。在 Taro 1.2，你可以通过如下命令进行字节跳动小程序端的编译预览及打包：# npm script\r\n$ npm run dev:tt\r\n$ npm run build:tt\r\n# 仅限全局安装\r\n$ taro build --type tt --watch\r\n$ taro build --type tt\r\n# npx 用户也可以使用\r\n$ npx taro build --type tt --watch\r\n$ npx taro build --type tt\r\n复制代码选择字节跳动小程序模式，你需要下载并打开 字节跳动小程序开发者工具 ，然后在项目编译完后选择项目根目录下 dist 目录进行预览。相应地，Taro 的平台标识（process.env.TARO_ENV）也增加了新成员 tt ，代表字节跳动小程序。CSS Modules 支持在 Taro 最早开源的时候我们就支持了 SCSS 、 LESS 和 Stylus ，而在 Taro 1.2 中我们百尺竿头更进一步，给社区带来了 JSX 的好伙伴：CSS Modules。对于 Taro 而言支持 CSS Modules 有着重要的意义。Taro 在 1.0 的时候已经支持组件的 style传入 JavaScript 对象，支持了 CSS Modules 之后组件的 className 也能做这点——这意味着 Taro 完全可以做到 JSX 的一项特性：「Everything in JavaScript」。同时，通过编辑器的自动补全和校验功能，开发者再也不用担心 CSS 类误输入和 CSS 类的命名问题。你可以查阅文档CSS Modules 的使用 找到 CSS Modules 的开启方法。CSS Modules 的支持主要由 Taro 社区的个人开发者 @MrKou47 (MrKou47) 开发，感谢他的贡献。MobX 支持在小程序应用变得日趋复杂的今天，越来越多的开发者选择使用独立的状态管理工具。在 Taro 1.1 你可以选择 Redux 的体系的 redux-thunk 、 dva-core 、 redux-saga 等工具。在 Taro 1.2 我们又带来了 taro-mobx 。在 Taro 中使用 MobX 非常简单，你可以通过 taro init <your app> 命令创建一个全新的 MobX 模板项目。也可以查阅使用 MobX 文档将 taro-mobx 接入已有项目。MobX 的支持主要由 Taro 社区的个人开发者 @nanjingboy (Tom Huang) 开发，感谢他的贡献。更多特性面对社区里给力的个人贡献者，Taro 官方团队也没有闲着。在 Taro 1.2 开发期间通过 commit 关闭了 169 个 issue 的同时，我们还披星戴月带来了更多特性。其中值得一提的是：H5 路由系统彻底重构小程序组件的 props 支持传入 JSX 元素支持 JSX 元素写在 switch-case 中，并支持 if-else 和 switch-case 的多重嵌套支持引用别名（alias）与百度小程序和字节跳动小程序官方通力合作，抹平了一大波和微信小程序的差异你可以通过 CHANGELOG 查阅完整的功能迭代纪录。写在最后Taro 1.2 最为激动人心的功能显然是「微信小程序转 Taro」 功能，通过这个功能已有的微信小程序应用能转化更好维护的 Taro（类 React） 代码，也能把 Taro 代码转化为多端应用。但更重要的是，本次 Taro 1.2 更新的两个核心功能点均由个人开发者贡献——这完全体现了 Taro 社区的活跃、强大和开放。我们也会长期地维护与社区开发者们的关系，与开发者们一同成长，互利互赢。这也是 Taro 选择开源的意义所在。如果你有任何想法，或者没有想法，Taro 都非常欢迎你来吐槽或观光：github.com/NervJS/taro"}
{"title": "小程序开发之模板消息篇 ", "author": "Rolan", "pub_time": "2018-12-25 00:11", "article_content": "1|5API实现 到这里，小程序端的工作就完成了，但是事情还没有结束，因为API也该咱实现(苦笑.JPG)。那我们接着来看看在API端有哪些需要处理的活：首先我们要新建发送模板的PostSendTemplete 模型 public class PostSendTemplete\r\n {\r\n        public string openId { get; set; }\r\n\r\n        public string touser { get; set; }\r\n\r\n        public string template_id { get; set; }\r\n\r\n        public string page { get; set; }\r\n\r\n        public string form_id { get; set; }\r\n\r\n        public object data { get; set; }\r\n\r\n        public string color { get; set; }\r\n\r\n        public string emphasis_keyword { get; set; }\r\n }和一个返回的TemplateResultModel 模型public class TemplateResultModel\r\n{\r\n        public int errcode { get; set; }\r\n        public string errmsg { get; set; }\r\n        public string template_id { get; set; }\r\n}第一步，我们新建一个SendTemplateMessage 的业务 接口如下：Task<TemplateResultModel> SendTemplateMessage(PostSendTemplete tmModel);第二步，实现这个业务接口：public async Task<TemplateResultModel> SendTemplateMessage(PostSendTemplete tmModel)\r\n{\r\n   WxaTempleteModel model = tmModel.TranslateToSendTemplateDto();\r\n   var result = await _template.SendTemplateMessage(model, tmModel.openId);\r\n   return result;\r\n}第三步，上述标红的是新建的一个数据接口，接口如下： Task<TemplateResultModel> SendTemplateMessage(WxaTempleteModel tmModel,string code);第四步，实现上述的数据接口：public async Task<TemplateResultModel> SendTemplateMessage(WxaTempleteModel tmModel,string openid)\r\n{\r\n            tmModel.touser = openid;\r\n            var url = _config[ConfigurationKeys.TEMPLATE_SEND_RUL];\r\n            var accesstoken = MinTokenContext.AccessToken;//注：此处用到的appId和密匙都是小程序的\r\n            string queryUrl = string.Format(url, accesstoken);\r\n            var objectdata = JsonConvert.SerializeObject(tmModel);\r\n            var data = Httphelper.SendPostHttpRequest(queryUrl, contentType, objectdata.ToString());\r\n            TemplateResultModel userCard = JsonConvert.DeserializeObject<TemplateResultModel>(data);\r\n            \r\n            if (userCard.errcode == Invalid_token)\r\n            {\r\n                MinTokenContext.RefreshAccessToken();\r\n                _logger.LogInformation(string.Format(@\"模板消息: Access Token 刷新，时间 {0}\", DateTime.Now.ToString(\"yy-MM-dd HH:mm\")));\r\n\r\n                data = Httphelper.SendPostHttpRequest(queryUrl, contentType, objectdata);\r\n                userCard = JsonConvert.DeserializeObject<TemplateResultModel>(data);\r\n            }\r\n\r\n            return userCard;\r\n}上述方法实现中，都需要将接口和实现在初始化的时候绑定，然后注入：//Startup中    public Startup(IConfiguration configuration)　　{　　　　Configuration = configuration;　　}　　public IConfiguration Configuration { get; } 　//Configure中：services.AddScoped<ITemplateMessage, TemplateMessage>();需要引入：using Microsoft.Extensions.Configuration;1|6实现效果      End"}
{"title": "小程序实战踩坑之B2B商城项目总结 ", "author": "Rolan", "pub_time": "2018-12-25 00:24", "article_content": "坑一：支付完成页面，点击“完成” 按钮会触发返回的页面的onShow()生命周期 (秘坑)如下图，原以为是微信的页面，不会影响到小程序，实际情况下是会触发返回的页面的onShow()的。触发bug业务场景详细描述：因为业务需要，我会在下订单页面触发 onShow()，在onShow里面会有调取查询购物车的商品数据，如果商品数据不存在，就会跳转到首页。当用户支付完成后，返回下订单页面，触发onShow生命周期，导致调取查询购物车api，因为已经创建订单去支付了，所以购车车的商品数据就在后台不存在了，所以在 跳过去支付成功页面的那一刻，页面闪了下，异步api在执行，又立刻跳回页面首页。解决方法：               self.cancelOnShow = true;\r\n                self.$apply();\r\n                wx.requestPayment({\r\n                    'timeStamp': d.timeStamp,\r\n                    'nonceStr': d.nonceStr,\r\n                    'package': d.package,\r\n                    'signType': d.signType,\r\n                    'paySign': d.paySign,\r\n                    'success': function(res) {\r\n                        console.log(res, '微信支付成功返回');\r\n                        wx.setStorageSync(\"isSucPay\", true);\r\n                        wx.setStorageSync(\"orderCode\", orderCode);\r\n                        wx.navigateTo({\r\n                            url: './paymentnote',\r\n                            complete:function(){\r\n                                self.cancelOnShow = false;\r\n                            }\r\n                        })\r\n                    },\r\n                    'fail': function(res) {\r\n                        console.log(res, '微信支付失败返回');\r\n                        wx.setStorageSync(\"isSucPay\", false);\r\n                        wx.setStorageSync(\"repayParams\",{amount:balance,invoiceid:orderCode});\r\n                        wx.navigateTo({\r\n                            url: './paymentnote',\r\n                            complete:function(){\r\n                                self.cancelOnShow = false;\r\n                            }\r\n                        })\r\n                    }\r\n                });onsShow(){\r\n    if(!this.cancelOnShow)\r\n    {\r\n        //业务代码******\r\n    }\r\n}主要是在调取支付前，通过设置 cancelOnShow 为true，然后在跳转 支付成功（失败）页面的complete回调函数，将设置cancelOnShow为false，不影响其他下次支付。有人问，将self.cancelOnShow = false;放在wx.requestPayment的 success 回调函数，在wx.navigateTo跳转之前，是否可行？我自身测试过，是不行的，原因自身体会去。其次，在onShow生命周期函数，要根据cancelOnShow来判断执行业务代码。坑二：多个倒计时重碟问题问题描述： 在一个页面如果用倒计时，如果切换到其他页面返回，会看到多个倒计时在错误重碟显示。解决代码如下：  /**\r\n     * 清除interval\r\n    * @param that\r\n    */\r\n   clearTimeInterval: function (that) {\r\n      var interval = that.data.interval;\r\n      clearInterval(interval)\r\n    },\r\n   \r\n   /**\r\n     * 生命周期函数--监听页面卸载\r\n     * 退出本页面时停止计时器\r\n    */\r\n   onUnload:function () {\r\n        var that = this;\r\n        that.clearTimeInterval(that)\r\n   },\r\n \r\n   /**\r\n     * 生命周期函数--监听页面隐藏\r\n     * 在后台运行时停止计时器\r\n    */\r\n   onHide:function () {\r\n        var that = this;\r\n        that.clearTimeInterval(that)\r\n   }在tab页面，运用 onHide 周期 进行 clearTimeInterval , 在 非tab页面，运用onUload() 周期 进行 clearTimeInterval。坑三：swiper的swiper-item变动，导致显示异常swiper 要根据地区选择不同的内容（swiper-item）播放动画，当切换 地区的时候，我的 swiper-item 个数也在变化， 但是原 swiper 的 current 还是之前的，比如切换2张变1张数据的时候，就会 导致swiper 不显示。解决方法和代码：坑四：微信二次授权无法再次获取授权问题获取个人地址授权，点击取消，再去获取，无反应，这个不算bug，但是可以总结下，这块是属于 微信二次授权问题，百度也可以找到相关，代码如下：通过 wx.openSetting 打开授权过的 权利，再次打开，在回调中，在执行你想要的业务逻辑即可。坑五：倒计时显示卡顿倒计时在触摸状态拖住不放的情况下，会发现有倒计时停止了，也就是所谓的卡顿，放开，或者随便动下页面又正常（而且时间恢复得特别快），暂时未找到解决方案，有知悉的同学麻烦告知。下面是我组队员志新同学总结的一些UI展示的坑位：坑六：button标签需清除默认的样式小程序button标签默认的样式不符合我们的设计稿，会出现一些比较丑的border，background等。去除button border线条button::after {\r\n\r\n  border: 0;\r\n\r\n}去除button背景色button{\r\nbackground:none !important;\r\n}坑七：行高不够被截头小程序的标签貌似没有写 默认行高是多少。不过根据截图文本可以发现文本的蓝色底色范围框会比文本内容高一些。如果担心这些蓝色的范围影响了一些设计稿的边距 ，想要收一收它的占位间隙，那么可以将视图内的文本行高设置为 1.1~1.3之间。为什么我不推荐直接设置为行高 1 呢？ 因为行高为1的话，在部分安卓机器上面有坑，会出现文字 头部 一些 笔画被 截取没了，出现貌似被砍头的效果!view，text{\r\n    line-height:（1.1 或者 1.3 ）  可以适当的收一收它默认行高的一些间隙；\r\n}被截头就如下面的图片：坑八：微信小程序通过background-image设置背景：只支持线上图片和base64图片，不支持本地图片坑九：小程序input需要调整聚焦的时候输入框和键盘的距离，增加体验感！cursor-spacingNumber 指定光标与键盘的距离，单位px（2.4.0起支持rpx）。取 input 距离底部的距离和 cursor-spacing 指定的距离的最小值作为光标与键盘的距离<input type=\"text\" cursor-spacing=\"70\" placeholder=\"请输入具体的营业地址\">坑十：textarea层级穿透（独家秘坑）小程序的textarea 里 placeholder提示不知道为什么，存在一个非常高的层级，平时布局放着还好，要是和一个自己写的弹出层展示，就会发现 textarea的层级比你自己写的弹出层层级还要高，导致结构穿透，紊乱。不管你自己定义的弹出层层级有多高，textarea依然会把它穿透！解决办法：障眼法，在textarea同级在写一个view 仿textarea的样式，当你的弹出层 弹出的时候，把这个真实的 textarea先hidden起来，（注意不要用 wx：if因为display：none会把之前输入的备注内容消息又清没了）。然后把那个高仿的textarea显示出来。当弹出层消失的时候，就把高仿的textarea隐藏，真实的textarea显示出来。"}
{"title": "记一次微信小程序在安卓的白屏问题 ", "author": "Rolan", "pub_time": "2018-12-25 00:30", "article_content": "在做小程序的时候，做到了一个限时商品售卖，用到了倒计时，因为这个原因导致了安卓手机上使用小程序时，将小程序放入后台运行一段时间后，再次进入小程序后出现了页面白屏或者点击事件失效的情况，这里记录下1.相关代码文件我这里是使用了自定义组件的形式来渲染的外部的引用的自定义组件的wxml文件/* limitCommodity是一个数组，返回的是商品对象，包含商品价格、商品结束时间、商品图片等 */\r\n<block wx:for=\"{{limitCommodity}}\" wx:key=\"{{item.id}}\">\r\n    <commodityItem class=\"specialContent\" goods=\"{{item}}\" />\r\n</block>自定义组件的js文件Component({\r\n  properties: {\r\n    goods: Object\r\n  },\r\n  data: {\r\n  },\r\n  timer: null,\r\n  /* 在组件实例进入页面节点树时执行，开始定时器 */\r\n  attached: function() {\r\n    if(this.timer) {\r\n      clearInterval(this.timer);\r\n    }\r\n    this.filterTime();\r\n    let that = this;    \r\n    this.timer = setInterval(function () {\r\n      that.filterTime();\r\n    }, 1000)\r\n  },\r\n  /* 在组件实例被从页面节点树移除时执行，将定时器清除 */\r\n  detached: function() {\r\n    clearInterval(this.timer);\r\n    this.timer = null;\r\n  },\r\n  methods: {\r\n    /* 用于将时间戳转换成自定义的时间格式 */\r\n    filterTime() {\r\n      let totalTime = new Date(parseInt(this.data.goods.endtime) * 1000) - new Date();\r\n      let days = parseInt(totalTime / 1000 / 60 / 60 / 24, 10);\r\n      let hours = parseInt(totalTime / 1000 / 60 / 60 % 24, 10);\r\n      let minutes = parseInt(totalTime / 1000 / 60 % 60, 10);\r\n      let seconds = parseInt(totalTime / 1000 % 60, 10);\r\n      let day = days >= 10 ? days : '0' + days;\r\n      day = day == 0 ? '' : day + '天';\r\n      let hour = hours >= 10 ? hours : '0' + hours;\r\n      let minute = minutes >= 10 ? minutes : '0' + minutes;\r\n      let second = seconds >= 10 ? seconds : '0' + seconds;\r\n      this.setData({\r\n        limitTime: day + hour + \":\" + minute + \":\" + second\r\n      })\r\n    },\r\n  }\r\n})2.引起的原因因为在外部引入自定义的组件时，直接就是调用了定时器并且进行了setData操作，这就导致了当在外部引用这个组件时，如果传入的商品数组长度较大时，定时器增多的同时，setData操作也不断的增多setData多了就会导致内存占用多3.改进方法改进方法就是减少setData操作可以再自定义一个组件，用于将整个数组传入然后对商品数组里的时间先进行计算改进后的js文件Component({\r\n  properties: {\r\n    limitCommodity:Array\r\n  },\r\n  data: {\r\n  },\r\n  timeOut:null,\r\n  /* 在组件实例进入页面节点树时执行 */\r\n  attached(){\r\n    this.calculate();\r\n  },\r\n  /* 在组件实例被从页面节点树移除时执行，将定时器清除 */\r\n  detached(){\r\n    clearTimeout(this.timeOut);\r\n    this.timeOut = null;\r\n  },\r\n  methods: {\r\n    filterTime(endtime) {\r\n      let totalTime = new Date(parseInt(endtime) * 1000) - new Date();\r\n      let days = parseInt(totalTime / 1000 / 60 / 60 / 24, 10);\r\n      let hours = parseInt(totalTime / 1000 / 60 / 60 % 24, 10);\r\n      let minutes = parseInt(totalTime / 1000 / 60 % 60, 10);\r\n      let seconds = parseInt(totalTime / 1000 % 60, 10);\r\n      let day = days >= 10 ? days : '0' + days;\r\n      day = day == 0 ? '' : day + '天';\r\n      let hour = hours >= 10 ? hours : '0' + hours;\r\n      let minute = minutes >= 10 ? minutes : '0' + minutes;\r\n      let second = seconds >= 10 ? seconds : '0' + seconds;\r\n      return day + hour + \":\" + minute + \":\" + second\r\n    },\r\n    calculate(){\r\n      let limitCommodity = this.data.limitCommodity;\r\n      for (let i = 0; i < limitCommodity.length;i++){\r\n        limitCommodity[i]['endtime_date'] = this.filterTime(limitCommodity[i]['endtime'])\r\n      }\r\n      this.setData({\r\n        limitCommodity\r\n      })\r\n      this.timeOut = setTimeout(()=>{\r\n        this.calculate();\r\n      },1000);\r\n    }\r\n  }\r\n})改进就是计算时间后再返回时间，而setData的是整个商品列表数组，这样就减少了setData次数正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断iOS和Android及PC端纯css实现瀑布流（multi-column多列及flex布局）实现单行及多行文字超出后加省略号微信小程序之购物车和父子组件传值及calc的注意事项"}
{"title": "使用LeanCloud快速开发一款小程序 ", "author": "Rolan", "pub_time": "2018-12-26 00:23", "article_content": "开发小程序离不开后台数据，对于独立开发者来说，既要写前端，又要写后端，工作量就会骤然增大。微信提供的云开发无疑是给独立开发者提供了很大的便利，但是由于其数据库不支持联表查询，对于某些场景就不是那么的友好了。当然，市面上有很多的 BaaS 服务提供商，大都类似，今天我们就用其中的一个 LeanCloud 来讲解一下，如何快速使用 LeanCloud 来开发一个小程序。 由于本次重点在 LeanCloud ，所以小程序的开发内容就不是重点。现在开始账号注册先去leancloud.cn官网注册一个账号，然后登录去控制台创建一个新应用。域名配置在微信小程序后台中配置域名白名单，具体需要按照这里说明的来配置，你也可以先跳过这一步，等完全开发完毕后再来配置。可在开发者工具的 详情 > 项目设置 中勾选 不校验安全域名、TLS 版本以及 HTTPS 证书 。SDK 集成下载你熟悉的SDK，目前支持 JS ， WePY ， mpvue ，下载链接在这里，后面以 JS 来说明，其他方式的 SDK 导入以及使用方法参考文档中的说明。初始化 SDK在 app.js 中加入以下代码即可。 appId 和 appKey 可以在控制台中的应用找到。const AV = require('./utils/av-live-query-weapp-min');\r\n\r\nAV.init({\r\n  appId: '换成你自己的appId',\r\n  appKey: '换成你自己的appKey',\r\n});\r\n复制代码查询数据先需要在控制台中的应用下新建一个表，在网页中叫做 Class 。每一张表会默认创建 objectId 、 createdAt 、 updatedAt 、 ACL 四个字段，分别表示 数据索引 ， 创建时间 ， 更新时间、 权限 。你可以添加你想要的字段，目前支持以下几种类型。其中 Object 是 map 对象， GeoPoint 是经纬度信息， Pointer 是另外一张表的表名，做多表联合查询使用的。 假设我们的表名是 T_TODO ，我们可以用以下代码来查询该表下面的数据。new AV.Query('T_TODO')\r\n      .descending('createdAt') // 排序\r\n      .limit(10) // 分页数量\r\n      .skip(10) // 跳过数量\r\n      .find()\r\n      .then(function(results) {\r\n      \t\tthat.setData({todo: results})\r\n      })\r\n      .catch(console.error);\r\n  }\r\n复制代码在你的 WXML 中可以这样写来做数据绑定：<!-- pages/todos/todos.wxml -->\r\n<block wx:for=\"{{todos}}\" wx:for-item=\"todo\" wx:key=\"objectId\">\r\n<text data-id=\"{{todo.objectId}}\">\r\n  {{todo.content}}\r\n</text>\r\n</block>\r\n复制代码是不是很方便。多表查询如果需要多多表查询，先要在一张表中新建一个 Pointer 字段，新建时会让你选择指向的表名，如下图所示：然后在查询是使用 include，就会返回关联表中的所有信息了，如下所示：new AV.Query('T_TODO')\r\n      .descending('createdAt') // 排序\r\n      .limit(10) // 分页数量\r\n      .skip(10) // 跳过数量\r\n      .include('T_POINT_CLASS')\r\n      .find()\r\n      .then(function(results) {\r\n      \t\tthat.setData({todo: results})\r\n      })\r\n      .catch(console.error);\r\n  }\r\n复制代码更新对象小程序中对表中字段做操作后，需要同步更新到服务端，可以使用以下代码来保存对象。// 第一个参数是 className，第二个参数是 objectId\r\n  var todo = AV.Object.createWithoutData('Todo', '5745557f71cfe40068c6abe0');\r\n  // 修改属性\r\n  todo.set('content', '每周工程师会议，本周改为周三下午3点半。');\r\n  // 保存到云端\r\n  todo.save();\r\n复制代码其他更多的操作请查看文档，不过你找不到小程序对应的详细开发文档，只能找到 数据存储开发指南 · JavaScript"}
{"title": "小程序--人脸识别功能（百度ai） ", "author": "Rolan", "pub_time": "2018-12-26 00:32", "article_content": "文档中心：https://ai.baidu.com/docs#/Begin/a2bbf4b2接入流程1. 按照文档获取AppID、API Key、Secret Key，进行Access Token（用户身份验证和授权的凭证）的生成const getBaiduToken = function () {\r\n    return new Promise((resolve, reject) => {\r\n        //自行获取APIKey、SecretKey\r\n        const apiKey = APIKey;\r\n        const secKey = SecretKey;\r\n        const tokenUrl = `https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&client_id=${apiKey}&client_secret=${secKey}`;\r\n        wx.request({\r\n            url: tokenUrl,\r\n            method: 'POST',\r\n            dataType: \"json\",\r\n            header: {\r\n                'content-type': 'application/json; charset=UTF-8'\r\n            },\r\n            success: function (res) {\r\n                resolve(res);\r\n            },\r\n            fail: function (res) {\r\n                wx.hideLoading();\r\n                wx.showToast({\r\n                    title: '网络错误，请重试！',\r\n                    icon: 'none',\r\n                    duration: 2000\r\n                })\r\n                reject(res);\r\n            },\r\n            complete: function (res) {\r\n                resolve(res);\r\n            }\r\n        })\r\n    })\r\n}2. 选择人脸识别-->人脸检测，人脸识别接口分为V2和V3两个版本，确认在百度云后台获得的是V2还是v3版本接口权限。//封装识别方法\r\nconst getImgIdentify = function(tokenUrl, data){\r\n    return new Promise((resolve, reject) => {\r\n        const detectUrl = `https://aip.baidubce.com/rest/2.0/face/v3/detect?access_token=${tokenUrl}`;\r\n        wx.request({\r\n            url: detectUrl,\r\n            data: data,\r\n            method: 'POST',\r\n            dataType: \"json\",\r\n            header: {\r\n                'content-type': 'Content-Type:application/json; charset=UTF-8'\r\n            },\r\n            success: function (res) {\r\n                resolve(res);\r\n            },\r\n            fail: function (res) {\r\n                wx.hideLoading();\r\n                wx.showToast({\r\n                    title: '网络错误，请重试！',\r\n                    icon: 'none',\r\n                    duration: 2000\r\n                })\r\n                reject(res);\r\n            },\r\n            complete: function (res) {\r\n                resolve(res);\r\n            }\r\n        })\r\n    })\r\n}\r\n3. 调用识别方法getBaiduToken().then((res) => {\r\n    let token = res.data.access_token;\r\n    let data = {\r\n        \"image\": self.data.img,\r\n        \"image_type\":\"URL\",\r\n        \"face_field\":\"ge,beauty,expression,face_shape,gender,glasses,landmark,race,quality,eye_status,emotion,face_type\"\r\n    }\r\n    util.getImgIdentify(token, data).then((res)=>{\r\n        //百度接口返回的结果\r\n        let score = parseInt(res.data.result.face_list[0].beauty);\r\n        self.setData({\r\n            score: score,\r\n        })\r\n    })\r\n})4. 结果如下：哼～一点都不准原文地址：https://github.com/liujianxi/..."}
{"title": "小程序 - 验证码倒计时组件 ", "author": "Rolan", "pub_time": "2018-12-27 00:08", "article_content": "发送验证码倒计时的方法很常见，在项目里面也经常会多次用到，这时就要把倒计时封装为组件，需要用到的时候方便使用。\r\n\r\n自定义组件\r\n需要封装一个组件，首先要熟悉小程序自定义组件的文档。官方文档在这里\r\n倒计时组件\r\n为了方便描述，我把页面定义为父组件，把倒计时组件定义为子组件吧。\r\n\r\n首先需要清楚子组件与父组件之间事件的响应方法，例如：子组件响应父组件的事件，子组件修改父组件的data属性等。\r\n\r\n小程序没有像Vue里面的watch模式也没有computed计算属性，但是还好小程序properties里有observer，官方文档说observer表示属性值被更改时的响应函数，那这样就好办了。\r\n当子组件倒计时完成之后，需要告诉父组件，子组件已经完成了倒计时，这里可以用到方法传递的e.detail来处理。\r\n\r\n\r\n子组件代码\r\ncountdown.js\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    // 是否开始倒计时\r\n    start: {\r\n      type: Boolean,\r\n      value: false,\r\n      observer(newVal){\r\n        if (newVal === true) {\r\n          this.countdownFunc()\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n    timerText: '获取验证码'\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    /**\r\n     * 触发页面点击事件\r\n     */\r\n    _getCountdownEvent(){\r\n      this.triggerEvent(\"getCountdownEvent\")\r\n    },\r\n\r\n    /**\r\n     * 触发页面修改data事件\r\n     */\r\n    _setStartDataEvent() {\r\n      this.triggerEvent(\"setStartDataEvent\", this.data.start)\r\n    },\r\n\r\n    /**\r\n     * 倒计时\r\n     */\r\n    countdownFunc() {\r\n\r\n      this.setData({\r\n        timerText: 60\r\n      })\r\n      let target = this\r\n      let countdownNum = target.data.timerText\r\n\r\n      let timer = setInterval(() => {\r\n        countdownNum--\r\n\r\n        target.setData({\r\n          timerText: countdownNum\r\n        })\r\n\r\n        if (countdownNum == 0) {\r\n          target.setData({\r\n            timerText: '重新发送',\r\n            start: false\r\n          })\r\n\r\n          this._setStartDataEvent() //倒计时为0时，让父组件的start重新设置为false\r\n          \r\n          clearInterval(timer) //清除定时器\r\n        }\r\n\r\n      }, 1000)\r\n    }\r\n  }\r\n})\r\n复制代码显示的倒计时（timerText）可以根据自己需求重新修改。\r\ncountdown.wxml\r\n<view bindtap=\"_getCountdownEvent\">{{timerText}}{{start?'s后重试':''}}</view>\r\n复制代码页面使用\r\n调用组件需要在相应的json文件里面注册，这个我就不说了。\r\n父组件代码\r\nsendRandom.wxml\r\n<countdown id=\"sendRandom\" \r\n    start=\"{{start}}\"\r\n    bind:getCountdownEvent=\"_getCountdownEvent\"\r\n    bind:setStartDataEvent=\"_setStartDataEvent\"\r\n    >\r\n</countdown>\r\n复制代码sendRandom.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    start: false\r\n  },\r\n\r\n  /**\r\n   * 点击获取验证码\r\n   */\r\n  _getCountdownEvent(e) {\r\n  \r\n  // todo: 点击获取验证码之后，可以根据自己的需求，通知子组件可以开始倒计时了\r\n  // 如： 向后台请求发送验证码的方法，请求成功之后将start设置为true，表示倒计时开始了。\r\n    \r\n    if (this.data.start === true) {\r\n      return\r\n    }\r\n    this.setData({\r\n      start: true\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 倒计时结束 设置setData为false\r\n   */\r\n  _setStartDataEvent(e){\r\n    if (e.detail === false) {\r\n      this.setData({\r\n        start: false\r\n      })\r\n    }\r\n  }\r\n  \r\n})\r\n复制代码结语\r\n以上是根据自己公司的需求封装的倒计时组件，写得不够优雅，只是想记录一下小程序自定义组件的互相传值和事件响应。如有更好的方法可以提供下思路。"}
{"title": "从入到放弃——快应用踩坑之路 ", "author": "Rolan", "pub_time": "2018-12-27 00:15", "article_content": "伴随着我司快应用审核通过、上线，此处应该有一篇快应用踩坑经历。我司开发的快应用刚好涉及到音频、视频、Feeds流业务，下面我说分享一下我在开发中遇到的问题。\r\n项目搭建\r\n  hap init <project_name> // 生成一个快应用项目脚手架\r\n  cd project_name\r\n  npm install // 安装依赖\r\n  npm run build // 打包快应用，输出build和dist文件夹\r\n  npm run watch // 监测到变化后自动编译\r\n  npm run server // 在另起一个终端开启server\r\n复制代码如果node版本用的是8以上的话，在运行完npm install后再运行npm run build时可能会报Cannot find module .../webpack.config.js异常，请重新执行一次hap update --force。这是由于高版本的npm在npm install时，会校验并删除了node_modules下部分文件夹，导致报错。而hap update --force会重新复制hap-toolkit文件夹到node_modules\r\n项目发布\r\n由于我们在开发环境下是用的debug签名，而正式发布到应用市场是需要正式签名\r\n创建私钥：\r\n通过openssl命令等工具生成签名文件private.pem、certificate.pem，例如：\r\nopenssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem\r\n(密钥长度，1024觉得不够安全的话可以用2048，但是代价也相应增大)\r\n在工程的sign目录下创建release目录，将私钥文件private.pem和证书文件certificate.pem拷贝进去\r\nCountry Name (2 letter code) [XX]:CN   #国家代码（中国）\r\nState or Province Name (full name) []:BeiJing   #省（北京）\r\nLocality Name (eg, city) [Default City]:BeiJing   #市（北京）\r\nOrganization Name (eg, company) [Default Company Ltd]:gdlb  #公司名称\r\nOrganizational Unit Name (eg, section) []:   #可不填\r\nCommon Name (eg, your name or your server's hostname) []: #可不填\r\nEmail Address []: #邮箱\r\nPlease enter the following 'extra' attributes\r\nto be sent with your certificate request\r\nA challenge password []:   #可不填\r\nAn optional company name []:   #可不填\r\n在工程的sign目录下创建release目录，将私钥文件private.pem和证书文件certificate.pem拷贝进去\r\n复制代码自定义根目录配置\r\n开发中可能需要引入js或者css文件等，为了方便通常回会备置相对路径,可以设置 alias （别名），来方便应用；具体的操作是，在 src 目录下建立 config 文件夹，在其中创建 webpack.config.js 文件,毕竟都是是用webpack，就像写vue项目一样。\r\nconst path = require('path')\r\nmodule.exports = {\r\npostHook: function(webpackConf, options){\r\n  webpackConf.resolve.alias = Object.assign(webpackConf.resolve.alias || {}, {\r\n    '@src': path.join(process.cwd(), 'src')\r\n  })\r\n}\r\n}\r\n\r\n复制代码开发中遇到的问题\r\n布局样式\r\n  初写快应用，因为之前是开发过小程序，再到快应用特别不适应。\r\n  1.首页面布局默认的就是flex，其他的浮动布局啥的都没有。\r\n  2.css 习惯连写，突然不能连写很不适应。\r\n  3. 不支position要实现z-index的图层效果请使用stack组件。\r\n  4.大量的css样式不支持，如bulr、box-shadow要实现只能用背景图。\r\n  5.background-image 1030 以下版本不支持网络路径\r\n  6. 华为平台对svg 和 动画有兼容性问题。\r\n  7. border-radius 如果是gif图片不生效。\r\n  8.自定义字体样式 1030+ 才支持font-face定义字体样式。\r\n复制代码组件\r\n\r\nlist-item\r\n\r\n作为使用率最高的组件之一，list-item组件类型不一致时,一定要给type=\"***\"\r\n不同命名来区别，否则也会闪退。\r\n解决方法：\r\n<list-item type=\"{{index}}\">\r\n复制代码\r\nswiper\r\n\r\nswiper也是作为出现频率非常高组件，但是字实际使用中，虽然bug不多，但是开放的功能太少，如vertical设置滑动方向都不支持。\r\n顺便教大家自定义dots(面板指示点)\r\n  <div class=\"swiper-container\">\r\n    <stack>\r\n      <swiper class=\"swiper\" autoplay=\"true\" indicator=\"false\" interval=\"2000\" loop=\"true\" onchange=\"swiperChange\">\r\n        <block for=\"(index, item) in data\">\r\n          <image class=\"wrap-img\" src=\"{{item.image}}\" onclick=\"bindViewTap(item)\" />\r\n        </block>\r\n      </swiper>\r\n      <div class=\"dots\">\r\n        <block for=\"(index, item) in data\">\r\n          <div class=\"dot {{index === swiperCurrent ? 'active' : ''}}\"></div>\r\n        </block>\r\n      </div>\r\n    </stack>\r\n  </div>\r\n  <script>\r\n    export default {\r\n        swiperChange(e) {\r\n            this.swiperCurrent = e.index\r\n        }\r\n    }\r\n  </script>\r\n  利用onchange事件去做修改\r\n复制代码\r\ntabstabs内不能再嵌套tabs，如有此类需求，外部需要div组件模拟选项卡\r\n复制代码\r\nslider\r\n\r\n这个也是一个特别坑爹的组件\r\nslider 组件只有滑动结束后end才有回调，进行中没有回调，改变value值也会触发change事件，无法判断change是人为滑动触发，还是改变数据触发的。官方demo竟然是有时差来区别。\r\n复制代码\r\nweb\r\n\r\n1.web组件使用网页与原生通信时（system.postMessage）。\r\n 当页面发生跳转时，就无法再触发通信，如:\r\n www.xxx.com?id=1跳转到www.xxx.com?id=2\r\n 在华为机型上有更多蜜汁bug.\r\n复制代码\r\nvideo\r\n\r\n    video组件，由于我用到了if渲染后，竟然不能立即调用它的方法，而且还打印是存在的，官方给出答复，可能还没准备就绪。\r\n    this.$forceUpdate()\r\n    /* 使用setTimeout解决蜜汁bug */\r\n    // this.$element(\"video\") && this.$element(\"video\").pause()\r\n    this.$element(\"video\")&&setTimeout(()=>{this.$element(\"video\").pause()},30);\r\n复制代码还有很坑爹的事情，如组件竟然没有onDestroy钩子，据说以后会增加。\r\n接口\r\n\r\n音频接口\r\n\r\n    音频接口特别坑爹。\r\n    1.没有获取当前播放状态的接口，据说1050才会加入。\r\n        audio.ontimeupdate = () => {\r\n          this.isplaying = true\r\n          // 由于快用还没提供获取播放状态的接口,暂时啊这样解决了。\r\n        }\r\n    2.在通知栏中点击关闭音乐触发onpause完之后，ontimeupdate没有立即停止。\r\n        audio.onpause = () => {\r\n          /* 我使用通知栏上的音乐通知栏，直接点击关闭，触发onpause完之后，ontimeupdate没有立即停止，用clearTimeout解决 */\r\n          let globalTime = this.$app.$def.globalTime\r\n          clearTimeout(globalTime)\r\n          globalTime = setTimeout(() => {\r\n            this.isplaying = false\r\n          }, 20)\r\n        }\r\n    3.当页面触发onDestroy，onHide一定要记得销毁不必要的回调。\r\n复制代码\r\n$watch\r\n\r\n此方法尽量避免使用，因为他在1020和1030中是有差异的，在 1030 上的 watcher 的响应确会存在滞后，相比于 1020（牵扯到的代码都是同步逻辑）\r\n复制代码\r\n$forceUpdate()\r\n\r\nthis.$forceUpdate()有点类似与vue的this.$nextTick()，\r\n若开发者期望数据更新时立即执行相应的 DOM 操作，可使用：this.$forceUpdate()；一般不推荐使用\r\n复制代码\r\n被禁用的 new Function，eval\r\n\r\n    eval这些容易注入恶意代码，所以小程序，快应用禁用了。\r\n    其实就是怕你怕你热更新，绕开审核，进行为所欲为的操作。\r\n    但是你确实想用eval，也可以自己实现一个。\r\n    参照-《前端与编译原理——用JS写一个JS解释器》\r\n    https://segmentfault.com/a/1190000017241258"}
{"title": "小程序中富文本解决方案 ", "author": "Rolan", "pub_time": "2018-12-28 00:12", "article_content": "微信小程序提供的 rich-text 在实际工作上根本不能满足我们的需求。正好项目中需要用到这个，就自己查下资料，网上说 wxParse 这个插件可以使用。好的！就决定使用这个了，但是实际情况并没有想象中那么简单。下面是后台返回的数据，也就是需要处理的数据，看到这些数据真的是很无奈，但没办法还得处理。wxParse 这个插件提供的方法也很简单处理简单的数据还是可以的。只好看他的源码了，并且做了修改。不多说了，直接贴代码了这是修改插件 wxParse.js 里面的方法这是请求数据后的处理这是渲染时的处理这是最终的结果"}
{"title": "使用uni-app快速Vue项目输出到小程序和H5 ", "author": "Rolan", "pub_time": "2018-12-28 00:32", "article_content": "跨端彻底，直接发行，无需二次开发；通过Tree-Shaking摇出最小化内置组件等优化策略，提升性能这应该是uni-app在H5平台的相对其他小程序框架更友好的地方背景随着微信小程序的火爆及百度、头条小程序的持续推进，跨端开发的需求愈发迫切，业界随之出现了一系列的跨端框架，但对于H5平台跨端支持的都不太彻底：Vue技术栈的小程序框架：对于H5平台支持普遍较弱部分React技术栈的小程序框架：虽支持生成可在H5端运行的代码，但仅仅是代码可运行，离项目直接发行上线的目标还存在一定差距。鉴于客观需求及现状，DCloud前端团队响应开发者彻底跨端的呼声，经过连续奋战，uni-app1.2版本支持发行到H5平台，完整模拟小程序生命周期、事件处理、组件规范等，真正实现“一套代码、多端发行”的目标。https://uniapp.dcloud.io/h5/ (二维码自动识别)本文主要分享，我们在实现uni-app发行到H5平台时，在引擎实现、差异抹平、性能优化方面都做了哪些工作。完整模拟小程序引擎uni-app设计的开发标准是：Vue.js的语法 + 小程序的API + 条件编译扩展平台个性化能力。其中：Vue.js 的语法在微信小程序端，uni-app是在mpvue的基础上增强实现的，在H5端则默认支持；而小程序的API，其实包括三个部分：框架 + 组件（UI）+ 接口（API），这三部分在微信小程序端是内置支持的，而uni-app若要发布到H5平台，则需完整模拟实现小程序运行时环境。如下是一个简易的小程序运行时框架，核心是一个响应的数据绑定系统。为实现小程序、H5两端的完整跨端，uni-app在H5平台完整模拟实现了小程序的逻辑层和视图层，相比业界其它跨端框架，uni-app在H5平台有如下几点实现更完善。页面配置小程序中的导航条、选项卡是通过配置文件生成的，配置后由原生组件进行渲染，uni-app在H5平台同样兼容这些配置，不过会降级通过div控件模拟实现，因此开发者无需单独为H5平台添加导航条或选项卡。生命周期uni-app在H5平台实现了完整的小程序生命周期，为此填了很多坑。举一个详情页互跳的栗子：详情A 打开 详情B，在通常的 web 端 SPA 方案中，会在详情A页面获取B详情的数据，仅会触发详情页A的updated生命周期，不会触发onHide；但在小程序中，则会打开一个新的webview并加载详情B，此时会触发详情A的onHide生命周期，也会触发详情B的onShow生命周期；uni-app完整模拟了小程序的生命周期，详情页之间互相切换时，会触发onHide、onShow等生命周期；这样的实现，即保证了两端兼容性，同时在详情B返回详情A时，详情A已被缓存，无需再次联网加载，也会有更高的性能。事件处理uni-app对于页面事件处理函数支持更为全面，下拉刷新、上拉触底等常用函数均可在H5平台正常复用，无需二次开发。组件规范uni-appH5平台的组件实现，有两个特点：兼容的组件数量更多：比如navigator等组件在H5平台可正常跳转组件属性、嵌套实现更接近小程序实现抹平引擎差异fixed元素遮挡微信小程序是一种 native + web 混合渲染的机制，比如小程序的导航条（navigationBar）、选项卡（tabBar）为原生组件，但H5平台为纯 web 渲染，导航条、选项卡均为 web 实现，这可能引发页面 fixed 元素 和导航条/选项卡位置发生互相遮挡的问题，如下一段 fixed 定位的代码：.fixed{\r\n    position: fixed;\r\n    z-index: 9999;\r\n    bottom: 0px;//底部距离为0\r\n    background-color:peru;\r\n}\r\n在不同平台上运行效果不同，如下图所示：uni-app通过引入css变量解决这类问题，在编译到不同平台时，给css变量设置对应的值。有了css变量，开发者若需处理 fixed 定位的元素，只需像如下方式编写即可：.fixed{\r\n    bottom:var(--window-bottom)\r\n}\r\ncss作用域uni-app在开发时遵循 Vue 单文件组件 (SFC) 规范，编译到微信小程序时会生成对应的 wxml 文件，最终运行时由 webview 渲染，iOS 平台由 WKWebView 渲染，Android 平台由 XWeb 引擎基于 Mobile Chrome 53 内核渲染；uni-app中的不同.vue页面文件( 编译后的.wxml 文件)，在小程序端会由不同的 webview 渲染，故 .vue页面文件中的 css 作用域是天然隔离的，开发者无需在<style> 标签上增加scoped 属性。但H5平台是一套SPA框架，无scoped就会变成全局样式，影响其他页面。uni-app在H5平台做了智能处理，自动增加了scoped。平台性能优化性能一直是 web app 首要关注的焦点，uni-app发行到H5平台时也做了很多性能优化。内置组件按需打包（Tree-Shaking）uni-app有8大类、几十个内置组件，但开发者实际开发时仅会使用其中的一部分组件，比如很多App不会用到map、canvas等组件，若打包时将uni-app整个组件类库都打包进去，则会造成极大的资源浪费，延迟首页渲染速度。uni-app发行到H5平台时采用了摇树优化（Tree-Shaking）策略，将开发者项目中没用到的组件从整个框架中“摇”掉，保证编译后的 JS 文件最小化。具体来说，uni-app编译到H5平台时分为预编译、再编译两个阶段，预编译阶段通过vue-template-compiler分析出来的AST，映射生成项目中使用到的组件清单，然后再基于Webpack插件将使用到的组件编译生成一个最小化的uni-app框架文件。我们以uni-app的两个开源项目模板登录模板、看图模板为例，测试 Tree-Shaking 前后组件框架的大小，效果喜人，数据如下：路由组件按需加载（Lazy-Loading）当打包构建 SPA 应用时，Javascript 包会变得非常大，影响页面加载。虽然开发者基于Vue 的异步组件和 Webpack 的code-splitting 功能，可以实现路由组件的懒加载，但开发者需调整.vue源码及Webpack配置，有一定的学习门槛，且比较繁琐。uni-app在H5平台实现了自动按需加载路由组件，开发者无需调整组件开发方式，仅需关心业务实现即可。其它方面uni-app为提升性能体验，在很多细节上都有特殊设计。比如常见的 SPA 框架一般采用div区域滚动，uni-app为改善用户体验，使用的是body滚动，由此填了很多坑，比如不同页面的background-color，若使用div滚动，则在编译阶段就可完成样式定义，但基于body滚动，就需要在页面前进、后退时动态设置body的背景色。githubuni-app在H5平台的相关代码均已全部开源，详见uni-app，欢迎大家 star 支持."}
{"title": "微信小程序获得openid免密登录 ", "author": "Rolan", "pub_time": "2018-12-28 00:38", "article_content": "{\r\n  wx.login({\r\n    success: res => {\r\n      let d = {\r\n        appid: 'wx111111111111', // 从微信公众平台开发设置中获取\r\n        secret: 'sec2222222222' // 从微信公众平台开发设置中获取\r\n      };\r\n      // 微信官方的获取openid的接口\r\n      var wxLoginUrl = 'https://api.weixin.qq.com/sns/jscode2session?appid=' + d.appid +'&secret=' \r\n      + d.secret + '&js_code=' + res.code + '&grant_type=authorization_code';\r\n      wx.request({\r\n        url: wxLoginUrl,\r\n        data: {},\r\n        method: 'GET',\r\n        success: res => {\r\n           let openid = res.data.openid;\r\n          this.judgeIsWxlogin(openid); // 向后端发送openid判断是否可以直接用该微信号登陆\r\n        }\r\n      });\r\n    }\r\n  });\r\n}从微信公众平台开发设置中获取appid和secret:"}
{"title": "原生js实现瀑布流及微信小程序中使用左右两列实现瀑布流 ", "author": "Rolan", "pub_time": "2018-12-11 00:46", "article_content": "1.效果图2.原生js实现瀑布流html文件<div id=\"root\">\r\n    <div class=\"item\">\r\n        <div class=\"itemImg\">\r\n            <img src=\"../images/1.jpeg\" alt=\"\" />\r\n        </div>\r\n    </div>\r\n    <div class=\"item\">\r\n        <div class=\"itemImg\">\r\n            <img src=\"../images/3.jpeg\" alt=\"\" />\r\n        </div>\r\n    </div>\r\n    <div class=\"item\">\r\n        <div class=\"itemImg\">\r\n            <img src=\"../images/2.jpg\" alt=\"\" />\r\n        </div>\r\n    </div>\r\n</div>图片可以自己找点替换下就可以了css文件*{\r\n    margin: 0;\r\n    padding: 0;\r\n}\r\n#root{\r\n    position: relative;\r\n}\r\n.item{\r\n    float: left;\r\n    padding: 5px;\r\n}\r\n/* 添加阴影的时候，加上border会显得更加有点悬浮感 */\r\n.itemImg{\r\n    padding: 5px;\r\n    border: 1px solid #ccc;\r\n    box-shadow: 0 0 5px #ccc;\r\n    border-radius: 5px;\r\n}\r\n.itemImg img{\r\n    width: 230px;\r\n    height: auto;\r\n}js文件window.onload = function () {\r\n\r\n    /* 计算图片列数及获取最小高度图片 */\r\n    generateImg('root', 'item');\r\n\r\n    /* 对窗口大小改变进行监听，大小改变则重新布局 */\r\n    window.addEventListener('resize', function() {\r\n        generateImg('root', 'item')\r\n    });\r\n\r\n    /* 图片对象 */\r\n    let imgData = {\r\n        images: [\r\n            {\r\n                \"src\":\"23.png\"\r\n            },\r\n            {\r\n                \"src\":\"22.png\"\r\n            },\r\n            {\r\n                \"src\":\"2.jpg\"\r\n            },\r\n            {\r\n                \"src\":\"4.jpg\"\r\n            },\r\n            {\r\n                \"src\":\"7.jpg\"\r\n            }\r\n        ]\r\n    };\r\n    /* 对滚动监听 */\r\n    window.addEventListener('scroll', function() {\r\n        if(checkIsScroll()) {\r\n            let rootElement = document.getElementById('root');\r\n            /* 利用documentFragment来创建 */\r\n//                    let documentFragment = document.createDocumentFragment();\r\n            let length = imgData.images.length;\r\n\r\n            /* 循环创建图片组 */\r\n            for(let i = 0; i < length; i++) {\r\n                let itemElement = document.createElement('div');\r\n                itemElement.className = 'item';\r\n                rootElement.appendChild(itemElement);\r\n                let itemImgElement = document.createElement('div');\r\n                itemImgElement.className = 'itemImg';\r\n                itemElement.appendChild(itemImgElement);\r\n                let itemImg = document.createElement('img');\r\n                itemImg.style.cssText = 'opacity: 0; transform:scale(0)';\r\n                itemImg.src = \"../images/\" + imgData.images[i].src;\r\n                itemImgElement.appendChild(itemImg);\r\n//                        documentFragment.appendChild(itemElement);\r\n\r\n                /* 在1秒后让图片显示出来 */\r\n                (function(img){\r\n                    setTimeout(function(){\r\n                        img.style.cssText=\"opacity:1;transform:scale(1)\";\r\n                    },1000);\r\n                })(itemImg);\r\n            }\r\n//                    rootElement.appendChild(documentFragment);\r\n            generateImg('root', 'item');\r\n        }\r\n    });\r\n};\r\n\r\n/* 计算图片列数及获取最小高度图片 */\r\nfunction generateImg(parent, content) {\r\n    /* 获取父元素及其所以节点内容 */\r\n    let parentElement = document.getElementById(parent);\r\n    let childContent = getChildElement(parentElement, content);\r\n\r\n    /* 获取图片宽度 */\r\n    let imgWidth = childContent[0].offsetWidth;\r\n    /* 获取一行图片形成的列数 */\r\n    let imgColumn = Math.floor(document.documentElement.clientWidth / imgWidth);\r\n    /* 重新设置父级容器的宽度 */\r\n    parentElement.style.cssText = 'width:' + imgColumn * imgWidth + 'px;margin:0 auto';\r\n\r\n    /* 存储每个图片的高度，以此来找到最小图片高 */\r\n    let imgHeightArray = [];\r\n    let length = childContent.length;\r\n    for(let i = 0; i < length; i++) {\r\n        /* i<imgColumn统计每一行的图片高度 */\r\n        if(i < imgColumn) {\r\n            /* 防止用户改变窗口大小时，内容样式错乱 */\r\n            childContent[i].style.cssText = '';\r\n            imgHeightArray.push(childContent[i].offsetHeight);\r\n        } else {\r\n            /* 如果不是这一行的，则找到最小值和最小值的索引值 */\r\n            let minHeight = getMinImgHeight(imgHeightArray);\r\n            let minHeightIndex = getMinHeightIndex(imgHeightArray, minHeight);\r\n            /* 对这个图片设置位置 */\r\n            childContent[i].style.position = 'absolute';\r\n            childContent[i].style.top = minHeight + 'px';\r\n            childContent[i].style.left = childContent[minHeightIndex].offsetLeft + 'px';\r\n            /* 更换此时的最小高度 */\r\n            imgHeightArray[minHeightIndex] = childContent[i].offsetHeight + minHeight;\r\n        }\r\n    }\r\n}\r\n\r\n/* 检测滚动是否达到了可视区 */\r\nfunction checkIsScroll() {\r\n    /* 获取root根节点 */\r\n    let parentElement = document.getElementById('root');\r\n    /* 获取父元素下的类名为box的元素节点 */\r\n    let childContent = getChildElement(parentElement, 'item');\r\n\r\n    /* 获取最后一个元素的高度 */\r\n    let lastElementHeight = childContent[childContent.length - 1].offsetTop;\r\n    /* 获取滚动的距离 */\r\n    let scrollTopSpace = document.documentElement.scrollTop || document.body.scrollTop;\r\n    /* 获取可视区的距离 */\r\n    let clientHeight = document.documentElement.clientHeight || document.body.clientHeight;\r\n\r\n    if(lastElementHeight > scrollTopSpace + clientHeight) {\r\n        return true;\r\n    }\r\n}\r\n/* 获取子节点的所有内容 */\r\nfunction getChildElement(parentElement, content) {\r\n    /* 存储元素信息 */\r\n    let elementArray = [];\r\n    /* 获取父元素下的所有节点信息 */\r\n    let allElement = parentElement.getElementsByTagName('*');\r\n    let length = allElement.length;\r\n    for (let i = 0; i < length; i++) {\r\n        /* 找到对应的类名 */\r\n        if (allElement[i].className === content) {\r\n            elementArray.push(allElement[i]);\r\n        }\r\n    }\r\n    return elementArray;\r\n}\r\n\r\n/* 获取图片最小高度 */\r\nfunction getMinImgHeight(heightArray) {\r\n    let length = heightArray.length;\r\n    let minHeight = heightArray[0];\r\n    for(let i = 0; i < length; i++) {\r\n        minHeight = Math.min(minHeight, heightArray[i]);\r\n    }\r\n    return minHeight;\r\n}\r\n\r\n/* 获取图片最小高度的索引值 */\r\nfunction getMinHeightIndex(heightArray, minHeight) {\r\n    let length = heightArray.length;\r\n    for(let i = 0; i < length; i++) {\r\n        if(heightArray[i] == minHeight) {\r\n            return i;\r\n        }\r\n    }\r\n}3.微信小程序中实现瀑布流效果图wxml文件<view class=\"cateCommodity\">\r\n  <view class=\"leftContainer\">\r\n    <block wx:for=\"{{imageArray}}\" wx:key=\"{{item.id}}\">\r\n      <view class=\"cateItem\" wx:if=\"{{index%2==0}}\">\r\n        <view class=\"item\">\r\n          <image src=\"{{item.src}}\" class=\"itemImg\" mode=\"widthFix\"></image>\r\n          <view class=\"title\">{{item.title}}</view>\r\n        </view>\r\n      </view>\r\n    </block>\r\n  </view>\r\n  <view class=\"rightContainer\">\r\n    <block wx:for=\"{{imageArray}}\" wx:key=\"{{item.id}}\">\r\n      <view class=\"cateItem\" wx:if=\"{{index%2==1}}\">\r\n        <view class=\"item\">\r\n          <image src=\"{{item.src}}\" class=\"itemImg\" mode=\"widthFix\"></image>\r\n          <view class=\"title\">{{item.title}}</view>\r\n        </view>\r\n      </view>\r\n    </block>\r\n  </view>\r\n</view>\r\n<view class=\"skipTop\" catchtap=\"skipTop\" wx:if=\"{{showTopImage}}\">\r\n  <image src=\"http://boweisou.oss-cn-shenzhen.aliyuncs.com/images/0/2018/11/ZBtqujbbcGjBDgjt0bbJqbTuGqq0z8.png\"></image>\r\n</view>wxss文件page{\r\n  background: #f6f6f6;\r\n}\r\n/* 最外层 */\r\n.cateCommodity {\r\n  display: flex;\r\n  padding: 20rpx 28rpx 8rpx;\r\n  box-sizing: border-box;\r\n  font-size: 28rpx;\r\n}\r\n/* 左右两个容器 */\r\n.leftContainer{\r\n  display: flex;\r\n  margin-right: 22rpx;\r\n  flex-direction: column;\r\n}\r\n.rightContainer{\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n/* 图片容器 */\r\n.cateItem {\r\n  margin-bottom: 20rpx;\r\n}\r\n.item{\r\n  padding: 20rpx 22rpx;\r\n  width: 335rpx;\r\n  box-sizing: border-box;\r\n  background: #fff;\r\n  border-radius: 6rpx;\r\n}\r\n.itemImg{\r\n  margin-bottom: 14rpx;\r\n  width: 100%;\r\n  vertical-align: middle;\r\n  border-radius: 6rpx;\r\n}\r\n.title{\r\n  display: -webkit-box;\r\n  overflow: hidden;\r\n  -webkit-line-clamp: 2;\r\n  -webkit-box-orient: vertical;\r\n  line-height: 1.5;\r\n}\r\n/* 返回顶部 */\r\n.skipTop {\r\n  position: fixed;\r\n  bottom: 30rpx;\r\n  right: 20rpx;\r\n  width: 90rpx;\r\n  height: 90rpx;\r\n}\r\n\r\n.skipTop image {\r\n  width: 100%;\r\n  height: 100%;\r\n  vertical-align: middle;\r\n}js文件Page({\r\n  data: {\r\n    imageArray: [\r\n      {\r\n        id: 1,\r\n        src: '../../images/avatar.jpeg',\r\n        title: '现代新中式创意陶瓷简约摆件客厅家居玄关软装饰品家居酒柜盘子'\r\n      },\r\n      {\r\n        id: 1,\r\n        src: '../../images/avatar3.jpg',\r\n        title: '秋冬季新款2018休闲运动服套装女士韩版金丝绒卫衣加绒加厚两件套'\r\n      },\r\n      {\r\n        id: 1,\r\n        src: '../../images/avatar4.jpeg',\r\n        title: '女童床上用品四件套公主房1.2m床品纯棉女孩1.8儿童床单三件套1.5'\r\n      },\r\n      {\r\n        id: 1,\r\n        src: '../../images/avatar7.jpg',\r\n        title: '婴儿床圆床蚊帐落地款宝宝椭圆床蚊帐支架款儿童床蚊帐BB床小蚊帐'\r\n      },\r\n      {\r\n        id: 1,\r\n        src: '../../images/avatar9.jpeg',\r\n        title: '包邮动感158T速滑鞋轮滑鞋竞速鞋高端碳纤鞋 固定码 专业定制'\r\n      },\r\n      {\r\n        id: 1,\r\n        src: '../../images/logo7.jpg',\r\n        title: 'Infanton落地婴儿床蚊帐带支架儿童床蚊帐宝宝蚊帐婴童蚊帐'\r\n      },\r\n      {\r\n        id: 1,\r\n        src: '../../images/logo6.jpg',\r\n        title: '老A轮滑 米高seba hl碳纤版SEBA HL CARBON 平花鞋刹车鞋全能鞋'\r\n      },\r\n      {\r\n        id: 1,\r\n        src: '../../images/logo.jpeg',\r\n        title: '洋洋法代 sandro 17秋冬 一粒扣羊毛长款大衣外套EKIN M9575H'\r\n      },\r\n    ],\r\n    showTopImage: false,\r\n  },\r\n  onPageScroll(event) {\r\n    /* 利用两个条件，防止重复的进行setData操作 */\r\n    if (event.scrollTop > 300 && this.data.showTopImage == false) {\r\n      this.setData({\r\n        showTopImage: true\r\n      })\r\n    } else if (event.scrollTop < 300 && this.data.showTopImage == true) {\r\n      this.setData({\r\n        showTopImage: false\r\n      })\r\n    }\r\n  },\r\n  skipTop() {\r\n    /* 返回顶部 */\r\n    wx.pageScrollTo({\r\n      scrollTop: 0,\r\n      duration: 300\r\n    });\r\n    this.setData({\r\n      showTopImage: false\r\n    });\r\n  },\r\n  onReachBottom: function () {\r\n    let temporaryArray = this.data.imageArray;\r\n    temporaryArray.push(...this.data.imageArray);\r\n    this.setData({\r\n      imageArray: temporaryArray\r\n    })\r\n  },\r\n})左右两列实现瀑布流其实就是对同一数组进行了两次渲染，只是把其中的一半给隐藏了正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断iOS和Android及PC端纯css实现瀑布流（multi-column多列及flex布局）实现单行及多行文字超出后加省略号微信小程序之购物车和父子组件传值及calc的注意事项"}
{"title": "前端错误收集（Vue.js、微信小程序） ", "author": "Rolan", "pub_time": "2018-12-12 00:14", "article_content": "随着公司业务的发展，前端项目也越来越多。有的时候客户反馈的一个问题，需要耗费大量的时间去查。错误信息不能第一时间获取，多少会给公司带来损失。这个时候我们就需要一套错误收集机制，去提前发现代码中存在的问题，在客户反馈之前把问题提前处理掉。或者在收到客户反馈的时候可以查到对应的错误栈来帮助我们快速去定位以及解决问题。下面主要介绍vue和微信小程序错误收集的方法。错误收集方法Vue错误收集Vue提供了一个全局配置errorHandler，用于收集Vue运行时发生的错误。 详细介绍api cn.vuejs.org/v2/api/#err…用法：Vue.config.errorHandler = function (err, vm, info) {\r\n  // handle error\r\n  //`err`是js错误栈信息，可以获取到具体的js报错位置。\r\n  //`vm` vue实例\r\n  //`info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子\r\n  // 只在 2.2.0+ 可用\r\n}\r\n复制代码当然拿到vue对应的实例之后，我们就可以轻松获取到vue对应的组件名称以及自定义属性等等（此处可自由发挥）。以下是获取组件名称的方法：（来源：fundebug）function formatComponentName(vm) {\r\n    if (vm.$root === vm) return 'root';\r\n    var name = vm._isVue\r\n        ? (vm.$options && vm.$options.name) ||\r\n        (vm.$options && vm.$options._componentTag)\r\n        : vm.name;\r\n    return (\r\n        (name ? 'component <' + name + '>' : 'anonymous component') +\r\n        (vm._isVue && vm.$options && vm.$options.__file\r\n            ? ' at ' + (vm.$options && vm.$options.__file)\r\n            : '')\r\n    );\r\n}\r\n复制代码这个时候我们代码就可以改写成这样：Vue.config.errorHandler = function(err, vm, info) {\r\n    if (vm) {\r\n        var componentName = formatComponentName(vm);\r\n        //调用错误日志收集接口\r\n    } else {\r\n        //调用错误日志收集接口\r\n    }\r\n};\r\n复制代码知道了怎么收集错误信息，接下来只需要简单的包装一下就可以应用到项目中去了。（当然你还需要一个保存错误信息的接口和展示错误信息的界面，网上也有一些成熟的日志处理框架，类似：ELK）新建一个文件 debug.jslet debugConfig = {\r\n    Vue: null,\r\n    //项目名称\r\n    entryName: 'entryName',\r\n    //脚本版本\r\n    scriptVersion: '1.0',\r\n    // 环境\r\n    releaseStage: 'pro'\r\n},\r\ndebug = {\r\n    notifyWarn({ message, metaData }) {\r\n        let type = 'caught',\r\n            severity = 'warn';\r\n        \r\n        _logReport({ type, severity, message, metaData });\r\n    },\r\n    notifyError({ type = 'caught', error, message, metaData, lineNumber, columnNumber, fileName }){\r\n        let severity = 'error';\r\n\r\n        _logReport({ type, severity, error, metaData, message, lineNumber, columnNumber, fileName });\r\n    }\r\n};\r\n\r\n// 日志上报\r\nfunction _logReport({ type, severity, error, metaData, message, lineNumber, columnNumber, fileName }) {\r\n\r\n    let { silentDev, Vue } = debugConfig;\r\n\r\n    message = message || error && error.message || '';\r\n\r\n    //这里可以做一个灰度控制\r\n\r\n    let { entryName, releaseStage, severity, scriptVersion } = debugConfig,\r\n        name = error && error.name || 'error',\r\n        stacktrace = error && error.stack || '',\r\n        time = Date.now(),\r\n        title = document.title,\r\n        url = window.location.href,\r\n        client = {\r\n            userAgent: window.navigator.userAgent,\r\n            height: window.screen.height,\r\n            width: window.screen.width,\r\n            referrer: window.document.referrer\r\n        },\r\n        pageLevel = 'p4';\r\n\r\n    //此处可以给你的页面进行分级\r\n    pageLevel = 'p0';//getPageLevel();\r\n\r\n    //此处http请求使用的是vue-resource，可以根据各自的情况进行调整\r\n    Vue.http.post(logReportUrl, {\r\n        entryName,\r\n        scriptVersion,\r\n        message,\r\n        metaData,\r\n        name,\r\n        releaseStage,\r\n        severity,\r\n        stacktrace,\r\n        time,\r\n        title,\r\n        type,\r\n        url,\r\n        client,\r\n        lineNumber,\r\n        columnNumber,\r\n        fileName,\r\n        pageLevel//页面等级\r\n    });\r\n\r\n}\r\n\r\nexport default function(Vue, option = {}){\r\n\r\n    debugConfig = Object.assign(debugConfig, { Vue, ...option });\r\n    \r\n    //如果你想在开发环境不去捕获错误信息 可以在此处加上环境判断\r\n\r\n    function formatComponentName(vm) {\r\n        if (vm.$root === vm) return 'root';\r\n        let name = vm._isVue\r\n            ? (vm.$options && vm.$options.name) ||\r\n            (vm.$options && vm.$options._componentTag)\r\n            : vm.name;\r\n        return (\r\n            (name ? 'component <' + name + '>' : 'anonymous component') +\r\n            (vm._isVue && vm.$options && vm.$options.__file\r\n                ? ' at ' + (vm.$options && vm.$options.__file)\r\n                : '')\r\n        );\r\n    }\r\n\r\n    Vue.config.errorHandler = function(err, vm, info) {\r\n        if (vm) {\r\n            let componentName = formatComponentName(vm);\r\n            let propsData = vm.$options && vm.$options.propsData;\r\n            debug.notifyError({\r\n                error: err,\r\n                metaData: {\r\n                    componentName,\r\n                    propsData,\r\n                    info,\r\n                    userToken: { userId: 1 }//metaData可以存一些额外数据，比如：用户信息等\r\n                }\r\n            });\r\n        } else {\r\n            debug.notifyError({\r\n                error: err,\r\n                metaData: {\r\n                    userToken: { userId: 1 }//metaData可以存一些额外数据，比如：用户信息等\r\n                }\r\n            });\r\n        }\r\n    };\r\n    \r\n    window.onerror = function(msg, url, lineNo, columnNo, error) {\r\n        debug.notifyError({\r\n            type: 'uncaught', \r\n            error, \r\n            metaData: {\r\n                userToken: { userId: 1 }//metaData可以存一些额外数据，比如：用户信息等\r\n            }, \r\n            message: msg, \r\n            lineNumber: lineNo, \r\n            columnNumber: columnNo, \r\n            fileName: url\r\n        });\r\n    }\r\n\r\n}\r\n\r\n//最后我们把debug抛到外面供其他地方调用\r\nexport { debug }\r\n复制代码当然你还可以捕获Promise、网络请求、图片等异常。此处推荐一篇比较全的文章，大家可自行去查看 juejin.im/post/5bd2db…初始化：//错误日志收集\r\nimport debug from './debug';\r\n//初始化错误处理\r\nVue.use(ngmmdebug, { entryName: 'webmall' });\r\n复制代码如果你想自己上报错误可以通过：import { debug } from './debug';\r\ndebug.notifyError({ messag: '发生错误了' });\r\n复制代码微信小程序错误收集微信小程序收集错误信息也是比较方便的，只需要在调用App函数时传入的对象中实现onError方法即可。文档地址： developers.weixin.qq.com/miniprogram…用法：App({\r\n  onError (msg) {\r\n    console.log(msg);//msg就是报错信息\r\n  }\r\n})\r\n复制代码如果你想让代码移植性更高一点可以通过这样做：//将App暂存起来\r\nlet _App = App;\r\n\r\nfunction HookParams(_appParams, eventName, eventFn) {\r\n  if (_appParams[eventName]) {\r\n    let _eventFn = _appParams[eventName];\r\n    //如果参数中已经存在onError函数，则保留并且添加错误收集\r\n    _appParams[eventName] = function (error) {\r\n      eventFn.call(this, error, eventName);\r\n      return _eventFn.call.apply(_eventFn, [this].concat(Array.prototype.slice.call(arguments)))\r\n    }\r\n  } else {\r\n    //如果参数中不存在onError函数，那比较简单直接定义一个，并且加入错误收集\r\n    _appParams[eventName] = function (error) {\r\n      eventFn.call(this, error, eventName)\r\n    }\r\n  }\r\n}\r\n\r\nfunction onErrorFn(error, eventName) {\r\n  //收集错误\r\n}\r\n\r\nApp = function (_appParams) {\r\n  HookParams(_appParams, \"onError\", onErrorFn);\r\n  _App(_appParams);\r\n};\r\n复制代码原理其实很简单，通过改写App函数，再通过Hook的手段来处理传入的参数即可。同样，我们现在已经知道了如何收集错误，接下来只需要简单包装一下 我们的代码即可。新建一个文件 debug.jsfunction HookParams(_appParams, eventName, eventFn) {\r\n  if (_appParams[eventName]) {\r\n    let _eventFn = _appParams[eventName];\r\n    _appParams[eventName] = function (error) {\r\n      eventFn.call(this, error, eventName);\r\n      return _eventFn.call.apply(_eventFn, [this].concat(Array.prototype.slice.call(arguments)))\r\n    }\r\n  } else {\r\n    _appParams[eventName] = function (error) {\r\n      eventFn.call(this, error, eventName)\r\n    }\r\n  }\r\n}\r\n\r\nfunction objToParam(options = {}) {\r\n    let params = '';\r\n    for (let key in options) {\r\n        params += '&' + key + '=' + options[key];\r\n    }\r\n    return params.substring(1);\r\n}\r\n\r\nfunction onErrorFn(error, eventName) {\r\n    _logReport(error);\r\n}\r\n\r\n// 将App暂存起来\r\nlet _App = App;\r\n\r\nApp = function (_appParams) {\r\n  HookParams(_appParams, \"onError\", onErrorFn);\r\n  _App(_appParams);\r\n};\r\n\r\n//config\r\nlet debugConfig = {\r\n  entryName: 'entryName',\r\n  releaseStage: 'pro',\r\n  scriptVersion: '1.0',\r\n  client: {}\r\n}\r\n\r\n//获取设备信息\r\nwx.getSystemInfo({\r\n  success: function (res) {\r\n    debugConfig.client = res;\r\n  }\r\n});\r\n\r\n//拼装postData\r\nfunction getPostData(error = '') {\r\n  let {\r\n    entryName,\r\n    releaseStage,\r\n    scriptVersion,\r\n    client\r\n  } = debugConfig,\r\n  curPage = getCurrentPages()[getCurrentPages().length - 1],\r\n    url = '',\r\n    urlParams = '',\r\n    name = 'error',\r\n    postData = \"postData\",\r\n    metaData = {},\r\n    pageLevel = 'p0';\r\n\r\n  //处理url\r\n  if (curPage) {\r\n    url = curPage.route;\r\n\r\n    //此处自己根据实际项目给页面定级\r\n    pageLevel = 'p0'; //getPageLevel(url);\r\n\r\n    urlParams = objToParam(curPage.options);\r\n    if (urlParams) {\r\n      url += '?' + urlParams;\r\n    }\r\n  }\r\n\r\n  name = error.split('\\n')[0] || 'error';\r\n  metaData = {\r\n    userToken: getHeaders()\r\n  }\r\n\r\n  try {\r\n    postData = {\r\n      data: JSON.stringify({\r\n        entryName,\r\n        type: 'caught',\r\n        scriptVersion,\r\n        releaseStage,\r\n        name,\r\n        stacktrace: error,\r\n        time: Date.now(),\r\n        client,\r\n        url,\r\n        metaData,\r\n        pageLevel,\r\n        serviceLevel\r\n      })\r\n    };\r\n  } catch (e) {\r\n    console.error(e);\r\n  }\r\n\r\n  return postData;\r\n}\r\n\r\n//控制错误的发送\r\nfunction _logReport(error) {\r\n    //灰度控制自行加\r\n    wx.request({\r\n        header: {\r\n        'content-type': 'application/x-www-form-urlencoded'\r\n        },\r\n        method: 'POST',\r\n        url: logReportUrl,\r\n        data: getPostData(error)\r\n    });\r\n}\r\n\r\nlet debug = {\r\n  init(option = {}) {\r\n    debugConfig = Object.assign({}, debugConfig, option);\r\n  },\r\n  notifyError(error) {\r\n    _logReport(error)\r\n  }\r\n}\r\n\r\nmodule.exports = debug;\r\n复制代码修改app.js：import ngmmdebug from './utils/ngmmdebug.js';\r\n//初始化\r\nngmmdebug.init({\r\n  entryName: 'mall-wxapp',\r\n  scriptVersion: '2.6.3'\r\n})\r\n复制代码手动上报错误import ngmmdebug from './utils/ngmmdebug.js';\r\nngmmdebug.notifyError('发生错误了～');\r\n复制代码小程序有几个比较特别的点可以看一下：1、通过 wx.getSystemInfo 获取设备信息，当然你还可以通过 wx.getUserInfo 获取用户信息等。2、小程序完整的链接需要通过页面options属性自行组装。参考收集字段参考{\r\n    \"entryName\":\"项目名称\",\r\n    \"scriptVersion\":\"1.0\",//脚本版本\r\n    \"message\":\"aler is not defined\",//错误描述\r\n    \"metaData\":{//自定义字段\r\n        \"componentName\":\"anonymous component at /Users/taoxinhua/git/webmall/src/components/app.vue\",//组件名称\r\n        \"info\":\"created hook\",//vue报错信息\r\n        \"userToken\":{//用户登录信息\r\n            \"user_id\": 1\r\n        }\r\n    },\r\n    \"name\":\"ReferenceError\",//错误名称\r\n    \"releaseStage\":\"local\",//报错环境pre|beta|local\r\n    \"stacktrace\":\"ReferenceError: aler is not defined\r\nat VueComponent.created (webpack-internal:///370:32:9)\r\nat callHook (webpack-internal:///1:2666:21)\r\nat VueComponent.Vue._init (webpack-internal:///1:4227:5)\r\nat new VueComponent (webpack-internal:///1:4397:12)\r\nat createComponentInstanceForVnode (webpack-internal:///1:3679:10)\r\nat init (webpack-internal:///1:3496:45)\r\nat createComponent (webpack-internal:///1:5148:9)\r\nat createElm (webpack-internal:///1:5091:9)\r\nat Vue$3.patch [as __patch__] (webpack-internal:///1:5607:9)\r\nat Vue$3.Vue._update (webpack-internal:///1:2415:19)\",//错误栈\r\n    \"time\":1544437068009,//发生错误时的客户端时间\r\n    \"title\":\"年糕妈妈优选\",//页面标题\r\n    \"type\":\"caught\",//错误类型参考fundebug\r\n    \"url\":\"http://localhost:3200/test\",//页面地址\r\n    \"client\":{//客户端信息\r\n        \"userAgent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36\",\r\n        \"height\":800,\r\n        \"width\":1280,\r\n        \"referrer\":\"http://localhost:3200/test\"\r\n    },\r\n    \"pageLevel\":\"p4\"//页面错误级别，方便查询和优先处理重要页面的bug\r\n}\r\n复制代码"}
{"title": "百度小程序遇到的那些“坑” ", "author": "Rolan", "pub_time": "2018-12-12 00:48", "article_content": "2018 年 5 月，受百度邀请，苏宁首批入驻百度小程序平台。作为微信小程序的开发工程师，我接手了“开荒”百度智能小程序（以下简称百度小程序）的任务，自 5 月初开发，一个多月就完成了苏宁易购百度小程序的开发工作，并在 7 月初的“百度开发者大会”上作为首批小程序对外提供服务。从 5 月至今，作为百度小程序的主力开发，总结了以下的一些开发经验。百度小程序的初探入驻百度小程序百度小程序的入驻方式，与微信小程序几乎相同，准备一个百度账号，登录百度智能小程序后台，选择入驻申请，选择适合的类型，填写表单信息，提交审核，一般 24 小时内可以审核通过。当然，如果有百度小程序的邀请码，也可以走邀请码通道进行入驻。这里特别需要注意的是，目前仅面向企业、政府、媒体及其它组织等非个人主体开放申请，个人用户是没有办法入驻的。入驻完成后，进入平台，可以看到自己的小程序。开发前的准备用注册得到的管理员账号登录后台，在成员管理设置项目组成员的权限, 百度小程序的用户权限主要分为：开发者权限、开发管理、开发设置、暂停服务设置、推广设置、流量主、数据统计、小程序简介、小程序头像。在设置 - 开发设置，获取小程序的 AppID、AppKey 和 AppSecret，并设置服务器域名、业务域名和代理域名（小程序 web 化使用）。在设置 - 基础设置设置小程序名称、头像和简介等信息。开发者工具在从百度小程序官网点击文档 - 开发 - 左侧导航栏工具 - 界面下载开发者工具，开发者工具启动后，有和微信开发者工具差不多的界面，不同的地方如下：百度小程序没有集成类似于微信小程序 Tgit、腾讯云，云开发平台等功能。开发者需要在自备代码管理工具，服务端所需要的服务器等资源。百度小程序 IDE 目前的新建功能只支持新建一个 DEMO，开发者需要在这个基础上进行修改来得到自己的项目，或者使用搬家具将微信小程序转换为百度小程序，不能从头开始新建。微信小程序的新建功能是从输入 appID 开始的，百度的 appid 只能在建好项目后手动的修改。百度小程序 IDE 不需要独立设置代理。微信小程序 IDE 需要单独配置代理，在复杂网络环境下可能会出现内外网不能同时访问的情况，但是百度小程序不需要设置单独代理。开发文档百度小程序有丰富的文档，详细的介绍了从申请入驻到小程序发布、从组件到 API 的百度小程序的方方面面，大家可以自行到官网上去阅读。前端开发者眼中的百度小程序因为同时开发百度小程序和微信小程序，我将对比微信小程序，讲述百度小程序开发过程中遇到的一些问题。组件和 API 几乎和微信相同，框架上分为逻辑层、视图层、自定义组件和基础能力，也支持分包加载等能力。百度小程序的组件也分为视图组件、基础组件、表单组件、导航组件、媒体组件、地图组件、画布组件和开放能力相关组件。在 API 方面，百度小程序也分为网络、媒体、文件、数据存储、位置、界面（包含绘图）、设备和开放接口等大类。以下是我们发现的一些百度小程序与微信小程序的不同。组件的不同百度小程序的列表渲染和微信不一致：<view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">{{idx}}: {{itemName.message}}</view>// 也可以简写为<view wx:for=\"{{array}}\">{{index}}: {{item.message}}</view>百度小程序的列表渲染：<view><view s-for=\"p in persons\">{{p.name}}</view></view>百度小程序的判断和循环不能再同一个组件上。例如微信小程序可以这么写：<view wx:for=\"{{array}}\" wx:if=\"{{item.isWx}}\">{{index}}: {{item.message}}</view>// 或者这样子<view wx:for=\"{{array}}\" wx:if=\"{{isWx}}\">{{index}}: {{item.message}}</view>而百度小程序则必须写成这边这个样子：<view s-for=\"(index,item) in array\"><block s-if=\"item.isBd\">{{index}}: {{item.message}}</block></view>// 或者这样子<block s-if=\"isBd\"><view s-for=\"p in persons\">{{p.name}}</view></block>API 的不同百度小程序提供了 AI 的能力，可以实现文字识别、文本审核、语音合成、图像审核、图像识别和语音识别功能。Swan.request 能力。request 的问题主要体现在对单引号, 以及 URL 的汉字的兼容上. 百度小程序 request 能力并未对请求 UR 中的汉字做 encodeURIComponent 处理, 导致手百客户端发送请求直接失败，这边建议开发者自己对 get 请求的入参做 encodeURIComponent 处理. 单引号的问题也是这样, 具体表现出来, 请求发送出去之后, 通过抓包可以看到请求正常的发送了, 也正常返回了, 但是小程序既不会走进 success 分支, 也不会进入 error 分支, 报错也不能被 catch, 这个问题后期百度官方已经修复了。分包体积限制不同微信小程序目前的限制规则是，每个包不超过 2M ，总包不超过 8M，而百度小程序目前的限制规则是主包不得超过 4M，每个分包不得超过 2M，总包不得超过 8M，这个规则和目前微信程序的限制规则差别较大，在方便了开发者的同时，可能会在性能方便有所损耗。在 CSS 和 JS 处理的上的细微差异百度小程序不支持 css 的 > 选择器, 建议样式直接使用 class 选择器。百度小程序支持的长度单位是 CSS3 的 vw，当然也支持微信小程序的 rpx。使用伪元素实现的 0.5px 边框在百度小程序下会有异常，建议不要使用这种方法。百度小程序不支持类似于微信小程序 WXS 的写法。百度小程序没有提供类似于微信小程序 WXS 的写法, 但是提供了 Filter 过滤器。Filer 代码可以编写在 swan 文件中的标签内，或以 .filter.js 为后缀名的文件内。登录方式的区别因为微信客户端是强制要求用户登录的，但是手百不需要，所以在联合登录时，针对此场景，百度小程序需要作出特别的开发。在百度小程序联合登录前，需要使用 swan.isloginsync api 进行手百客户端的登录状态判断，手百没有登录的，不能使用联合登录，所以建议开发者还需要准备一套独立账号登录体系。支付方式的区别微信小程序使用的是微信支付，而百度小程序使用的是百度聚合收银台，在接入流程和开发流程上都和微信小程序不一样，当然百度小程序官方也贴心的提供了微信直联和支付宝直联的能力，大家可以根据自己的需要选用适合自己的付款方式。打包方式及发布的区别百度小程序点击预览按钮生成的开发版小程序是可以给其他用户扫码查看的，并未像微信一样严格要求开发者权限才能打开开发版小程序，也没有体验者这一角色，这一点对于测试同学来说还是很方便的。百度小程序 IDE 提供了两种编译模式: 依赖分析、普通编译。 依赖分析模式 : 无用文件不会被打包到产出中，支持 node_modules 的使用 ; 普通编译模式 : 不支持 node_modues 的使用，打包全部文件。PhoneX 等机型样式适配目前微信小程序并没有提供对 iphoneX，iphoneXS 等机型底部 bar 的适配，但是百度小程序提供了这样一个适配方案。.swan-security-padding-bottom {padding-bottom:34px; }.swan-security-margin-bottom {margin-bottom: 34px;}.swan-security-fixed-bottom {bottom: 34px;}该组样式会自动在需要适配安全区的场景动态注入，开发者不需要自行添加，只要在.swan 文件中使用这组类名即可。效果如下图所示：如果你之前有开发微信小程序开发，百度小程序提供了一个搬家工具。 搬家工具，是基于 Abstract Syntax Tree 开发的辅助工具，可以帮助您把微信小程序的部分代码迁移到百度智能小程序上。工具可进行静态语法上的转换，根据一些规则去转换代码，抹平微信小程序语法和百度智能小程序语法上的差异，为大家减少因平台差异带来的苦恼。需要注意的是：工具做不到运行时 diff 的抹平，也做不到一个 API 从无到有的过程。所以，需要大家根据转换 log，进行二次开发。网络的虚拟性导致信任关系难以建立，交易决策困难。对于小程序这种轻便、易传播的特性，如何让用户能够更容易的决策，并且给用户适合他的商品。这无疑是十分重要的一环，而与百度合作的手百小程序中，百度的基于用户操作行为的大数据商品推荐系统可以处理信任评估中的主观因素，提高交易预测的准确性。基于双方协同过滤的思想建立一个模糊信誉管理系统，突出对商品信息的处理与个性化推荐。上线以来，百度推荐模块的数据对比于原有苏宁内部的推荐来看，更贴合于用户在基于百度强大的搜索端的行为数据。对垂直行业的定制化推荐，满足不同行业的需求，让我们看到了百度推荐的智能化、专业化。以上是我在苏宁开发百度小程序的一些经验，各公司也可以尝试一下，百度小程序也在不断的迭代中，每一次迭代都能感觉到进步，感觉百度小程序开发组的同学，远程帮我们解决了很多问题，特别感谢百度方的李嘉辉来苏宁驻场提供技术支持，没有你我们的开发之路不会这么顺利，以及百度的 QA 同学，对我们小程序提出宝贵的建议。"}
{"title": "小程序白屏问题和内存研究 ", "author": "Rolan", "pub_time": "2018-12-13 00:08", "article_content": "在开发小程序应用中，QA发现过几次页面白屏的情况，苦于难易复现和调试，故想对小程序白屏问题进行一番探究。从小程序官方开发者文档得知，微信小程序运行在三端：iOS（iPhone/iPad）、Android和用于调试的开发者工具。三端的脚本执行环境以及用于渲染非原生组件的环境是各不相同的[1]：在 iOS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中，视图层是由 WKWebView 来渲染的，环境有 iOS8、iOS9、iOS10；在 Android 上，旧版本，小程序逻辑层的 javascript 代码运行中 X5 JSCore 中，视图层是由 X5 基于 Mobile Chrome 53/57 内核来渲染的；新版本，小程序逻辑层的 javascript 代码运行在 V8 中，视图层是由自研 XWeb 引擎基于 Mobile Chrome 53 内核来渲染的；在 开发工具上，小程序逻辑层的 javascript 代码是运行在 NW.js 中，视图层是由 Chromium 60 Webview 来渲染的。下面说说WKWebView、Mobile Chrome 53/57、Mobile Chrome 53是什么。在Apple公司的开发者文档网站上，有对WKWebView进行介绍，简单来说，WKWebView是一个为app内置浏览器渲染交互式网页内容的组件，用于替换老版本的UIWebView组件[2]。不管是UIWebView，还是WKWebView，它们都属于IOS WebView。我们可以把WebView理解为手机操作系统的一个系统级的组件。不管是手机内置的浏览器，还是其他app，比如微信等，只要你想呈现交互式的网页内容，都可以调用WebView去完成这件事情。Android WebView亦是如此[3]。现在我们可以把WKWebView称为IOS端的WebView，那么Android端的Mobile Chrome 53/57，或者Mobile Chrome 53又是什么，这两个跟WebView又是什么关系呢？ 我们可以把Mobile Chrome 53/57理解为Chrome for Android 537版本，这里的537是指Chrome的排版引擎(layout engine)采用的WebKit内核版本，具体参考Google Chrome version history[4]。需要指出的是，53/57是不是就是537，这里存疑，没有查到有效的参考资料，但是这个对我们的研究应该没有什么影响，可以不予考虑。到这里，又引入了两个概念：layout engine、WebKit内核。接下来简单介绍一下layout engine和WebKit内核。我们都知道浏览器有两个重要的引擎：渲染引擎（rendering engine，也称layout engine，即上面提到的排版引擎，后续为了方便，统一描述为渲染引擎）和JS引擎。其中渲染引擎负责解析网页内容，计算显示方式，输出至显示设备。JS引擎则负责解析JavaScript语言，实现网页的动态交互效果。最开始时渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎，即浏览器内核就是该浏览器采用的渲染引擎，主要参考X5内核调研报告[5]。在后续的讨论中，浏览器内核就单指渲染引擎。那WebKit内核又是什么？这个不得不追溯WebKit的历史了。1998，自由软件社区KDE开发了HTML排版引擎KHTML和JavaScript解析引擎KJS，也就是现代浏览器两个重要的引擎。Apple公司的开发者Don Melton于2001年在KDE的基础之上开始了WebKit项目。刚开始时，WebKit仅为KDE的复刻，我们可以理解为WebKit是KDE基础上fork出来的分支。后来，在WebKit项目中，KHTML被命名为WebCore，KJS被命名为JavaScriptCore，主要参考维基百科[6]。至此，我们可以回答，至少针对Apple的产品来说，浏览器内核就是WebKit，即渲染引擎采用的是WebKit内核。webkit项目是Apple公司发展自家浏览器启动的项目。Google公司在发展Chrome浏览器也成立了Chromium项目。在Chromium项目中，JavaScript解析引擎采用Google自己开发的大名鼎鼎的V8引擎，渲染引擎采用的是WebKit内核。到2013年7月份，Chromium项目将渲染引擎替换为Blink引擎，并在Chrome28及后续的版本上采用[4][7]。Blink引擎是Google在WebKit项目中的WebCore基础上fork出来的一个分支[8][9]。我们可以用一幅图把KDE、WebKit和Chromium串联起来：现在，我们再回过头来看一下Mobile Chrome 53/57，或者Mobile Chrome 53，其实它的内核还是从WebKit上演化而来。绕了这么远，只为一句话：小程序就是运行在WebView之上。那么我们的初衷，研究小程序白屏问题，其实就是在探究WebView白屏问题。如果要更详细一点，那就是WKWebview、Android WebView白屏的原因。关于WKWebview白屏，网上罗列的常见原因大致有以下几种：内存占用比较大时，WebContent Process 会 crash，从而出现白屏现象。URL网址无效或者含有中文字符。WKWebview刚推出时，在IOS8.0~8.2会偶尔出现白屏由于滚动组件嵌套的结构，不刷新的问题。针对原因3，解决的方案是判断IOS系统版本，小于8.2的使用UIWebView。如果站在小程序开发者的角度，这个跟我们好像没有关系。小程序是个平台，我们在这个平台上开发我们的小程序应用，如果小程序也有这个问题，那只能由小程序团队去解决这件事情。还有，比如原因4，我们该嵌套还是得嵌套，有问题也是小程序团队去解决。至于原因2，如果是小程序原生开发的话，页面间的跳转URL包含中文也是能正常跳转的，这个应该是小程序内部兼容了。但是原因1，这个跟我们就有很大的关系了，比如我们定义了大量的变量，使用完了却没有释放，那么这部分内存在小程序销毁之前会被一直占用。再比如我们在某一刻操作了某个比较大的变量，可能在短时间内，内存使用量也会飙升。同样的，对于导致Android WebView白屏的问题，绝大部分也只能由小程序团队去解决。这样一来，从开发小程序应用的前端角度来说，我们能够把握的是尽量避免由于内存使用紧张导致的部分WebView被回收而出现的白屏问题。至此，我们研究的小程序白屏问题，可以转向对小程序内存优化的研究。下面总结一下平时开发过程中可能会导致内存警告的操作：使用大图片和长列表图片。根据小程序团队分析过的大部分案例，大图片和长列表图片的使用，都会引起WKWebview被回收[10]。其中长列表页图片是指页面包含数目较大的列表，每个列表里面又引用了图片。随意定义变量，由于小程序的机制而又没有得到释放。以下四种场景下定义的变量，即使离开当前页面，变量也不会被回收：定义在Page构造器外层的全局变量。定义在data内部的数据。定义在Page内部，类data数据。挂载到getApp().globalData上的数据。假如我们在testvar页面定义了上述变量，由testvar通过navigateTo跳转到下一个页面otherpage，在页面otherpage里面我们可以通过getCurrentPages()获取页面testvar的引用，进而获取里面的变量。通过navigateTo打开新页面，上一个页面进入页面栈，并且该页面只是hide，并不是unload[11]。小程序框架的页面栈最多可支持10层页面。设想一下，那些具有复杂交互的页面，每层页面都附带了众多的数据，甚至包含很多图片，再考虑多层页面并存的问题，那内存使用量将是很可观的。在页面栈里面的页面unload之前，都会造成持续的内存占用。短时间内大数据操作。假设在某个时间点，我们需要对接口返回的大量数据进行操作，可能会造成瞬时的内存占用。列表数据的持续累加，导致某个数据异常大。设想一下，假如我们的列表页有很多条数据，每经过一次分页请求，我们就把新的数据concat到已有的数据之上，久而久之，这条数据可能会变成巨无霸，逐渐侵蚀我们的内存。所幸的是，上述这些可能造成内存大量占用的操作，我们是可以避免或者优化的。针对原因1中的大图片，我们就可以适当压缩压缩。如果不能再压了，或者图片必须这么大，还有单个图片本来都不大，但是列表太多造成引用的图片太多怎么办呢？好，这个可以暂时先放下，在后续的讨论中再提对应的解决方案。针对原因2，我们需要结合实际的业务场景，对那些用完就可以丢弃的，不需要伴随页面整个生存周期存在的变量，就不要用那四种方式去定义数据。针对原因3，我们可以尽量和接口开发方协商，通过分页或其他方式来避免接口一次返回大量的数据。针对原因4，本质的原因是持续的分页请求导致新的数据不断追加到已有的数据之上，那么这种场景，我们就需要对已有的部分数据进行舍弃。舍弃哪些已有的数据，需要一个原则。设想一下有这样一个场景，我们进入列表页list，我们定义了listData用来存放每次分页请求过来的数据。第一页的数据过来了，listData仅仅包含第一页数据。第二页数据过来了，我们把新数据concat到第一页上，此时，listData就包含了第一、第二两个页面的数据。第三页的数据过来了，listData就包含前三个页面的数据。现在我们不妨停下来想想，目前我们给用户呈现的是第三页的数据，第一页的数据处于不可见的状态，既然不可见，为何不把它丢弃？如果用户往上滑动，需要呈现第一页的数据时，我们可以再请求第一页的数据。listData丢弃部分数据，会及时反馈到view层，view层部分节点也会随之销毁，这样App Service层和view层占用的部分内存都会得到释放。当然，我们提出的这种方案，就是为了解决持续的分页请求导致新的数据不断追加到已有的数据之上的问题，至于要不要采用，采用了什么场景下进行已有数据丢弃，丢弃哪些数据，这些都要结合实际的业务进行评估和权衡。希望大家进行批评和指正！参考文献： [1]: developers.weixin.qq.com/miniprogram… [2]: developer.apple.com/documentati… [3]: developer.android.com/reference/a… [4]: en.wikipedia.org/wiki/Google… [5]: juejin.im/post/5a3522… [6]: zh.wikipedia.org/wiki/WebKit [7]: zh.wikipedia.org/wiki/Google… [8]: zh.wikipedia.org/wiki/Chromi… [9]: zh.wikipedia.org/wiki/Blink [10]: developers.weixin.qq.com/miniprogram… [11]: developers.weixin.qq.com/miniprogram…"}
{"title": "手把手系列，100行代码搞定微信小程序全局状态同步 ", "author": "Rolan", "pub_time": "2018-12-13 00:24", "article_content": "最近接了一个小程序项目，对于以前只写过一个小工具的我而言，是时候考察一波小程序的基本功了（认真脸）。上手先了解了各路大神撸小程序的方式，前有基于vue语法的mpvue ，专职生成小程序；又有基于react的京东团队的taro 在后，一语多端，支持react语法生成小程序、H5、react-native......；还有官方wepy，仿vue语法，官方支持更稳定......都芥末:ox:的吗？ 赶紧每个都学习了一下。然鹅——！！翻开issue页，似乎都有几十到上百条的open isuue未解决，同时还有一些诡异的bug夹杂其中，好怕怕。遂放弃......逃于是手撸原生框架，于是遇到了原生框架中一个最大的问题，全局状态同步管理 /(ㄒoㄒ)/~~。小程序框架提供了许多开箱即用的组件，大大提高我们的开发效率。但是作为一个不能直接引用js npm包的语法 (支持的模式很繁琐) ，同时小程序本身也没有提供类似redux、vuex的全局的状态管理工具，这简直违反了mvc(mvvm)党的一贯作风。于是想到了手写一个简单的全局状态管理库，从各方面考察似乎可行，毕竟是一个接近vue的框架。心路历程如上。。。。。。还是不废话了，上主菜 (可直接翻到文末查看代码完整版) 。小程序官方提供且推荐的demo中是把全局数据放在app实例上——示例 ，咋一看似乎很接近我们的全局状态管理需求，但这只是一个数据存储方式，完全没法做到响应式状态。想想我们常见的需求，在个人中心页点击“去登录”，跳转到登录页，测试一番骚操作，好不容易登录成功了，返回个人中心，依旧是一个大大的“去登陆”按钮在嘲讽着他/她，于是测试打了你一顿并让你回去加班。这时候你完全可以在onShow中使用 this.setData 刷新每一次页面展开......前提是你不怕繁琐，同时愿意消耗更多的性能(sex power)。所以开始手写，第一步，在项目中生成一个 /store/sotre.js 文件。再放两个轮子中常用的方法const _toString = Object.prototype.toString\r\n\r\nfunction isFunction(obj) {\r\n    return typeof obj === 'function' || false\r\n}\r\n\r\nfunction isObject(obj) {\r\n    return _toString.call(obj) === '[object Object]' || false\r\n}\r\n复制代码createStore全局状态管理理索当然需要一个全局的状态存储，同时考虑使用react-redux的connect模式做绑定：let _state = null\r\n\r\nfunction connect(mapStateToData, mapMethodTopPage) {\r\n    ...\r\n}\r\n\r\n/**\r\n * 创建store对象\r\n *\r\n * @param { Object } store\r\n * @returns { Object } _Store\r\n */\r\nfunction createStore(state) {\r\n    if (_state) {\r\n        console.warn(\r\n            'there are multiple store active. This might lead to unexpected results.'\r\n        )\r\n    }\r\n    _state = Object.assign({}, state)\r\n    // 这里返回_Store的原因是因为想通过app实例直接获取\r\n    // const { connect, setState, createStore } = getApp().Store\r\n    return _Store\r\n}\r\n\r\nconst _Store = {\r\n    connect,\r\n    setState,\r\n    createStore\r\n}\r\n\r\nmodule.exports = _Store\r\n\r\n\r\n复制代码connect现在的打算是将_state作为内部存储，以免暴露出去被直接操作，无法做到响应式（单一状态树只读原则）。接下来的重点当然是作为绑定数据和修改数据相互响应了，先来connect:let _state = null\r\nlet _subjects = [] // 用来存储页面实例对象\r\nlet _observers = [] // 用来存储状态响应器\r\n\r\n/**\r\n * 仿写react-redux的connect简单工厂\r\n *\r\n * @param { Function } mapStateToData\r\n * @param { Function } mapMethodTopPage\r\n * @returns { Function } pageConnect\r\n */\r\nfunction connect(mapStateToData, mapMethodTopPage) {\r\n    // mapStateToData接收state参数，且必须返回一个绑定对象，key会被绑定到page实例的data中\r\n    const dataMap = mapStateToData ? mapStateToData(_state) : {}\r\n    // mapMethodTopPage接收setState和state参数，且必须返回一个绑定对象，key会被绑定到page实例上\r\n    const methodMap = mapMethodTopPage ? mapMethodTopPage(setState, _state) : {}\r\n    return function(pageObject) {\r\n        // 接收page对象\r\n        // 遍历绑定data\r\n        for (let dataKey in dataMap) {\r\n            if (pageObject.data) {\r\n                if (pageObject.data[dataKey]) {\r\n                    console.warn(\r\n                        `page class had data ${dataKey}, connect map will cover this prop.`\r\n                    )\r\n                }\r\n                pageObject.data[dataKey] = dataMap[dataKey]\r\n            } else {\r\n                pageObject.data = {\r\n                    [dataKey]: dataMap[dataKey]\r\n                }\r\n            }\r\n        }\r\n        // 遍历绑定method\r\n        for (let methodKey in methodMap) {\r\n            pageObject[methodKey] = methodMap[methodKey]\r\n        }\r\n        // 存储onLoad、onUnload周期函数，以便对其做改造\r\n        const onLoad = pageObject.onLoad\r\n        const onUnload = pageObject.onUnload\r\n        pageObject.onLoad = function() {\r\n            // 存储page实例和事件响应器，两者保持同步，一个实例对应一个响应器\r\n            if (!~_subjects.indexOf(this)) {\r\n                // 首次load需要修改data\r\n                this.setData(mapStateToData ? mapStateToData(_state) : {})\r\n                _subjects.push(this)\r\n                _observers.push(() => {\r\n                    // mapStateToData生成新的mapData，并使用this.setData更新page状态\r\n                    this.setData(mapStateToData ? mapStateToData(_state) : {})\r\n                })\r\n            }\r\n            // 触发原有生命周期函数\r\n            onLoad && onLoad.call(this)\r\n        }\r\n        pageObject.onUnload = function() {\r\n            // 注销响应器\r\n            const index = _subjects.indexOf(this)\r\n            if (!~index) {\r\n                _subjects.splice(index, 1)\r\n                _observers.splice(index, 1)\r\n            }\r\n            // 触发原有生命周期函数\r\n            onUnload && onUnload.call(this)\r\n        }\r\n        return pageObject\r\n    }\r\n}\r\n复制代码setState状态存储和绑定都有了，现在需要一个修改state的方法：/**\r\n * 所有的state状态修改必须通过setState方法，以完成正常的响应\r\n *\r\n * @param { Object | Function } state\r\n */\r\nfunction setState(state) {\r\n    // state 接收需要更新的state对象或者一个接收state的方法，该方法必须返回一个state更新对象\r\n    let newState = state\r\n    if (isFunction(state)) {\r\n        newState = state(_state)\r\n    }\r\n    // 合并新状态\r\n    _state = Object.assign(_state, newState)\r\n    // 触发响应器\r\n    _observers.forEach(function(observer) {\r\n        isFunction(observer) && observer()\r\n    })\r\n}\r\n复制代码完整的代码最后加上一些报错信息：function isFunction(obj) {\r\n    return typeof obj === 'function' || false\r\n}\r\n\r\nfunction isObject(obj) {\r\n    return obj.toString() === '[object Object]' || false\r\n}\r\n\r\nlet _state = null\r\nconst _subjects = [] // 用来存储页面实例对象\r\nconst _observers = [] // 用来存储状态响应器\r\n\r\n/**\r\n * 仿写react-redux的connect简单工厂\r\n *\r\n * @param { Function } mapStateToData\r\n * @param { Function } mapMethodTopPage\r\n * @returns { Function } constructorConnect\r\n */\r\nfunction connect(mapStateToData, mapMethodTopPage) {\r\n    if (mapStateToData !== undefined && !isFunction(mapStateToData)) {\r\n        throw new Error(\r\n            `connect first param accept a function, but got a ${typeof mapStateToData}`\r\n        )\r\n    }\r\n    if (mapMethodTopPage !== undefined && !isFunction(mapMethodTopPage)) {\r\n        throw new Error(\r\n            `connect second param accept a function, but got a ${typeof mapMethodTopPage}`\r\n        )\r\n    }\r\n    // mapStateToData接收state参数，且必须返回一个绑定对象，key会被绑定到page实例的data中\r\n    const dataMap = mapStateToData ? mapStateToData(_state) : {}\r\n    // mapMethodTopPage接收setState和state参数，且必须返回一个绑定对象，key会被绑定到page实例上\r\n    const methodMap = mapMethodTopPage ? mapMethodTopPage(setState, _state) : {}\r\n    return function(pageObject) {\r\n        // 接收page对象\r\n        if (!isObject(pageObject)) {\r\n            throw new Error(\r\n                `page object connect accept a page object, but got a ${typeof pageObject}`\r\n            )\r\n        }\r\n        // 遍历绑定data\r\n        for (const dataKey in dataMap) {\r\n            if (pageObject.data) {\r\n                if (pageObject.data[dataKey]) {\r\n                    console.warn(\r\n                        `page object had data ${dataKey}, connect map will cover this prop.`\r\n                    )\r\n                }\r\n                pageObject.data[dataKey] = dataMap[dataKey]\r\n            } else {\r\n                pageObject.data = {\r\n                    [dataKey]: dataMap[dataKey]\r\n                }\r\n            }\r\n        }\r\n        // 遍历绑定method\r\n        for (const methodKey in methodMap) {\r\n            if (pageObject[methodKey]) {\r\n                console.warn(\r\n                    `page object had method ${methodKey}, connect map will cover this method.`\r\n                )\r\n            }\r\n            pageObject[methodKey] = methodMap[methodKey]\r\n        }\r\n        // 存储onLoad、onUnload周期函数，以便对其做改造\r\n        const onLoad = pageObject.onLoad\r\n        const onUnload = pageObject.onUnload\r\n        pageObject.onLoad = function() {\r\n            // 存储page实例和事件响应器，两者保持同步，一个实例对应一个响应器\r\n            if (!~_subjects.indexOf(this)) {\r\n                // 首次load需要修改data\r\n                this.setData(mapStateToData ? mapStateToData(_state) : {})\r\n                _subjects.push(this)\r\n                _observers.push(() => {\r\n                    // mapStateToData生成新的mapData，并使用this.setData更新page状态\r\n                    this.setData(mapStateToData ? mapStateToData(_state) : {})\r\n                })\r\n            }\r\n            // 触发原有生命周期函数\r\n            onLoad && onLoad.call(this)\r\n        }\r\n        pageObject.onUnload = function() {\r\n            // 注销响应器\r\n            const index = _subjects.indexOf(this)\r\n            if (!~index) {\r\n                _subjects.splice(index, 1)\r\n                _observers.splice(index, 1)\r\n            }\r\n            // 触发原有生命周期函数\r\n            onUnload && onUnload.call(this)\r\n        }\r\n        return pageObject\r\n    }\r\n}\r\n\r\n/**\r\n * 所有的state状态修改必须通过setState方法，以完成正常的响应\r\n *\r\n * @param { Object | Function } state\r\n */\r\nfunction setState(state) {\r\n    // state 接收需要更新的state对象或者一个接收state的方法，该方法必须返回一个state更新对象\r\n    let newState = state\r\n    if (isFunction(state)) {\r\n        newState = state(_state)\r\n    }\r\n    // 合并新状态\r\n    _state = Object.assign(_state, newState)\r\n    // 触发响应器\r\n    _observers.forEach(function(observer) {\r\n        isFunction(observer) && observer()\r\n    })\r\n}\r\n\r\n/**\r\n * 创建store对象\r\n *\r\n * @param { Object } store\r\n * @returns { Object } _Store\r\n */\r\nfunction createStore(state) {\r\n    if (_state) {\r\n        console.warn(\r\n            'there are multiple store active. This might lead to unexpected results.'\r\n        )\r\n    }\r\n    _state = Object.assign({}, state)\r\n    // 这里返回_Store的原因是因为想通过app实例直接获取\r\n    // const { connect, setState, createStore } = getApp().Store\r\n    return _Store\r\n}\r\n\r\nconst _Store = {\r\n    connect,\r\n    setState,\r\n    createStore\r\n}\r\n\r\nmodule.exports = _Store\r\n\r\n\r\n复制代码确实够简单吧，缺点是不支持模块化和component，也没有实现reducer和action，但是这些，我统统都不要 。 考虑现有需求和性能影响，目前没有支持component和模块化state——“小”程序方向靠拢（其实是懒）。“小程序是一种不需要下载安装即可使用的应用，它实现了应用‘触手可及’的梦想，用户扫一扫或搜一下即可打开应用；也体现了‘用完即走’的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。”“微信之父”张小龙的这段话确定了小程序的开发基调。鉴于小程序作为Web端的轻应用，本身的特质就决定了它不适合实现太过复杂的功能（为我的懒找到了官方支持）。"}
{"title": "微信小程序—setTimeOut定时器的坑 ", "author": "Rolan", "pub_time": "2018-12-13 00:32", "article_content": "背景实验室需要将项目的app搬到微信的小程序上，终于知道为什么程序员是手艺人了，只要有需求，就要想方设法去填充这种需求，去年是小程序的元年了可以说，去年冬天一个叫跳一跳的小程序游戏出现在我的微信中，当时就觉得腾讯是真的牛皮。一时间很多的软件小程序版相继出现，各大微信公众号也开始关联小程序。小程序相比于app，有着独特的优势，其中最大的就是没有ios和android平台之分，但是同时也有局限，你给我开发个小程序王者荣耀试试。定时任务微信小程序API中有两种定时任务setIntervalsetTimeOut这两者都能实现定时任务，比如实现一个定时器，但是建议采用后者setTimeOut,理由是前者并不精确。详细请参考https://www.zhihu.com/question/20479535setTimeOut用法不多说直接上：var timerName = setTimeOut(function() {\r\n    //循环代码\r\n}, delay)这里在循环代码处做我们需要循环处理的逻辑，delay是延迟的毫秒数，5秒 = 5 * 1000，timerName是返回的定时器名称，有什么用，因为要取消这个定时器就需要给需要给出取消的定时器名称clearTimeOut(timerName)坑我有一个需求是每五秒获取一次位置startReportHeart() {\r\n     var timerTem = setTimeout(function () {\r\n         that.heartReport();\r\n     }, app.globalConfig.heart_delay)\r\n     // 保存定时器name\r\n     that.setData({\r\n         timer: timerTem\r\n     })\r\n },heartReport()就是获取位置信息，这样的效果是，只执行了一次。然后查看了一通资料，发现这个setTimeOut只是在delay毫秒之后执行代码，嗦嘎。那如何才能循环执行呢？——>递归登场好吧，我的递归就是(错误代码)startReportHeart() {\r\n     var timerTem = setTimeout(function () {\r\n         that.heartReport();\r\n     }, app.globalConfig.heart_delay)\r\n     // 保存定时器name\r\n        that.setData({\r\n            timer: timerTem\r\n     })\r\n     })\r\n     that.startReportHeart()\r\n },好像没有毛病啊，自递归调用，嗯，没毛病，但是，，，，情况就是，瞬间出现了堆栈溢出。哈哈哈哈哈哈哈。。。。。。。分析:我在startReportHeart函数中开启了一个timer，5秒后开始执行，heartReport获取位置信息，此时直接递归调用自己，再开启一个timer，我的天，这么愚蠢的代码，是谁写的，没错就是我。手动捂脸。在知道了原因之后，那么如何才能解决呢？我们需要5秒后在一次执行，对就是这个需求，那么自然就是在timer中调用自身啊。笨蛋。正确代码:startReportHeart() {\r\n     var timerTem = setTimeout(function () {\r\n         that.heartReport();\r\n         that.startReportHeart()\r\n     }, app.globalConfig.heart_delay)\r\n     // 保存定时器name\r\n      that.setData({\r\n            timer: timerTem\r\n     })\r\n },就这样完美。总结有的时候，遇到的坑真的很想打自己一巴掌，但是解决坑的过程，并发现自己的愚蠢却是一件非常开心的事呢。这个过程也是十分的funning呢。小程序开发刚开始一周时间，是的，一周上手，一点一点，现在越来越顺手，虽然写的东西比较low，但是再一次印证了那句话，只有实践才是最好的学习方式。不要找什么从入门到精通，你会发现，这些都会让你从入门到放弃。此致，敬礼转载请注明出处：http://www.cnblogs.com/numen-fan/"}
{"title": "小程序不同页面之间通讯的解决方案 ", "author": "Rolan", "pub_time": "2018-12-13 00:42", "article_content": "小程序做开发的时候难免需要不同页面之间的通讯，比如首页打开新的页面搜索获取结果返回到首页，不同tab页面之间的数据交互等等。于是做了以下总结当前页面打开新的页面打开新的页面可以通过 navigator 组件来实现，通过url传参来实现，例如<navigator url=\"../search/search?id=123\" open-type=\"redirect\">搜索</navigator>在新的页面 onLoad 事件可以拿到传过来的参数 optionsonLoad: function(options) {\r\n  console.log(options.id);\r\n}新的页面回传数据到当前页面在当前页面定义一个方法searchRet(results) {\r\n  console.log(results);\r\n}在搜索页面获取到的结果，由于小程序页面是通过栈来存储的，所以可以通过 getCurrentPages() 获取获取当前页面栈的实例，第一个元素为首页，最后一个元素为当前页面let pages = getCurrentPages();\r\nlet homePage = pages[pages.length - 2];\r\nif (homePage) {\r\n  homePage.searchRet(results);\r\n}生命周期和storage通过 wx.setStorageSync() 方法可以在本地存储数据，在 page 的 onShow 回调里获取 storage 的值后做相应的处理，例如// index.js\r\nwx.setStorageSync('refresh', true);\r\n\r\n// mycenter.js\r\nif (wx.getStorageSync('refresh')) {\r\n  // 做更新操作\r\n  wx.removeStorageSync('refresh');\r\n}storage 也可以用 globalData 来代替，原理一样，这里不做展开，两种办法都可行，但是就是太笨了，场景复杂起来没法搞"}
{"title": "小程序登录、微信网页授权（Java版） ", "author": "Rolan", "pub_time": "2018-12-14 00:08", "article_content": "首先呢，“登录”、“授权”、“授权登录”，是一样的意思，不用纠结。写小程序授权登录的代码前，需要了解清楚openid与unionid的区别，这里再简单介绍一下：腾讯有个 “微信·开放平台”，只有企业才能注册账号，可理解为微信体系里，最顶级的账号。官网地址：https://open.weixin.qq.com除了这个微信开放平台，还有另一个叫做 “微信公众平台”，可注册四种账号，包括服务号、订阅号、小程序、企业微信。也就是说，公众号（服务号和订阅号可统称为公众号）占一个账号，小程序也占一个账号。在没有绑定开放平台前，小程序授权登录只能拿到用户的openid。官网地址：https://mp.weixin.qq.com小程序可绑定在公众号下，公众号可以绑定在微信开放平台下，小程序也可以绑定在微信开放平台下。（好像有点小绕）简单点说，所有的公众平台账号都需要绑定在 “开放平台” 下，才可获得的unionid，这是打通同个企业下所有微信公众账号的最有效方法（官方推荐）更加具体的可自行百度…一、以下为小程序登录的代码：方式一：通过code调用code2session接口获得message，包含openid、session_key，满足条件的情况下还能直接获得unionid条件如下：（存在局限性）官方说明UnionID获取途径，如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号。开发者可以直接通过wx.login +code2Session 获取到该用户 UnionID，无须用户再次授权。开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。也可通过code2session获取该用户的 UnionID。1/**\r\n 2 * Author: huanglp\r\n 3 * Date: 2018-11-28\r\n 4 */\r\n 5public class WeiXinUtils {\r\n 6\r\n 7    private static Logger log = LoggerFactory.getLogger(WeiXinUtils.class);\r\n 8\r\n 9    /**\r\n10     * 通过前端传过来的code, 调用小程序登录接口, 获取到message并返回 (包含openid session_key等)\r\n11     *\r\n12     * @param code\r\n13     * @return\r\n14     */\r\n15    public static JSONObject login(String code) {\r\n16        log.info(\"==============小程序登录方法开始================\");\r\n17        WxMiniProperties properties = WeiXinPropertiesUtils.getWxMiniProperties();\r\n18        String url = properties.getInterfaceUrl() + \"/sns/jscode2session?appid=\"\r\n19            + properties.getAppId() + \"&secret=\" + properties.getAppSecret() \r\n20            + \"&js_code=\" + code + \"&grant_type=authorization_code\";\r\n21        JSONObject message;\r\n22        try {\r\n23            // RestTemplate是Spring封装好的, 挺好用, 可做成单例模式\r\n24            RestTemplate restTemplate = new RestTemplate();\r\n25            String response = restTemplate.getForObject(url, String.class);\r\n26            message = JSON.parseObject(response);\r\n27        } catch (Exception e) {\r\n28            log.error(\"微信服务器请求错误\", e);\r\n29            message = new JSONObject();\r\n30        }\r\n31        log.info(\"message：\" + message.toString());\r\n32        log.info(\"==============小程序登录方法结束================\");\r\n33        return message;\r\n34\r\n35        // 后续, 可获取openid session_key等数据, 以下代码一般放在Service层\r\n36        //if (message.get(\"errcode\") != null) {\r\n37        //    throw new ValidationException(message.toString());\r\n38        //}\r\n39        //String openid = message.get(\"openid\").toString();\r\n40        //String sessionKey = message.get(\"session_key\").toString();\r\n41        //...\r\n42\r\n43    }\r\n44}\r\n复制代码- 补充1： WeiXinPropertiesUtils工具类1public class WeiXinPropertiesUtils {\r\n 2\r\n 3    // 微信小程序配置\r\n 4    private static WxMiniProperties miniProperties;\r\n 5    // 微信公众号配置\r\n 6    private static WxProperties wxProperties;\r\n 7\r\n 8    private static void init() {\r\n 9        if (miniProperties == null) {\r\n10            miniProperties = ContextLoader.getCurrentWebApplicationContext()\r\n11                .getBean(WxMiniProperties.class);\r\n12        }\r\n13        if (wxProperties == null) {\r\n14            wxProperties = ContextLoader.getCurrentWebApplicationContext()\r\n15                .getBean(WxProperties.class);\r\n16        }\r\n17    }\r\n18\r\n19    public static WxMiniProperties getWxMiniProperties() {\r\n20        init();\r\n21        return miniProperties;\r\n22    }\r\n23\r\n24    public static WxProperties getWxProperties() {\r\n25        init();\r\n26        return wxProperties;\r\n27    }\r\n28}\r\n复制代码- 补充2： WxMiniProperties配置类1@Data\r\n 2@Component\r\n 3@ConfigurationProperties(prefix = \"luwei.module.wx-mini\")\r\n 4public class WxMiniProperties {\r\n 5\r\n 6    private String appId;\r\n 7    private String appSecret;\r\n 8    private String interfaceUrl;\r\n 9\r\n10}\r\n复制代码到此已能通过code获取到用户的openid和session_key，但若不满足条件，即使将小程序绑定到微信开放平台上，也获取不到unionid，所以此方式不稳定，推荐使用解密的方式获取数据。方式二：通过解密的方式获取用户unionid1/**\r\n 2 * 通过encryptedData,sessionKey,iv获得解密信息, 拥有用户丰富的信息, 包含openid,unionid,昵称等\r\n 3 */\r\n 4public static JSONObject decryptWxData(String encryptedData, String sessionKey, String iv) throws Exception {\r\n 5    log.info(\"============小程序登录解析数据方法开始==========\");\r\n 6    String result = AesCbcUtil.decrypt(encryptedData, sessionKey, iv, \"UTF-8\");\r\n 7    JSONObject userInfo = new JSONObject();\r\n 8    if (null != result && result.length() > 0) {\r\n 9        userInfo = JSONObject.parseObject(result);\r\n10    }\r\n11    log.info(\"result: \" + userInfo);\r\n12    log.info(\"============小程序登录解析数据方法结束==========\");\r\n13    return userInfo;\r\n14}\r\n复制代码- 补充1： AesCbcUtil工具类，直接复制即可，需要添加bouncycastle依赖。BouncyCastle是一个开源的加解密解决方案，官网可查看 www.bouncycastle.org/1package com.luwei.common.utils;\r\n 2\r\n 3import org.bouncycastle.jce.provider.BouncyCastleProvider;\r\n 4import org.apache.commons.codec.binary.Base64；\r\n 5import javax.crypto.Cipher;\r\n 6import javax.crypto.spec.IvParameterSpec;\r\n 7import javax.crypto.spec.SecretKeySpec;\r\n 8import java.security.AlgorithmParameters;\r\n 9import java.security.Security;\r\n10\r\n11/**\r\n12 * Updated by huanglp\r\n13 * Date: 2018-11-28\r\n14 */\r\n15public class AesCbcUtil {\r\n16\r\n17    static {\r\n18        Security.addProvider(new BouncyCastleProvider());\r\n19    }\r\n20\r\n21    /**\r\n22     * AES解密\r\n23     *\r\n24     * @param data     //被加密的数据\r\n25     * @param key      //加密秘钥\r\n26     * @param iv       //偏移量\r\n27     * @param encoding //解密后的结果需要进行的编码\r\n28     */\r\n29    public static String decrypt(String data, String key, String iv, String encoding) {\r\n30\r\n31        // org.apache.commons.codec.binary.Base64\r\n32        byte[] dataByte = Base64.decodeBase64(data);\r\n33        byte[] keyByte = Base64.decodeBase64(key);\r\n34        byte[] ivByte = Base64.decodeBase64(iv);\r\n35\r\n36        try {\r\n37            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\r\n38            SecretKeySpec spec = new SecretKeySpec(keyByte, \"AES\");\r\n39            AlgorithmParameters parameters = AlgorithmParameters.getInstance(\"AES\");\r\n40            parameters.init(new IvParameterSpec(ivByte));\r\n41\r\n42            cipher.init(Cipher.DECRYPT_MODE, spec, parameters);// 初始化\r\n43            byte[] resultByte = cipher.doFinal(dataByte);\r\n44            if (null != resultByte && resultByte.length > 0) {\r\n45                return new String(resultByte, encoding);\r\n46            }\r\n47            return null;\r\n48\r\n49        } catch (Exception e) {\r\n50            e.printStackTrace();\r\n51        }\r\n52\r\n53        return null;\r\n54    }\r\n55}\r\n复制代码到此已经获取到 JSONObject类型的 userInfo，包含openid，unionid，昵称，头像等数据后续可以将用户信息保存到数据库，再返回给前端一个token即可，shiro经过公司封装了一层，代码如下：1...\r\n2// 获得用户ID\r\n3int userId = wxUser.getWxUserId();\r\n4shiroTokenService.afterLogout(userId);\r\n5String uuid = UUID.randomUUID().toString();\r\n6String token = StringUtils.deleteAny(uuid, \"-\") + Long.toString(System.currentTimeMillis(), Character.MAX_RADIX);\r\n7shiroTokenService.afterLogin(userId, token, null);\r\n8return token;\r\n复制代码二、以下为公众号（网页）授权的代码：网页授权更加简单，可查看官方文档需添加 riversoft 相关依赖包，公众号网页授权，只需要将公众号绑定了开放平台，就能获取到unionid及其他用户信息。1public static OpenUser webSiteLogin(String code, String state) {\r\n 2    log.info(\"============微信公众号(网页)授权开始===========\");\r\n 3    WxProperties properties = WeiXinPropertiesUtils.getWxProperties();\r\n 4    AppSetting appSetting = new AppSetting(properties.getAppId(), properties.getAppSecret());\r\n 5    OpenOAuth2s openOAuth2s = OpenOAuth2s.with(appSetting);\r\n 6    AccessToken accessToken = openOAuth2s.getAccessToken(code);\r\n 7\r\n 8    // 获取用户信息\r\n 9    OpenUser openUser = openOAuth2s.userInfo(accessToken.getAccessToken(), accessToken.getOpenId());\r\n10    log.info(\"============微信公众号(网页)授权结束===========\");\r\n11    return openUser;\r\n12\r\n13    // 后续, 可将用户信息保存\r\n14    // 最后一步, 生成token后, 需重定向回页面\r\n15    //return \"redirect:\" + state + \"?token=\" + token;\r\n16}\r\n复制代码以下就是本人整理的关于微信公众号授权和小程序授权的一些经验和问题汇总，希望大家能够从中获得解决方法。"}
{"title": "微信小程序网络请求request局域网下的开发测试 ", "author": "Rolan", "pub_time": "2018-12-14 00:12", "article_content": "关于网络请求微信小程序官方文档已经讲解的很清楚了，有一点官网没有提到的，就是局域网下开发测试时，要注意两点：这两种情况都不需要在“微信公众平台-开发设置-服务器域名”配置，因为下面这两种URL是不合法的。1. 请求的URL是：http://localhost/不管是本机还是同一个局域网下其他电脑，开启的wampserver服务器，都可以让本机电脑请求到服务器的数据。wx.request({url: 'http://localhost/test.php'})当然只有电脑“微信开发者工具”可以请求到数据，而调试的时候，手机是请求不到数据的2. 请求的URL是IP地址：http://192.168.0.111/（另一台电脑的IPv4 地址）将localhost换成IP地址后，不仅电脑可以请求到数据，手机调试的时候，也可以请求到数据，前提是手机也是在该局域网下。开启wampserver服务器的电脑的IP，是多少呢？DOS命令查看IP地址：  ipconfigIPv4 地址  我的IPv4 地址微信开发者工具中，wx.requset请求地址：wx.request（{utl ：'http://192.168.0.111/'}）这样本机电脑和手机都可以请求到另一台电脑的wampserver服务器中的数据了后台php文件的配置中，也要有URL地址的设置，这里截取部分代码：  test.php这就是我对“微信小程序局域网下的request网络请求”的愚拙的见解，有不懂的地方，欢迎大家留言，有不足的地方也欢迎大家指出。"}
{"title": "兼容小程序的canvas画图组件jmGraph ", "author": "Rolan", "pub_time": "2018-12-14 00:22", "article_content": "基于CANVAS的简单画图组件让你用类似于dom的方式，在canvas上画图，感觉会不会很爽。主页：http://graph.jm47.com/示例：http://graph.jm47.com/example/index.html安装直接从github下载https://github.com/jiamao/jmgraph\r\n入门下载jmGraph.min.js代码，并引用到你的html中。1<script type=\"text/javascript\" src=\"../dist/jmGraph.min.js\"></script>  　　在dom中添加一个div或canvas，然后初始化jmGraph。<div id=\"mycanvas_container\"></div>\r\n<script type=\"text/javascript\">    \r\n    //也可以是一个dom对象或一个jquery对象 \r\n    //例如：$('#mycanvas_container') || document.getElementById('mycanvas_container')\r\n    var container = 'mycanvas_container';\r\n\r\n    // 用Promise方式\r\n    /*jmGraph(container, {\r\n        width: 800,\r\n        height: 600\r\n    }).then((g)=>{\r\n        //g就是一个jmGraph实例\r\n        init(g);\r\n    });    */\r\n    \r\n    var g = new jmGraph(container, {\r\n        width: 800,\r\n        height: 600,\r\n        //样式，规则请参照样式说明\r\n        style: {\r\n            fill: '#000' //指定背景色\r\n        }\r\n    });\r\n</script> 在画布上画一个方块function init(g){\r\n    var style = {\r\n        stroke:'#46BF86',\r\n        lineWidth: 2\r\n    };\r\n    style.shadow = '0,0,10,#fff';//阴影\r\n    //style.opacity = 0.2;            \r\n    //style.lineCap = 'round';\r\n\r\n    //创建一个方块\r\n    var rect = g.createShape('rect',{\r\n        style:style,\r\n        position: {x:100,y:100}, //左上角坐标\r\n        width:100,\r\n        height:100\r\n    });\r\n    g.children.add(rect);\r\n\r\n    //绘制，可以用requestAnimationFrame动态刷新\r\n    function update() {\r\n        g.redraw();\r\n        //requestAnimationFrame(update);\r\n    }\r\n    update();\r\n} 样式样式可以直接用canvas支持的名称，也可以用本组件简化后的。样式一览事件的绑定函数：bind/unbind事件示例：//创建一条线\r\nvar line = graph.createLine({x:10,y:200},{x:80,y:120},style);\r\n//鼠标移到上面显示不同的样式            \r\nline.bind('mouseover',function(evt) {\r\n    this.style.stroke = 'rgba(39,72,188,0.5)';\r\n    this.cursor('pointer');\r\n    this.neadUpdate = true; //需要刷新\r\n}); 事件一览Path控件path是多数图形的基类，可以指定一个points数组来绘制一个路径。在线示例var path = graph.createPath(null,style);\r\npath.points.push({x:10,y:10});\r\npath.points.push({x:10,y:60});\r\npath.points.push({x:80,y:20});\r\npath.points.push({x:90,y:80});\r\npath.points.push({x:80,y:80}); 圆arc可以创建椭圆、圆弧和圆，circle调用的是原生的arc函数绘制，harc可以绘制一个圆环。 具体请参考示例。 在线示例//创建一个椭圆，指定不同的宽高就为椭圆。如果相同或指定半径则为圆。\r\nvar arc1 = g.createShape('arc', {\r\n    style: style,\r\n    center: {x:100, y:150},\r\n    width: 120,\r\n    height: 80\r\n});         箭头arraw为创建一个箭头， arrawline是一条带箭头的直线。具体请参考示例。 在线示例//带箭头的直线\r\nvar shape = g.createShape('arrawline',{\r\n    style:style,\r\n    start: {x:100,y:100},\r\n    end: {x: 200, y: 350}\r\n});    \r\n//一起结束点和一个角度angle可以决定一个箭头，如果不填angle，则会用start和end来计算角度\r\nvar arraw = g.createShape('arraw',{\r\n    style:style,\r\n    start: {x:150, y:120},\r\n    end: {x: 160, y: 150}\r\n    //angle: Math.PI/2, //箭头角度  可以不填\r\n    //offsetX: 5, //箭头X偏移量\r\n    //offsetY: 8 //箭头Y偏移量\r\n});     贝塞尔曲线bezier可以指定无隐个控制点，绘制复杂的曲线。 具体请参考示例。 在线示例//一个固定的bezier曲线\r\nvar bezier = g.createShape('bezier', { style: style, points: [p0, p1, p2, p3, p4] }); 图片img是用来承载一张图片的控件，可以用style.src来指定图片url。 具体请参考示例。 在线示例var style = {\r\n    src: 'http://mat1.gtimg.com/www/qq2018/imgs/qq_logo_2018x2.png'\r\n};\r\nstyle.shadow = '0,0,10,#fff';\r\n//style.opacity = 0.2;        \r\n\r\n//创建一个image\r\nvar img = g.createShape('image',{\r\n    style:style,\r\n    position: {x:100,y:100}\r\n});    \r\n//设置图片可以用鼠标移动        \r\nimg.canMove(true); 文字label可以用来绘制文字，通过style指定样式。 具体请参考示例。 在线示例var style = {\r\n    stroke: '#effaaa',\r\n    fill: '#fff',\r\n    textAlign: 'center', //水平居中\r\n    textBaseline: 'middle', //垂直居中\r\n    font: '20px Arial',\r\n    border: {left:1,top:1,right:1,bottom:1}, //边框\r\n    shadow: '0,0,10,#fff'\r\n};\r\n//style.opacity = 0.2;        \r\n\r\n//创建一个label\r\nvar label = g.createShape('label',{\r\n    style:style,\r\n    position:{x:200,y:150},\r\n    text:'test label',\r\n    width:120,\r\n    height:80\r\n});         棱形prismatic具体请参考示例。 在线示例var prismatic = g.createShape('prismatic',{\r\n    style:style,\r\n    center:{x:200,y:150},\r\n    width:120,\r\n    height:80\r\n});         可缩放控件resize 可以自由放大缩小的控件。 具体请参考示例。 在线示例var style = {\r\n    stroke: 'red',\r\n    fill: 'yellow',\r\n    lineWidth: 2, //边线宽\r\n    //小方块样式\r\n    rectStyle: {\r\n        stroke: 'green', //小方块边颜色\r\n        fill: 'transparent',//小方块填充色\r\n        lineWidth: 1, //小方块线宽\r\n        close: true\r\n    }\r\n};\r\n//style.opacity = 0.2;        \r\n\r\n//创建一个resize\r\nvar resize = g.createShape('resize', {\r\n    style: style,\r\n    position: {x:200, y:150},\r\n    width: 120,\r\n    height: 80\r\n});    \r\n//大小改变事件\r\nresize.on('resize', function() {\r\n    console.log(arguments);\r\n});     自定义控件大多数控件直接继承jmPath即可，然后通过实现initPoints来绘制当前控件。当需要从某点重新开始画时，给点指定m属性为true，表示移到当前点。示例来画一个X在线示例：http://graph.jm47.com/example/controls/test.htmlfunction jmTest(graph,params) {\r\n    if(!params) params = {};\r\n    this.points = params.points || [];\r\n    var style = params.style || {};\r\n    \r\n    this.type = 'jmTest';\r\n    this.graph = graph;\r\n        \r\n    this.center = params.center || {x:0,y:0};\r\n    this.radius = params.radius || 0;\r\n\r\n    this.initializing(graph.context, style);\r\n}\r\njmUtils.extend(jmTest, jmPath);//jmPath\r\n\r\n//定义属性\r\n\r\n/**\r\n * 中心点\r\n * point格式：{x:0,y:0,m:true}\r\n * @property center\r\n * @type {point}\r\n */\r\njmUtils.createProperty(jmTest.prototype, 'center');\r\n\r\n/**\r\n * 半径\r\n * @property radius\r\n * @type {number}\r\n */\r\njmUtils.createProperty(jmTest.prototype, 'radius', 0);\r\n\r\n\r\n/**\r\n * 初始化图形点\r\n * 控件都是由点形成\r\n * \r\n * @method initPoint\r\n * @private\r\n * @for jmArc\r\n */\r\njmTest.prototype.initPoints = function() {\r\n    //可以获取当前控件的左上坐标，可以用来画相对位置\r\n    var location = this.getLocation();//获取位置参数\r\n    \r\n    var cx = location.center.x ;\r\n    var cy = location.center.y ;\r\n    \r\n    this.points = [];\r\n\r\n    //简单的画一个X\r\n\r\n    //根据半径计算x,y偏移量\r\n    //由于是圆，偏移量相同\r\n    var offw = Math.sqrt(location.radius * location.radius / 2);\r\n    //左上角到右下角对角线\r\n    this.points.push({x:cx - offw, y:cy-offw}, {x:cx + offw, y:cy+offw});\r\n\r\n    //左下角到右上角对角线\r\n    //画完上面的线后，需要重新移到这条线的起点，指定m:true即可\r\n    this.points.push({x:cx - offw, y:cy+offw, m:true}, {x:cx + offw, y:cy-offw});\r\n\r\n    return this.points;\r\n} 微信小程序支持微信小程序稍有差别，因为无需压缩，请直接把dist中的jmgraph.js合并后的文件引用到你的小程序中。示例wxml<canvas style=\"width: 400px; height: 600px;background:#000;\" \r\n    canvas-id=\"mycanvas\" \r\n    bindtouchstart=\"canvastouchstart\" \r\n    bindtouchmove=\"canvastouchmove\" \r\n    bindtouchend=\"canvastouchend\" \r\n    bindtouchcancel=\"canvastouchcancel\">\r\n</canvas> javascript/**\r\n   * 生命周期函数--监听页面初次渲染完成\r\n   */\r\n  onReady: function () {\r\n    \r\n    //这里引用jmgraph\r\n    let jmGraph = require('../../utils/jmgraph');\r\n\r\n    var self = this;\r\n\r\n    jmGraph('mycanvas', {\r\n      width: 400,\r\n      height: 600\r\n    }).then((g) => {\r\n      init(g)\r\n    });\r\n\r\n    function init(g) {\r\n      //g.style.fill = '#000'; //画布背景\r\n      var style = {\r\n        stroke: '#46BF86',\r\n        fill: '#556662',\r\n        lineWidth: 2\r\n      };\r\n      style.shadow = '0,0,10,#fff';\r\n      //style.opacity = 0.2;            \r\n      //style.lineCap = 'round';\r\n\r\n      //创建一个方块\r\n      var rect = g.createShape('rect', {\r\n        style: style,\r\n        position: { x: 100, y: 100 },\r\n        width: 100,\r\n        height: 100\r\n      });\r\n      rect.canMove(true);\r\n      g.children.add(rect);\r\n\r\n      function update() {\r\n        if (g.needUpdate) g.redraw();\r\n        setTimeout(update, 20);\r\n      }\r\n\r\n      update();\r\n\r\n      //初始化jmGraph事件\r\n      //把小程序中的canvas事件交给jmGraph处理\r\n      self.canvastouchstart = function() {\r\n        return g.eventHandler.touchStart.apply(this, arguments);\r\n      }\r\n      self.canvastouchmove = function() {\r\n        return g.eventHandler.touchMove.apply(this, arguments);\r\n      }\r\n      self.canvastouchend = function() {\r\n        return g.eventHandler.touchEnd.apply(this, arguments);\r\n      }\r\n      self.canvastouchcancel = function() {\r\n        return g.eventHandler.touchCancel.apply(this, arguments);\r\n      }\r\n    }\r\n  }"}
{"title": "微信小程序利用setData对列表进行局部刷新超详细 ", "author": "Rolan", "pub_time": "2018-12-14 00:28", "article_content": "之前写的一篇利用setData进行局部渲染的文章，有些朋友可能看的不是很明白，那篇文章写的可能也有一些问题，今天我就把那篇文章重新做一个详细解说，希望大家都能看的明白。 看这篇文章的小伙伴肯定是遇到了这些问题，在一个上拉加载的列表中，想对某一条数据进行操作。但是又不想刷新整个列表。如果有html的dom操作的话大家都不会觉得有问题。其实这种双向数据绑定的方法也是能很轻松的解决此类问题。现在就开始吧。data:{      List:[],//这里是存放整个列表的数组      INDEX:1,//这里是存放操作某条数据的下标      pg:1,//这里是存放操作某条数据当前所在的页数      page:1,//这个是上拉加载的页数      dataID:-1,//这个是存放操作某条数据的id，用来匹配数据。      offon:true//这个是上拉加载的开关} // 操作删除，点赞  setLike: function(e) {  //wxml中传值data-index  data-id       service_common.fetchData(service_common.getUrl(\"Love\"), {////这里是封装好的请求，参考小程序wx.request({})      id: e.currentTarget.dataset.id//点赞哪一条    }, (res) => {      if (res.data.code == 0) {//请求成功，具体参考服务器返回的状态码        var page = Math.ceil(e.currentTarget.dataset.index / 15)  //取页数 向上取整        if (page == 0) {//针对下标为0的操作          page = 1        }     //将下标和id赋值到变量dataID,INDEX，后面会用到    this.setData({        dataID:e.currentTarget.dataset.id,        INDEX: e.currentTarget.dataset.index    })        this.getWrqList(page, 0)//带过去的参数页数，page是操作的数据当前所在的页数，0是代表我要局部渲染，获取数据的时候进行判断（-1：正常逻辑操作。0：局部渲染）      }    }, \"GET\");  },getData:function(pg=this.data.page,ty=-1){//页数默认是page，pg只有在操作数据的时候才会使用到,ty默认等于-1，否则就是操作某条数据需要进行局部渲染操作。  service_common.fetchData(service_common.getUrl(\"getDataList\"), {//这里是封装好的请求，参考小程序wx.request({})      page: pg    }, (res) => {      if (res.data.code == 0) {//数据请求成功，具体参考服务器返回的状态码        if (ty == -1) {//-1正常逻辑操作          if (this.data.page == 1) {//如果是第一页，直接替换掉List            this.setData({              List: res.data.data            })          } else {            //如果是1+页需要用concat进行数组合并，组成新的数组，赋值给List            if (res.data.data.length == 0) {              if (this.data.List.length >= 10) {//为了防止只有几条数据就会弹出来这个提示，所以建议List数据大于10条才弹出                wx.showToast({                  title: '数据加载完成',                })              }            } else {        //上拉加载后数组合并              this.data.List= this.data.List.concat(res.data.data)              this.setData({                List: this.data.List,                offon:true              })            }          }        } else {         //0走操作单条数据，需要局部渲染操作          for (var i in res.data.data) {//循环获取到对应页数的数据，循环查找相对应id的数据，这条数据就是最新的，            if (res.data.data[i].id == this.data.dataID) {      //res.data.data[i]就是最新获取的数据，替换掉原来List[index]的数据              this.setData({                [`demandList[${this.data.INDEX}]`]: res.data.data[i]              })          //结束              return            }          }        }      }    }, \"GET\");},// 触底操作onReachBottom: function() {  if (this.data.offon){//是否还可以下拉刷新        this.data.offon=false//默认关闭下拉刷新，请求成功后自动开启        this.data.page += 1        this.setData({          page: this.data.page,          offon: this.data.offon        })        this.getData()  },下面给一下wxml的简易代码<image src=\"/image/like.png\" bindtap='setLike' data-index=\"{{index}}\" data-id=\"{{item.id}}\"></image>原版地址 这次我介绍的可能还有不足的地方，小伙伴们可以给我留言，我会补足，希望对大家能有帮助。"}
{"title": "小程序登录按钮遮罩浮层效果 ", "author": "Rolan", "pub_time": "2018-12-17 00:14", "article_content": "逻辑如下：1：第一次登陆的时候会有一个登录按钮遮罩浮层提示去授权登录2：在弹出的授权框里，拒绝授权按钮的时候，界面的数据没有办法加载出来，允许授权的时候，界面就能渲染从后端拿过来的数据3：判断是否授过权（判断是第一次登录还是第n次），如果用户第一次已经登录授权，后面继续登录的时候悬浮框就不会再出现效果如下：index.html  <!--  授权弹框提示  --> <view class=\"container\">  <view class=\"float\" hidden='{{viewShowed}}'>    <view class='floatContent'>      <view class='floatText'>        <text>获取微信授权信息</text>        <button open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">去设置</button>      </view>    </view>  </view></view>index.wxss.float {  height: 100%;  width: 100%;  position: fixed;  background-color: rgba(0, 0, 0, 0.5);  z-index: 2;  top: 0;  left: 0;}.floatContent {  padding: 20rpx 0;  width: 80%;  background: #fff;  margin: 40% auto;  border-radius: 20rpx;  display: flex;  flex-direction: column;  justify-content: space-around;  align-items: center;  position: relative;  height: 332rpx;}.floatText text {  color: #000;  font-size: 40rpx;  display: block;  text-align: center;  line-height: 90rpx;  border-radius: 30rpx;  margin-right: 10rpx;}index.jsjs代码，与后台数据库交互，授权的信息存入了数据库，可根据自己的需要做出相应的修改。//index.js//获取应用实例var app = getApp()Page({  data: {    carList: [], //车辆数据集合    viewShowed: true, //控制授权是否显示  },  onLoad: function () {    var that = this;    app.getOpenid().then(function (res) {      if (res.status == 200) {        //判断是否授权        wx.getSetting({          success(e) {            if (e.authSetting['scope.userInfo']) { //已经授权              that.getCars(res.data);            } else { //没有授权，显示授权框              that.setData({                viewShowed: false,              })            }          }        })      }    })  },  getUserInfo: function (e) {    var that = this;    that.setData({      viewShowed: true,    });    var userinfo = e.detail.userInfo;    wx.request({      url: \"http://localhost:8081/wpDeboServer/wx.do\",      data: {        \"openid\": app.globalData.openid,        \"nickname\": userinfo.nickName      },      method: 'PUT',      header: {        'Content-type': 'application/json'      },      success: function (res) {        //查询绑定车辆        that.getCars(app.globalData.openid);      }    });  },})原文作者：祈澈姑娘。 技术博客：https://www.jianshu.com/u/05f416aefbe190后前端妹子一枚，爱编程，爱运营，爱折腾。长期坚持总结工作中遇到的技术问题。"}
{"title": "用 mpvue 写个【微博-青铜版】微信小程序 ", "author": "Rolan", "pub_time": "2018-12-17 00:32", "article_content": "第一次写小程序，由于偏爱 Vue，所以选则了 mpvue 这个框架。那就写个青铜版微博来练练手吧。效果截图：图1：微博首页图2：发微博图3：我的技术要点1、小程序框架：mpvue2、http 请求库：fly.js3、状态管理：vuex4、数据来源：微博开放平台 api实现的功能：1、微博列表2、发微博3、个人信息4、我的粉丝5、我关注的人6、我的收藏（收藏和取消收藏）7、查看我的微博（由于api限制，只能查看自己的）8、分享到微信聊天项目结构api -----------------------   所有的api划分模块\r\n     |-- user.js   // 用户相关的 api\r\n\r\n  config ----------------------   一些基本的配置\r\n     |-- const.js // 基本常量\r\n     |-- fly.js   // fly 的配置\r\n     |-- http.js  // 基本的请求封装 比如 get，post 请求\r\n\r\n components --------------------   最小单位的基础组件 \r\n     |-- Btn.vue  // button 组件\r\n     |-- Input.vue // input 组件\r\nviews --------------------   业务组件 \r\n    |-- PostCell.vue  //  信息流单条微博组件\r\n    |-- UserCell.vue // 单个用户信息组件   pages ----------------------   所有的页面\r\n     |-- timeline -------------   时间线页面（一个页面一个文件夹）\r\n            |-- index.vue //  页面组件\r\n            |-- main.js  // 页面的入口文件\r\n            |-- main.json // 页面配置文件\r\n\r\n    store ---------------------   状态管理\r\n      | -- module -- 模块\r\n      |       |- user.js // 用户模块\r\n      |       |- post.js // 微博模块 \r\n      | -- getters.js // 全局getters\r\n      | -- actions.js  // 全局 actions     \r\n      | -- mutations.js  // 全局 mutations\r\n      | -- state.js  // 全局 state\r\n      | -- mutation-types.js  // 所有的 mutation types\r\n      | -- index.js  //  整合成一个 store，导出\r\n\r\n    utils ---------------------   存放所有的工具函数    \r\n      |-- index.js    // 工具函数\r\n\r\n    images ---------------------   所有的图片资源（小程序中不支持 svg）\r\n      |-- home.png\r\n\r\n   app.json --------------------   整个小程序的全局配置\r\n   App.vue  --------------------   给全局入口一个挂载点\r\n   main.js  --------------------   全局入口文件\r\n   复制代码vuex 在 mpvue 中的使用跟 Vue 项目中使用只有一个区别vue ：new Vue({\r\n    el: '#app',\r\n    store,\r\n    ....\r\n})复制代码mpvue：Vue.prototype.$store = store 挂在到全局一般来说，实在找不到合适的模块，就先公共的里面，以后想整合到模块中也很简单，尽量还是用模块区分。在 .vue 组件中使用 state, getter, mutation, action<template>  \r\n    <div class=\"container\">    \r\n        我是一个 .vue 组件  \r\n    </div>\r\n</template>\r\n<script>\r\nimport { mapState, mapGetters, mapMutations, mapActions } from 'vuex'\r\nexport default {  \r\n    data () {    \r\n        return {}  \r\n    },  \r\n    computed: {   \r\n         ...mapGetters({      \r\n            userInfo: 'userInfo'   \r\n         }),    \r\n         ...mapState({\r\n            someState: 'someState'\r\n         })  \r\n    },\r\n  components: {  },\r\n  onShow () {\r\n    // 小程序的钩子函数\r\n  },\r\n  methods: {\r\n    ...mapMutations({\r\n        someMutation: 'someMutation'\r\n    }),\r\n    ...mapActions({\r\n       someAction: 'someAction'\r\n    })  \r\n  }\r\n}\r\n</script>\r\n<style lang=\"scss\" scoped>\r\n</style>\r\n复制代码在 mpvue 中使用小程序的生命周期钩子函数// vue 的钩子函数\r\ncreated () {\r\n\r\n},\r\n// 小程序的生命周期函数\r\nonShow() {\r\n}\r\n。。。复制代码看到这里你会发现，跟写 vue 项目没啥太大的区别。完全是 vue 的写法，只需要去关注小程序提供哪些能力即可。微博数据通过微博开放平台 api，通过 oauth 2.0 授权操作，拿到自己的 access_token。微博提供了以下开放接口，但是对于单个用户来说，微博每天限制 150 次请求，开发的时候省着点用吧。相比于微信 oauth 授权，微博显得更加开放，微信是不给开发权限的，必须提供备案的域名。说明 ：发微博的接口微博是没有提供的，我借用了第三方分享到微博这个接口，看上去跟发微博没啥区别，但内容中必须带上一个安全域名，这个域名是在微博开放平台设置的。"}
{"title": "微信小程序电商实战-你所困扰的自定义顶部导航栏都在这里 ", "author": "Rolan", "pub_time": "2018-12-17 00:46", "article_content": "本文章是一个系列文章，以一个完整的可用于生产的实际项目探索微信小程序开发中我们经常会遇到的问题，希望能提供完美的解决方案，这次是本系列文章的第二篇了，一下列出该系列文章链接。微信小程序及h5，基于taro，zoro最佳实践探索 微信小程序电商实战-解决你的登陆难问题微信自6.6.0版本之后提供了自定义底部导航栏的功能，这使得我们的全屏页面设计成为了可能 首先演示下最终的实现效果我们实现了一个与微信之前的导航栏行为基本一致，样式可自定义的导航栏，接下来让我们一步一步实现它，这里主要需要考虑如下几点不同的手机，状态栏高度不同，需要进行相关适配 当开启小程序下拉刷新时，如何让顶部导航不会跟着下拉 自定义导航栏封装成独立组件，实现仅需引入到页面，无需对页面样式做相关适配工作该项目托管于github，有兴趣的可以直接查看源码，weapp-clover，如何运行项目源码请查看ztaro 要想实现自定义导航，首先我们需要配置navigationStyle为custom(src/app.js)config = {  window: {    navigationStyle: 'custom'  }}再实际情况中，我们往往需要对自定义导航进行各种各样的定制化，因此我们希望，封装一个最基本的导航栏，用于解决适配问题，其他样式的导航栏仅需对其进行二次封装，无需在关心适配问题，对于这个项目，我们封装组件如下： ComponentBaseNavigation 导航栏基本组件，用于解决适配问题 ComponentHomeNavigation 引入基本导航组件，定制化首页导航栏组件 ComponentCommonNavigation 引入基本导航组件，定制化其他页面导航组件ComponentBaseNavigation实现对于适配不通手机顶部的状态栏高度，我们需要利用微信wx.getSystemInfo获取状态栏的高度，因此在user model中新增如下代码(src/models/user.js)// 省略其他无关代码import Taro from '@tarojs/taro'export default {  namespace: 'user',  mixins: ['common'],  state: {    systemInfo: {},  },  async setup({ put }) {    // 新增初始化获取用户手机系统相关信息，存储到redux全局状态中    Taro.getSystemInfo().then(systemInfo =>      put({ type: 'update', payload: { systemInfo } }),    )  }}实现组件逻辑(src/components/base/navigation/navigation.js)import Taro, { Component } from '@tarojs/taro'import { View } from '@tarojs/components'import { connect } from '@tarojs/redux'import './navigation.scss'@connect(({ user }) => ({  // 链接redux中存储的状态栏高度到组件中  statusBarHeight: user.systemInfo.statusBarHeight,}))class ComponentBaseNavigation extends Component {  static defaultProps = {    color: 'white',    backgroundColor: '#2f3333',  }  render() {    const { statusBarHeight, backgroundColor, color } = this.props    const barStyle = {      paddingTop: `${statusBarHeight}px`,      backgroundColor,      color,    }    return (      <View className=\"navigation\">        <View className=\"bar\" style={barStyle}>          {this.props.children}        </View>        <View className=\"placeholder\" style={barStyle} />      </View>    )  }}export default ComponentBaseNavigation样式如下(src/components/base/navigation.scss)// 大写的PX单位是为了告诉Taro，不要转换成单位rpx// 通过测试和观察发现，微信顶部的胶囊宽高如下，并且各个屏幕下一致// 因此采用PX单位$capsule-padding: 6PX; // 胶囊的上下padding距离$capsule-height: 32PX; // 胶囊的高度$capsule-width: 88PX; // 胶囊的宽度$navigation-height: $capsule-padding * 2 + $capsule-height;$navigation-font-size: 15PX;$navigation-icon-font-size: 25PX;$navigation-box-shadow: 0 2PX 2PX #222;.navigation {  position: relative;  background: transparent;  .bar {    position: fixed;    top: 0;    left: 0;    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    width: 100%;    height: $navigation-height;    z-index: 1;    font-size: $navigation-font-size;  }  .placeholder {    display: block;    height: $navigation-height;    background: transparent;  }}要解决我们先前提到的问题当开启小程序下拉刷新时，如何让顶部导航不会跟着下拉，仅仅只需设置.bar样式为position: fixed，这样当我们下拉刷新时导航栏就不会跟着动了，那为什么我们还需要.placeholder标签呢 如果你尝试着去掉它，并且运行查看效果时，你会发现，页面的内容会被顶部导航栏遮挡了，我们需要对每个页面进行额外的设置以使它如预期一样显示，比如给每个页面设置顶部padding，这样的消耗太大，因此我们专门设置placeholder标签占据与导航栏相同的高度，使页面不被遮挡，且无需额外处理ComponentHomeNavigation实现有了这样一个基础组件，我们要实现首页导航栏效果就变得相当的简单了，直接上代码(src/components/home/navigation/navigation.js)import Taro, { Component } from '@tarojs/taro'import { View, Image, Text } from '@tarojs/components'import { noop } from '../../../utils/tools'import ComponentBaseNavigation from '../../base/navigation/navigation'import './navigation.scss'class ComponentHomeNavigation extends Component {  static defaultProps = {    onSearch: noop,  }  render() {    const { onSearch } = this.props    return (      <ComponentBaseNavigation>        <View className=\"navigation\">          <Image className=\"logo\" src=\"@oss/logo.png\" />          <View className=\"search\" onClick={onSearch}>            <View className=\"icon iconfont icon-search\" />            <Text className=\"text\">搜索</Text>          </View>        </View>      </ComponentBaseNavigation>    )  }}export default ComponentHomeNavigation引入导航组件到首页中, 省略样式代码(src/pages/home/home.js)import Taro, { Component } from '@tarojs/taro'import { View } from '@tarojs/components'import { dispatcher } from '@opcjs/zoro'import ComponentCommonLogin from '../../components/common/login/login'import ComponentCommonSlogan from '../../components/common/slogan/slogan'// 引入导航组件import ComponentHomeNavigation from '../../components/home/navigation/navigation'import ComponentHomeCarousel from '../../components/home/carousel/carousel'import ComponentHomeBrand from '../../components/home/brand/brand'import './home.scss'class PageHome extends Component {  config = {    enablePullDownRefresh: true,  }  state = {    // 请到README.md中查看此参数说明    __TAB_PAGE__: true, // eslint-disable-line  }  componentDidMount() {    dispatcher.banner.getBannerInfo()    dispatcher.brand.getHotBrandList()  }  onPullDownRefresh() {    Promise.all([      dispatcher.banner.getBannerInfo(),      dispatcher.brand.getHotBrandList(),    ])      .then(Taro.stopPullDownRefresh)      .catch(Taro.stopPullDownRefresh)  }  handleGoSearch = () => Taro.navigateTo({ url: '/pages/search/search' })  render() {    return (      <View className=\"home\">        <ComponentCommonLogin />        <ComponentHomeNavigation onSearch={this.handleGoSearch} />        <ComponentHomeCarousel />        <View class=\"content\">          <ComponentCommonSlogan />          <ComponentHomeBrand />        </View>      </View>    )  }}export default PageHomeComponentCommonNavigation实现该组件的实现方式与首页基本一致，需要提的一点就是返回键的实现，我们该如何统一的判断该页面是否需要返回键呢，这里需要利用微信接口wx.getCurrentPages()，实现代码如下(src/components/common/navigation/navigation.js)import Taro, { Component } from '@tarojs/taro'import { View } from '@tarojs/components'import classNames from 'classnames'import ComponentBaseNavigation from '../../base/navigation/navigation'import './navigation.scss'class ComponentCommonNavigation extends Component {  static defaultProps = {    title: '',  }  state = {    canBack: false,  }  componentDidMount() {    // 获取当前页面是否需要返回键    const canBack = Taro.getCurrentPages().length > 1    this.setState({ canBack })  }  handleGoHome = () => Taro.switchTab({ url: '/pages/home/home' })  handleGoBack = () => Taro.navigateBack()  render() {    const { title } = this.props    const { canBack } = this.state    return (      <ComponentBaseNavigation>        <View className={classNames('navigation', { padding: !canBack })}>          <View className=\"tools\">            {canBack && (              <View                className=\"iconfont icon-arrow-left back\"                onClick={this.handleGoBack}              />            )}            <View              className=\"iconfont icon-home home\"              onClick={this.handleGoHome}            />          </View>          <View className=\"title\">{title}</View>        </View>      </ComponentBaseNavigation>    )  }}export default ComponentCommonNavigation感谢观看，文笔不佳，不能完全表达出设计思路，代码是最好的表达，移步weapp-clover 本项目会持续完善，如有兴趣，请关注一波作者：FaureWu 链接：https://www.jianshu.com/p/5877a3dc0b1e 來源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。"}
{"title": "写一个菜鸟裹裹小程序吧 ", "author": "Rolan", "pub_time": "2018-11-30 00:26", "article_content": "新手写小程序并不简单，这是我的第一次尝试学习到了很多。最近双十一过后，每天不是拿快递就是去拿快递的路上，翻开手机应用里的菜鸟裹裹查看快递是很方便的，当我在微信端搜索菜鸟裹裹小程序时，却没有发现，于是便想自己动手仿app版写一个菜鸟裹裹的小程序，对其中的快递查询物流跟踪很有兴趣。项目效果预览项目目录结构使用的开发工具VScode和 微信开发者工具平台提供：微信公众品台|小程序，在该品台注册账号获取AppId，使用AppId登入微信开发者工具，开启项目使用的API文档:微信小程序开发文档, 微信小程序开发教程手册文档_w3c 详细介绍了微信各种工具的使用Vant Weapp,提供了好多实用性的组件，我项目中搜索框使用了该组件库的搜索组件weUI微信团队的基础样式库，使用的接口：快递鸟 接口 提供快递单号和公司编码可以查询快递的物流信息。腾讯地图开放品台提供了关于使用地图，地图显示，标注/多边形绘制，路线显示这些功能的实现。页面解构如下图，总共四个页面\r\n复制代码第一个主要页面<view class=\"container\">\r\n\r\n  <van-search class=\"van-search\" value=\"{{ value }}\" placeholder=\"请输入拼音缩写或中文\" background=\"#ffffff\" bindtap=\"searchAnother\" />\r\n   \r\n  <image class=\"message\" src=\"https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/5.jpg?sign=62596b8fb882fafa4735a7bb02ec48cf&t=1542775874\"></image>\r\n  <view class=\"weui-tabbar\">\r\n    <icon href=\"#\" class=\"weui-tabbar__item weui-tabbar__item_on\">\r\n      <icon>\r\n        <image mode=\"aspectFit\" src=\"https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/saoma.jpg?sign=22ecf7d2269084181e8ace24c1319b06&t=1542775996\" alt=\"\" class=\"weui-tabbar__icon\"></image>\r\n      </icon>\r\n      <icon class=\"weui-tabbar__label\" bindtap='scanCode'>扫一扫</icon>\r\n    </icon>\r\n    <icon href=\"#\" class=\"weui-tabbar__item weui-tabbar__item_on\" >\r\n      <icon>\r\n        <image mode=\"aspectFit\" src=\"https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/2.jpg?sign=2c956d50da50cdf22b74812d1cc51b12&t=1542776039\" alt=\"\" class=\"weui-tabbar__icon\"></image>\r\n      </icon>\r\n      <icon class=\"weui-tabbar__label\" >快递员上门</icon>\r\n    </icon>\r\n    <icon href=\"#\" class=\"weui-tabbar__item weui-tabbar__item_on\" >\r\n      <icon>\r\n        <image mode=\"aspectFit\" src=\"https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/3.jpg?sign=a9cbe061ac103a8e380f73f8c56cec2c&t=1542776057\" alt=\"\" class=\"weui-tabbar__icon\"></image>\r\n      </icon>\r\n      <icon class=\"weui-tabbar__label\">精灵书屋</icon>\r\n    </icon>\r\n    <icon href=\"#\" class=\"weui-tabbar__item weui-tabbar__item_on\" >\r\n      <icon>\r\n        <image mode=\"aspectFit\" src=\"https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/4.jpg?sign=da2382ecf07e72710947db853406d600&t=1542776076\" alt=\"\" class=\"weui-tabbar__icon\"></image>\r\n      </icon>\r\n      <icon class=\"weui-tabbar__label\">领裹酱</icon>\r\n    </icon>\r\n  </view>\r\n  <swiper class=\"ad\" indicator-dots='true' indicator-active-color='blue' autoplay='true'>\r\n    <swiper-item wx:for=\"{{imageList}}\" wx:key=\"index\" wx:for-item=\"item\">\r\n      <image src=\"{{item.pic}}\" mode=\"widthFix\" bind:tap=\"tapImage\" class='ad-img'></image>\r\n    </swiper-item>\r\n  </swiper>\r\n  <view class='action'>\r\n    <text class='action-text'>进行中</text>\r\n    <image class='action-img' mode='aspectFill' src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/ad2.jpg?sign=ae6b53f73ba106c5be937df83b016e07&t=1542776132'></image>\r\n  </view>\r\n  <loading hidden=\"{{isLoading}}\"></loading>\r\n<scroll-view class='scroll-view' scroll-y=\"true\">\r\n<view class='package-item'  wx:for=\"{{expressLists}}\" wx:key=\"{{item.contentId}}\"\r\n wx:for-item=\"item\" data-contentId='{{item.text3}}' bindtap='toDetail'>\r\n    \r\n     <view class='item-wrapper'> \r\n\r\n      <text class='item-title'>{{item.text1}}</text>\r\n      <image class='item-img' mode='aspectFill' src='{{item.image}}'></image>\r\n      <view class=\"item-block\">\r\n        <text class='item-text1'>{{item.text2}}</text>\r\n        <text class='item-text2'>{{item.text3}}</text>\r\n        <text class='item-text3'>{{item.text4}}</text>\r\n      </view>\r\n      </view>\r\n    </view>\r\n<view class='package-item'>//最后一个广告项\r\n    <view class='item-wrapper'>\r\n\r\n     <text class='item-title'>有一个神秘包裹想你飞来</text>\r\n      <image class='item-img' mode='aspectFill' src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/6.jpg?sign=e713b1367255f2bd83f8098aaac630d4&t=1542776179'></image>\r\n      <view class=\"item-block\">\r\n        <text class='item-text1'>已放入裹裹自提柜</text>\r\n        <text class='item-text2'>菜鸟裹裹</text>\r\n        <text class='item-text3'>神秘包裹已送至裹裹自提柜</text>\r\n      </view>\r\n    \r\n    \r\n    </view>\r\n     \r\n</view>\r\n<text class='{{bottomshow== true? \"bottomshow\":\"hide\"}}' bindtap='watchMore'>查看全部</text>\r\n  </scroll-view>\r\n  \r\n</view>\r\n复制代码第二个页面写起来很简单<view class='largecontainer'>\r\n  <view class='container'>\r\n    <van-search class=\"search-top\" value=\"{{value}}\" placeholder=\"请输入运单号\" use-action-slot bind:change=\"onChange\" bind:search=\"onSearch\">\r\n      <view slot=\"action\" bindtap=\"cancel\">取消</view>\r\n    </van-search>\r\n    <view class='search-middle' bindtap='selectCompany'>\r\n      <image class='car' src='{{src}}' mode='aspectfit'></image>\r\n      <text class='middle-text'>{{company}}</text>\r\n    </view>\r\n    <view class=\"dr\">\r\n      <image class='dr-img' src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/dr.jpg?sign=8fa530125c0e20b0a6f9b0a39a5afae6&t=1542885013' mode='aspectfit'></image>\r\n    </view>\r\n    <view class='save-list'>\r\n      <text class='save-text'>保存到包裹列表</text>\r\n      <van-switch class='save-switch' bind:tap=\"onChangeswitch\" checked=\"{{checked}}\" size=\"110%\" active-color=\"#4b0\" inactive-color=\"#f44\"></van-switch>\r\n    </view>\r\n    <view class='search-bottom' bindtap=\"getExpressInfo\" data-number='{{no}}' data-name='{{no}}'>\r\n      查询\r\n    </view>\r\n  </view>\r\n  <scroll-view scroll-y class='scroll-view'>\r\n    <view class='history'>\r\n      <view class='history-text'>{{historyOrder}}</view>\r\n      <view class='history-item' wx:for=\"{{historyList}}\" wx:key=\"{{index}}\">\r\n        <view class='item-num'>{{item.code}}</view>\r\n        <view class='item-text'>{{item.company}}</view>\r\n        <image class='item-image' mode='aspectFit' src='../../images/x.jpg' data-code='{{item.code}}' bindtap='delectoneHistory'></image>\r\n      </view>\r\n      <view class='clear-history' bindtap='onSHowdialog'>{{delectHistory}}</view>\r\n      <wxc-dialog class=\"wxc-dialog\" title=\"确认全部清除\" bindcancel=\"onCancel\" bindconfirm=\"delectHistory\"></wxc-dialog>\r\n    </view>\r\n  </scroll-view>\r\n</view>\r\n复制代码第三个主要页面<view class=\"container flex_vert \">\r\n  <view class=\"search\">\r\n    <view class='search-text'></view>\r\n    <van-search class=\"van-search\" value=\"{{ value }}\" placeholder=\"请输入拼音缩写或中文\" background=\"#ffffff\" />\r\n  </view>\r\n  <scroll-view class='company' scroll-y bindscrolltoupper=\"upper\" bindscrolltolower=\"lower\" scroll-into-view=\"{{toView}}\">\r\n    <view class='select-list'>\r\n      <view class='select-word' wx:for=\"{{scrollList}}\" wx:key=\"{{index}}\" data-index='{{index}}' data-id=\"{{item}}\" bindtap='switchTab'>\r\n        {{item}}\r\n      </view>\r\n    </view>\r\n    <view class='item-A' id='{{item.number}}' hover-stay-time='3000' wx:for=\"{{comList}}\" wx:key=\"{{index}}\" wx:for-item=\"item\" scroll-with-animation=\"true\" scroll-animation-duration=\"3000\">\r\n      <text>{{item.number}}</text>\r\n      <view class='company-item' wx:for=\"{{item.list}}\" wx:key=\"{{index}}\" bindtap='backwithData' data-text='{{item.text}}' data-src=\"{{item.pic}}\">\r\n        <image src='{{item.pic}}' class='item-image' mode='acpectFill'></image>\r\n        <text class='item-text'>{{item.text}}</text>\r\n        <icon>\r\n          <image src='{{item.likepic}}' class='icon'></image>\r\n        </icon>\r\n      </view>\r\n    </view>\r\n  </scroll-view>\r\n</view>\r\n复制代码第四个主要页面<view class='container'>\r\n  <view class='header'>\r\n    <view class=\"container-header\">\r\n      <view class='left'>\r\n        <image class='left-img1' mode='aspectFit' src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/d1.jpg?sign=418294a51084375aa75faf9c934a232a&t=1542776464'></image>\r\n        <image class='left-img2' mode='aspectFit' src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/d2.jpg?sign=860b4b91983b5882361fd8518d4f5052&t=1542776482'></image>\r\n        <text class='left-text'>已签收</text>\r\n      </view>\r\n      <view class='right'>\r\n        <view class='right-box' bindtap='service'>\r\n          <image src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/d3.jpg?sign=e0896127eca1f639dc3f987713007073&t=1542776506'></image>\r\n          <text class='right-box_text'>物流客服</text>\r\n        </view>\r\n        <view class='right-box' bindtap=' complaint'>\r\n          <image src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/d4.jpg?sign=88eea48517eae4dd43e484a4011db0b3&t=1542776526'></image>\r\n          <text class='right-box_text'>物流投诉</text>\r\n        </view>\r\n        <view class='right-box'>\r\n          <image src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/d5.jpg?sign=cd8068ae4d4079e834c6cf1be6a63017&t=1542776546' class='right-box_img3'></image>\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <scroll-view scroll-y=\"{{true}}\" class='scroll'>\r\n    <view class=\"detail-container\">\r\n      <image class='errormessage' src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/error.jpg?sign=5e662ac9d3f2137611fbc78ed57f7d91&t=1542776565'></image>\r\n      <view class='talkinn'>\r\n        <text class='inn-text'>评价驿站 东华理工大学南区七栋菜鸟驿站</text>\r\n        <view class='innbar'>\r\n          <image src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/ink.jpg?sign=dcf1be9f08dc50684d63fb521fc3573a&t=1542776591' class='inn'></image>\r\n          <view class='stars'>\r\n            <image src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/star.jpg?sign=be15af8bc087f1bc75ab4e7b2eec88b3&t=1542811791' class='star'></image>\r\n            <image src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/star.jpg?sign=be15af8bc087f1bc75ab4e7b2eec88b3&t=1542811791' class='star'></image>\r\n            <image src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/star.jpg?sign=be15af8bc087f1bc75ab4e7b2eec88b3&t=1542811791' class='star'></image>\r\n            <image src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/star.jpg?sign=be15af8bc087f1bc75ab4e7b2eec88b3&t=1542811791' class='star'></image>\r\n            <image src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/star.jpg?sign=be15af8bc087f1bc75ab4e7b2eec88b3&t=1542811791' class='star'></image>\r\n          </view>\r\n        </view>\r\n        <view class='inn-bottom'>\r\n          <text class='inn-bottom_text'>{{company}}  {{code}}</text>\r\n          <image src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/error.jpg?sign=ae3162eb21f9eb321f3cf443751cd5ef&t=1542776616' class='errormessage2'></image>\r\n        </view>\r\n      </view>\r\n      <view class='detail'>\r\n        <view class='detail-data1'>\r\n          <view class='time'></view>\r\n          <view class='shouicon'>\r\n            <image class='icon' src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/shou.jpg?sign=2b723580f5bcd7a63fadcafca12f7fac&t=1542776646' class='icon1'></image>\r\n          </view>\r\n          <view class='data-msg'>\r\n            <view class='data-msg_title'></view>\r\n            <view class='data-msg_article'>【收货地址】江西省南昌市青山湖区 蛟桥镇 东华理工大学广兰大道广兰校区</view>\r\n          </view>\r\n        </view>\r\n        <view class='detail-data'>\r\n          <view class='time'>{{time1}}</view>\r\n          <view class='shouicon'>\r\n            <image class='icon2' src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/shou2.jpg?sign=ab586f9e02814f37c32b3673be252728&t=1542776674'></image>\r\n          </view>\r\n          <view class='data-msg'>\r\n            <view class='data-msg_title'>已签收</view>\r\n            <view class='data-msg_article'>您已在东华理工大学南区七栋菜鸟驿站完成取件，感谢使用菜鸟驿站，期待再次为您服务。</view>\r\n            <text class='data-select'>我要退货</text>\r\n            <text class='data-select'>联系卖家</text>\r\n            <text class='data-select'>查看订单</text>\r\n          </view>\r\n        </view>\r\n        <view class='detail-data'>\r\n          <view class='time'>{{time2}}</view>\r\n          <view class='shouicon'>\r\n            <image class='icon2' src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/shou3.jpg?sign=0df85fc9d103f7717e2b963f2f5f7746&t=1542776695'></image>\r\n          </view>\r\n          <view class='data-msg'>\r\n            <view class='data-msg_title'>待取件</view>\r\n            <view class='data-msg_article'>您已在东华理工大学南区七栋菜鸟驿站完成取件，感谢使用菜鸟驿站，期待再次为您服务。</view>\r\n          </view>\r\n        </view>\r\n        <view class='detail-data1'>\r\n          <view class='time'>{{time3}}</view>\r\n          <view class='shouicon'>\r\n            <image class='icon2' src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/shou4.jpg?sign=949a5b5f8436e0933e279c7dab7d99f0&t=1542776714'></image>\r\n          </view>\r\n          <view class='data-msg'>\r\n            <view class='data-msg_title'>派送中</view>\r\n            <view class='data-msg_article'>{{text3}}</view>\r\n          </view>\r\n        </view>\r\n        <view class='detail-data1'>\r\n          <view class='time'>{{time3}}</view>\r\n          <view class='shouicon'>\r\n            <image class='icon2' src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/shou5.jpg?sign=bdab3c461441de6b8cea13589bb4dfc2&t=1542776737'></image>\r\n          </view>\r\n          <view class='data-msg'>\r\n            <view class='data-msg_title'>运输中</view>\r\n            <view class='data-msg_article'>{{text3}}</view>\r\n          </view>\r\n        </view>\r\n        <view class='detail-data2' wx:for=\"{{Traces2}}\" wx:key=\"index\">\r\n          <view class='time'>{{item.AcceptTime}}</view>\r\n          <view class='shouicon2'>\r\n            <image class='icon2' src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/shou6.jpg?sign=2c10e0b37d9ac31b88a1c5d836ef7ffb&t=1542776755'></image>\r\n          </view>\r\n          <view class='data-msg'>\r\n            <view class='data-msg_title'></view>\r\n            <view class='data-msg_article'>{{item.AcceptStation}}</view>\r\n          </view>\r\n        </view>\r\n        <view class='detail-data'>\r\n          <view class='time'>{{time3}}</view>\r\n          <view class='shouicon3'>\r\n            <image class='icon3' src='https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/shou7.jpg?sign=f7309cadf586fa539d3a04b77488dd97&t=1542776785'></image>\r\n          </view>\r\n          <view class='data-msg'>\r\n            <view class='data-msg_title'>已揽件</view>\r\n            <view class='data-msg_article'></view>\r\n          </view>\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </scroll-view>\r\n</view>\r\n<!-- <view id='map'> -->\r\n<!-- <map id=\"myMap\" markers=\"{{markers}}\" longitude=\"{{lon}}\" latitude=\"{{lat}}\" scale='16'>\r\n  </map> -->\r\n<!-- </view> -->\r\n复制代码这个页面的功能是实现查询已签收的快递的物流状态，而且签收地固定了一下还有其他状态比如运输中，未发货，快递单号过期。为了把这个效果展现出来。这里没有写其他的页面。 第一个数据detail-data 收 需要获取用户的收货地址 第二个数据 detail-data 已签收可以送请求的数据中获取使用easy-mock + 小程序云开发数据库使用easy-mock可以实现高效伪造数据 easy-mock在上面注册后可以创建一个接口，编辑接口可以添加数据， 可以获取接口的url，然后通过小程序的 wx.request(url) 获取在easy-mock里的数据，本例使用easy-mock构建了首页中 expressLists 的数据{\r\n\"data\": {\r\n expressList: [{\r\n     image: \"https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/yy.jpg?sign=b28732bd498113a8c88cfa634121a363&t=1542776282\",\r\n     text1: \"【送历年真题】,朱伟老师推荐！新东方201...\",\r\n     text2: \"签收时间：10-29 21:01\",\r\n     text3: \"百世快递：71220099817129\",\r\n     text4: \"北京北京市--江西南昌\",\r\n     contentId: \"001\",\r\n   },\r\n   {\r\n     image: \"https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/lq.jpg?sign=82cc4a8eca681accf06dd4737f2422cc&t=1542776323\",\r\n     text1: \"淘宝|运动护具篮球护指套艾弗森库...\",\r\n     text2: \"签收时间：11-10 12:20\",\r\n     text3: \"圆通快递：802511355217367857\",\r\n     text4: \"广州广州市--江西南昌\",\r\n     contentId: \"002\",\r\n   },\r\n   {\r\n     image: \"https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/css.jpg?sign=324ebd7e4e3203b2071cb7e0f24a0d2e&t=1542776355\",\r\n     text1: \"天猫|CSS世界web前端开发CSS3+...\",\r\n     text2: \"签收时间：10-17 17:11\",\r\n     text3: \"圆通快递：802022497906214489\",\r\n     text4: \"河南省新乡市--江西南昌\",\r\n     contentId: \"003\",\r\n   },\r\n   {\r\n     image: \"https://636c-cloud-912718-1257892962.tcb.qcloud.la/images2/js.jpg?sign=d07ef9708724b5d20595923a16964fa8&t=1542776376\",\r\n     text1: \"淘宝|二手包邮 你不知道的javaScri...\",\r\n     text2: \"签收时间：09-21 17:13\",\r\n     text3: \"韵达快递：3956570250807\",\r\n     text4: \"河南洛阳--江西南昌\",\r\n     contentId: \"004\",\r\n   }\r\n ]\r\n}\r\n}\r\n复制代码小程序云开发数据库使用companyes：选择快递公司页面对应的快递公司图片标志，快递公司名字，和喜欢收藏icon图片expresses：每一个快递单号对应的信息，这里通过接口获取数据后添加到数据库中，同时把快递单号作为每一个记录的一个字段，后面可以通过单号直接查询，重复单号不添加，无效单号也不添加进云数据库。getExpresses：这是代取件里面的数据集合，云数据库存储 这里把项目的图片资源存储在了小程序的云数据库上，新建文件将名字为images点击上传可以把本地图片上传到存储中利用云数据库提供的图片地址可以实现本地图片url书写。使用小程序云开发品台里的数据库，存储管理，既不用占用本地资源，也方便请求和修改。云开发为开发者提供完整的云端支持，不用操心后端的管理，同时也不需要很麻去构建服务器，直接使用小程序提供的云函数的API文档和对小程序数据库操作的相关API即可实现数据的增删改操作，比mysql数据库操作更简单方便，这样就可以可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。接口使用整个查询快递的流程预览快递鸟接口 首先注册一个快递鸟账号，选择订购物流查询免费版应用，期间需要上传身份证，还需要填写技术人员信息，通通写自己就好了，申请成功后，可以得到自己的API key和用户ID查询快递的js代码 这里需要先选择快递公司，在selectCompany页面选择，选择完成返回到查询订单号 sarch页面选择后在 selectCompany 页面的js代码里保存选择的快递公司代码。即 companyname 在搜索框中填入要搜索的快递单号信息，用 exp 保存 即可获得使用接口的两个参数。这样就得到了使用接口的两个参数，详情看 快递鸟即时查询api接口 的使用下面是具体的请求参数需要对请求的数据中的Datasign部分做以下处理使用工具包util里的MD5函数进行加密运算 (util.md5(RequestData + 'eb016c6c-ab32-47b2-be8c-8fddf3f59c1e')) 需要把请求的数据进行encodeURI()编码，该函数可把字符串作为 URl 进行编码。使用util工具包中的Base64编码算法对请求数据编码成base64格式 Base64是当今比较流行的编码方法，因为它编起来速度快而且简单 好处: base64特别适合在http，协议下快速传输数据。最后把数据内容签名进行encodeURI编码，请求数据准备好了请求的地址，数据，请求头的格式都在下面代码里给出，这里不需要多说var util = require('../../utils/util.js')\r\nconst db = wx.cloud.database()\r\nconst expresses = db.collection('expresses')\r\nconst app = getApp()\r\ngetExpressInfo:function(nu,cb){\r\n    //查物流\r\n    //快递公司和，快递单号\r\n   let companyname=wx.getStorageSync(\"codename\")||\"YTO\";\r\n    let company = wx.getStorageSync(\"company\") || \"圆通快递\";\r\n   console.log(companyname);\r\n     let exp=nu.currentTarget.dataset.name\r\n    var logistics = [companyname,exp];//保存在一个数组中\r\n    this.setData({\r\n      ShipperCode:logistics[0],\r\n      LogisticCode:logistics[1]\r\n\r\n    })\r\n    //数据内容\r\n    var RequestData = \"{'OrderCode':'','ShipperCode':'\" + logistics[0] + \"','LogisticCode':'\" + logistics[1] + \"'}\"\r\n    //utf-8编码的数据内容\r\n    // OrderCode\tString\t订单编号\tO\r\n    // ShipperCode\tString\t快递公司编码\tR\r\n    // LogisticCode\tString\t物流单号\r\n    console.log(RequestData)\r\n    var RequestDatautf = encodeURI(RequestData)\r\n    console.log(\"RequestDatautf:\" + RequestDatautf) //签名\r\n    console.log(RequestData + 'eb016c6c-ab32-47b2-be8c-8fddf3f59c1e')\r\n    var DataSign = encodeURI(util.Base64((util.md5(RequestData + 'eb016c6c-ab32-47b2-be8c-8fddf3f59c1e'))))\r\n    console.log(\"DataSign:\" + DataSign)\r\n    if (logistics != null&&exp>999) {\r\n      wx.request({\r\n        url: 'https://api.kdniao.com/Ebusiness/EbusinessOrderHandle.aspx',\r\n        data: {\r\n          //数据内容(进行过url编码)\r\n          'RequestData': RequestDatautf,\r\n          //电商ID\r\n          'EBusinessID': '1399017',\r\n          //请求指令类型：1002\r\n          'RequestType': '1002',\r\n          //数据内容签名把（请求内容（未编码）+ApiKey）进行MD5加密，然后Base64编码，最后进行URL（utf-8）编码\r\n          'DataSign': DataSign,\r\n          //请求、返回数据类型： 2-json；\r\n          'DataType': '2',\r\n        },\r\n        header: {\r\n          'content-type': 'application/json'\r\n        },\r\n        success:(res)=> {\r\n          console.log(res)\r\n          let list = wx.getStorageSync(\"historys\")||[];\r\n          var item = {\r\n            company: company,\r\n            code: logistics[1]\r\n          }\r\n          if (list==null||list.length=== 0||list.every(res => {  return res.code!==logistics[1] })) {\r\n           list.push(item);\r\n          }\r\n          wx.setStorage({\r\n            key: 'historys',\r\n            data: list,\r\n          })\r\n          this.setData({\r\n            historyList: list\r\n          })\r\n          this.setData({\r\n            delectHistory: \"清楚历史记录\",\r\n            historyOrder: \"历史记录\"\r\n          })\r\n          // this.setData({ mydata: res.data})\r\n          expresses.where({\r\n            code:exp\r\n          }).count().then(res3=>{\r\n            if (res3.total == 0){\r\n              expresses.add({\r\n                data: {\r\n                  message: res.data,\r\n                  code: exp\r\n                }\r\n              })\r\n            } else {\r\n              // wx.showToast({\r\n              //   // title: '不能重复加'\r\n              // })\r\n            }\r\n          })\r\n         .then(res2 => {\r\n           if(res.data.State>1) {\r\n             wx.navigateTo({\r\n               url: '../Todetail/index',\r\n             })\r\n           }\r\n           wx.setStorage({\r\n             key: 'code',\r\n             data: exp,\r\n           }),\r\n             wx.setStorage({\r\n               key: 'nowcompany',\r\n               data: logistics[0],\r\n             })\r\n            \r\n          })\r\n        }\r\n      })\r\n    }\r\n  },\r\n复制代码数据请求成功以后打印出 res.data成功后做以下操作 全是小程序MVVM的思想的体现M -Model数据 模型V -view 页面 视图VM -ViewModel数据绑定到界面上 视图模型层->模板{{}}显示在历史记录中.为了防止第一次从storage中取不到键为historys的历史记录，这样子写比较好 let list = wx.getStorageSync(\"historys\")||[]; ,如果数组 list 为空或者已经不存在正在查询的快递单号，则添加 ，反之则不添加,存储 this.setData({historyList: list}) 页面重新渲染显示把当前快递单号对应的快递信息存储到云数据库上跳转到物流详情页面，显示。腾讯地图接口使用 最终效果见下图Todetil页面但是在手机端确总有个bug，样式里写了z-index表示元素的堆叠顺序，在手机端只出现地图，不过这只是一个效果。腾讯地图的接口需要在 腾讯地图开放品台注册申请，使用API获取当前地址经纬度信息，利用逆地址查询获取当前 位置，这里只是获取地图作为背景图片。可以看下我的源码在github上面这个页面的逻辑就是获取快递单号和公司代码，这里有四种情况两种界面效果，未查询到显示一种界面效果，这个很简单效果都一样，从首页查询到，搜索查询到，历史记录点击查询到显示另外一个界面状态，这种属于殊途同归，都是在onLoad函数中获取.onLoad(options) {\r\n    let company = wx.getStorageSync(\"company\");\r\n    this.setData({\r\n      company\r\n    })\r\n    let codeExpress=options.contentId\r\n    // console.log(codeExpress);\r\n    this.getLocation()\r\n    if(!codeExpress){\r\n      let code = wx.getStorageSync(\"code\")\r\n      console.log(code);\r\n      this.setData({\r\n        code,\r\n      })\r\n    }else{\r\n      var  Navcode = codeExpress.substr(5);\r\n      let company=codeExpress.substr(0,4);\r\n      console.log(company);\r\n      this.setData({\r\n        code:Navcode,\r\n        company:company\r\n      })\r\n      console.log(Navcode);\r\n    }\r\n    let code=this.data.code;\r\n   \r\n    expresses.where({\r\n      code:code\r\n    }).get().then(res=>{\r\n      this.setData({\r\n      tracesList:res.data,\r\n      Traces:res.data[0].message.Traces\r\n      })\r\n      console.log(res.data);\r\n      let Traces=this.data.Traces;\r\n       this.showdetail();\r\n       this.packageData(Traces);\r\n    })\r\n  \r\n  },\r\n复制代码组件使用这里使用来对话框组件， 点击 清楚历史记录 ，触发对话框。点击对话框确定，全部清楚历史记录点击对话框取消，隐藏对话框，不清楚历史记录组件Components使用首先在index.json中引入{\r\n     \"wxc-dialog\": \"/components/dialog/dialog\"\r\n}\r\n复制代码对应search.wxml中使用的代码在search.wxml中引入components中的dialog组件 dialog<view class='clear-history' bindtap='onSHowdialog'>{{delectHistory}}</view>\r\n     <wxc-dialog class=\"wxc-dialog\" title=\"确认全部清除\"bindcancel=\"onCancel\" bindconfirm=\"delectHistory\"></wxc-dialog>\r\n</view> \r\n复制代码组建的js是这样写的onGotUserInfo(e) {\r\n      this.triggerEvent('confirm', e)\r\n      //向外传递\r\n    }\r\n复制代码组件中的确定按钮调用组件自身的 onGotUserInfo 方法<button class=\"getUserInfo_btn\" open-type=\"getUserInfo\" lang=\"zh_CN\" bindgetuserinfo=\"onGotUserInfo\">确定</button>\r\n复制代码点击确定，触发search.js页面的 bindconfirm=\"delectHistory\" 事件，清除历史记录并回显页面页面可以向组件传递props数据，让组件在页面显示组件可以负责与页面调用部分的通信。请求封装的优化在util包中封装 ，使用promise 返回promise对象，可以then操作 通用性的对wx.request封装const $get = (url, data = {}) => {\r\n  //发送请求\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: url,\r\n      data: data,\r\n      method: 'GET', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT\r\n      // header: {}, // 设置请求的 header\r\n      success: function (res) {\r\n        resolve(res)\r\n      },\r\n      fail: function () {\r\n        reject()\r\n      },\r\n      complete: function () {\r\n      }\r\n    })\r\n  })\r\n}\r\nmodule.exports = {\r\n  $get,\r\n}\r\n复制代码首页中请求easy-mock中的数据就是使用了util类中对request的封装，可以实现多次调用，重复调用，实现了代码的复用性。 getList()函数用于获取数据getList(type) {\r\n    this.setData({\r\n    isLoading: true,\r\n      hasMore: true\r\n    })\r\n    type === 'down' ? this.setData({ page: 0 }) : null;\r\n    util.$get('https://www.easy-mock.com/mock/5bca919de6742c1bf8220b50/example/express#!method=get', ).then(res => {\r\n      if (res.statusCode == 200) {\r\n        this.processData(type, res.data.data.expressList)\r\n      }\r\n    }).catch(e => {\r\n      this.setData({\r\n        isLoading: true,\r\n        hasMore: false\r\n      })\r\n      wx.stopPullDownRefresh()\r\n      wx.showToast({ title: `网络错误!`, duration: 1000, icon: \"none\" })\r\n    })\r\n \r\n  },\r\n复制代码当页面请求数据到两页后，出现 查看全部 点击跳转到另外一个页面查看全部 这个text的 出现是onReachBottom()这个函数在起作用，每次到达页面底部，检查此时page的值，小于3，上拉刷新，负责停止刷新，把样式改为bottomshow 在模型层就是把 bottomshow 的值改为 true<text class='{{bottomshow== true? \"bottomshow\":\"hide\"}}' bindtap='watchMore'>查看全部</text>\r\n复制代码onReachBottom() {\r\n    if (!this.data.isLoading) { // 防止数据还没回来再次触发加载\r\n      return;\r\n    }\r\n    if(this.data.page<=3){\r\n      this.getList('up')\r\n\r\n    }else{\r\n      wx.stopPullDownRefresh()\r\n      this.setData({\r\n        bottomshow:true\r\n\r\n      })\r\n    }\r\n复制代码样式hide对用代码\r\n复制代码.hide{\r\n    display: none;\r\n   }\r\n复制代码toView巧妙使用效果预览selectCompany.wxml,这里外层循环了companyList列表，先输出右边的侧边栏A-Z，再输出列表项的大写字母A,B,C...，和该项的内层循环，内层循环了每一个大写字母对应了以该大写字母开头的公司列表， scroll-view 每一项动态设置 id='{{item.number}}' 设置 scroll-into-view=\"{{toView}}\" 当点击侧边栏的A，B，C，D...Z时，触发 bindtap='switchTab' 设置相对应的 toView 。这里有比较奇怪的一点，就是I字母没有以该字母出现的公司列表，原版菜鸟裹裹点击后回到A，我想用户要么不会去点击 ，要么点击邻近的不小心点错了。可以点击I时 ， scroll-into-view 到附近的去 给switchTab新增一个判断条件 搞定。switchTab(e){\r\n if (e.currentTarget.dataset.id==\"I\"){\r\n      this.setData({\r\n        curIndex: e.currentTarget.dataset.index,\r\n        toView: \"F\",\r\n      })\r\n\r\n    }\r\n    console.log(e);\r\n    this.setData({\r\n      curIndex:e.currentTarget.dataset.index,\r\n      toView: e.currentTarget.dataset.id,\r\n    })\r\n  },\r\n复制代码整个scroll-view代码<scroll-view class='company' scroll-y bindscrolltoupper=\"upper\" bindscrolltolower=\"lower\" scroll-into-view=\"{{toView}}\">\r\n    <view class='select-list'>\r\n      <view class='select-word' wx:for=\"{{scrollList}}\" wx:key=\"{{index}}\" data-index='{{index}}' data-id=\"{{item}}\" bindtap='switchTab'>\r\n        {{item}}\r\n      </view>\r\n    </view>\r\n    <view class='item-A' id='{{item.number}}' hover-stay-time='3000' wx:for=\"{{comList}}\" wx:key=\"{{index}}\" wx:for-item=\"item\" scroll-with-animation=\"true\" scroll-animation-duration=\"3000\">\r\n      <text>{{item.number}}</text>\r\n      <view class='company-item' wx:for=\"{{item.list}}\" wx:key=\"{{index}}\" bindtap='backwithData' data-text='{{item.text}}' data-src=\"{{item.pic}}\">\r\n        <image src='{{item.pic}}' class='item-image' mode='acpectFill'></image>\r\n        <text class='item-text'>{{item.text}}</text>\r\n        <icon>\r\n          <image src='{{item.likepic}}' class='icon'></image>\r\n        </icon>\r\n      </view>\r\n    </view>\r\n  </scroll-view>\r\n复制代码回显到上个页面 选择某一行时点击触发 bindtap='backwithData' wx.navigatBack()改变上个页面中的数据，存储公司标志，公司文本，公司代码Storage，上个页面获取数据显示。代码如下var pages = getCurrentPages();\r\n    var Page = pages[pages.length - 1];//当前页\r\n    var prevPage = pages[pages.length - 2];  //上一个页面\r\n    var info = prevPage.data //取上页data里的数据也可以修改\r\n    prevPage.setData({ src,company })//设置数据\r\n    wx.navigateBack({\r\n      \r\n    })\r\n\r\n复制代码云函数使用， 这里使用了云函数，查询数据库集合的符合条件的列表项并删除，云函数确实较高的权限，直接对云数据库进行修改，云控制台的权限同管理端，拥有所有权限， 但是数云函数有点不太好的就是每次修改都要上传部署。后面项目更新会继续使用云函数解决问题。这里只写了主要的常用的快递物流查询，如下图， 对于后面获取的数据的处理，因为获取的是倒叙的数据，我先用 packageData() 处理一下，把页面需要的单个数据或者列表整理出来，存储显示。结语\r\n总结一下就是用快递公司名字查找对应的编码，快递单号从用户输入或首页点击事件获得，然后请求查询，最后一个页面是显示的结果，还有路径标注任务没有完成，由于项目工程较大，只做了主要的一部分吧，关于组件封装，方法调用还有，效果展示应该会有更多激动人心的效果，项目就玩到这吧，再慢慢学习，慢慢补充。\r\n感谢各位读者的阅读，文章中如有错误或不妥之处，请不吝赐教。\r\n你的赞与肯定将会成为我代码之路上的一缕阳光，使我更加勇敢坚定的往前走。"}
{"title": "微信小程序 关于【canvas.drawImage 】完全显示图片问题 ", "author": "Rolan", "pub_time": "2018-11-30 00:32", "article_content": "问题描述问题产生对于微信小程序，canvas处理过程中，dramImage默认图片引用是有残缺的导入初始项目打开链接（原官网例子），浏览器唤醒微信开发这工具，打开连接之前需要下载好微信开发者工具，如已安装则直接唤起，没有则会提示下载目的通过对canvas绘图过程的修改，或者其样式的修改，达到完全显示，并自适应不同机型的目的解决方案准备工作  Page({\r\n   data:{\r\n     imgSrc: '', // 需要处理图片地址\r\n     imgW: '', // canvas 宽度\r\n     imgH: '', // canvas 高度\r\n     byclear: 1 // 比例，这里将iphon6- 375像素设置为1标准，以便在自适应上的转换\r\n   },\r\n   onReady() {\r\n    var that = this\r\n    // 根据屏幕的宽度计算标准比例值。这里讲375作为标准值\r\n    wx.getSystemInfo({\r\n      success: function(res) {\r\n        let byclear = res.screenWidth / 375\r\n        that.setData({\r\n          byclear\r\n        })\r\n      },\r\n    })\r\n   },\r\n   openAndDraw() { // 选择图片\r\n    var that = this\r\n    wx.chooseImage({\r\n      success: (res) => {\r\n        that.setData({\r\n          imgSrc: res.tempFilePaths[0],\r\n          res\r\n        })\r\n      }\r\n    })\r\n   },\r\n   checkwh(e) {\r\n    // 处理逻辑\r\n   }\r\n  })获取选择目标图片的宽高度~默认canvas 是无法获取图片的高度的，再者小程序里面没有 new Image()这个方法，只能通过标签组件image间接获取，所以我们需要在wxml中插入一个隐藏的标签image，隐藏方法我们设置display:none 或者hidden就可以了，注意不要wx:if, wx:if 不会触发bindload事件。  <image src=\"{{imgSrc}}\" bindload='checkwh' mode='widthFix' hidden/>\r\n  <canvas canvas-id=\"canvasIn\" class=\"canvas\"></canvas>在方法checkwh里面即可获取到图片宽高  checkwh(e){\r\n     // 实际宽度 e.detail.width 高度 e.detail.height\r\n     let whsrc = e.detail.height / e.detail.width\r\n     // 计算高宽，需要处理图片宽度小于屏幕宽度的时候 对应的canvas比例\r\n     \r\n  }canvas.scale 方案dramImage 绘图方法，我们可以通过对画布的放大缩小scale来完整绘制,继续在checkwh中进行处理.scale缩放比例很简单，我们只要计算出屏幕与图片的实际比例，对应缩小就可。即：375 * byclear / e.detail.width 这里要带上自适应比例，当然对于图片宽度小于屏幕的我们不做缩放处理  checkwh(e){\r\n     // 实际宽度 e.detail.width 高度 e.detail.height\r\n    let whsrc = e.detail.height / e.detail.width\r\n     // 计算高宽，需要处理图片宽度大于屏幕宽度的时候 对应的canvas比例\r\n    let res = this.data.res \r\n    let byclear = this.data.byclear\r\n    const ctx = wx.createCanvasContext('canvasIn', this);\r\n    // 对画布进行缩放，注意scale两个参数保持一致，即缩放比例都是一样的。保证宽高比一致\r\n    if (e.detail.width > 375 * byclear) ctx.scale(375 * byclear / e.detail.width, 375 * byclear / e.detail.width);\r\n    ctx.drawImage(res.tempFilePaths[0], 0, 0, e.detail.width, e.detail.height)\r\n    ctx.draw()\r\n    // 后续操作\r\n  }上面我们已经完整的将图片绘制到canvas中了，还不够，下面我们将设置设置canvas宽高大小，已达到完全展示  <canvas canvas-id=\"canvasIn\" class=\"canvas\" style=\"width:{{imgW}}rpx;height:{{imgH}}rpx;margin:0 auto;\">\r\n  </canvas>微信自适应单位是rpx，对于iphone 6 ，375px = 750rpx => 1px = 2rpx; 其他型号计算是带上比例byclear即可，然后图片小于屏幕宽度，不做处理，checkwh后续代码因此:  checkwh(e){\r\n    // 前面代码...\r\n      this.setData({\r\n        imgW: e.detail.width > 375 ? 750 : e.detail.width * 2 / byclear,\r\n        imgH: e.detail.width > 375 ? 750 * whsrc : e.detail.height * 2 / byclear\r\n      })\r\n  }canvas 缩放 zoom 方案zoom方案对比scale方案，比较好的地方在于，不用计算canvas的大小，也不用缩放比例，直接将原图的宽高设置成canvas的宽高，然后，通过zoom对canvas进行缩放，直接放代码额，这里的缩放比例，即为 图片宽度 / 750，注意这里不需要比例计算，css样式会自动进行样式比率计算关键wxml代码<canvas canvas-id=\"canvasIn\" class=\"canvas\" style=\"width:{{imgW}}rpx;height:{{imgH}}rpx;margin:0 auto;zoom:{{imgW > 750 ? 750 / imgW : 1}}\"></canvas>关键js代码  checkwh(e){\r\n    var vhsrc = e.detail.height / e.detail.width\r\n    let res = this.data.res\r\n    let byclear = this.data.byclear\r\n    const ctx = wx.createCanvasContext('canvasIn', this);\r\n    ctx.drawImage(res.tempFilePaths[0], 0, 0, e.detail.width, e.detail.height)\r\n    ctx.draw()\r\n    this.setData({\r\n      imgW: e.detail.width * 2 / byclear,\r\n      imgH: e.detail.height * 2 / byclear\r\n    })\r\n  },"}
{"title": "支付宝小程序框架浅析及如何在 mPaaS 内深度集成 ", "author": "Rolan", "pub_time": "2018-12-3 00:01", "article_content": "本文将结合阔悬在 iWeb 杭州站沙龙现场的分享《支付宝小程序在 mPaaS 中的深度集成实践》，介绍支付宝小程序框架的设计原理，以及如何在 mPaaS 体系中的深度集成支付宝小程序。分享内容将从以下两个方面展开：支付宝小程序框架的系统介绍 （支付宝小程序框架概述、应用层框架、Native SDK）mPaaS 技术架构与助力 （mPaaS 小程序、mPaaS 小程序 IDE、mPaaS MDS）2. 小程序简介：移动互联网新热点近来，小程序俨然成为了移动互联网的新热点。继 2017 年初微信正式推出微信小程序后，各个大厂陆续发布了各自的小程序 —— 支付宝小程序、百度小程序、头条小程序，小程序成为了各家移动互联网生态布局的重要一环。通过小程序生态可以引入大量的外部服务，不仅丰富了平台的能力，而且可以为平台带来大量的用户流量，从而使得平台具备无限的潜能。3. 支付宝小程序简介支付宝小程序是一种全新的开发模式，它运行在支付宝客户端，可以被便捷地获取和传播，为终端用户提供更优的用户体验。为方便小程序的开发者，支付宝小程序具有类似微信小程序的 DSL 和开发环境，降低小程序开发者的学习成本。4. 支付宝小程序框架浅析1. 基础需求小程序的本质需求是让第三方开发者可以接入，使得第三方开发的小程序可以在平台级应用中运行。对于这个需求，最简单的实现方案是：让外部开发者开发纯 H5 应用，在应用的H5 容器里打开，容器提供一些原生的接口供H5使用。比如在支付宝和微信上的“滴滴出行”以 H5 的形式运行在各自的平台中，这种模式看似还不错，但是实际上这种简单的方案不能满足这两个小程序的基础需求：体验： 作为一个“小程序”需要让体验接近原生，而上述像滴滴出行这些普通 H5 的体验不太行，包括启动速度、页面切换流畅度都有问题，跟原生体验没法比。管控： 作为一个平台必须对接入的应用有管控能力，必须能尽量精确控制应用的内容和类型，毕竟若出现非法应用平台是要承担责任的，H5 的方式太过自由，开发者可以随时改变整个应用的内容，平台难以检测到这些改变，无法管控。另外 H5 开发质量参差不齐，平台也无法管控。2. 框架概述为了实现小程序并满足上述的小程序的两个需求，小程序框架应运而生。我们先看下小程序框架大图，自上而下看。小程序代码： 这是小程序开发者使用小程序 DSL 及各种组件开发的小程序。小程序组件及 API： 这是小程序的组件及 API 层，提供了小程序所需的各种组件和小程序 API。小程序开发者只需要在基于这一层提供的组件及 API 进行小程序的开发。小程序应用层框架： 这是小程序运行的框架层，它基于 React 实现了小程序的运行框架。该层主要包含小程序的逻辑处理引擎及渲染层。Native SDK： 该层提供了小程序所需的 Native 能力，通过J avaScriptCore 为小程序的 JS 层框架提供大量的 Native API，此外该层还提供了小程序包管理、后台保活等基础能力。React 和 React Native： 这一层是小程序底层运行环境，分别对应于 Web 和 Native 环境，使得小程序可运行在 WebView 和 iOS/Android 上。系统层： 即 Web 内核、iOS 和 Android，是系统级的平台层。目前支付宝的小程序使用的是 React 版，蚂蚁内部的其他 App 有在使用 React Native 版的小程序。3. 应用层框架我们一起看下小程序应用层框架。每个小程序的代码分为两部分——逻辑处理和视图渲染，分别运行在 worker （js 引擎） 以及 render （渲染层）中。worker 运行小程序的逻辑处理代码 ，包括事件处理，api 调用以及框架的生命周期管理。 worker 只有一个，方便 App 数据在页面间的共享和交互。render 运行小程序的渲染代码 ，主要包括模版、样式和框架的跨终端的 js 组件或 native 组件，获取逻辑层的数据操作渲染引擎（React/ReactNative）进行渲染，render 在小程序中可以有多个。worker 和所有的 render 都建立连接 ，将需要渲染的数据传递给对应的 render 进行渲染，worker 也会将 api 调用转给 Native SDK 处理。render 则将组件的触发事件送到对应的 worker 处理 ，同时接受 worker 的调用进行重新渲染。 render 可以看作一个无状态的渲染终端，小程序的状态都保留在 worker 内。可见该框架可以做到，JS 逻辑代码与页面渲染分离并行执行，不会出现 JS 代码执行时卡住页面渲染的情况，进而提升渲染性能。多个页面可以共享一个 JS 运行环境，数据可以很方便地共享，整个小程序生命周期里共享同一个上下文，更接近 App 的开发体验。小程序的模板样式是自定义的格式，这样可以做到开发时使用固定的 DSL，不依赖底层的渲染引擎，这样引擎的优化升级不会造成上层的小程序代码的不兼容，并且渲染行为是完全是可控的。4. Native SDK我们再看 Native 层，在支付宝中是由 Nebula H5 容器负责实现，它为小程序提供 Native 能力，为小程序提供的包管理、后台保活等功能。Native API ：小程序调用的 API 中有部分功能需要在 native 中实现，这部分 API 通过桥接调用进入对应的 Native API。包管理 ：负责小程序包的下载、存储、加载。小程序包的下载具有多种策略，可以满足小程序的预下载、强制更新等需求。后台保活 ：小程序在后台可以存活 5 分钟，使得用户在下次打开时可以获得更好的体验。5. 小结现在让我们回到前面提到的两个小程序的基本需求，体验和管控。我们看下框架是如何实现这两个需求的。对于体验需求，主要有以下几点：框架对小程序做了逻辑处理和视图渲染的分离以提升渲染性能对于较重的组件（地图）使用 Native 实现以提升性能小程序公共资源预置在小程序框架以提升加载性能后台保活机制提高二次启动速度对于管控需求，主要有两点：小程序开发只能使用框架提供的自定义的模板样式JS 代码运行在与 Webview 隔离的 JS 引擎中，无法操作浏览器 DOM5. mPaaS 技术架构与助力1. 支付宝小程序与 mPaaS小程序这么有优势，那能否把支付宝小程序放到其他 APP 中运行呢？答案是肯定的，借助 mPaaS，小程序技术不仅在蚂蚁金服内部使用，也能够提供给外部用户使用。首先简单介绍下什么是 mPaaS，mPaaS 全称是 Mobile Platform as a Service，即移动端的 PaaS 。作为蚂蚁金服独创的移动研发平台，它源于支付宝近 10 年的移动技术的沉淀，为移动开发、测试、运营及运维提供云到端的一站式解决方案，能有效降低技术门槛、减少研发成本、提升开发效率，协助生态伙伴快速搭建稳定高质量的移动 App。2. mPaaS 小程序再来看下什么是 mPaaS 小程序，它是在支付宝小程序的基础上做了瘦身、去依赖的小程序 SDK，为了能便捷的输出给其他 App 快速地搭建出小程序平台。它保持和支付宝小程序一样的模板样式和通用 API，仅仅少量的像授权这样的开放的 API 需要客户自定义开发。借助 mPaaS 小程序，可以做到一套小程序代码，在支付宝和自己的 App 上双端投放和运行，甚至可以构建出自己的小程序生态体系。这里和大家分享下 mPaaS 小程序在其他 App 中集成时可能需要解决的问题：SDK 集成冲突，这个是多个 SDK 集成可能会遇到的共性问题，一般通过去除不要的 SDK 或者对 SDK 中部分符号名做针对性的修改。开放 API 定制开发，开放 API 依赖后端的服务，比如用户授权这个 API，它需要获取用户的账号信息，那么就需要重写这个 API 的具体实现，去访问 App 的用户中心服务以实现授权功能。小程序框架提供了一套自定义和重写 API 的插件机制，能快速的去重写某个 API，甚至添加一个新的 API。3. mPaaS 小程序 IDE小程序的开发除了可使用支付宝小程序开放平台提供的 IDE，还可以使用 mPaaS 版的小程序 IDE。通过 mPaaS 版的 IDE 可以导出本地的小程序包，后续在 mPaaS 发布平台中使用这个本地包直接发布。未来，小程序 IDE 将会与 mPaaS 直接打通，在 IDE 中可以直接完成 mPaaS 小程序的开发、测试和发布这一系列的开发运维体验。4. mPaaS MDS小程序技术的一个基础的能力，就是小程序发布系统。mPaaS 小程序的发布服务是由 mPaaS 的移动发布系统（MDS）提供的。MDS 提供多种发布策略，能够在正式发布之前进行多种类型的灰度测试。MDS 提供增量差分包更新能力，可减少更新包的体积，在移动端网络不稳定场景中发挥优势。mPaaS MDS 控制台目前，mPaaS 小程序已在众多政务项目中落地服务，帮助政务小程序在支付宝和自有 App 双端投放运行。相同的业务功能使用小程序实现，在支付宝和自有 App 中可进行共用，能显著地降低开发成本，做到业务的快速上线及动态更新。如果想要进一步了解 mPaaS 小程序，可以复制地址到浏览器中打开：t.cn/ELBlvEr关于小程序框架的优化思路或具体实践，如果你有任何疑问或建议，欢迎随时和我们一同交流。往期阅读《开篇 | 模块化与解耦式开发在蚂蚁金服 mPaaS 深度实践探讨》《支付宝移动端动态化方案实践》《支付宝客户端架构解析：iOS 容器化框架初探》《支付宝客户端架构解析：Android 容器化框架初探》《支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」》《Demo Show | 蚂蚁金服 mPaaS IDEA 插件实践》《支付宝客户端架构分析：自动化日志收集及分析》"}
{"title": "诗和远方：旅行小账本云开发实战 ", "author": "Rolan", "pub_time": "2018-12-3 00:25", "article_content": "最近沉迷小程序开发，发现了一款功能、界面、体验俱佳的小程序“旅行小账本”。该小程序由腾讯旅游操刀制作，简约大气，功能性强。借着最近云开发的热潮，着手做了个简约版——\"旅行小账本\"。效果比较满意，毕竟前后台一人单干。Talk is cheap！show~IDE微信开发者工具VSCode小程序开发必然少不了微信开发者工具，再加上其对云开发的全面支持，再好不过的开发利器。但熟悉微信开发者工具的朋友们应该知道，它不支持Emmet缩写语法，并且wxml的属性值默认用单引号表示(强迫症表示很难受)。而VSCode很好的补足了微信开发者工具的不足之处，并且支持多元化插件开发，轻量好用。所以这里推荐采用微信开发者工具+VSCode配合开发。微信开发者工具负责调试、模拟小程序运行情况，VSCode负责代码编辑工作。二者各司其职，会使开发更加的高效、便捷。总体架构该项目基于小程序云开发，使用的模板是云开发快速启动模板由于是个全栈项目，前端使用小程序所支持的wxml + wxss + js开发模式，命名采用BEM命名规范。后台则是借助云数据库+云储存进行数据管理。项目总体结构|-travelbook  项目名\r\n    |-cloudfunctions  云函数模块\r\n        |-deleteItems 级联删除--云函数\r\n        |-getTime     获取时间--云函数\r\n    |-miniprogram  项目模块\r\n        |-components  自定义组件\r\n            |-accountCover  账本封面组件\r\n            |-spendDetail   支出细节组件\r\n        |-pages  页面\r\n            |-accountBooks     总账本页\r\n            |-accountCalendar  账本日历页\r\n            |-accountDetail    支出细节页\r\n            |-accountList      支出明细页\r\n            |-accountPage      选定账本页\r\n            |-editAccount      账本编辑页\r\n            |-index            首页\r\n        |-vant-weapp   有赞vant框架组件库\r\n            |-···      系列组件...\r\n        app.js         全局js\r\n        app.json       全局json配置\r\n        app.wxss       全局wxss\r\n复制代码逆向工程在做该小程序之前，有必要进行项目的逆向工程，进一步解构每一个页面，从而深入了解这款小程序的交互细节。那么现在我假设自己为腾讯旅游的产品设计师，在绘制完界面原型后，撰写了相应的交互文档。当然解构过程中可能有些细节处理并没有那么仔细到位...以下是我绘制的界面原型接下来对每个页面的细节进行解构，并完成简单的wxml结构<!--switchList使用定位布局-->\r\n<view bindtap=\"switchList\" class=\"list\"></view>\r\n\r\n<!--newAccount使用flex布局-->\r\n<view class=\"newAccount\" bindtap=\"createNewAccount\">\r\n    <view class=\"desc\">旅行中的每一笔开支都有独特的意义！</view>\r\n    <image src=\"{{}}\"></image>\r\n    <view class=\"title\">创建一个新账本</view>\r\n</view>\r\n复制代码<!--整体用flex + 百分比布局-->\r\n<input type=\"text\" class=\"accuntName\" placeholder=\"旅行账本名称\" bindinput=\"getInput\" />\r\n  \r\n<van-panel title=\"选择封面\" class=\"panel\">\r\n    <van-row class=\"imageBox\">\r\n        <!--使用wx:for遍历数据库账本图片信息-->\r\n        <van-col span=\"8\" class=\"imgCol\" bindtap=\"selectThis\">\r\n            <image class=\"select\" src=\"{{}}\"></image>\r\n        </van-col>\r\n        \r\n        <van-col span=\"8\">\r\n            <view class=\"addBox\" bindtap=\"useMore\">更多封面</view>\r\n        </van-col>\r\n    </van-row>\r\n</van-panel>\r\n\r\n<button type=\"primary\" bindtap=\"save\">保存</button>\r\n<button type=\"warn\" bindtap=\"delete\">删除</button>\r\n复制代码<view class=\"accountDesc\" bindtap=\"viewDetail\">\r\n    <!--使用wx:for遍历数据库账本信息-->\r\n    <view class=\"accountName\">\r\n        <view>{{}}</view>\r\n        <view class=\"accountTime\">{{}}</view>\r\n    </view>\r\n    \r\n    <!--绝对定位-->\r\n    <image class=\"updateImg\" catchtap=\"editAccount\" src=\"{{}}\"></image>\r\n</view>\r\n复制代码<!--switchList使用定位布局-->\r\n<view bindtap=\"switchList\" class=\"list\"></view>\r\n\r\n<view class=\"account__list-year\">{{}}</view>\r\n<view class=\"account__list-new account__list-public\" bindtap=\"createNewAccount\">\r\n    <!--日期小圆点-->\r\n    <view class=\"account__list-point\"></view>\r\n    <view class=\"account__list-time\">{{}}</view>\r\n    <image src=\"{{}}\"></image>\r\n    <view class=\"account__list-title\">创建一个新账本</view>\r\n</view>\r\n\r\n<!--使用wx:for遍历数据库账本信息-->\r\n<view class=\"account__list-item account__list-public\" bindtap=\"viewDetail\">\r\n    <!--日期小圆点-->\r\n    <view class=\"account__list-point\"></view>\r\n    <image src=\"{{}}\" mode=\"aspectFill\"></image>\r\n    <view class=\"account__list-name\">{{}}</view>\r\n    <view class=\"account__list-time\">{{}}</view>\r\n    <image class=\"account__list-update\" catchtap=\"editAccount\" src=\"{{}}\"></image>\r\n </view>\r\n复制代码<view class=\"account__spend\">\r\n    <image bindtap=\"getCalendar\" class=\"account__spend-calendar\" src=\"{{}}\"></image>\r\n    <view class=\"account__spend-text\">\r\n        <view class=\"account__spend-total\">总花费(元)</view>\r\n        <view class=\"account__spend-num\">{{}}</view>\r\n    </view>\r\n    <image bindtap=\"accountAnalyze\" class=\"account__spend-detail\" src=\"{{}}\"></image>\r\n</view>\r\n\r\n<view class=\"account__show-time\">今天</view>\r\n    <view class=\"account__show-detail\">\r\n        <view class=\"account__show-income account__show-public\">\r\n        <view class=\"account__show-title\">收入(元)</view>\r\n        <text class=\"account__show-in\">+{{}}</text>\r\n    </view>\r\n    <view class=\"account__show-spend account__show-public\">\r\n        <view class=\"account__show-title\">支出(元)</view>\r\n        <text class=\"account__show-out\">-{{}}</text>\r\n    </view>\r\n</view>\r\n\r\n<!--使用wx:for遍历数据库账本信息-->\r\n<view class=\"account__show-items-spend\">\r\n    <view>\r\n        <image src=\"{{}}\"></image>\r\n    </view>\r\n    <text>{{}}</text>\r\n    <text class=\"account__show-items-money\">{{}}</text>\r\n</view>\r\n复制代码<!--日历使用极点日历的插件-->\r\n<!--json中做配置-->\r\n\"usingComponents\": {\r\n    \"calendar\": \"plugin://calendar/calendar\"\r\n}\r\n\r\n<!--js改变样式-->\r\ndays_style.push({\r\n  month: 'current',\r\n  day: new Date().getDate(),\r\n  color: 'white',\r\n  background: '#e0a58e'\r\n})\r\n\r\n<!--wxml中引用-->\r\n<calendar weeks-type=\"cn\" cell-size=\"50\" next=\"{{true}}\" prev=\"{{true}}\"\r\n    show-more-days=\"{{true}}\" calendar-style=\"demo6-calendar\"\r\n    header-style=\"calendar-header\"board-style=\"calendar-board\" active-type=\"rounded\" \r\n    lunar=\"true\" header-style=\"header\"calendar-style=\"calendar\"days-color=\"{{days_style}}\">\r\n</calendar>\r\n复制代码<!--顶栏日期及收支结构-->\r\n<view class=\"account__title\">\r\n    <text class=\"account__title-time\">{{}}</text>\r\n    <text class=\"account__title-spend\">支出{{}}元 收入{{}}元</text>\r\n</view>\r\n\r\n<!--收支细节结构 使用flex弹性布局-->\r\n<view class=\"account__detail\">\r\n    <image src=\"{{}}\"></image>\r\n    <view class=\"account__detail-name\">{{}}</view>\r\n    <view class=\"account__detail-money\">{{}}</view>\r\n</view>\r\n复制代码<!--使用vant框架的van-tabs组件-->\r\n<!--并封装自定义组件复用收支页，自定义组件后面会详细说明-->\r\n<van-tabs active=\"{{ active }}\" bind:change=\"onChange\">\r\n  <van-tab title=\"支出\">\r\n    <spendDetail detail=\"{{detail}}\" accountKey=\"{{accountKey}}\"></spendDetail>\r\n  </van-tab>\r\n  <van-tab title=\"收入\">\r\n    <spendDetail detail=\"{{income}}\" accountKey=\"{{accountKey}}\"></spendDetail>\r\n  </van-tab>\r\n</van-tabs>\r\n复制代码云开发在做完逆向工程的解构，页面基础结构基本搭建完成。但页面依旧是静态的，需要数据来填充。所以第二步就是数据库的设计。而小程序的云控制台恰好提供了数据的操作功能，为数据驱动提供基石。云数据库设计云数据库是一种NoSQL数据库。每一张表是一个集合。值得注意的是在设计数据库时， _id和 _openid 这两个字段需要带上。 _id 是表的主键，而 _openid 是用户标识，每个用户都有不同的 _openid ，可区分不同用户。以下是项目中的数据表设计cover_photos 账本封面表  用于存储创建账本时需要的封面信息\r\n    - _id\r\n    - _openid\r\n    - cover_index 封面索引\r\n    - cover_url   封面url\r\n    - isSelected  封面是否选中\r\n复制代码accounts 账本表   用于存储用户创建的账本\r\n    - _id\r\n    - _openid\r\n    - accountKey  账本唯一标识\r\n    - coverUrl    账本封面\r\n    - i           账本索引\r\n    - inputValue  账本名字\r\n    - now         账本创建时间\r\n    - spend       账本总花费\r\n复制代码account_detail 支出类型表   用于存储消费类型\r\n    - _id\r\n    - _openid\r\n    - detail       类型细节\r\n    - pic_index    消费类型索引\r\n    - pic_url      未点击时的图片\r\n    - pic_url_act  点击后的图片\r\n    - type         消费类型\r\n复制代码account_income 收入类型表   用于存储收入类型\r\n    - _id\r\n    - _openid\r\n    - pic_index    收入类型索引\r\n    - pic_url      未点击时的图片\r\n    - pic_url_act  点击后的图片\r\n    - type         收入类型\r\n复制代码spend_items   消费明细表\r\n    - _id\r\n    - _openid\r\n    - accountKey   账本唯一标识\r\n    - address      消费地点\r\n    - desc         消费描述\r\n    - fullDate     消费时间\r\n    - money        消费金额\r\n    - pic_type     消费类型\r\n    - pic_url      消费类型图片\r\n复制代码云储存管理这是个非常实用的板块。类似于百度云盘，它提供了文件存储、上传与下载功能。除此之外，它还会将你所上传的资源自动进行压缩操作，并生成一个地址供你引用。该项目中的一些图片资源就是存在于此，然后在云数据库的字段中引用这些资源地址即可，十分方便，不必在本地存储，占用小程序内存。云函数设计云函数简单来说就是在云后端(Node.js)运行的代码，本地看不到这些代码的执行过程，全封闭式只暴露接口供本地调用执行，本地只需等待云端代码执行完毕后返回结果。这也是面向接口编程的思想体现。项目中的云函数设计// getTime  获取当前时间并格式化为 yyyy-mm-dd\r\n\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\n// 初始化云函数\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  var date = new Date()\r\n  var seperator1 = \"-\"\r\n  var year = date.getFullYear()\r\n  var month = date.getMonth() + 1\r\n  var strDate = date.getDate()\r\n  if (month >= 1 && month <= 9) {\r\n    month = \"0\" + month\r\n  }\r\n  if (strDate >= 0 && strDate <= 9) {\r\n    strDate = \"0\" + strDate\r\n  }\r\n  // 格式化当前时间\r\n  var currentdate = year + seperator1 + month + seperator1 + strDate\r\n  return currentdate\r\n}\r\n复制代码// deleteItems  批量删除，云数据库的批量删除只允许在云函数中执行\r\n\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\n// 初始化云函数\r\ncloud.init()\r\n\r\n// 连接云数据库\r\nconst db = cloud.database()\r\nconst _ = db.command\r\n\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  try {\r\n    return await db.collection('spend_items')\r\n      .where({\r\n        accountKey: event.accountKey\r\n      })\r\n      .remove()\r\n  } catch (e) {\r\n    console.error(e)\r\n  }\r\n}\r\n复制代码MVVM界面有了，数据有了。万事俱备，只欠东风！所以下一步就是MVVM的设计。小程序本质就是基于MVVM所设计的，在MVVM的世界里，数据是灵魂，一切都由数据来驱动。账本页显示账本页有两种显示的风格，左上角的按钮可以来回切换风格，下拉可刷新页面，显示accounts数据表中存储的账本信息。显示时有个小细节，需要根据创建的时间先后来显示，越晚创建的越先显示。// 页面数据设计, 在wxml中使用{{}}符号引用数据，数据就动态显示到了页面上\r\ndata: {\r\n    isList: false, // 转换页面风格的标识 true为竖向风格 false为横向风格\r\n    accounts: [],  // 存储查询的账本数据\r\n    now: null,     // 存储当日时间\r\n    year: null     // 存储年份\r\n}\r\n\r\n // 转换显示风格\r\nswitchList() {\r\n    // 设置页面风格样式\r\n    let isList = !this.data.isList\r\n    this.setData({\r\n      isList\r\n    })\r\n    wx.setStorage({\r\n      key: \"isList\",\r\n      data: isList\r\n    })\r\n}\r\n\r\n// 获取页面风格转换标识\r\nvar isList = wx.getStorageSync('isList')\r\n    \r\n// 查询账本\r\ndb.collection('accounts')\r\n  .get({\r\n    success: res => {\r\n      this.setData({\r\n        accounts: res.data.reverse(),  // 反转数组，优先显示创建早的账本\r\n        isList\r\n      })\r\n      wx.hideLoading()\r\n    }\r\n  })\r\n\r\n// 调用云函数接口 获取当前日期\r\nwx.cloud.callFunction({\r\n    // 云函数接口名就是创建的云函数名字，这里是'getTime'\r\n    name: 'getTime',\r\n    success: (res) => {\r\n    let year = res.result.split('-')[0]\r\n    this.setData({\r\n      now: res.result,\r\n      year\r\n    })\r\n    },\r\n    fail: console.error\r\n})\r\n复制代码账本页增删改账本页通过调用相应的云数据库API，可进行一系列的增删改操作。值得一提的是，修改时需要表单回显，删除时需要级联删除。因为一个账本中有许多收支情况，spend_items表就是进行收支记录，所以删除账本时需要级联删除对应的spend_items表中的收支信息。一些重要的逻辑封面单选逻辑data: {\r\n    images: [],      // 封面数组\r\n    selectImg: null, // 选择其它封面\r\n    isSelected: {},  // 选中的图片\r\n    inputValue: '',  // 账本名字\r\n    now: null,       // 当前时间\r\n    account: {}      // 传入账本信息\r\n}\r\n\r\n  // 单选逻辑 通过构造{'0': isSelected}来实现\r\nselectThis(e) {\r\n    let index = e.currentTarget.dataset.index\r\n    let coverUrl = e.currentTarget.dataset.coverurl\r\n    let is = this.data.isSelected[index]\r\n    let obj = {\r\n        coverUrl\r\n    }\r\n    // obj[index] 属性动态改变\r\n    obj[index] = !is\r\n    obj.i = index\r\n    this.setData({\r\n        isSelected: obj\r\n    })\r\n}\r\n复制代码表单回显逻辑// 页面加载时先通过对应的accountKey, 得到回显信息\r\nlet { i, id, value, url, accountKey } = options\r\nphotos.get({\r\n    success: res => {\r\n    this.setData({\r\n      images: res.data,\r\n      account: {\r\n        id,\r\n        value,\r\n        url,\r\n        i,\r\n        accountKey\r\n      },\r\n      isSelected: obj\r\n    })\r\n    wx.hideLoading()\r\n  }\r\n})\r\n// 修改\r\nsave() {\r\n    let { id } = this.data.account\r\n    let { i, coverUrl, value } = this.data.isSelected\r\n    // 若没修改 则为之前的value\r\n    let inputValue = this.data.inputValue || value\r\n    \r\n    db.collection('accounts')\r\n      .doc(id)\r\n      .update({\r\n        data: {\r\n            inputValue,\r\n            coverUrl,\r\n            i\r\n        }\r\n    })\r\n}\r\n复制代码级联删除逻辑db.collection('accounts')\r\n    .doc(this.data.account.id)\r\n    .remove()\r\n    .then(() => {\r\n      wx.hideLoading()\r\n      wx.showToast({\r\n        title: '删除成功'\r\n      })\r\n      setTimeout(() => {\r\n        wx.reLaunch({\r\n          url: '../accountBooks/accountBooks'\r\n        })\r\n      }, 400)\r\n    })\r\n  // 调用deleteItems云函数, 传入对应accountKey主键, 通过云函数批量删除\r\n  wx.cloud.callFunction({\r\n    name: 'deleteItems',\r\n    data: {\r\n      accountKey\r\n    }\r\n  })\r\n复制代码账本页收支因为收入与支出页面基本类似，所以使用自定义组件封装，可以复用。// 封装spendDetail组件\r\n// 注册组件\r\nproperties: {\r\n    detail: {\r\n      type: Object\r\n    },\r\n    accountKey: {\r\n      type: Number\r\n    },\r\n    isSpend: {\r\n      type: Boolean\r\n    }\r\n}\r\n\r\n// 引用组件\r\n<van-tab title=\"支出\">\r\n    <spendDetail detail=\"{{detail}}\" accountKey=\"{{accountKey}}\" isSpend=\"{{isSpend}}\"></spendDetail>\r\n  </van-tab>\r\n  <van-tab title=\"收入\">\r\n    <spendDetail detail=\"{{income}}\" accountKey=\"{{accountKey}}\" isSpend=\"{{isSpend}}\"></spendDetail>\r\n</van-tab>\r\n复制代码收入与支出类型icon选择使用两个view来存放，通过选择不同类型，跳转不同的icon// js\r\ndata: {\r\n    address: '',\r\n    money: 0,\r\n    desc: '',\r\n    selectPicIndex: 0,\r\n    selectIndex: 0\r\n}\r\n// 选择消费类别\r\nselectSpend(e) {\r\n  let { index } = e.currentTarget.dataset\r\n  let { selectPicIndex } = this.data\r\n  selectPicIndex = index\r\n  this.setData({\r\n    selectPicIndex\r\n  })\r\n},\r\n\r\n// 选择消费类别中的细节\r\nselectSpendDetail(e) {\r\n  let { index } = e.currentTarget.dataset\r\n  let { selectIndex } = this.data\r\n  selectIndex = index\r\n  this.setData({\r\n    selectIndex\r\n  })\r\n}\r\n\r\n// wxml\r\n// 消费类型\r\n<view class=\"expense\">\r\n  <block wx:for=\"{{detail}}\" wx:key=\"index\">\r\n    <view class=\"expense__type\" bindtap=\"selectSpend\" data-index=\"{{index}}\">\r\n      <block wx:if=\"{{selectPicIndex == item.pic_index}}\">\r\n        <view class=\"expense__type-icon\" style=\"background-color: #e64343\">\r\n          <image src=\"{{item.pic_url_act}}\"></image>\r\n        </view>\r\n      </block>\r\n      <block wx:else>\r\n        <view class=\"expense__type-icon\">\r\n          <image src=\"{{item.pic_url}}\"></image>\r\n        </view>\r\n      </block>\r\n      <view class=\"expense__type-name\">{{item.type}}</view>\r\n    </view>\r\n  </block>\r\n</view>\r\n\r\n// 消费子类型\r\n<view class=\"detail\">\r\n  <block wx:for=\"{{detail[selectPicIndex].detail}}\" wx:key=\"index\">\r\n    <view class=\"detail__type\" bindtap=\"selectSpendDetail\" data-index=\"{{index}}\">\r\n      <image class=\"detail__type-icon\" src=\"{{item.detail_url}}\"></image>\r\n      <block wx:if=\"{{selectIndex == item.detail_index}}\">\r\n        <view class=\"detail__type-name\" style=\"color: #f86319; border-bottom: 1rpx solid #f86319;\">\r\n          {{item.detail_type}}\r\n        </view>\r\n      </block>\r\n      <block wx:else>\r\n        <view class=\"detail__type-name\" style=\"border-bottom: 1rpx solid #e4e2e2;\">\r\n          {{item.detail_type}}\r\n        </view>\r\n      </block>\r\n    </view>\r\n  </block>\r\n</view>\r\n复制代码账本页明细因为收支明细中需要显示每一天的消费信息，所以需要将数据表中的数据通过时间来分类，分成若干个数组，页面从而使用wx:for来遍历这些数组。在显示之前，首先需要判断有无收支信息。// 通过时间分类算法  {} => [ [{时间1}], [{时间2}], [{时间3}] ]\r\narr.forEach(item => {\r\n  if (!_this.isExist(item.fullDate, dateArr)) {\r\n    dateArr.push([item])\r\n  } else {\r\n    dateArr.forEach(res => {\r\n      if (res[0].fullDate == item.fullDate) {\r\n        res.push(item)\r\n      }\r\n    })\r\n  }\r\n})\r\n\r\n// 使用map 方法构造 [{}, {}, {}, ...] 类型数组\r\ndateArr = dateArr.map((item) => {\r\n  let spend = 0\r\n  let income = 0\r\n  item.forEach(res => {\r\n    if (res.money > 0) {\r\n      spend += res.money\r\n    } else {\r\n      income += (-res.money)\r\n    }\r\n  })\r\n  return {\r\n    item,\r\n    spend,\r\n    income\r\n  }\r\n})\r\n\r\n// 判断自身是否存在数组中\r\nisExist(item, arr) {\r\n    for (let i = 0; i < arr.length; i++) {\r\n      if (item == arr[i][0].fullDate)\r\n        return true\r\n    }\r\n    return false\r\n  }\r\n复制代码以上是小程序中比较复杂的逻辑实现。一点感悟提交日志 github.com/FightingHao…之前做项目时，只是在github提交时草草写一句话当做提交日志。这次做了一个比较正式提交日志，做这个的初衷其实是为了监督自己不要偷懒，坚持每天完成项目一部分，并总结不足之处。学而时习之才能成长的更快！篇幅有限，奉上项目 github 如果你喜欢这篇文章或是这个项目，不妨进去点个Star支持下，有兴趣的朋友欢迎Fork，一起探讨知识或是旅行~~当然也希望您能留下一些宝贵的建议。感激不尽！生活不止眼前的苟且，还有诗和远方。最后要感谢腾讯旅游的各位大大设计出一个这么简洁美观大方的小程序产品，实属良心之作！"}
{"title": "小程序自动埋点教程 ", "author": "Rolan", "pub_time": "2018-12-3 00:36", "article_content": "在这个大数据的时代里，数据是一个互联网发展的核心，除了对客户分析重要之外，公司对自己的产品能否客观的掌控也十分重要。埋点的意思是在项目关键位置注入代码，代码会向服务器发送设备信息、用户操作、时间点等信息。代码埋点最简单实现埋点的方法，是让开发者在需要的地方添加一句代码，用来向服务器发起请求，汇报情况自动埋点埋点的代码和业务逻辑的代码是没有直接联系的，如果让开发者手动的在项目中添加代码，会增加项目耦合。不仅开发者麻烦，后期维护也增加了难度。所以能通过引入外部代码，自动在最常用的位置注入埋点，是更合理的一种手段。就web端而言，一般选择的注入点有：页面加载完成、用户点击链接、登录登出等场景。小程序生命周期小程序App函数有：onLaunch、onShow、onHide、onError、onPageNotFound五个周期方法，小程序启动时会走onLaunch方法。小程序有后台机制，当用户关闭当前小程序，回到微信页面时，小程序不会直接结束进程，而是到内存占用到了一定量后，微信会自动对小程序进行销毁。onShow与onHide两个方法对应的就是小程序前后台转换，当用户从微信到小程序时，onShow会被调用；反之，用户从小程序到微信界面时，会调用onHide。小程序每个页面都是一个Page，每个Page有：onLoad/onReady/onShow/onHide/onUnload/onShareAppMessage/onPullDownRefresh等等周期方法。小程序埋点在小程序各个生命周期埋点，可以有效的收集到用户操作数据，正常小程序开发者，这些周期方法都是由开发者声明的。开发者可以在周期方法中写入汇报服务器代码，但就像之前说的，通过外部代码实现这一功能会是更好的选择。所以我们需要一些功能代码，实现自动注入埋点。App与Page函数小程序像是一个定制的webview，打开App时，小程序首先会调用声明的App函数，所以我们可以通过劫持App函数，注入埋点。var oldApp = App\r\nApp = function(args) {\r\n    ... // 改写周期方法\r\n    oldApp(args)\r\n}\r\n复制代码如以上代码所示，劫持App函数后，进行改写周期函数，最后运行真正的App函数。 args及为小程序app.js中配置的模型，包含了App的周期函数和globalData对象，例如，要在onLaunch方法中注入埋点：function customLaunch(opt) {\r\n    track() // 向服务器汇报\r\n}\r\nvar oldLaunch = args.onLaunch\r\nargs.onLaunch = function(opt) {\r\n    if (oldLaunch) { // 如果小程序开发者有声明\r\n        oldLaunch.call(this, opt)\r\n    }\r\n    customLaunch.call(this, opt) // 自定义周期方法\r\n}\r\n复制代码其他的周期方法，也可以用这种方式进行改写。扩展自动埋点每个应用的需求都会不一样，所以也需要给自动埋点赋予自定义埋点的能力。 在每个page的index.js中，我们可以用 getApp() 方法获取到小程序全局对象，App函数中的this指向的就是这个全局对象，所以我们可以在上面代码块中定义自定义埋点方法：--- app.js\r\nargs.onLaunch = function(opt) {\r\n    this[track] = function() {\r\n        ... // 自定义埋点代码\r\n    }\r\n    ...\r\n}\r\n\r\n--- Page的index.js\r\nvar app = getApp()\r\napp.track(name) // 发送自定义报文\r\n复制代码小程序天然的生命周期相对于web应用来说，对埋点需求友好很多，如何控制和实现可视化埋点是我们需要努力的方向。"}
{"title": "小程序api的promisefy ", "author": "Rolan", "pub_time": "2018-12-6 00:32", "article_content": "微信小程序的大部分api是 异步 的。简单地举个:chestnut:: wx.showToast(Object object)wx.showToast({\r\n      title: '成功',\r\n      icon: 'success',\r\n      duration: 2000,\r\n      success: function(res) { // TODO },\r\n      fail: function(err) { // TODO }\r\n   });\r\n复制代码事实上这样的api 写的真够好，但是对于使用者来说并不友好。所以，为了方便同事们更加舒爽地去写代码，于是我开始琢磨封装一个小程序api的 promisefy 的函数。那么到底怎么封装呢？// defaultProps为默认属性，extraProps为定制化的属性\r\n /**\r\n * promisefy 微信内置函数\r\n * @param fn\r\n * @return { promise }\r\n */\r\n  const promisefy = fn => defaultProps => extraProps => new Promise((resolve, reject) => fn({\r\n    ...defaultProps,\r\n    ...extraProps,\r\n    success: res => resolve(res),\r\n    reject: err => reject(err),\r\n  }));\r\n复制代码那么到底怎么使用呢？const showToast = promisefy(wx.showToast)({\r\n  title: '',\r\n  icon: \"none\",\r\n  duration: 2000,\r\n  confirmColor: '#ff673f',\r\n  mask: true\r\n});\r\n\r\nshowToast({ title: 'title' }); // 即可使用\r\n复制代码那么这个promisefy还能怎么用呢？ 1.我们可能会经常使用storage相关的api， 那么到底是把对象JSON.stringify, 再setStorage。需要使用的时候再getStorage, 最后JSON.parse呢？当然这是一种解决方案。如果使用promisefy，可以这样干。/**\r\n *\r\n * @param 需要往LocalStorage里面存数据\r\n * @returns {Promise<any[] | never>}\r\n */\r\nconst setStorage = (param = {}) => {\r\n  if (!Object.keys(param).length) throw new Error('输入的对象不为空');\r\n  return Promise.all(Object.entries(param)\r\n    .map(item => promisefy(wx.setStorage)({\r\n      key: item[0],\r\n      data: item[1]\r\n    })()));\r\n};\r\n\r\nsetStorage({ a:1, b:2 });\r\n复制代码/**\r\n *\r\n * @param 需要从storage 读取的key。\r\n * 单个值直接传string, 多个值传数组\r\n * eg. ['key1', 'key2', 'key3'] 或者 'key1' ;\r\n * @returns {key1: value1, key2: value2, key3: key3 }\r\n */\r\nconst getStorage = param => Promise.all(\r\n  Object.entries(((typeof param) === 'string') ? [param] : param)\r\n    .map(item => promisefy(wx.getStorage)({ key: item[1] })()\r\n      .then(res => ({ [`${item[1]}`]: res.data }))))\r\n  .then(res => res.reduce((prev, curr) => ({ ...prev, ...curr }), {}));\r\n\r\ngetStorage('a'); // { a: 1 },\r\ngetStorage(['a', 'b']); // { a: 1, b: 2 },\r\n复制代码/**\r\n * @param 需要从storage 清除记录eg. [key1, key2], key3。\r\n */\r\nconst removeStorage = param => Promise.all(\r\n  Object.entries(((typeof param) === 'string') ? [param] : param)\r\n    .map(item => promisefy(wx.removeStorage)({ key: item[1] })()));\r\n\r\nremoveStorage('a');\r\nremoveStorage(['a', 'b']);\r\n复制代码2.对于有router 的页面我们经常会出现router 的三种跳转方案。例如微信就提供了三种api:navigateTo， redirectTo ，navigateBack，这里没有包含小程序跳小程序的api。那么我们是不是可以封装一个公共的方法呢？// 路径参数的拼接\r\nconst obj2Url = params => {\r\n  if (params instanceof Array || typeof params === 'number') throw new Error('跳转参数限制于string和对象');\r\n  // 如果路径参数为 object, 做以下转换\r\n  if (typeof params === 'object') {\r\n    const rawParams = Object.entries(params).reduce((acc, cur) => {\r\n      if ((!cur[1]) && ((typeof cur[1]) !== 'boolean')) console.warn(`${cur[0]}的值为空， 请检查原因！`);\r\n      return `${acc + cur[0]}=${cur[1]}&`;\r\n    }, '');\r\n    params = rawParams.substr(0, rawParams.length - 1);\r\n  }\r\n  return params;\r\n};\r\n\r\n/**\r\n *\r\n * @param page 需要跳转的页面或者页面路径(如果是\"pages/a/b/b\"这样的路径，page='pages/a/b/b', specialUrl=true )\r\n * @param type\r\n * @param params\r\n * @param specialUrl\r\n * @return {*}\r\n */\r\nconst jumpTo = (page = 'index', type = 'navigate', params = '', specialUrl = false) => {\r\n  const { navigateTo, redirectTo, navigateBack } = wx;\r\n  const types = {\r\n    navigate: url => promisefy(navigateTo)({ url })(),\r\n    redirect: url => promisefy(redirectTo)({ url })(),\r\n    back: delta => promisefy(navigateBack)({ delta })(),\r\n  };\r\n  params = obj2Url(params);\r\n  console.log('**test**', 'params', params, `${page}?${params}`);\r\n  if (specialUrl) return types[type](params ? `${page}?${params}` : page);\r\n  // 获取跳转参数，如果为数字，则为navigateBack，反之为 navigateTo 或 navigateBack。\r\n  const jumpPram = (typeof page === 'number') ? page : `/pages/${page}/${page}${params ? `?${params}` : ''}`;\r\n  console.log(`%c**跳转参数**jumpPram** ${jumpPram}`, 'color:white;background:green');\r\n  sendTrack(`**跳转参数**jumpParam** ${jumpPram}`);\r\n  return types[type](jumpPram);\r\n};\r\n\r\njumpTo('a'); // navigateTo到a页面\r\njumpTo('a', 'navigate', { m: 'm' }); // navigateTo到a页面 ,路径参数为?m=m\r\njumpTo('a', 'redirect', { m: 'm' }); // redirectTo到a页面 ,路径参数为?m=m\r\njumpTo(1, 'redirect', { m: 'm' }); // back 上一步 ,路径参数为?m=m\r\n复制代码项目实践1.native 小程序开发者。（下载babel-polyfill，导入regeneratorRuntime）import regeneratorRuntime from '你放置的文件夹';\r\n\r\nconst showLoading = promisefy(wx.showLoading)({ title: '加载中', mask: true });\r\nconst hideLoading = () => wx.hideLoading();\r\nconst showMoshowToast = promisefy(wx.showToast)({ title: 'title', content: '', mask: true });\r\n\r\n\r\nconst Loading = { show: showLoading, hide: hideLoading };\r\nconst Toast = { show: showToast };\r\n\r\nconst handleErr = (e, cb) => {\r\n  Loading.hide();\r\n  if ((typeof e) === 'string') {\r\n    Toast.show({ title: e || '服务器异常，请稍后再试' });\r\n  } else {\r\n    const { message } = e;\r\n    Toast.show({ title: message || '服务器异常，请稍后再试' });\r\n  }\r\n  cb && cb();\r\n};\r\n\r\nconst fetchData = () => {}\r\n\r\naync function() {\r\n try {\r\n  await Loading.show();\r\n  const { data } = await fetchData();\r\n  this.setData({\r\n   data\r\n  })\r\n  Loading.hide();\r\n } catch (e) {\r\n  handleErr(e)\r\n }\r\n}\r\n复制代码2.webpack和taro 用户直接引入用配置bable 相关npm即可,可参考"}
{"title": "苏宁：我们开发百度小程序遇到的那些 “坑” ", "author": "Rolan", "pub_time": "2018-12-7 00:21", "article_content": "作者｜马建旭编辑｜覃云2018 年 5 月，受百度邀请，苏宁首批入驻百度小程序平台。作为微信小程序的开发工程师，我接手了“开荒”百度智能小程序（以下简称百度小程序）的任务，自 5 月初开发，一个多月就完成了苏宁易购百度小程序的开发工作，并在 7 月初的“百度开发者大会”上作为首批小程序对外提供服务。从 5 月至今，作为百度小程序的主力开发，总结了以下的一些开发经验。百度小程序的初探入驻百度小程序百度小程序的入驻方式，与微信小程序几乎相同，准备一个百度账号，登录百度智能小程序后台，选择入驻申请，选择适合的类型，填写表单信息，提交审核，一般 24 小时内可以审核通过。当然，如果有百度小程序的邀请码，也可以走邀请码通道进行入驻。这里特别需要注意的是，目前仅面向企业、政府、媒体及其它组织等非个人主体开放申请，个人用户是没有办法入驻的。入驻完成后，进入平台，可以看到自己的小程序。开发前的准备用注册得到的管理员账号登录后台，在成员管理设置项目组成员的权限, 百度小程序的用户权限主要分为：开发者权限、开发管理、开发设置、暂停服务设置、推广设置、流量主、数据统计、小程序简介、小程序头像。在设置 - 开发设置，获取小程序的 AppID、App Key 和 App Secret，并设置服务器域名、业务域名和代理域名（小程序 web 化使用）。在设置 - 基础设置设置小程序名称、头像和简介等信息。开发者工具在从百度小程序官网点击文档 - 开发 - 左侧导航栏工具 - 界面下载开发者工具，开发者工具启动后，有和微信开发者工具差不多的界面，不同的地方如下：百度小程序没有集成类似于微信小程序 Tgit、腾讯云，云开发平台等功能。开发者需要在自备代码管理工具，服务端所需要的服务器等资源。百度小程序 IDE 目前的新建功能只支持新建一个 DEMO，开发者需要在这个基础上进行修改来得到自己的项目，或者使用搬家具将微信小程序转换为百度小程序，不能从头开始新建。微信小程序的新建功能是从输入 appID 开始的，百度的 appid 只能在建好项目后手动的修改。百度小程序 IDE 不需要独立设置代理。微信小程序 IDE 需要单独配置代理，在复杂网络环境下可能会出现内外网不能同时访问的情况，但是百度小程序不需要设置单独代理。开发文档百度小程序有丰富的文档，详细的介绍了从申请入驻到小程序发布、从组件到 API 的百度小程序的方方面面，大家可以自行到官网上去阅读。前端开发者眼中的百度小程序因为同时开发百度小程序和微信小程序，我将对比微信小程序，讲述百度小程序开发过程中遇到的一些问题。组件和 API 几乎和微信相同，框架上分为逻辑层、视图层、自定义组件和基础能力，也支持分包加载等能力。百度小程序的组件也分为视图组件、基础组件、表单组件、导航组件、媒体组件、地图组件、画布组件和开放能力相关组件。在 API 方面，百度小程序也分为网络、媒体、文件、数据存储、位置、界面（包含绘图）、设备和开放接口等大类。以下是我们发现的一些百度小程序与微信小程序的不同。组件的不同百度小程序的列表渲染和微信不一致：<view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">\r\n  {{idx}}: {{itemName.message}}\r\n</view>\r\n// 也可以简写为\r\n<view wx:for=\"{{array}}\">\r\n  {{index}}: {{item.message}}\r\n</view>百度小程序的列表渲染：<view>\r\n    <view s-for=\"p in persons\">\r\n        {{p.name}}\r\n    </view>\r\n</view>百度小程序的判断和循环不能再同一个组件上。例如微信小程序可以这么写：<view wx:for=\"{{array}}\" wx:if=\"{{item.isWx}}\">\r\n  {{index}}: {{item.message}}\r\n</view>\r\n// 或者这样子\r\n<view wx:for=\"{{array}}\" wx:if=\"{{isWx}}\">\r\n  {{index}}: {{item.message}}\r\n</view>而百度小程序则必须写成这边这个样子：<view s-for=\"(index,item) in array\">\r\n  <block s-if=\"item.isBd\">\r\n    {{index}}: {{item.message}}\r\n  </block>\r\n</view>\r\n// 或者这样子\r\n<block s-if=\"isBd\">\r\n  <view s-for=\"p in persons\">\r\n    {{p.name}}\r\n  </view>\r\n</block>API 的不同百度小程序提供了 AI 的能力，可以实现文字识别、文本审核、语音合成、图像审核、图像识别和语音识别功能。Swan.request 能力。request 的问题主要体现在对单引号, 以及 URL 的汉字的兼容上. 百度小程序 request 能力并未对请求 UR 中的汉字做 encodeURIComponent 处理, 导致手百客户端发送请求直接失败, 这边建议开发者自己对 get 请求的入参做 encodeURIComponent 处理. 单引号的问题也是这样, 具体表现出来, 请求发送出去之后, 通过抓包可以看到请求正常的发送了, 也正常返回了, 但是小程序既不会走进 success 分支, 也不会进入 error 分支, 报错也不能被 catch, 这个问题后期百度官方已经修复了。分包体积限制不同微信小程序目前的限制规则是，每个包不超过 2M ，总包不超过 8M，而百度小程序目前的限制规则是主包不得超过 4M，每个分包不得超过 2M，总包不得超过 8M，这个规则和目前微信程序的限制规则差别较大，在方便了开发者的同时，可能会在性能方便有所损耗。在 CSS 和 JS 处理的上的细微差异百度小程序不支持 css 的>选择器, 建议样式直接使用 class 选择器。百度小程序支持的长度单位是 CSS3 的 vw，当然也支持微信小程序的 rpx。使用伪元素实现的 0.5px 边框在百度小程序下会有异常，建议不要使用这种方法。百度小程序不支持类似于微信小程序 WXS 的写法。百度小程序没有提供类似于微信小程序 WXS 的写法, 但是提供了 Filter 过滤器。Filer 代码可以编写在 swan 文件中的标签内，或以 .filter.js 为后缀名的文件内。登录方式的区别因为微信客户端是强制要求用户登录的，但是手百不需要，所以在联合登录时，针对此场景，百度小程序需要作出特别的开发。在百度小程序联合登录前，需要使用 swan.isloginsync api 进行手百客户端的登录状态判断，手百没有登录的，不能使用联合登录，所以建议开发者还需要准备一套独立账号登录体系。支付方式的区别微信小程序使用的是微信支付，而百度小程序使用的是百度聚合收银台，在接入流程和开发流程上都和微信小程序不一样，当然百度小程序官方也贴心的提供了微信直联和支付宝直联的能力，大家可以根据自己的需要选用适合自己的付款方式。打包方式及发布的区别百度小程序点击预览按钮生成的开发版小程序是可以给其他用户扫码查看的，并未像微信一样严格要求开发者权限才能打开开发版小程序，也没有体验者这一角色，这一点对于测试同学来说还是很方便的。百度小程序 IDE 提供了两种编译模式: 依赖分析、普通编译。 依赖分析模式 : 无用文件不会被打包到产出中，支持 node_modules 的使用 ; 普通编译模式 : 不支持 node_modues 的使用，打包全部文件。PhoneX 等机型样式适配目前微信小程序并没有提供对 iphoneX，iphoneXS 等机型底部 bar 的适配，但是百度小程序提供了这样一个适配方案。.swan-security-padding-bottom { \r\npadding-bottom:34px; \r\n} \r\n.swan-security-margin-bottom { \r\nmargin-bottom: 34px; \r\n} .swan-security-fixed-bottom { \r\nbottom: 34px; \r\n}该组样式会自动在需要适配安全区的场景动态注入，开发者不需要自行添加，只要在.swan 文件中使用这组类名即可。效果如下图所示：如果你之前有开发微信小程序开发，百度小程序提供了一个搬家工具。 搬家工具，是基于 Abstract Syntax Tree 开发的辅助工具，可以帮助您把微信小程序的部分代码迁移到百度智能小程序上。工具可进行静态语法上的转换，根据一些规则去转换代码，抹平微信小程序语法和百度智能小程序语法上的差异，为大家减少因平台差异带来的苦恼。需要注意的是：工具做不到运行时 diff 的抹平，也做不到一个 API 从无到有的过程。所以，需要大家根据转换 log，进行二次开发。网络的虚拟性导致信任关系难以建立，交易决策困难。对于小程序这种轻便、易传播的特性，如何让用户能够更容易的决策，并且给用户适合他的商品。这无疑是十分重要的一环，而与百度合作的手百小程序中，百度的基于用户操作行为的大数据商品推荐系统可以处理信任评估中的主观因素，提高交易预测的准确性。基于双方协同过滤的思想建立一个模糊信誉管理系统，突出对商品信息的处理与个性化推荐。上线以来，百度推荐模块的数据对比于原有苏宁内部的推荐来看，更贴合于用户在基于百度强大的搜索端的行为数据。对垂直行业的定制化推荐，满足不同行业的需求，让我们看到了百度推荐的智能化、专业化。以上是我在苏宁开发百度小程序的一些经验，各公司也可以尝试一下，百度小程序也在不断的迭代中，每一次迭代都能感觉到进步，感觉百度小程序开发组的同学，远程帮我们解决了很多问题，特别感谢百度方的李嘉辉来苏宁驻场提供技术支持，没有你我们的开发之路不会这么顺利，以及百度的 QA 同学，对我们小程序提出宝贵的建议。作者简介马建旭，苏宁易购前端技术经理，苏宁易购小程序产品线技术负责人。曾任途牛旅游网在线预订前端负责人，具有丰富的前端开发经验，在 nodeJs、reacrJs、vue 等多个领域均有技术实践。对前后端分离、前端组件化、小程序开发等方面，有独特的见解和丰富的实践经验。活动推荐12 月 7 日北京 ArchSummit 全球架构师峰会上，来自美团、百度、阿里、快手的讲师齐聚一堂，共同分享“打造 Native 体验 Hybrid App 实践”、“定制统一可维护的前端架构”、“10 年双十一前端关键技术”和“同构 Web App 的另一种探索”的分享。会议开幕倒数第 4 天，购票联系票务灰灰 17326843116详情可 扫描以下二维码 或点击 阅读原文 。"}
{"title": "小程序新请假界面 ", "author": "Rolan", "pub_time": "2018-12-7 00:34", "article_content": "小程序新请假界面效果:.wxml:<view class=\"head\">\r\n  <view class=\"head_item {{selected?'head_itemActive':''}}\" bindtap=\"selected\">新请假</view>\r\n  <view class=\"ring\"></view>\r\n  <view class=\"head_item {{selected1?'head_itemActive':''}}\" bindtap='selected1'>请假结果</view>\r\n</view>\r\n<view class=\"main {{selected?'show':'hidden'}}\">\r\n  <form bindsubmit=\"formSubmit\">\r\n    <view class='bg'>\r\n      <view class='item'>\r\n        上传图片：\r\n        <view class='uploaderpic' wx:for=\"{{files}}\" wx:key=\"{{index}}\">\r\n          <image src='{{item}}' class='upload-img'></image>\r\n        </view>\r\n        <view class='uploader' wx:if=\"{{upload}}\" bindtap=\"previewImage\">\r\n          <view class='add-icon'>+</view>\r\n          <view class='title'>添加图片</view>\r\n        </view>\r\n        <button class='btn' bindtap='delete'>删除</button>\r\n      </view>\r\n      <view class='item'>\r\n        \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n年级：\r\n        <input name='gradeName' placeholder=\"请输入年级\" maxlength='15' class='bk' />\r\n      </view>\r\n      <view class='item'>\r\n        \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n班级：\r\n        <input name='className' placeholder=\"请输入班级\" maxlength='15' class='bk' />\r\n      </view>\r\n      <view class='item'>\r\n        \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n学号：\r\n        <input name='studentNo' placeholder=\"请输入学号\" maxlength='15' class='bk' />\r\n      </view>\r\n      <view class='item'>\r\n        请假天数：\r\n        <input name='leaveDays' placeholder=\"请输入请假天数\" maxlength='15' class='bk' />\r\n      </view>\r\n      <view class='item'>\r\n        开始时间：\r\n        <view class='bk'>\r\n          <picker mode=\"date\" value=\"{{date}}\" bindchange=\"changeDate\" name=\"startTime\" bindchange=\"changeDate\">\r\n            {{date}}\r\n          </picker>\r\n        </view>\r\n      </view>\r\n      <view class='item'>\r\n        结束时间：\r\n        <view class='bk'>\r\n          <picker mode=\"date\" value=\"{{date1}}\" bindchange=\"changeDate1\" name=\"endTime\" start=\"{{date}}\">\r\n            {{date1}}\r\n          </picker>\r\n        </view>\r\n      </view>\r\n      <view class='item'>\r\n        请假类型：\r\n        <view class='bk'>\r\n          <input name='leaveType' placeholder=\"病假输1/事假输2\" maxlength='15' type=\"number\" />\r\n        </view>\r\n      </view>\r\n      <view class='item'>\r\n        请假理由：\r\n        <view class='bk'>\r\n          <input name=\"leaveReason\" placeholder=\"请输入请假理由\" maxlength='500' auto-height/>\r\n        </view>\r\n      </view>\r\n      <button class='btn' formType=\"submit\">提交</button>\r\n    </view>\r\n  </form>\r\n</view>\r\n\r\n<view class=\"main {{selected1?'show':'hidden'}}\">\r\n 达叔小生\r\n</view>.wxss:Page {\r\n  background-color: #f1f1f1;\r\n}\r\n\r\n.head_item {\r\n  width: 374rpx;\r\n  text-align: center;\r\n  font-size: 34rpx;\r\n  color: #999;\r\n  letter-spacing: 0;\r\n}\r\n\r\n.head_itemActive {\r\n  color: #30d1ff;\r\n}\r\n\r\n.ring {\r\n  width: 2rpx;\r\n  height: 100%;\r\n  background-color: rgba(204, 204, 204, 1);\r\n}\r\n\r\n.head {\r\n  width: 100%;\r\n  height: 100rpx;\r\n  background-color: rgba(255, 255, 255, 1);\r\n  border-bottom: 1rpx solid rgba(204, 204, 204, 1);\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  position: fixed;\r\n  top: 0;\r\n  z-index: 10;\r\n}\r\n\r\n.main {\r\n  position: absolute;\r\n  width: 100%;\r\n  height: 100%;\r\n  display: block;\r\n  box-sizing: border-box;\r\n  padding-top: 100rpx;\r\n  top: 0;\r\n}\r\n\r\n.show {\r\n  display: block;\r\n  text-align: center;\r\n}\r\n\r\n.hidden {\r\n  display: none;\r\n  text-align: center;\r\n}\r\n\r\n/* 新请假 */\r\n\r\n.uploader {\r\n  position: relative;\r\n  width: 168rpx;\r\n  height: 168rpx;\r\n  background: #f0f0f2;\r\n  border-radius: 10rpx;\r\n}\r\n\r\n.uploaderpic {\r\n  width: 168rpx;\r\n  height: 168rpx;\r\n  margin-top: 10rpx;\r\n  border-radius: 10rpx;\r\n}\r\n\r\n.add-icon {\r\n  position: absolute;\r\n  font-size: 105rpx;\r\n  top: -23rpx;\r\n  left: 50rpx;\r\n  color: #a3a3a3;\r\n}\r\n\r\n.title {\r\n  position: absolute;\r\n  bottom: 30rpx;\r\n  left: 32rpx;\r\n  color: #a3a3a3;\r\n  font-size: 28rpx;\r\n}\r\n\r\n.upload-img {\r\n  width: 95%;\r\n  height: 95%;\r\n  border-radius: 10rpx;\r\n}\r\n\r\n.bg {\r\n  margin: 40rpx;\r\n  background-color: #fff;\r\n  border: 2rpx dotted #ccc;\r\n  border-radius: 15rpx;\r\n  height: 100%;\r\n}\r\n\r\n.item {\r\n  display: flex;\r\n  flex-direction: row;\r\n  font-size: 30rpx;\r\n  margin: 25rpx;\r\n  align-items: center;\r\n}\r\n\r\n.btn {\r\n  background-color: #79caff;\r\n  color: #fff;\r\n  width: 120rpx;\r\n  font-size: 30rpx;\r\n  margin-top: 30rpx;\r\n}\r\n\r\n.bk {\r\n  border-radius: 10rpx;\r\n  border: 2rpx solid #ccc;\r\n  padding: 10rpx;\r\n  width: 65%;\r\n}.jsvar dateTimePicker = require('../../utils/dateTimePicker.js');\r\nvar util = require('../../utils/util.js');\r\nPage({\r\n  // 页面的初始数据\r\n  data: {\r\n    date: '',\r\n    date1: '',\r\n    selected: true,\r\n    selected1: false,\r\n    articles: [],\r\n    upload: true,\r\n    files: [],\r\n    sum: 0,\r\n  },\r\n  //  上传图片\r\n  previewImage: function() {\r\n    wx.chooseImage({\r\n      count: 1,\r\n      sizeType: ['compressed'], // 可以指定是原图还是压缩图\r\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success: (res) => {\r\n        console.log(res) // 打印输出返回值\r\n        let files = this.data.files\r\n        files.push(res.tempFilePaths[0]) // 把图片地址push到数组中\r\n        let sum = this.data.sum\r\n        sum++ // 开始计数\r\n        this.setData({\r\n          sum: sum\r\n        })\r\n        if (this.data.sum == 1) { \r\n          this.setData({\r\n            upload: false\r\n          })\r\n        }\r\n        // tempFilePath可以作为img标签的src属性显示图片\r\n        this.setData({\r\n          files: files\r\n        });\r\n\r\n      }\r\n    })\r\n  },\r\n\r\n  // 删除图片\r\n  delete: function(e) {\r\n    let index = e.currentTarget.dataset.index\r\n    let files = this.data.files\r\n    files.splice(index, 1)\r\n    this.setData({\r\n      files: files\r\n    })\r\n    if (this.data.files.length == 0) {\r\n      this.setData({\r\n        upload: true,\r\n        sum: 0\r\n      })\r\n    }\r\n  },\r\n  // 保存\r\n  formSubmit: function(e) {\r\n    var that = this;\r\n    console.log('form发生了submit事件，携带数据为：', e.detail.value);\r\n    let data = e.detail.value;\r\n    if (that.data.files[0] !== null) {\r\n      data.certificate = that.data.files[0];\r\n    }\r\n    console.log(data);\r\n    wx.request({\r\n      url: '####',\r\n      method: 'POST',\r\n      data: JSON.stringify(data),\r\n      header: {\r\n        'Authorization': 'Bearer' + wx.getStorageSync('token'),\r\n      },\r\n      success(res) {\r\n        console.log(\"绑定\", res);\r\n        wx.showModal({\r\n          title: '提示',\r\n          content: res.data.msg,\r\n          showCancel: false,\r\n          success: function(res) {\r\n            if (res.confirm) {\r\n              console.log('用户点击确定');\r\n            }\r\n          }\r\n        })\r\n      },\r\n      fail: function(fail) {\r\n        wx.showModal({\r\n          title: '提示',\r\n          content: '输入有误,请重新输入',\r\n          showCancel: false,\r\n          success: function(res) {\r\n            if (res.confirm) {\r\n              console.log('用户点击确定');\r\n            }\r\n          }\r\n        })\r\n      }\r\n    })\r\n  },\r\n  // 时间\r\n  changeDate(e) {\r\n    this.setData({\r\n      date: e.detail.value,\r\n    });\r\n  },\r\n  changeDate1(e) {\r\n    this.setData({\r\n      date1: e.detail.value,\r\n    });\r\n  },\r\n  // 生命周期函数--监听页面加载\r\n  onLoad: function(options) {\r\n    // 获取当天时间\r\n    var that = this;\r\n    var time = util.formatTime(new Date()).substring(0, 10);\r\n    console.log(time)\r\n    that.setData({\r\n      date: time,\r\n      date1: time,\r\n    });\r\n    // 获取完整的年月日 时分秒，以及默认显示的数组\r\n    var obj = dateTimePicker.dateTimePicker(this.data.startYear, this.data.endYear);\r\n    var obj1 = dateTimePicker.dateTimePicker(this.data.startYear, this.data.endYear);\r\n    // 精确到分的处理，将数组的秒去掉\r\n    var lastArray = obj1.dateTimeArray.pop();\r\n    var lastTime = obj1.dateTime.pop();\r\n  },\r\n  selected: function(e) {\r\n    this.setData({\r\n      selected1: false,\r\n      selected: true\r\n    })\r\n  },\r\n\r\n  selected1: function(e) {\r\n    this.setData({\r\n      selected: false,\r\n      selected1: true\r\n    })\r\n  },\r\n  // 生命周期函数--监听页面初次渲染完成\r\n  onReady: function() {\r\n\r\n  },\r\n  // 生命周期函数--监听页面显示\r\n  onShow: function() {\r\n\r\n  },\r\n  // 生命周期函数--监听页面隐藏\r\n  onHide: function() {\r\n\r\n  },\r\n  // 生命周期函数--监听页面卸载\r\n  onUnload: function() {\r\n\r\n  },\r\n}).json{\r\n  \"navigationBarTitleText\": \"请假\"\r\n}往后余生，唯独有你简书作者：达叔小生90后帅气小伙，良好的开发习惯；独立思考的能力；主动并且善于沟通简书博客： https://www.jianshu.com/u/c785ece603d1结语下面我将继续对 其他知识 深入讲解 ，有兴趣可以继续关注小礼物走一走 or 点赞"}
{"title": "小程序弹出框详解 ", "author": "Rolan", "pub_time": "2018-12-7 00:52", "article_content": "小程序弹出框详解\" style=\"margin: 20px 0px; font-family: \"PingFang SC\", \"Hiragino Sans GB\", \"Helvetica Neue\", \"Microsoft Yahei\", \"WenQuanYi Micro Hei\", sans-serif; font-weight: 500; line-height: 40px; color: rgb(44, 62, 80); text-rendering: optimizeLegibility; font-size: 21px; background-color: rgb(249, 249, 245);\">小程序弹出框详解qjlx: function() {    var itemList = ['病假', '事假'];    wx.showActionSheet({      itemList: itemList,      success: function(res) {        console.log(res);        console.log(itemList[res.tapIndex]);      },      fail: function(res) {        console.log(res.errMsg);      }    })  },操作菜单——wx.showActionSheet(OBJECT)效果效果//获取应用实例    var app = getApp()    Page({      actioncnt:function(){          wx.showActionSheet({              itemList: ['A', 'B', 'C'],              success: function(res) {                  console.log(res.tapIndex)              },              fail: function(res) {                  console.log(res.errMsg)              }          })      }  })  弹出框<view class='item'>    登录密码    <view class='bk'>      <input class=\"textarea\" placeholder=\"{{password}}\" value='{{password}}' bindinput=\"password\" maxlength='100' auto-height disabled/>    </view>    <button class='btn' bindtap='dlmm'>修改</button>    <modal hidden=\"{{hiddenmodalput}}\" title=\"修改密码\" confirm-text=\"提交\" cancel-text=\"取消\" bindcancel=\"cancelM\" bindconfirm=\"confirmM\">      <input bindinput='ipsd' type='text' placeholder=\"请输入原密码...\" auto-focus/>      <input bindinput='newipsd' type='password' placeholder=\"请输入新密码...\" />    </modal>  </view>// js// 获取登录密码:  password: function(e) {    this.setData({      password: e.detail.value,    })    console.log(\"获取登录密码:\" + this.data.password);  },// 修改登录密码  dlmm: function(e) {    this.setData({      hiddenmodalput: !this.data.hiddenmodalput    })  },  cancelM: function(e) {    this.setData({      hiddenmodalput: true,    })  },  confirmM: function(e) {    var that = this;    console.log(\"原密码\" + that.data.psd + \"新密码\" + that.data.newpsd);    that.setData({      hiddenmodalput: true,    })    wx.request({      url: '',      method: 'POST',      header: {        'Authorization': 'Bearer' + wx.getStorageSync('token'),      },      success(res) {        if (res.data.code == 0) {          wx.showToast({            title: '保存失败',            icon: 'success',            duration: 500          })        } else {          that.getShowToast();        }      }    })  },  ipsd: function(e) {    this.setData({      psd: e.detail.value    })  },  newipsd: function(e) {    this.setData({      newpsd: e.detail.value    })  },指定modal弹出效果<!--show.wxml-->  <view class=\"container\" class=\"zn-uploadimg\">      <button type=\"primary\"bindtap=\"modalinput\">modal有输入框</button>   </view>  <modal hidden=\"{{hiddenmodalput}}\" title=\"请输入验证码\" confirm-text=\"提交\" cancel-text=\"重置\" bindcancel=\"cancel\" bindconfirm=\"confirm\">      <input type='text'placeholder=\"请输入内容\" auto-focus/>  </modal> //获取应用实例    var app = getApp()    Page({      data:{          hiddenmodalput:true,          //可以通过hidden是否掩藏弹出框的属性，来指定那个弹出框      },      //点击按钮痰喘指定的hiddenmodalput弹出框      modalinput:function(){          this.setData({             hiddenmodalput: !this.data.hiddenmodalput          })      },      //取消按钮      cancel: function(){          this.setData({              hiddenmodalput: true          });      },      //确认      confirm: function(){          this.setData({              hiddenmodalput: true          })      }  })  效果//获取应用实例  var app = getApp()  Page({    actioncnt:function(){        wx.showActionSheet({            itemList: ['A', 'B', 'C'],            success: function(res) {                console.log(res.tapIndex)            },            fail: function(res) {                console.log(res.errMsg)            }        })    }})<!--.wxml--><view class=\"container\" class=\"zn-uploadimg\">    <button type=\"primary\"bindtap=\"modalinput\">modal有输入框</button> </view><modal hidden=\"{{hiddenmodalput}}\" title=\"请输入验证码\" confirm-text=\"提交\" cancel-text=\"重置\" bindcancel=\"cancel\" bindconfirm=\"confirm\">    <input type='text'placeholder=\"请输入内容\" auto-focus/></modal>//.js //获取应用实例  var app = getApp()  Page({    data:{        hiddenmodalput:true,        //可以通过hidden是否掩藏弹出框的属性，来指定那个弹出框    },    //点击按钮痰喘指定的hiddenmodalput弹出框    modalinput:function(){        this.setData({           hiddenmodalput: !this.data.hiddenmodalput        })    },    //取消按钮    cancel: function(){        this.setData({            hiddenmodalput: true        });    },    //确认    confirm: function(){        this.setData({            hiddenmodalput: true        })    }})达叔小生：往后余生，唯独有你You and me, we are family !90后帅气小伙，良好的开发习惯；独立思考的能力；主动并且善于沟通简书博客： 达叔小生https://www.jianshu.com/u/c785ece603d1结语下面我将继续对 其他知识 深入讲解 ，有兴趣可以继续关注 小礼物走一走 or 点赞"}
{"title": "怎么掌握微信小程序的取值、传值、数据存储 ", "author": "Rolan", "pub_time": "2018-12-10 00:12", "article_content": "小程序界面设定如下父级页面：A界面子级页面：B界面异级页面：C界面 一.本页面取值（A界面→A界面）a.例如：input输入文字获取到value（键盘输入时触发）wxml：<input type='text' name=\"userName\" maxlength=\"11\" bindinput=\"userPhoneInput\" ></input>js:data: {\r\n    userPhone: '',\r\n  },\r\n  //手机号输入框事件键盘输入时触发(文字提醒)\r\n  userPhoneInput: function (e) {\r\n    this.setData({\r\n      userPhone: e.detail.value\r\n    })\r\n  },\r\n  //接口取值格式\r\n  onShow: function () {\r\n    .....\r\n    data:{\r\n        UserPhoneNum:that.data.userPhone,\r\n    },\r\n    .....\r\n  }, b.例如：input不输入文字获取到全部的value（键盘不输入时触发）wxml：<form bindsubmit=\"formSubmit\">\r\n        <input type='text' value='{{putdata.name}}' name=\"companyname\" placeholder='请输入你的姓名/公司名称'></input>\r\n        <input type='text' value='{{putdata.bankName}}' name=\"openbank\" placeholder='请输入你的开户行全称'></input>\r\n        <button formType=\"submit\">完成</button>\r\n</form>注：form表单与button绑定获取input的内容js://按钮点击事件\r\n  formSubmit: function (e) {\r\n    var companyname = e.detail.value.companyname;\r\n    var openbank = e.detail.value.openbank;\r\n    //根据name取input的value\r\n    wx.request({\r\n      url: aaaaaa,\r\n      data: {\r\n        name: companyname,\r\n        bankName: openbank,\r\n      },\r\n      header: {\r\n        'content-type': 'application/json',\r\n      },\r\n      success: function (res) {\r\n\r\n      },\r\n      fail: function () {\r\n\r\n      }\r\n    })\r\n  } 二.异页面传值取值（A界面→B界面，A界面→C界面）a.url传值用 navigator标签或 wx.navigator传值，A界面向B界面传值；（不懂的自行安利小程序api和组件）wxml:// navigator标签传值\r\n<navigator url=\"/page/index/index?id=1432&name=qima&password=hj1234\" >传值</navigator>\r\n\r\n//wx.navigator传值\r\nwx.navigateTo({\r\n      url: '/page/index/index?id=' + id +'&username='+ username+'&password='+ password\r\n})下一个页面取值方法：js:data: {\r\n    id : \"\" ,\r\n    name : \"\" ,\r\n    password : \"\",\r\n  },\r\nonLoad: function (options) {\r\n    var id = options.id;\r\n    var name = options.name;\r\n    var password = options.password;\r\n    this.setData({\r\n      id:id,\r\n      name:name,\r\n      password:password,\r\n    })\r\n},一般小程序能不用接口解决的就不要用到接口呈现数据，可以用URL传值，到下一个页面取值，然后呈现到页面即可； b.数据存储我们会用到小程序的api,通过调用微信提供的方法：wx.setStorage、wx.setStorageSync、wx.getStorage、wx.getStorageSync、wx.clearStorage、wx.clearStorageSync、实现对数据本地缓存、获取、清除。js缓存:我们获取接口传回的数据，id,code之类的，我们做全局储存，命名一个key和内容value；wx.request({\r\n        url: aaaaa,\r\n        data: {\r\n          UserPhoneNum: '86//' + that.data.userPhone,\r\n          Password: that.data.passWd,\r\n          IP: that.data.IP,\r\n        },\r\n        header: {\r\n          'content-type': 'application/json',\r\n        },\r\n        success: function (res) {\r\n          console.log(res.data),\r\n          //存储格式 wx.setStorageSync('key命名', value内容);\r\n          wx.setStorageSync('salemanId', res.data.salemanId);\r\n          wx.setStorageSync('salemanLevel', res.data.salemanLevel);\r\n          if (res.data.state == 200){\r\n            \r\n          }else{\r\n           \r\n          }\r\n        },\r\n })js获取：根据key获取到数据，缓存到本地或上传到接口；//根据key获取到缓存的值\r\nvar salemanId= wx.getStorageSync(\"salemanId\");js清除：从本地缓存中同步移除指定 key。这里具体使用同步或是异步需要根据你存储时的方法，或是同步清理本地数据缓存；//清除数据\r\nwx.removeStorageSync(\"salemanId\") 查看自己缓存数据地点：（如图） c.全局App对象在我们的app.js文件里面，我们需要写好我们需要全局使用的数据；//用户学校数据\r\n globalData: {\r\n     school:null,\r\n }我们需要给它赋值，赋值代码如下：var self = this\r\n......\r\nself.globalData.school = res.data.schoolID在我们需要取值的地方引用全局的app.js,然后取值：var app = getApp();\r\nonLoad: function () {\r\n    var that = this; \r\n    //调用应用实例的方法获取全局数据  \r\n    app.getUserSchool(function (school) {\r\n      //更新数据  \r\n    })\r\n},\r\n//取值\r\n......\r\nschool: app.globalData.school,\r\n...... 三.总结小程序了解到这些传值取值过程，接通接口，呈现数据就快多了，还有哪些可以传值取值的方法，欢迎大家留言哦，交流才能让人进步，有什么错误的地方也欢迎大家指正，我将进行更改，觉得博主写的还可以的，欢迎点个关注，以后有空常来我的博客逛逛，虽然可能写的东西不是很高级，但是对于初级的人来说，还是能帮助到很多东西的，我的博文能帮助到大家我就很开心了，谢谢您百忙之中的观看，一起加油进步，哇哈哈哈"}
{"title": "小程序无限层级路由方案（无框架依赖） ", "author": "Rolan", "pub_time": "2018-12-10 00:20", "article_content": "小程序历史栈最多只支持10层当小程序业务比较复杂时，就很容易超过10层。当超过10层后，有的机型是点击无反应，有的机型会出现一些未知错误为了解决这些问题，我们引入了无限层级路由方案。方案首先声明一下，最初方案并不是我提出的，是我司内部一位清华学霸提出的。但他们是基于wepy框架做的处理，由于我们用的是mpvue，所以对这个方案上做了修改，同时不依赖于框架。虽然是改造版，但原理是一样的，下面我来介绍一下修改后的方案。几个关键点：9层（含9层）以内时 ：走小程序自己的历史栈就ok了，跳转时候更新一下逻辑栈，这没啥可说的从9层跳转10层 ：需要把第9层重定向到中转页，再由中转页跳转到10层10层以后跳转 ：在navigateTo方法中处理，到10层之后，再跳转就第10层页面一直做redirectTo（重定向）操作了10层以上返回 ：会返回到中转页，由中转页判断，具体返回到哪个页面，然后navigateTo（跳转）过去从10层返回到9层 ：返回到中转页，将中转页redirectTo（重定向）到第9层页面9层内的返回 ：直接返回就好了，返回时候不会更新逻辑栈，但没有关系，因为只有中转页才会用到逻辑栈逻辑栈更新机制 ：跳转、返回中转页时更新navigateTo时更新redirectTo时更新reLaunch时更新navigateBack时更新图示：用户操作小程序历史栈js逻辑栈：自行维护的js路由栈“中”表示中转页“1 2 3 4 5 6 7 8 9 A B C”表示不同的页面路径之前跳转操作和10层以上的返回操作都会更新逻辑栈，到了10层以内的返回操作就不会更新逻辑栈了。到这里细心的读者可能已经发现：原因：这块也是我们对原有方案的主要改造点。因为到了10层以内，所有的返回和跳转都由微信系统历史栈接管了。我们只要保证用户在通过api进行跳转操作时更新就可以了。而且，自己维护的逻辑路由栈实际上只有中转页才会用到。这样也就不用在每个页面都要注册onUnload钩子去实时更新返回时的路由信息了。把更新路由信息的逻辑都放到了api调用这一层。业务开发时完全不用关心。示意代码lib/navigator/Navigator.js (自己封装的跳转方法, History.js代码省略了)...\r\nimport History from '@/lib/navigator/History'\r\nconst MAX_LEVEL = 10 // 小程序支持打开的页面层数\r\nexport default class Navigator {\r\n  // 中转页面路径\r\n  static curtainPage = '/pages/curtain/curtain/main'\r\n  // 最大页数\r\n  static maxLevel = MAX_LEVEL\r\n  // 逻辑栈\r\n  static _history = new History({\r\n    routes: [{ url: '' }],\r\n    correctLevel: MAX_LEVEL - 2\r\n  })\r\n  \r\n  ...\r\n  \r\n  /**\r\n   * 打开新页面\r\n   * @param {Object} route 页面配置，格式同wx.navigateTo\r\n   */\r\n  @makeMutex({ namespace: globalStore, mutexId: 'navigate' }) // 避免跳转相关函数并发执行\r\n  static async navigateTo (route) {\r\n    console.log('[Navigator] navigateTo:', route)\r\n    // 更新逻辑栈\r\n    Navigator._history.open({ url: route.url })\r\n\r\n    let curPages = getCurrentPages()\r\n    // 小于倒数第二层时，直接打开\r\n    if (curPages.length < MAX_LEVEL - 1) {\r\n      await Navigator._secretOpen(route) // 就是调用wx.navigateTo\r\n    // 倒数第二层打开最后一层\r\n    } else if (curPages.length === MAX_LEVEL - 1) {\r\n      const url = URL.setParam(Navigator.curtainPage, { url: route.url })\r\n      await Navigator._secretReplace({ url })  // wx.redirectTo 到中转页，再由中转页跳转到第10层页面\r\n    // 已经达到最大层数，直接最后一层重定向\r\n    } else {\r\n      await Navigator._secretReplace(route)    // wx.redirectTo 第10层页面直接重定向\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 完整历史记录\r\n   * @return {Array}\r\n   */\r\n  static get history () {\r\n    return Navigator._history.routes\r\n  }\r\n  \r\n  /**\r\n   * 更新路由\r\n   * @param {Object} config 自定义配置，可配置项参见 _config 相关字段及注释\r\n   */\r\n  static updateRoutes (routes = []) {\r\n    this._history._routes = routes\r\n  }\r\n  \r\n  ...\r\n}\r\n复制代码中转页代码 /pages/curtain/curtain/index.vue<template>\r\n  <div class=\"main\"></div>\r\n</template>\r\n<script>\r\nimport Navigator from '@/lib/navigate/Navigator'\r\n// query参数\r\nlet opts = null\r\n// 是否为返回操作\r\nlet isBack = false\r\n\r\nexport default {\r\n  onLoad (options) {\r\n    // 缓存参数\r\n    opts = options\r\n    // 执行onLoad生命周期，认为是跳转或者重定向操作\r\n    isBack = false\r\n  },\r\n  onShow () {\r\n    // 跳转、重定向操作时，逻辑栈的状态会在跳转函数里更新\r\n    if (!isBack) {\r\n      const url = decodeURIComponent(opts.url)\r\n      // 再返回时认为是返回操作\r\n      isBack = true\r\n      // 跳转操作\r\n      if (opts.type === 'navigateTo') {\r\n        Navigator._secretOpen({ url })      // 相当直接执行wx.navigateTo,不会更新逻辑栈\r\n      // 重定向\r\n      } else if (opts.type === 'redirectTo') {\r\n        Navigator._secretReplace({ url })   // 相当直接执行wx.redirectTo,不会更新逻辑栈\r\n      }\r\n    // 返回操作\r\n    } else {\r\n      // 获取逻辑栈\r\n      let routes = Navigator.history\r\n      // 如果10层之外的返回，用navigateTo操作\r\n      // 如果是10层返回到9层，用redirectTo操作\r\n      const operation = (routes.length === Navigator.maxLevel) ? 'redirectTo' : 'navigateTo'\r\n      // 获取要返回的页面路由\r\n      let preRoute\r\n      if (operation === 'navigateTo') {\r\n        // 移除逻辑层中后两个元素：\r\n        // 移除最后一个是因为要返\r\n        // 移除倒数第二个是因为，跳转到倒数第二个页面时会重新插入逻辑栈\r\n        preRoute = routes.splice(routes.length - 2, 2)[0]\r\n      } else {\r\n        // 重定向时只移除最后一个元素\r\n        preRoute = routes[routes.length - 2]\r\n        routes.splice(routes.length - 1, 1)\r\n      }\r\n      // 更新逻辑栈\r\n      Navigator.updateRoutes(routes)\r\n      // 执行自己包装的跳转、重定向方法，该操作会更新逻辑栈\r\n      Navigator[operation](preRoute)\r\n    }\r\n  }\r\n}\r\n</script>\r\n<style lang=\"scss\">\r\n  .main {\r\n    background-color: $white-color;\r\n  }\r\n</style>\r\n复制代码原理就是这样，但是有几点需要注意：业务代码中需要调用自己封装的跳转方法切记不要直接调用wx的api，也不要使用组件，这样是没法更新js逻辑栈的，正确跳转方式如：Navigator.navigateTo({ url: 'xxx' })。跳转时要及时更新js逻辑栈（更新时机如上所述），因为这会直接影响中转页的跳转逻辑这个方案最大的优点在于不用监听页面卸载时对逻辑栈的更新，无需在每个页面里加入更新逻辑栈代码。OK，这次就介绍这么多，有问题或者有更好的方案，可以留言沟通，大家相互学习。"}
{"title": "微信小程序发送模板消息！附前端+后端源码~ ", "author": "Rolan", "pub_time": "2018-12-10 00:25", "article_content": "前端，index.wxml<form bindsubmit=\"submit\" report-submit='true' >\r\n  <input type='text' value='填写openid' name=\"openid\"></input>\r\n  <input type='text' value='填写ACCESS_TOKEN' name=\"token\"></input>\r\n  <input type='text' value='填写模板ID' name=\"template\"></input>\r\n  <input type='text' value='模板的第1个关键词' name=\"keyword1\"></input>\r\n  <input type='text' value='模板的第2个关键词' name=\"keyword2\"></input>\r\n  <input type='text' value='模板的第3个关键词' name=\"keyword3\"></input>\r\n  <input type='text' value='模板的第4个关键词' name=\"keyword4\"></input>\r\n  <input type='text' value='模板的第5个关键词' name=\"keyword5\"></input>\r\n  <button form-type=\"submit\" type=\"default\">推送</button>\r\n</form>index.js// pages/mubanxiaoxi/mubanxiaoxi.js\r\nPage({\r\n  data: {\r\n     \r\n  },\r\n \r\n  submit: function (e) {\r\n    var openid = e.detail.value.openid;\r\n    var access = e.detail.value.token;\r\n    var template = e.detail.value.template;\r\n    var keyword1 = e.detail.value.keyword1;\r\n    var keyword2 = e.detail.value.keyword2;\r\n    var keyword3 = e.detail.value.keyword3;\r\n    var keyword4 = e.detail.value.keyword4;\r\n    var keyword5 = e.detail.value.keyword5;\r\n    var that = this;\r\n    wx.request({\r\n      url: '域名/muban.php?openid=' + e.detail.value.openid + '&token=' + e.detail.value.token + '&template=' + e.detail.value.template + '&formid=' + e.detail.formId + '&keyword1=' + e.detail.value.keyword1 + '&keyword2=' + e.detail.value.keyword2 + '&keyword3=' + e.detail.value.keyword3 + '&keyword4=' + e.detail.value.keyword4 + '&keyword5=' + e.detail.value.keyword5, //接口地址，我学习就用get，建议用post\r\n      data: {\r\n        open_id: openid,\r\n        tok_en: access,\r\n        temp_late: template,\r\n        form_id: e.detail.formId,\r\n        keyword_1: keyword1,\r\n        keyword_2: keyword2,\r\n        keyword_3: keyword3,\r\n        keyword_4: keyword4,\r\n        keyword_5: keyword5\r\n      },\r\n      success: function (res) {\r\n       \r\n      // console.log(e.detail.formId);\r\n      // console.log(res.data);\r\n      }\r\n    })\r\n  }\r\n})后端，muban.php<?php\r\n    //GET参数\r\n    $access_token=$_GET['token'];\r\n    $openid=$_GET['openid'];\r\n    $templateid=$_GET['template'];\r\n    $formid=$_GET['formid'];\r\n    $keyword1=$_GET['keyword1'];\r\n    $keyword2=$_GET['keyword2'];\r\n    $keyword3=$_GET['keyword3'];\r\n    $keyword4=$_GET['keyword4'];\r\n    $keyword5=$_GET['keyword5'];\r\n    echo $keywordd1;\r\n    //此处开始处理数据\r\n    $dataa=array(\r\n        \"keyword1\"=>array(\r\n                            \"value\"=>$keyword1,\r\n                            \"color\"=>\"#9b9b9b\"),\r\n        \"keyword2\"=>array(\r\n                            \"value\"=>$keyword2,\r\n                            \"color\"=>\"#9b9b9b\"),\r\n        \"keyword3\"=>array(\r\n                            \"value\"=>$keyword3,\r\n                            \"color\"=>\"#9b9b9b\"),\r\n        \"keyword4\"=>array(\r\n                            \"value\"=>$keyword4,\r\n                            \"color\"=>\"#9b9b9b\"),\r\n        \"keyword5\"=>array(\r\n                            \"value\"=>$keyword5,\r\n                            \"color\"=>\"#9b9b9b\")\r\n                );\r\n  \r\n    $data=array();\r\n    $data['touser']=$openid;\r\n    $data['template_id']=$templateid;\r\n    $data['form_id']=$formid;\r\n    $data['data']=$dataa;\r\n      \r\n    $url = 'https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token='.$access_token;  \r\n    $type=\"json\";\r\n        if($type=='json'){//json $_POST=json_decode(file_get_contents('php://input'), TRUE);\r\n            $headers = array(\"Content-type: application/json;charset=UTF-8\",\"Accept: application/json\",\"Cache-Control: no-cache\", \"Pragma: no-cache\");\r\n            $data=json_encode($data);\r\n        }\r\n        $curl = curl_init();\r\n        curl_setopt($curl, CURLOPT_URL, $url);\r\n        curl_setopt($curl, CURLOPT_POST, 1); // 发送一个常规的Post请求\r\n        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\r\n        curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);\r\n        if (!empty($data)){\r\n            curl_setopt($curl, CURLOPT_POST, 1);\r\n            curl_setopt($curl, CURLOPT_POSTFIELDS,$data);\r\n        }\r\n        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\r\n        curl_setopt($curl, CURLOPT_HTTPHEADER, $headers );\r\n        $output = curl_exec($curl);\r\n        if (curl_errno($curl)) {\r\n            echo 'Errno'.curl_error($curl);//捕抓异常\r\n        }\r\n        curl_close($curl);\r\n        echo $output;\r\n?>至于openid和access_token怎么获取，自己另外学习咯！推送成功！"}
{"title": "mpvue开发小程序总结 ", "author": "Rolan", "pub_time": "2018-12-10 00:33", "article_content": "export const request = (url, data, method) => {\r\n    return new Promise((resolve, reject) => {\r\n        const accessToken = wx.getStorageSync('accessToken')\r\n          const header  = {\r\n            'Content-Type': 'application/json',\r\n            'token': accessToken             // 所有请求将token放在header里传输\r\n          }\r\n          wx.request({\r\n            url,\r\n            data,\r\n            method,\r\n            success(res) {\r\n                if (res.data.success) {\r\n                    resolve(resp)\r\n                } else {\r\n                    if(res.data.errorCode === 401) {        // token错误特殊逻辑（code码跟后端约定）\r\n                         const url = \"../login/main\"\r\n                         wx.redirectTo({ url })\r\n                         wxToast('登录失效,请重新登录')\r\n                         return\r\n                    }\r\n                    wxToast(res.errorMessage || '服务异常，请稍后再试')     // 错误统一以toast形式弹出\r\n                    reject(res.data)              // 并将错误抛出以便在catch中处理一些特殊业务逻辑\r\n                    \r\n                }\r\n            },\r\n            fail(res) {\r\n                reject(res)\r\n                wxToast(res.errorMessage || '服务异常，请稍后再试')\r\n                console.log(res)\r\n            }\r\n          })\r\n    })\r\n}\r\n\r\n//调用：\r\nconst url = 'https://xxx'\r\nexport const login = params => request(`${url}/xxx`, params, 'POST'); // 登录\r\n\r\nlogin(params).then(data => {\r\n    console.log('success')\r\n}).catch(e => {\r\n    console.log('failed')\r\n})\r\n复制代码1.2 toast的封装export const wxToast = (title='',icon='none',duration=2000) => {\r\n    wx.showToast({\r\n        title,\r\n        icon,\r\n        duration\r\n    })\r\n}\r\n复制代码1.3 storage的封装export const wxStorage = (key, data) => {\r\n    if(data) {             // data存在，则是设置\r\n        wx.setStorage({\r\n            key,\r\n            data\r\n        })\r\n    } else {\r\n        wx.getStorageSync(key)\r\n    }\r\n}\r\n复制代码二、mpvue小程序采坑2.1 vue的created钩子所有页面的created钩子在onLaunch后就执行了,所以页面里使用created钩子函数是拿不到实时数据的，故created一般情况下不使用。可用小程序的onReady或onLoad代替2.2 vue的mounted钩子退出再进来页面后mounted里的数据并没有重置（页面跳转后并没有销毁页面实例，而是将其推入页面栈中，所以会保存之前的旧的数据），将会导致一系列数据错误，可用小程序的onShow代替（在onShow里初始化数据 或者在onUnLoad里销毁数据）2.3 用户拒绝授权后 重新授权小程序官方已经禁止 主动跳转设置页了，必须在button上触发（类似获取用户信息wx.getUserInfo()首次也是无法主动唤起授权操作，必须在button上绑定@getuserinfo函数）预授权const that = this\r\n   wx.getSetting({\r\n     success (res) {\r\n       console.log('点击查询用户录音权限', res.authSetting['scope.record'])\r\n       if (!res.authSetting['scope.record']) {\r\n         // 如果用户之前已经同意授权，则不会出现弹窗，直接返回成功\r\n         wx.authorize({\r\n           scope: 'scope.record',\r\n           success () {\r\n             that.isAuth = true\r\n           },\r\n           fail () {    // 主动授权失败后引导用户打开权限设置页\r\n             that.isAuth = false\r\n           }\r\n         })\r\n       } else {\r\n         that.isAuth = true\r\n       }\r\n     }\r\n   })\r\n复制代码用户点击 需要授权的操作时(点击的必须是button,否则wx.openSetting()无法唤起权限设置页)if (!this.isAuth) {\r\n   wx.openSetting()\r\n   return\r\n }\r\n复制代码2.4 不支持template中使用复杂渲染函数，可用computed计算属性替代<template>\r\n   <div> {{format(a)}} </div>   // 不支持使用渲染函数format\r\n   <div>{{b}}</div>             // 使用计算属性(若是一个数组列表，只能先转译数组)\r\n</template>\r\n\r\n<script>\r\n   export default {\r\n       data() {\r\n           return {\r\n               a:1\r\n           }\r\n       }\r\n       methods: {\r\n           format(e) {\r\n               return `${e}bbb`\r\n           }\r\n       },\r\n       computed: {\r\n           b() {\r\n               return `${this.a}bbb`\r\n           }\r\n       }\r\n   }\r\n</script>\r\n复制代码2.5 class/style 不支持 vue 的 classObject/styleObject， 但支持如下形式：<p class=\"static\" :class=\"{ active: isActive, 'text-danger': hasError }\">222</p>\r\n<p class=\"static\" :class=\"[isActive ? activeClass : '', errorClass]\">444</p>\r\n:style=\"{transform: 'translate('+ (item.ansId==currentTouchId ? xAxis : 0) + 'px,'+ ((item.ansId==currentTouchId ? yAxis : 0)) +'px)',width: width + 'px', height: height + 'px'}\"\r\n复制代码2.6 css background-image 不支持本地图片，必须是远程cdn资源2.7 用canvas绘图，生成带参数的小程序码的海报用于分享朋友圈由于 海报图是放在cdn中，canvas不能操作不在同一域名下的图片，故由服务端去合成2.8 跳转tabBar页面必须用switchTab2.9 强制更新const updateManager = wx.getUpdateManager()\r\n\r\nupdateManager.onCheckForUpdate(function (res) {\r\n    // 请求完新版本信息的回调\r\n    console.log(res.hasUpdate)\r\n})\r\n\r\nupdateManager.onUpdateReady(function () {\r\n    wx.showModal({\r\n        title: '更新提示',\r\n        content: '新版本已经准备好，是否重启应用？',\r\n        success: function (res) {\r\n            if (res.confirm) {\r\n                // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启\r\n                updateManager.applyUpdate()\r\n            }\r\n        }\r\n    })\r\n    \r\n})\r\n复制代码2.10 单独为每个页面的设置页面头部信息(main.js中设置)// main.js\r\nconst app = new Vue(App)\r\napp.$mount()\r\nexport default {\r\n  config: {\r\n    navigationBarTitleText: '登录'\r\n  }\r\n}\r\n复制代码2.11 获取扫 带参数二维码用户进来的参数onLoad(options) {\r\n    console.log(decodeURIComponent(options.scene))\r\n}\r\n复制代码2.12 小程序checkbox 点击选中显示错乱<checkbox :value=\"index\" :checked=\"checkItem.checked\" />\r\n// 加上checked属性，点击修改其boolean值\r\n复制代码2.13 带参数的自定义分享<template>\r\n    //通过button触发\r\n    <button open-type=\"share\" ></button>\r\n</template>\r\n<script>\r\nonShareAppMessage(res) {\r\n    let id = wx.getStorageSync(\"id\");\r\n    let title = `${this.name}哈哈哈！`              // 可以取到data中的数据\r\n    let path = \"/pages/xxx/main?sourceId=\" + id   // 必须是以 / 开头的完整路径\r\n    let imageUrl = \"https:xxx.jpg\"                  // 默认是截屏\r\n    \r\n    return {\r\n        title: title,\r\n        path: path,\r\n        imageUrl: imageUrl\r\n    };\r\n}\r\n</script>\r\n复制代码2.14 获取模板消息id<form :report-submit=\"true\"\t @submit=\"onClick\">\r\n  <button @click=\"onShare('students')\" class=\"applyStu\" formType=\"submit\">获取form_id</button>\r\n</form>\r\n\r\nonClick(e){\r\n    this.formId = e.mp.detail.formId\r\n}\r\n// 点击一次获取多个formId:\r\n//https://www.jianshu.com/p/84dd9cd6eaed?_blank\r\n复制代码2.15 分包与主包的配置{\r\n  \"pages\": [\r\n    \"pages/index/main\",\r\n    \"pages/logs/main\"  \r\n  ],\r\n  \"window\": {\r\n    \"backgroundTextStyle\": \"light\",\r\n    \"navigationBarBackgroundColor\": \"#fff\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\": \"black\"\r\n  },\r\n  \"subPackages\": [\r\n    {\r\n      \"root\": \"pages/subPackages\",              // 分包根路径\r\n      \"pages\": [\r\n        \"index/main\"\r\n      ]\r\n    }\r\n  ]\r\n}\r\n\r\n复制代码"}
{"title": "微信小程序引入Font Awesome-icon ", "author": "Rolan", "pub_time": "2018-12-11 00:12", "article_content": "1下载最新版本Font Awesome选择最新免费使用版本下载：https://www.thinkcmf.com/font_awesome.html2 将字体转换为 BASE642.1 进入转换网站transfonter.orghttps://transfonter.org/2.2 解压下载好的 fontawesome-free-5.0.13.zip2.3 点击网址上的Add fonts：点击Add fonts2.4 进入fontawesome-free-5.0.13\\web-fonts-with-css\\webfonts 选中fa-solid-900.ttffa-solid-900.ttf2.5 上传完成后，按下图配置后，点击转换即可配置转换2.6 转换完成，点击下载转换完成2.7 解压，选择stylesheet.css文件选择stylesheet.css文件2.8 将改文件重命名为: font-awesome.wxss3 在app.wxss中引入该文件，并且增加fa样式@import \"/assets/css/icon/font-awesome.wxss\";\r\n.container {\r\n    height: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: space-between;\r\n    padding: 200rpx 0;\r\n    box-sizing: border-box;\r\n}\r\n\r\n/*增加`fa`样式*/\r\n.fa {\r\n    font-family: 'Font Awesome 5 Free';\r\n    font-weight: 900;\r\n    -moz-osx-font-smoothing: grayscale;\r\n    -webkit-font-smoothing: antialiased;\r\n    display: inline-block;\r\n    font-style: normal;\r\n    font-variant: normal;\r\n    text-rendering: auto;\r\n    line-height: 1;\r\n}\r\n复制代码4 使用方式<text class=\"fa fa-user\"></text>\r\n复制代码5 样例:demo6 注意，需要引入你要使用的icon的样式例如：.fa-picture-o:before { \r\n    content: \"\\f03e\"; \r\n}复制代码---End---"}
{"title": "小程序用Canvas给图片加水印，拼接图片，制作名片 ", "author": "Rolan", "pub_time": "2018-11-22 00:32", "article_content": "Canvas是微信小程序中的一个原生组件，因此我们在使用它的时候要特别注意微信小程序对原生组件的使用说明。canvas这个组件其实就是一个画布，你可以在上面画很多你用其他方式不好实现的内容。下面我就将介绍一下怎么给图片添加水印，图片的拼接，怎么制作个性名片以及制作一个涂鸦的画板。水印水印的添加总的来说可以简单的分为三步来走，第一步先完成一个画布的创建，第二步在画板上画出你想添加水印的图片，第三步画上你要添加的水印文字。创建画板<canvas style=\"width: {{imageWidth}}px; height: {{imageHeight}}px;\" canvas-id=\"myCanvas\"></canvas>需要注意的是canvas-id的唯一性，如果使用一个已经出现过的 canvas-id，该 canvas 标签对应的画布将被隐藏并不再正常工作。这里我们将宽度和高度设置成动态的，根据图片的宽高来确定画板宽高的比例。 然后我们需要在.js文件中进行操作：var ctx= wx.createCanvasContext('myCanvas')var that = this//选择图片，这里我们设置先选择一张。wx.chooseImage({  count: 1,  sizeType: ['original', 'compressed'],  sourceType: ['album', 'camera'],  success(res) {    var tempFilePaths = res.tempFilePaths    //获取图片基本信息    wx.getImageInfo({        src: tempFilePaths[0],        success: function (res) {          var width = res.width          var height = res.height          //获取屏幕宽度          let screenWidth = wx.getSystemInfoSync().windowWidth          //处理一下图片的宽高的比例          if (width >= height) {            if (width > screenWidth) {              width = screenWidth            }            height = height / res.width * width          } else {            if (width > screenWidth) {              width = screenWidth            }            if (height > 400) {              height = 400              width = res.width / res.height * height            } else {              height = height / res.width * width            }          }          that.setData({            imageWidth: width,            imageHeight: height,          })          ctx.drawImage(res.path, 0, 0, width, height)          ctx.rotate(obj.rotate * Math.PI / 180)          for (let j = 1; j < 12; j++) {              ctx.beginPath()              ctx.setFontSize(14)              ctx.setFillStyle('white')              ctx.fillText('你要添加的文字', 0, 50 * j)              for (let i = 1; i < 12; i++) {                  ctx.beginPath()                  ctx.setFontSize(14)                  ctx.setFillStyle('white')                  ctx.fillText(\"你要添加的文字\", (15 + (14-1)*\"你要添加的文字\".length) * i, 50 * j)              }          }          for (let j = 0; j < 12; j++) {              ctx.beginPath()              ctx.setFontSize(obj.fontSize)              ctx.setFillStyle(obj.color)              ctx.fillText(\"你要添加的文字\", 0, -50 * j)              for (let i = 1; i < 12; i++) {                  ctx.beginPath()                  ctx.setFontSize(14)                  ctx.setFillStyle('white')                  ctx.fillText(\"你要添加的文字\", (15 + (14-1)* \"你要添加的文字\".length) * i, -50 * j)              }            }            ctx.draw()        }    })  }})图片拼接图片拼接思路就更加简单了，说白了就是在一个画布上咱们连续地画几张图片再将它导出来就OK了。 创建画布我就不说了，还是和上面的一样，width和height也是动态的。我们得根据获取的图片来动态的计算出它的宽高，这里主要是计算它的高度，以保证我们弄出来的图片是不会变形的。// 这里的图片数组可以从相册中选取出来，也可以从上一个页面传过来，但是要注意传的时候得转成JSON再传for(var i = 0; i < imagesArr.length; i++){  var imageUrl = imagesArr[i]  wx.getImageInfo({    src: imageUrl,    success: function (res) {      var width = res.width      var height = res.height      // downNum是一个对象，用来计数      obj.downNum = obj.downNum + 1      let sw = wx.getSystemInfoSync().windowWidth      if(width > sw){        width = sw        height = height / res.width * width      }      // heightForCanvas也是一个对象，用来记录总的高度         ctx.drawImage(res.path, (sw-width)/2.0, obj.heightForCanvas, width, height)      obj.heightForCanvas = obj.heightForCanvas + height      that.setData({        height: obj.heightForCanvas      })      // 全部drawImage调用完毕后再调用draw()      if (obj.downNum == imagesArr.length){        ctx.draw()      }    }  })}个性名片个性名片其实就是对画布的一个综合整体的运用，同样的技巧你也可以用来制作海报什么的。还是说一下思路，首先我们也是创建画布，然后给它添加一个贴切你主题的背景图，添加背景图最需要注意的还是获取图片的尺寸防止其变形。背景添加了我们就需要给它添加展示的内容了，添加文字添加图片等等。这里说一下怎么给图片切圆角，首先我们需要用canvas画一个圆，然后再对其进行裁剪，因为一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内。 onLoad: function () {    var that = this;    var ctx = wx.createCanvasContext('myCanvas')    // 先保存状态 已便于画完圆再用    ctx.save();     // 开始绘制    ctx.beginPath();    //先画个圆    ctx.arc(100, 100, 100, 0, Math.PI * 2, false);    // 画了圆 再剪切 原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内    ctx.clip();    ctx.drawImage('图片的地址', 0, 0, '图片宽度', '图片高度');     //恢复之前保存的绘图上下文 恢复之前保存的绘图上下午即状态 可以      继续绘制    ctx.restore();     ctx.draw();   }})最后还有很多的细节没有讲到大家如果还有疑点可以看看这个demo这是我写的一个简单处理图片的一个小程序，你也可以在微信小程序中搜索“图片帮手”。也可以直接扫描下方的二维码 demo:由于本人也是小程序小白，有什么地方说的不对的还请海涵。作者：codeLover_0324 链接：https://www.jianshu.com/p/50b662e93053"}
{"title": "小程序云开发之新闻类项目分析 ", "author": "Rolan", "pub_time": "2018-11-23 00:23", "article_content": "应该每一个前端开发者都有一颗 全干 全栈的心:heartpulse:吧。 那就让云开发满足你云开发一出来就开始玩，云数据库，云函数，全栈的体验和开发速度，真的不是一般的爽。 接下来工作中要开发一款新闻类小程序，于是就开始了对头条君的调研，此篇文章，是我的个人总结和分析，欢迎大佬拍砖。一. 准备小程序云开发必须有小程序AppId才能使用，所以首先应先注册一个小程序账号（如果已有请忽略）。设置->开发设置中的小程序AppId开发工具：编辑器- vscode ， 微信开发者工具辅助工具：Markman ：图标标注工具，可用于取色、测量。小程序云开发文档 ：文档Iconfont-阿里巴巴矢量图标库 : 各种你需要的图标，下载代码，体量比用图片小多了组件库：刚开始项目的时候我使用了vant组件库，想快速的完成项目，写着写着就发现使用起来有点麻烦，样式达不到自己想要的。所以我果断抛弃了它，我当然不能承认自己菜，只好说这个组件坑，我的项目中也就没使用组件库。但用组件库能极大的提升开发的速度，听大佬说 wux 这个组件库很好用，同行们可以试试。感觉“真香”的记得告诉我看看效果图：（没有展示全，下面有更多配图以供学习这个项目）二. 先聊聊云开发小程序云开发是什么？？？开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。云开发为开发者提供完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容 > ，并不互斥。目前提供三大基础能力支持：云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码数据库：一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库存储：在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理这是官方文档的描述其实简单的来说小程序云开发是一款Serverless服务，开发者可以使用它开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。目前提供云函数、数据库、存储三大基础能力支持。，并且将这些能力封装成特定的接口，以wx.cloud.xxx来进行调用。三.数据库建立根据需求建立了三个集合文章基本信息articles文章详情detail3.文章评论信息comment三个集合通过id字段“连接”，要是个新手这时会想那么麻烦干嘛，直接全部放一起，梭哈一下，全给拿过来，直接用。这肯定是不行的，想想要是这个数据多怎么办，你要让用户等你多久？ 作为前端工程师肯定是希望给用户带来极佳的使用体验，所以你想在页面上展示什么，就设置一个对应的数据去关联，要什么取什么。后台数据无非就是一对一，一对多，你要啥数据就用传相关字段进云函数，在云函数里进行简单的增删改查。千万记住，要考虑你的集合数据的使用范围进行权限设置，比如我添加的是articles文章，那这是公开的。那我就应该在权限设置中修改为所有用户可读、仅管理员可写，默认的是仅创建者及管理员可读写。如何建表，表和表之间的联系，在动手项目之前要考虑好，避免表里的内容重复导致内存浪费，在能实行其功能的基础上做到不浪费内存。我上面的表建的就有点问题，图片URL的地址存错了地方，而且在两表里都存储了，大家做的时候可以吸取我的教训。四. 项目分析头条功能那么多是不可能写的完，我们在这里就选择其首页、新闻详情、登录界面这部分来实现一下。首页推荐：头条里面有不同的新闻样式，有无图的，一张图的还有三张图的，所以我们肯定要分离出不同的模板，根据后台传过来的数据去判断新闻的样式最后在页面中显示出来 数据驱动页面MVVMM 是数据 模型V view 页面 视图VM 数据绑定到界面上 视图模型 -> 模板{{}}新闻详情：打开新闻详情页，分析之后发现大体分为三个部分 头部的作者信息 新闻内容底部的用户评论 这些信息都是在云开发数据库中不同的集合里面，这些数据的提取操作封装在云函数里面以便调用 这三部分都是重复的结构抽离出来作为组件，组件非常的灵活，这样做的好处是页面结构将会更加的清晰，增加代码的复用性，并且耦合度降低，后续程序的维护也更为方便。登录界面：直接使用wx.getUserInfo获得用户信息 后面会贴出js代码五.功能实现不详解1. 目录2. 首页该页面采用顶部的固定搜索栏、scroll-view和swiper内容区三个模块，三个模块均可采用绝对定位，搜索栏flex布局，swiper内容区内swiper-item有关注，推荐，热点，南昌和视频<scroll-view class=\"navBar-box\" scroll-x=\"true\" style=\"white-space: nowrap; display:flex \">\r\n    <view class=\"cate-list {{curIndex==index?'on':''}}\" wx:for=\"{{category}}\" \r\n    wx:key=\"{{item.id}}\" data-id=\"{{item.id}}\" data-index=\"{{index}}\" bindtap=\"switchCategory\">\r\n    {{item.name}}\r\n    </view>\r\n</scroll-view>在jsdata里面 设置curIndex, toView,用以监控不同版块的状态 实现了将上面的scroll-view和下面的文章swiper建立关系<swiper class=\"notes\"  current=\"{{curIndex}}\"  bindchange=\"swiperchange\">\r\n      <swiper-item class=\"focus\">\r\n            ...\r\n        </swiper-item>\r\n        <swiper-item class=\"category\"  wx:key=\"{{item.id}}\">\r\n            <scroll-view class=\"cate-box\"  scroll-y=\"true\" bindscrolltolower=\"loadarticles\">\r\n            <view class=\"note\" wx:for=\"{{notes}}\" wx:for-item=\"note\" wx:key=\"{{index}}\">\r\n                 <block wx:if=\"{{note.image.length < 3 }}\">\r\n                 <template is=\"templateone\" data=\"{{...note}}\"></template>\r\n                 </block>\r\n                 <block wx:elif=\"{{note.image.length >= 3}} \">\r\n                 <template is=\"templatetwo\" data=\"{{...note}}\"></template>\r\n                 </block>\r\n      </view>\r\n    </scroll-view>\r\n  </swiper-item>\r\n</swiper>不同的新闻显示模板 使用组件化的概念，创建一个template文件夹<template name=\"templateone\">\r\n  <view class=\"newList\">\r\n         ...\r\n  </view>  \r\n</template>\r\n<template name=\"templatetwo\">\r\n  <view class=\"newList\">\r\n         ...\r\n  </view>  \r\n</template>在需要用到模板的地方就可以直接使用<import src=\"../../components/template/template.wxml\"/>既然要用到模板那接下来我们就把模板给写出来。分析一下模板里面的内容里面的数据除时间以外都是可以直接从后台调取在页面上显示出来的数据，但时间不一样，它是变化的在数据库中time字段以时间戳的形式保存。在后面的详情页中也要用到时间的格式化，so写一个js封装起来数据的调取 JS在小程序中我们时时刻刻需要去请求数据，数据的调取封装起来是极好的，存在util里想用的时候拿一下就okwx.cloud.init();\r\nconst db = wx.cloud.database();\r\nconst notes = db.collection('articles');\r\n// 加载notes，page=1默认形参 ，limit = 4 ，fn \r\nconst loadNotes = (fn,page = 1,limit = 4) =>{\r\n  //return 数据集 异步\r\n  const skip = (page -1) * limit;\r\n  notes\r\n  .count()\r\n  .then(() =>{\r\n    return notes\r\n    .limit(limit)\r\n     .skip(skip)\r\n    .get()\r\n  })\r\n  .then(res =>{\r\n    //console.log(res.data)\r\n    fn({\r\n      data:res.data\r\n    })\r\n  })\r\n  // fn(data);\r\n};\r\n\r\nmodule.exports = {\r\n  loadNotes,\r\n}WXS实现时间格式WXS 是小程序的一套脚本语言，结合WXML，可以构建出页面的结构。 了该一哈新建一个timeapi.wxs文件，在template.wxml引用，定义模块名即可引用：<wxs src=\"../../utils/timeapi.wxs\" module=\"timeapi\" ></wxs>\r\n.....\r\n <text class=\"newList-item-time\">{{timeapi.formatTime(time)}}</text>timeapi.wxs文件和时间格式实现方法：var formatTime = function (time) {\r\n  // 获取当前时间\r\n  var getUnix = function () {\r\n    var date = getDate()\r\n    return date.getTime()\r\n  }\r\n  // 获取今天零点时间\r\n  var getTodayUnix = function () {\r\n    var date = getDate()\r\n    date.setHours(0)\r\n    date.setMinutes(0)\r\n    date.setSeconds(0)\r\n    date.setMilliseconds(0)\r\n    return date.getTime()\r\n  }\r\n  // 获取今年的1月1日零点时间\r\n  var getYearUnix = function () {\r\n    var date = getDate()\r\n    date.setMonth(0)\r\n    date.setDate(1)\r\n    date.setHours(0)\r\n    date.setMinutes(0)\r\n    date.setSeconds(0)\r\n    date.setMilliseconds(0)\r\n    return date.getTime()\r\n  }\r\n  // 获取标准时间\r\n  var getLastDate = function (time) {\r\n    var date = getDate(time)\r\n    var month = date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1\r\n    var day = date.getDay() < 10 ? '0' + (date.getDay()) : date.getDay()\r\n    return date.getFullYear() + '-' + month + '-' + day\r\n  }\r\n  // 转换时间\r\n  var getFormatTime = function (timestamp) {\r\n    var now = getUnix()\r\n    var today = getTodayUnix()\r\n    var year = getYearUnix()\r\n    var timer = (now - timestamp) / 1000\r\n    var tip = ''\r\n    if (timer <= 0) {\r\n      tip = '刚刚'\r\n    } else if (Math.floor(timer / 60) <= 0) {\r\n      tip = '刚刚'\r\n    } else if (timer < 3600) {\r\n      tip = Math.floor(timer / 60) + '分钟前'\r\n    } else if (timer >= 3600 && (timestamp - today >= 0)) {\r\n      tip = Math.floor(timer / 3600) + '小时前'\r\n    } else if (timer / 86400 <= 31) {\r\n      tip = Math.ceil(timer / 86400) + '天前'\r\n    } else {\r\n      tip = getLastDate(timestamp)\r\n    }\r\n    return tip\r\n  }\r\n  return getFormatTime(time)\r\n}\r\n\r\n  module.exports = {\r\n    formatTime: formatTime\r\n  }wxs有优点有缺点，用的时候要考虑好。注意以下三点。wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript 一致。wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。3.详情页详情页涉及到三个表的内容。那就在云函数里完成表的查询组装输出，多方便啊。这个代码就不贴了，要参考的话，底部会把GitHub贴出来，目录在上面的图片。使用云函数的话有个技巧。 在开发工具里看是否成功，且把数据传输过来了 。如图。项目中的数据是从网站上爬下来的，数据库里的文章内容就是html的格式，so我们应该把tml =>wxmlwxParse-微信小程序富文本解析自定义组件,支持HTML及markdown解析本githup 上有使用方法，这里我就不做重复的描述 点着我这里使用这个工具完全是为项目实现的而去做，如果真正做一个小程序新闻类项目肯定是不太好的，先不说wxParse解析可能会出现乱码，再就是它所占的内存也不小。真正开发的时候就别用了，数据库里的数据也不会是html格式的。在手机上显示时(坑)wxparse 代码的一个 bug，在一些特殊的手机里面，在 wxparse/html2json.js 中的第 112 和 119 行，都有一个 console.dir 这个函数的使用，把这个函数注释掉，内容就可以正常显示出来评论组件我们这里提一下点赞功能实现，借用大佬的话点赞的变化是由用户产生的一个交互，传统的观点就是用户点赞->后端更新数据->前端拉取数据->数据驱动视图的变化。那我们就先把样式给用户表现出来,数据交给后台慢慢异步处理4.登陆页面页面布局就没啥好说的，登录 (知识点)getUserInfobutton type=\"bindUserInfo\"auth 授权登录高阶函数异步的处理html部分<view wx:if=\"{{auth === 0}}\" > //判断登录情况\r\n             <button open-type=\"getUserInfo\" \r\n                bindgetuserinfo=\"getUserInfo\">\r\n                 登录\r\n             </button>\r\n</view>\r\n            <view wx:else>\r\n                <view class=\"top\">\r\n                    <image class=\"avatar\" src=\"{{avatarUrl}}\"/>\r\n                    <view class=\"name\">\r\n                        <text class=\"nickname\">{{nickname}}</text>\r\n                        <button>申请认证</button>\r\n                    </view>\r\n            <icon type=\"zhixiang\" color=\"#848484\"></icon>  //封装的icon\r\n                </view>//获取应用实例\r\nconst app = getApp()\r\nconst globalData= app.globalData;\r\n\r\nPage({\r\n  data: {\r\n    auth:-1,\r\n    nickname:'',\r\n    avatarUrl:''\r\n  },\r\n  onLoad: function () {\r\n    this.getScope(this.getUserInfo,()=>{\r\n      this.setData({\r\n        auth:0\r\n      })\r\n    });\r\n  },\r\n  //高阶函数 success 参数也是一个函数\r\n  getScope(success,fail,name='scope.userInfo'){\r\n    wx.getSetting({\r\n      success:(res) => {\r\n        // console.log(res); \r\n        if(res.authSetting[name]){\r\n          success();\r\n        }else{\r\n          fail();\r\n        }\r\n      }\r\n    })\r\n  },\r\n  getUserInfo (){\r\n    // console.log('userinfo')\r\n    if(!globalData.nickname||!globalData.avatarUrl){\r\n      // 1. wx.getUserInfo(nickname,avatar)函数 \r\n      // 2. 放到全局 函数\r\n      this._getUserInfo((res) =>{\r\n        // console.log(res);\r\n        this.setData({\r\n          nickname:res.nickName,\r\n          avatarUrl:res.avatarUrl,\r\n          auth:-1\r\n        });\r\n        globalData.nickname=res.nickName;\r\n        globalData.avatarUrl=res.avatarUrl;\r\n      });\r\n    }\r\n  },\r\n  _getUserInfo(cb = () =>{}){\r\n    wx.getUserInfo({\r\n      success:(res) =>{\r\n        cb(res.userInfo);\r\n      }\r\n    })\r\n  }\r\n})六.总结页面无非是基本结构和一堆模块外加js交互组合起来的。快速完成一张简单的demo的页面只需要：绘制基本架构、增加功能模块、js交互三步就能完成。绘制基本架构：第一步看页面的基本构造，分析布局,这时细节不重要，看总体架构，使用BEM命名规则增加合适的class命名格式，这样可以为内部的模块提供合理的class命名格式，避免class混乱而造成页面样式混乱，维护css样式麻烦wxml上不要不舍得套盒子,盒子就和分类箱一样,给你整的明明白白,服服帖帖.在云函数中，我们大多会实现一些在小程序中无法实现，这时我们不能使用传统的 Callback 方法来进行请求，因为传统的 callback 方法执行完成后，云函数早已将数据返回给客户端，我们需要使用 Promise 来处理。界面只是一架躯壳，而数据是灵魂，核心思想MVVM 数据驱动页面将平凡的事坚持下去，就会变的不平凡，路漫漫其修远兮，吾将上下而求索。您的鼓励是我前行最大的动力，欢迎点赞，欢迎送小星星:sparkles: ~项目地址彩蛋每个人看问题的角度不同，可能我没有把一些东西讲清楚，别急，我给你带来掘金上大佬的云开发项目总有适合您的：手把手教你完成一个云开发项目，细节详细到爆炸，连设计稿都给你准备好了：[零门槛的全栈体验 小程序云开发完整项目分享]( https://juejin.im/post/5be3d9...仿头条项目，功能实现了很多，喜欢专研的来这： 小程序云开发让你不加班仿快狗打车项目，界面很nice，项目完成度高，可以跟着他文章实现一下：小程序云开发之踩到狗尾巴功能、界面、体验极佳的小程序“旅行小账本” 诗和远方 旅行小账本云开发实战"}
{"title": "小程序扫码进入信息没有绑定推广中心， 没有显示团队 ", "author": "w_60", "pub_time": "2018-11-25 11:41", "article_content": "小程序bug是，我的二手车小程序二维码推广给别人 以后 别人扫码进入小程序 新人的信息没有绑定推广账号 ，推广页面没有显示团队，小程序后台是微擎 PHP接口 数据库字段里面 parent_uid 一直0； 没有更改  希望大神帮忙 ，发红包也行[AppleScript] 纯文本查看 复制代码function t(t) {\r\n  if (Array.isArray(t)) {\r\n    for (var a = 0, e = Array(t.length); a < t.length; a++) e[a] = t[a];\r\n    return e;\r\n  }\r\n  return Array.from(t);\r\n}\r\n\r\nvar a = getApp();\r\n\r\nPage({\r\n  data: {\r\n    isShow: !1,\r\n    parent_uid: 0,\r\n    is_ok: !1,\r\n    banner: [],\r\n    indicatorDots: !0,\r\n    autoplay: !0,\r\n    interval: 5e3,\r\n    duration: 1e3,\r\n    textJson: [],\r\n    textIndex: 0,\r\n    nav_choose: [\"分类\", \"品牌\", \"年限\", \"公里数\", \"排序\"],\r\n    active_index: 0,\r\n    fenlei_id: 0,\r\n    pinpai_id: 0,\r\n    nianxian_id: 0,\r\n    km_id: 0,\r\n    sort_id: 0,\r\n    car_year: \"\",\r\n    car_brand: \"\",\r\n    car_km: \"\",\r\n    car_class: \"\",\r\n    search_arr: [],\r\n    market: [],\r\n    brand: [],\r\n    check_name: \"\",\r\n    carList: [],\r\n    sort_show: !1,\r\n    leftid: 1,\r\n    show_new: !0,\r\n    brand_show: !1,\r\n    recom: 0,\r\n    home_arr: [],\r\n    brandname: \"\",\r\n    selectbrand: \"\",\r\n    brand_status: 0,\r\n    plate_type: 1,\r\n    scanReachBottom: !1,\r\n    unitid: 123,\r\n    latitude: 0,\r\n    longitude: 0,\r\n    index: 0,\r\n    region: [\"\"]\r\n  },\r\n  onLoad: function (t) {\r\n    var e = this;\r\n    t && t.scene && (e.setData({\r\n      parent_uid: t.scene\r\n    }), wx.getUserInfo({\r\n      success: function (t) {\r\n        t.memberInfo ? e.firstin(t.memberInfo) : e.setData({\r\n          isShow: !0\r\n        });\r\n      }\r\n    })),\r\n    wx.getStorage({\r\n      key: 'cityget',\r\n      success: function(res) {\r\n        \r\n        e.initData(res.data);\r\n      },\r\n      fail:function(res){\r\n        e.initData(0);\r\n      } \r\n    })\r\n   // console.log('onLoad == > ' + this.data.index)\r\n  },\r\n  initData: function (t) {\r\n    var e = this;\r\n    e.setData({\r\n      index: t\r\n    }),\r\n      \r\n    //console.log(\"初始化====\" + t)\r\n    wx.getLocation({\r\n      type: \"gcj02\",\r\n      success: function (t) {\r\n        e.setData({\r\n          latitude: t.latitude,\r\n          longitude: t.longitude\r\n        });\r\n      },\r\n      fail: function (t) {\r\n        wx.openSetting({\r\n          success: function (t) {\r\n            t.authSetting[\"scope.userLocation\"] ? wx.getLocation({\r\n              type: \"gcj02\",\r\n              success: function (t) {\r\n                e.setData({\r\n                  latitude: t.latitude,\r\n                  longitude: t.longitude\r\n                });\r\n              }\r\n            }) : (wx.showModal({\r\n              content: \"您未授权获取当前位置无法进行地区筛选！\",\r\n              showCancel: !1\r\n            }), this._list(0));\r\n          }\r\n        });\r\n      }\r\n    }), this._list(1), this._notice(), this._info_set(0);\r\n  },\r\n  bindRegionChange: function (t) {\r\n    console.log(t.detail);\r\n    this.setData({\r\n      index: t.detail.value\r\n    }); this._list(2);\r\n    console.log(this.data.index)\r\n    wx.setStorage({\r\n      key: 'cityget',\r\n      data: this.data.index,\r\n    })\r\n\r\n  },\r\n  hideDialog: function () {\r\n    this.setData({\r\n      isShow: !this.data.isShow\r\n    });\r\n  },\r\n  updateUserInfo: function (t) {\r\n    var e = this;\r\n    a.util.getUserInfo(function (t) {\r\n      e.hideDialog(), e.firstin(t.memberInfo);\r\n    }, t.detail);\r\n  },\r\n  firstin: function (t) {\r\n    var e = this;\r\n    debugger\r\n    a.util.request({\r\n      url: \"entry/wxapp/Api\",\r\n      data: {\r\n        m: \"monai_market\",\r\n        r: \"me.binding\",\r\n        uid: t.uid,\r\n        head_image: t.avatar,\r\n        nickname: t.nickname,\r\n        parent_uid: e.data.parent_uid\r\n      },\r\n      success: function (t) { }\r\n    });\r\n  },\r\n  _info_set: function () {\r\n    var t = this;\r\n    a.util.request({\r\n      url: \"entry/wxapp/Api\",\r\n      data: {\r\n        m: \"monai_market\",\r\n        r: \"home.index.info_set\"\r\n      },\r\n      cachetime: \"0\",\r\n      success: function (a) {\r\n        console.log(a), 2 == a.data.data.head_flow && \"\" != a.data.data.head_flow_id && t.setData({\r\n          unitid: a.data.data.head_flow_id\r\n        });\r\n      }\r\n    });\r\n  },\r\n  _notice: function () {\r\n    var t = this;\r\n    a.util.request({\r\n      url: \"entry/wxapp/Api\",\r\n      data: {\r\n        m: \"monai_market\",\r\n        r: \"home.index.home1\"\r\n      },\r\n      cachetime: \"0\",\r\n      success: function (a) {\r\n        console.log(a), a.data.data.info_name.name && wx.setNavigationBarTitle({\r\n          title: a.data.data.info_name.name + \"\"\r\n        }), 1 == a.data.data.info_name.recom && t.is_home(), 2 == a.data.data.info_name.plate_type && t.setData({\r\n          plate_type: 2\r\n        }), t.setData({\r\n          banner: a.data.data.banner,\r\n          market: a.data.data.market,\r\n          brand: a.data.data.brand,\r\n          textJson: a.data.data.notice,\r\n          info_name: a.data.data.info_name.name,\r\n          recom: a.data.data.info_name.recom,\r\n        });\r\n      }\r\n    });\r\n  },\r\n  ok: function () {\r\n    this.setData({\r\n      is_ok: !1\r\n    });\r\n  },\r\n  banner: function (t) {\r\n    var e = a.getAttr(t, \"id\"), i = a.getAttr(t, \"type\");\r\n    console.log(i), 4 == i ? wx.navigateTo({\r\n      url: \"/pages/mine/sale/index\"\r\n    }) : 5 == i ? wx.navigateTo({\r\n      url: \"/pages/enter/enter\"\r\n    }) : 6 == i || 0 != e && wx.navigateTo({\r\n      url: \"/pages/home/carMessage/carMessage?id=\" + e\r\n    });\r\n  },\r\n  market_class: function (t) {\r\n    var e = a.getAttr(t, \"active_index\"), i = !1;\r\n    this.data.active_index == e && (e = 0, i = !0), this.setData({\r\n      car_type: this.data.market,\r\n      brand_show: !1,\r\n      sort_show: !1,\r\n      active_index: e,\r\n      show_new: i\r\n    });\r\n  },\r\n  market_brand: function (t) {\r\n    wx.navigateTo({\r\n      url: \"../selectscards/index\"\r\n    });\r\n  },\r\n  car_detail: function (t) {\r\n    var e = !1, i = a.getAttr(t, \"active_index\");\r\n    this.data.active_index == i && (i = 0, e = !0), this.setData({\r\n      is_ok: !0,\r\n      car_type: this.data.km_arr,\r\n      sort_show: !1,\r\n      show_new: e,\r\n      brand_show: !1,\r\n      active_index: i\r\n    });\r\n  },\r\n  car_yer: function (t) {\r\n    var e = a.getAttr(t, \"active_index\");\r\n    this.data.active_index == e && (e = 0), this.setData({\r\n      sort_show: !1,\r\n      car_type: this.data.year_arr,\r\n      active_index: e,\r\n      show_new: !1,\r\n      brand_show: !1\r\n    });\r\n  },\r\n  carList: function (t) {\r\n    var e = a.getAttr(t, \"name\"), i = a.getAttr(t, \"id\");\r\n    if (1 == this.data.active_index) {\r\n      n = {\r\n        fenlei_id: i,\r\n        car_class: e,\r\n        active_index: 1,\r\n        mark: d = \"active_index1\",\r\n        check_name: e\r\n      };\r\n      (o = this.data.search_arr.filter(function (t) {\r\n        return t.mark != d;\r\n      })).push(n), this.setData({\r\n        car_class: e,\r\n        fenlei_id: i,\r\n        check_name: e,\r\n        search_arr: o,\r\n        leftid: 1,\r\n        show_new: !0\r\n      });\r\n    } else if (2 == this.data.active_index) {\r\n      var e = a.getAttr(t, \"name\"), n = {\r\n        pinpai_id: i = a.getAttr(t, \"id\"),\r\n        car_brand: e,\r\n        active_index: 2,\r\n        mark: d = \"active_index2\",\r\n        check_name: e\r\n      };\r\n      (o = this.data.search_arr.filter(function (t) {\r\n        return t.mark != d;\r\n      })).push(n), this.setData({\r\n        is_ok: !1,\r\n        car_brand: e,\r\n        pinpai_id: i,\r\n        search_arr: o,\r\n        leftid: 1,\r\n        show_new: !0,\r\n        brand_show: !1\r\n      });\r\n    } else if (3 == this.data.active_index) {\r\n      var s = a.getAttr(t, \"year\"), n = {\r\n        nianxian_id: i = a.getAttr(t, \"index\"),\r\n        car_year: s,\r\n        active_index: 3,\r\n        mark: d = \"active_index3\",\r\n        check_name: s\r\n      };\r\n      (o = this.data.search_arr.filter(function (t) {\r\n        return t.mark != d;\r\n      })).push(n), this.setData({\r\n        is_ok: !1,\r\n        car_year: s,\r\n        nianxian_id: 1 + parseInt(i),\r\n        search_arr: o,\r\n        leftid: 1,\r\n        show_new: !0\r\n      });\r\n    } else if (4 == this.data.active_index) {\r\n      var r = a.getAttr(t, \"km\"), d = \"active_index4\", n = {\r\n        km_id: i = a.getAttr(t, \"index\"),\r\n        car_km: r,\r\n        active_index: 4,\r\n        mark: d,\r\n        check_name: r\r\n      }, o = this.data.search_arr.filter(function (t) {\r\n        return t.mark != d;\r\n      });\r\n      o.push(n), this.setData({\r\n        is_ok: !1,\r\n        car_km: r,\r\n        km_id: 1 + parseInt(i),\r\n        search_arr: o,\r\n        leftid: 1,\r\n        show_new: !0\r\n      });\r\n    }\r\n    this._list(1);\r\n  },\r\n  _list: function (e) {\r\n    console.log('dangqian index == ==    '+this.data.index)\r\n    var i = this;\r\n    1 == e ? this.setData({\r\n      carList: []\r\n    }) : 2 == e && this.setData({\r\n      carList: [],\r\n      leftid: 1,\r\n      show_new: !0\r\n    }), \r\n    this.setData({\r\n      active_index: 0\r\n    }), a.util.request({\r\n      url: \"entry/wxapp/Api\",\r\n      data: {\r\n        m: \"monai_market\",\r\n        r: \"home.index.carList\",\r\n        fenlei_id: this.data.fenlei_id,\r\n        pinpai_id: this.data.pinpai_id,\r\n        nianxian_id: this.data.nianxian_id,\r\n        km_id: parseInt(this.data.km_id),\r\n        sort_id: this.data.sort_id,\r\n        leftid: this.data.leftid++,\r\n        latitude: this.data.latitude,\r\n        longitude: this.data.longitude,\r\n        province: this.data.region[0],\r\n        city: this.data.array[this.data.index]\r\n      },\r\n      cachetime: \"0\",\r\n      success: function (a) {\r\n        if (a.data.data.length > 0) {\r\n          var e;\r\n          (e = i.data.carList).push.apply(e, t(a.data.data)), i.setData({\r\n            scanReachBottom: !1\r\n          }), i.setData({\r\n            is_ok: !1,\r\n            carList: i.data.carList\r\n          });\r\n        } else i.setData({\r\n          scanReachBottom: !0\r\n        }), i.data.show_new = !1;\r\n      }\r\n    });\r\n  },\r\n  clone: function (t) {\r\n    var e = a.getAttr(t, \"index\"), i = this.data.search_arr;\r\n    1 == i[e].active_index ? this.setData({\r\n      fenlei_id: 0,\r\n      check_name: \"\"\r\n    }) : 2 == i[e].active_index ? this.setData({\r\n      pinpai_id: 0,\r\n      car_brand: \"\"\r\n    }) : 3 == i[e].active_index ? (this.setData({\r\n      nianxian_id: 0,\r\n      car_year: \"\"\r\n    }), this.data.nianxian_id = 0) : 4 == i[e].active_index && (this.setData({\r\n      km_id: 0,\r\n      car_km: \"\"\r\n    }), this.data.km_id = 0), i.splice(e, 1), this.setData({\r\n      search_arr: i,\r\n      active_index: 0,\r\n      leftid: 1\r\n    }), this._list(2);\r\n  },\r\n  active_nav: function (t) {\r\n    var e = a.getAttr(t, \"active_index\");\r\n    this.data.active_index != e ? this.setData({\r\n      sort_show: !0,\r\n      show_new: !1,\r\n      active_index: e,\r\n      brand_show: !1\r\n    }) : this.setData({\r\n      sort_show: !1,\r\n      active_index: 0,\r\n      show_new: !1\r\n    });\r\n  },\r\n  sort_car: function (t) {\r\n    var e = a.getAttr(t, \"index\");\r\n    if (this.setData({\r\n      sort_show: !1,\r\n      is_ok: !1\r\n    }), 5 == e) return this._distanceSort(e), !1;\r\n    this.setData({\r\n      sort_id: e\r\n    }), this._list(2);\r\n  },\r\n  _distanceSort: function (t) {\r\n    var a = this;\r\n    if (a.setData({\r\n      active_index: 0\r\n    }), 0 !== a.data.latitude && 0 !== a.data.longitude) return a.setData({\r\n      sort_id: t\r\n    }), a._list(2), !1;\r\n    wx.getLocation({\r\n      type: \"gcj02\",\r\n      success: function (e) {\r\n        a.setData({\r\n          latitude: e.latitude,\r\n          longitude: e.longitude,\r\n          sort_id: t\r\n        }), a._list(2);\r\n      },\r\n      fail: function (e) {\r\n        wx.openSetting({\r\n          success: function (e) {\r\n            e.authSetting[\"scope.userLocation\"] ? wx.getLocation({\r\n              type: \"gcj02\",\r\n              success: function (e) {\r\n                a.setData({\r\n                  latitude: e.latitude,\r\n                  longitude: e.longitude,\r\n                  sort_id: t\r\n                }), a._list(2);\r\n              }\r\n            }) : wx.showModal({\r\n              content: \"您未授权获取当前位置无法使用距离排序！\",\r\n              showCancel: !1\r\n            });\r\n          }\r\n        });\r\n      }\r\n    });\r\n  },\r\n  search: function () {\r\n    wx.navigateTo({\r\n      url: \"../home/searchShop/searchShop\"\r\n    });\r\n  },\r\n  previewImage: function (t) {\r\n    var e = a.getAttr(t, \"src\"), i = a.getAttr(t, \"index\"), n = this, s = [], r = !0, d = !1, o = void 0;\r\n    try {\r\n      for (var c, _ = n.data.carList.image[Symbol.iterator](); !(r = (c = _.next()).done); r = !0) {\r\n        var h = c.value;\r\n        s.push(h.img_patch);\r\n      }\r\n    } catch (t) {\r\n      d = !0, o = t;\r\n    } finally {\r\n      try {\r\n        !r && _.return && _.return();\r\n      } finally {\r\n        if (d) throw o;\r\n      }\r\n    }\r\n    wx.previewImage({\r\n      current: e,\r\n      urls: s\r\n    });\r\n  },\r\n  detile: function (t) {\r\n    var e = a.getAttr(t, \"id\");\r\n    wx.navigateTo({\r\n      url: \"/pages/home/carMessage/carMessage?id=\" + e\r\n    });\r\n  },\r\n  onReachBottom: function () {\r\n    this.data.show_new && this._list(0);\r\n  },\r\n  onPullDownRefresh: function () {\r\n    var t = this;\r\n    setTimeout(function () {\r\n      wx.stopPullDownRefresh(), t.setData({\r\n        is_ok: !1,\r\n        banner: [],\r\n        indicatorDots: !0,\r\n        autoplay: !0,\r\n        interval: 5e3,\r\n        duration: 1e3,\r\n        textJson: [],\r\n        textIndex: 0,\r\n        active_index: 0,\r\n        index: 0,\r\n        fenlei_id: 0,\r\n        pinpai_id: 0,\r\n        nianxian_id: 0,\r\n        km_id: 0,\r\n        sort_id: 0,\r\n        market: [],\r\n        brand: [],\r\n        car_year: \"\",\r\n        car_brand: \"\",\r\n        car_km: \"\",\r\n        car_class: \"\",\r\n        search_arr: [],\r\n        check_name: \"\",\r\n        carList: [],\r\n        sort_show: !1,\r\n        leftid: 1,\r\n        show_new: !0,\r\n        brand_show: !1\r\n      }), t.onLoad();\r\n    }, 1500);\r\n  },\r\n  can_1: function () {\r\n    this.setData({\r\n      is_ok: !1,\r\n      sort_show: !1,\r\n      active_index: 0,\r\n      show_new: !0,\r\n      brand_show: !1\r\n    });\r\n  },\r\n  info_notice: function () {\r\n    wx.navigateTo({\r\n      url: \"../dting/index\"\r\n    });\r\n  },\r\n  store: function (t) {\r\n    var e = a.getAttr(t, \"uid\");\r\n    wx.navigateTo({\r\n      url: \"../store/index?uid=\" + e\r\n    });\r\n  },\r\n  onShareAppMessage: function (t) {\r\n    return {\r\n      title: this.data.info_name + \"\",\r\n      path: \"/pages/index/index\",\r\n      success: function (t) { },\r\n      fail: function (t) { }\r\n    };\r\n  },\r\n  is_home: function () {\r\n    var t = this;\r\n    a.util.request({\r\n      url: \"entry/wxapp/Api\",\r\n      data: {\r\n        m: \"monai_market\",\r\n        r: \"home.index.is_home\"\r\n      },\r\n      cachetime: \"0\",\r\n      success: function (a) {\r\n        a.data.data.length > 0 && t.setData({\r\n          home_arr: a.data.data\r\n        });\r\n      }\r\n    });\r\n  },\r\n  onShow: function () {\r\n    var t = this;\r\n    if (\"\" != t.data.brandid && \"\" != t.data.brandname && 1 == t.data.brand_status) {\r\n      var a = t.data.brandname, e = t.data.brandid, i = \"active_index2\", n = {\r\n        pinpai_id: e,\r\n        car_brand: a,\r\n        active_index: 2,\r\n        mark: i,\r\n        check_name: a\r\n      }, s = this.data.search_arr.filter(function (t) {\r\n        return t.mark != i;\r\n      });\r\n      s.push(n), this.setData({\r\n        is_ok: !1,\r\n        car_brand: a,\r\n        pinpai_id: e,\r\n        search_arr: s,\r\n        leftid: 1,\r\n        show_new: !0,\r\n        brand_show: !1,\r\n        brandid: 0,\r\n        brandname: \"\"\r\n      }), this._list(1);\r\n    }\r\n  }\r\n});php后台的接口代码[PHP] 纯文本查看 复制代码    /**\r\n     * 扫码绑定推荐关系\r\n     */\r\n    public function binding(){\r\n        global $_GPC, $_W;\r\n        $detail = pdo_get('monai_market_member',['uniacid'=>$_W['uniacid'],'uid' => $_GPC['uid']]);\r\n        if(!$detail){\r\n            $data = [\r\n                'uniacid'=>$_W['uniacid'],\r\n                'uid' => $_GPC['uid'],\r\n                'head_image'=> $_GPC['head_image'],\r\n                'create_time' => $_SERVER['REQUEST_TIME'],\r\n                'nickname' => $_GPC['nickname'],\r\n                'parent_uid' => $_GPC['parent_uid']\r\n            ];\r\n          pdo_insert('monai_market_member',$data);\r\n        }\r\n        return $this->result(0, '', '');\r\n    }"}
{"title": "hooks 在微信小程序中的试验 ", "author": "Rolan", "pub_time": "2018-11-27 00:04", "article_content": "前段时间 react hooks 特性刷得沸沸扬扬的，看起来挺有意思的，估计不少其他框架也会逐步跟进，所以也来尝试一下能不能用在小程序上。react hooks 允许你在函数式组件中使用 state，用一段官方的简单例子概括如下：import { useState } from 'react';\r\n\r\nfunction Example() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>You clicked {count} times</p>\r\n      <button onClick={() => setCount(count + 1)}>\r\n        Click me\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\n复制代码函数式组件本身非常简洁，不维护生命周期和状态，是一个可以让性能得以优化的使用方式。但是在之前这种方式只能用于纯展示组件或者高阶组件等，它很难实现一些交互行为。但是在 hooks 出现之后，你就可以为所欲为了。这里有一份官方的文档，不明围观群众有兴趣的可以点进去了解一下： reactjs.org/docs/hooks-… 。hooks 的使用目前有两个限制：只能在函数式组件内或其他自定义 hooks 内使用，不允许在循环、条件或普通 js 函数中调用 hooks。只能在顶层调用 hooks 。这个限制和 hooks 的实现方式有关，下面小程序 hooks 也会有同样限制，原因应该也是类似的。为了能让开发者更好的使用 hooks，react 官方也提供了一套 eslint 插件来协助我们开发： reactjs.org/docs/hooks-… 。下面就来介绍下在小程序中的尝试~函数式组件小程序没有提供函数式组件，这倒是很好理解，小程序的架构是双线程运行模式，逻辑层执行 js 代码，视图层负责渲染。那么声明在逻辑层的自定义组件要渲染在视图层必须保证来两个线程都存在自定义组件实例并一一对应，这样的架构已经成熟，目前对函数式组件并没有强烈的需求。在基础库不大改的情况下，就算提供了函数式组件也只是提供了另一种新写法而已，本质上的实现没有区别也不能提升什么性能。不过也不排除以后小程序会提供一种只负责渲染不维护生命周期不做任何逻辑的特殊组件来优化渲染性能，这种的话本质上就和函数式组件类似了，不过函数式组件较为极端的是在理论上是有办法做到无实例的，这个在小程序中怕是有点困难。言归正传，小程序没有提供函数式组件，那么就强行封装出一个写法好了，假设我们有一个自定义组件，它的 js 和 wxml 内容分别是这样的：// component.js\r\nconst {useState, useEffect, FunctionalComponent} = require('miniprogram-hooks') \r\n\r\nFunctionalComponent(function() {\r\n  const [count, setCount] = useState(1)\r\n\r\n  useEffect(() => {\r\n    console.log('count update: ', count)\r\n  }, [count])\r\n\r\n  const [title, setTitle] = useState('click')\r\n\r\n  return {\r\n    count,\r\n    title,\r\n    setCount,\r\n    setTitle,\r\n  }\r\n})\r\n复制代码<!-- component.wxml -->\r\n<view>{{count}}</view>\r\n<button bindtap=\"setCount\" data-arg=\"{{count + 1}}\">{{title}}</button>\r\n<button bindtap=\"setTitle\" data-arg=\"{{title + '(' + count + ')'}}\">update btn text</button>\r\n复制代码一个很奇葩的例子，但是能看明白就行。小程序里视图和逻辑分离，不像 react 可以将视图和逻辑写到一起，那么小程序里的函数式组件里想返回一串渲染逻辑就不太科学了，这里就改成返回要用于渲染的 state 和方法。PS：wxml 里不支持 bindtap=\"setCount(count + 1)\" 这种写法，所以参数就走 dataset 的方式传入了。FunctionComponent 函数其实就相当于封装了小程序原有的 Component 构造器，它的实现类似这样：function FunctionalComponent(func) {\r\n  func = typeof func === 'function' ? func : function () {}\r\n\r\n  // 定义自定义组件\r\n  return Component({\r\n    attached() {\r\n      this._$state = {}\r\n      this._$effect = {}\r\n      this._$func = () => {\r\n        currentCompInst = this // 记录当前的自定义组件实例\r\n        callIndex = 0 // 初始化调用序号\r\n        const newDef = func.call(null) || {}\r\n        currentCompInst = null\r\n\r\n        const {data, methods} = splitDef(newDef) // 拆分 state 和方法\r\n\r\n        // 设置 methods\r\n        Object.keys(methods).forEach(key => {\r\n          this[key] = methods[key]\r\n        })\r\n\r\n        // 设置 data\r\n        this.setData(data)\r\n      }\r\n\r\n      this._$func()\r\n    },\r\n    detached() {\r\n      this._$state = null\r\n      this._$effect = null\r\n      this._$func = null\r\n    }\r\n  })\r\n}\r\n复制代码实现很简单，就是在 attached 的时候跑一下传入的函数，拿到 state 和方法后设置到自定义组件实例上就行。其中 currentCompInst 和 callIndex 在 useState 和 useEffect 的实现上会用到，下面来介绍。useState 和 useEffect这里的一个难点是，useState 是没有指定变量名的。初次渲染还好，二次渲染的话要找回这个变量就要费一段代码了。PS：后续的实现除了参考了 react 的 hooks 外，也参考了 vue-hooks 的尝试，有兴趣的同学也可以去观摩一下。这里上面提到的 currentCompInst 和 callIndex，将上一次的变量存储在 currentCompInst 中，用 callIndex 记录调用 useState 和 useEffect 的顺序，这样就可以在二次渲染的时候通过顺序找回上一次使用的变量：function useState(initValue) {\r\n  if (!currentCompInst) throw new Error('component instance not found!')\r\n\r\n  const index = callIndex++\r\n  const compInst = currentCompInst\r\n\r\n  if (compInst._$state[index] === undefined) compInst._$state[index] = initValue\r\n\r\n  const updater = function (evt) {\r\n    let value = evt\r\n\r\n    // wxml 事件回调\r\n    if (typeof evt === 'object' && evt.target && evt.currentTarget) {\r\n      const dataset = evt.currentTarget.dataset\r\n      value = dataset && dataset.arg\r\n    }\r\n\r\n    // 存入缓存\r\n    compInst._$state[index] = value\r\n    compInst._$func()\r\n  }\r\n  updater._isUpdater = true\r\n\r\n  return [compInst._$state[index], updater]\r\n}\r\n复制代码useEffect 的实现逻辑也类似，这里就不再贴代码了。小程序本身没有提供 render 函数，调 FunctionalComponent 声明函数式组件传入的函数就作为 render 函数来用。每次调 setXXX 方法——也就是上面代码中返回的 updater 的时候，找到原本存储这个 state 的地方存储进去，然后再次执行 render 函数，进行组件的渲染。到这里应该就明白了，对于 hooks 使用为什么会有一开始的那两条限制。如果在一些条件、循环等语句内使用 hooks，就无法确保 state 的顺序，再二次渲染时就不一定能找回对应的 state。尾声完整的代码在 github.com/wechat-mini… ，不过这终究只是个试验性质的尝试，并不推荐拿来实战，写在这里是为与大家共享~"}
{"title": "微信小程序使用touch事件实现左滑删除 ", "author": "Rolan", "pub_time": "2018-11-27 00:13", "article_content": "前言之前写过一篇微信小程序使用movable-view实现左滑删除功能，有同学使用了这种方案并提出我之前没有发现的bug（现在bug已进行了修复），感谢。有同学问了如果不使用movable-view的话如何来实现左滑删除？那这次就写一下如何只使用touch事件来实现左滑删除。源码Talk is cheap. Show me the code.实现原理此次组件需要处理touchstart、touchmove和touchend三个touch事件touchstart事件时需要先禁用掉transition动画，同时记录下触摸点的pageX和pageY的值，以及此时滑动的起始点，即删除按钮的状态，隐藏还是显示。touchmove事件处理手指的滑动，此时需要进行以下不同情况的判断：手指上下移动的距离超过左右滑动的距离，此时我们可以把用户的操作理解为上下滑动而不是左右滑动，此时我们对组件不进行移动判断如果是以下两种情况时不进行组件的移动：在最右边时向右滑动;在最左边时向左滑动如果手指滑动超出了删除按钮的宽度时（包括左滑和右滑两个方向），取按钮宽度作为移动距离其他情况：手指滑动了多少就对组件位移多少touchend事件则是处理手指离开屏幕之后组件的一些后续动作:先根据touchmove中记录的手指位移方向进行判断，非左右滑动时则对组件不进行移动左右移动超出右滑最大位移时，设置位移终点为0左右移动超出左滑最大位移时，设置位移终点为负的删除按钮宽度以下两种情况组件都滑动到右边起点（即删除按钮隐藏的状态）：从右边起点左滑但未超过最大位移的一半，回退到右边起点从左边起点右滑且超过最大位移的一半，继续滑到到右边起点其他情况组件都滑到左边起点（即删除按钮显示的状态）设置位移值，并打开组件的transition动画效果图"}
{"title": "用大型开发框架开发小程序那点事儿 ", "author": "Rolan", "pub_time": "2018-11-23 00:48", "article_content": "最近在写支付宝小程序，支付宝小程序相比较微信小程序，更加缺少一些框架/工具/以及生态环境，借着这个时机我们一起来探讨一个问题小程序最原始的开发模式有什么弊端？为什么我们很需要一些大型框架怎么在小程序中科学的运用大型开发框架的设计思想？如何在缺乏现成框架的情况下，学习思想，初步自己灵活运用起来如何在已有现成框架的情况下，深度解读框架设计思想这其实是一篇循序渐进的小程序实践记录。对于支付宝小程序：从一开始缺乏整体框架，深感不便。到决定自己融合框架思想自行实现。再到公司内有更优更全面的整体框架后追求的最佳实践。目录：原始小程序开发中面临的问题构建一个 store 初步实现数据仓库LunaX 的小程序上层开发组件库Lux 单 store 数据仓库实践LunaX 的其他工具小程序开发中面临的问题原始的小程序开发模式下，天然具备了页面的 data 数据与 xml 渲染 mvvm 能力，同时也维护好了整个 app 与页面 page 的生命周期，在实际开发过程中已经比没有主流框架支持下的前端页面开发要便捷的多。但相比于前端广泛使用的 Vue 开发框架，以及蚂蚁内部对 Vue 进一步封装出来的 Kylin 框架来说，小程序的原始开发模式还是非常原始，存在着非常多的弊端与开发效率问题，逐一举例：全局状态管理跨页面跨组件通信computed 计算能力数据 Mock 能力研发部署工作流问题全局状态管理问题在原始的小程序开发模式下，全局的状态只能挂在 app.js 内，可以考虑给 app 对象加一个 globalData 的属性，用来存放和管理全局变量，并且可以在任意代码通过 app 进行访问。App({\r\n  globalData: {\r\n\tuserName:'hehe'\r\n\t},\r\n  onLaunch(options) {},\r\n})\t\t\r\n\r\n// 在页面访问全局状态\r\nconst app = getApp();\r\nlet userName = app.globalData.userName\r\n但是小程序的开发中其实是有一种 mvvm 的响应式设计思维融入其中的，页面上的数据可以做到 setData 的时候响应式去改变界面中的渲染内容，但仅限 page 页面内的 data 数据，我能不能让 globalData 也做到这样的响应式。能让我 app 的每个页面，每个组件，但凡需要展示 UserName 的情况下，只需要再 axml 中使用全局 globalData.userName ，就能做到任何时候有任何人操作修改了 globalData.userName ，其他的页面（包括已经展示出来的页面），都能响应式的变更渲染内容？汇总一下我们面临的痛点希望在页面/组件的 axml 中，能够可以直接使用全局 globalData 数据进行渲染希望 globalData 在发生变化的时候，能够响应式的通知所有用到的页面/组件，更新对应渲染元素跨页面跨组件通信说完了所有组件对全局状态的痛点，我们再聊聊页面/组件间的通信，小程序原始开发框架中最头疼的莫过于跨页面跨组件进行通信，几乎是完全隔离的，有限的通信手段也非常的不易用，这里举一些例子跨页面数据传递问题page A 向 page B 传递数据有且只有一个方法，将数据拼接成 url 的 query 然后通过 navigateTo 传递给下一个页面，在 page B 的 onLoad 方法中读取 options 入参。痛点1: 还有没有别的办法？有，很山寨的让 page A 在 app 的 globalData 上挂一个全局变量，在 page B 的 onLoad 时机读取这个全局变量，这种方法实在太low了，全局变量太多非常的不易维护，并且 app 对象所有人都可以操作，也会存在风险。痛点2: 如果我要传递大量数据，嵌套型数据怎么办？比如我要传递的是一个 object 对象，里面不仅有很多 key value 还有一个 key 的 value 是一个数组，数组里面依然是各种对象，这种情况下怎么传递？各种 key value 还算可以通过拼 url 的方式，那不知道长度的 Array 数组如何拼接 url ？整个 object 对象，用 JSON.stringify 变成字符串，然后经过 urlencode 后拼接进入 url ？ 太麻烦了。深层组件嵌套数据传递问题page 页面内含有 component A ，这个组件包含引用了 component B ，B 又包含引用了 Component C，这种 page -> component A -> component B -> component C 的界面嵌套层级，如果 component C 希望访问 page 才有的数据该怎么做？在原始的小程序开发方案中，只能通过 component 的 props 一层层透传下去，同一个数据在3个组件中都得写一份并且传递给下一个组件，这个过程耦合了4个页面/组件，而只有 C 才会使用到。就好像对于全局状态管理的诉求一样，我们希望在组件 C 中有更方便更解耦的方式来访问跨组件乃至跨页面的数据，并且能够符合小程序 mvvm 的响应式设计思想，一旦访问的数据发生变化，组件 C 也能自动触发元素渲染变更。痛点1: 希望能够在组件 C 中直接访问其他组件/其他页面的 data 数据痛点2: 希望能够将组件 C 的 axml 中的其他组件/其他页面 data 的渲染元素，能够响应式的自动根据原数据变化触发渲染更新跨页面（主要是跨页面，跨组件理论也需要支持） 函数调用在老的前端多页应用开发模式下，2个页面之间是几乎不存在相互调用的问题的，如果 page B 页面执行了某些操作需要在 page B 页面关闭后跳转刷新 page A 页面。一般都会把数据提交给服务器，然后在 page A 页面加载的时候，再从服务器拉取这些数据，而这些数据有可能不见得需要落库存db，有可能只不过是前端中转的一些数据而已，通过服务器就太浪费了。于是前端有 shared worker 可以实现这种页面之间通信。也可以使用单页应用 SPA 的开发模式，用成熟的 Vue 等框架进行组件间调用和通信。但是到了原始的小程序开发模式里，所有 page 之间想要进行调用通信就变得很难。虽然小程序本质上所有页面是运行在同一个 JSContext 的 JS 虚拟机上下文中，本质上完全应该可以进行相互通信，但小程序的框架层面并没有开发对应的 page 之间的通信 api，必须自己想办法。痛点1: 仿照前端网页开发的方案，把这些数据提交给服务器中转存储？在新页面展现的时候从服务器拉取？说实话这样可以，但这些没必要的网络通信无形中也在浪费着用户的流量与服务器的压力痛点2: 利用 globalData 全局暂存临时对象，在 navigateTo 跳转到下一个页面之前，把当前页面的 this 对象挂在全局，当作临时对象暂存，在新页面 onLoad 的时候从全局变量中补货这个临时对象，自己持有，需要的时候直接调用暂存页面 page 的方法。这种临时变量的方案没啥可说的，能不用就别用了。computed 计算能力习惯了前端页面使用 vue 开发的同学应该都会对 vue 的 computed 与 kylin 的 getter 有所了解，他能够很方便的对数据进行加工再返回页面进行渲染。而在小程序的原始开发模式下，是缺乏这种能力的。我们终端团队之前没参与过 kylin 开发的同学可能不太了解，那么举几个最简单的例子：多人账本记录着用户之间的交易行为，大量的地方都在展示着金钱，而金钱的展示需要进行一定的格式化，比如无论是否整数还是小数都得转化为保留2位的格式化比如 998.00 然后再进行展示。但是服务端下发的数据都是 number 类型，page 中存储的也应该是 number 类型方便后续的计算。在小程序的里没有提供相关的计算能力于是只能这么写，再网络返回的数据回掉中同时 set 2个数据，这样就要求任何时候操作 money 的时候，都要同步维护 moneyForShow 的值，如果忘记了，那么页面就不会正常展示。//在网络请求中调用\r\nthis.setData{\r\n\tmoney: result.money;\r\n\tmoneyForShow: utils.money2show(result.money)\r\n}\r\n\r\n//在axml中使用\r\n<text>{{moneyForShow}}</text>\r\n还是希望能有类似 Vuex 中 computed 的能力，在 page 的 data 中只维护一个值 money ，而定义一个 moneyForShow 的 getter 函数，在 axml 中直接写 moneyForShow 这个 getter，就能正常的渲染，并且还能保证响应式的数据同步，每当 money 发生变化，通过 moneyForShow 这个 getter 渲染的元素也能自动刷新。数据 Mock 能力小程序框架提供了 HttpRequest/Rpc/Mtop 等网络通信的能力，但 Rpc/Mtop 这两种网络请求能力是必须依托在支付宝钱包客户端内才能生效的 jsbridge 能力（大家申请的内部小程序都是 web 小程序，某种程度上讲就是 nebula 容器内核，所有 jsbridge 理论都能直接使用）。但是小程序官方提供的 IDE 开发环境并不是钱包环境，调用 Rpc/Mtop 的请求的时候会直接失败。换句话说在没有 mock 能力的支持下，我们平日里开发的小程序根本不可能在官方 IDE 环境中正常开发调试。官方提供的另外一种命令行 appx + hpm 模拟器的开发模式可以一定程度的解决这个问题。就好比在开发 kylin 离线 h5 应用的时候，在 chrome 浏览器里也是无法发起 rpc 的，只能通过 hpm 模拟器在支付宝 app 中运行，但 kylin 框架是提供了完善的 mock 方案了痛点1: 在缺乏架构层面的 mock 解决方案的情况下，想要进行 mock 开发（或者希望在官方 IDE 中进行调试），每个业务只能自行把 json 数据硬编码到临时测试代码里，然后侵入业务逻辑的进行修改返回，这种侵入业务代码的 mock 方式并不优雅。痛点2: 不仅仅网络请求需要 mock ，有一些 jsapi ，甚至小程序的 api 也需要 mock ，举个例子，getAuthUserInfo 这个 api 是用来获取用户授权后的用户信息的，但因为 appx + hpm 模拟器的开发模式下，用户授权环节环境差异，这个 api 一定会返回失败，所以在这个环境下，这个小程序 api 也许要 mock 能力研发部署工作流问题小程序官方推荐的 IDE 研发工作流是一套独立在前端 basement 平台之外的工作流。有着自己的正式环境+发布平台，开发环境+发布平台。更详细的工作流可以参见 小程序环境部署开发期用官方 IDE 连开发环境进行开发用 IDE 模拟器模拟用 IDE 打包上传生成二维码 + 真机扫码进行调试不用官方 IDE 用其他编辑器进行开发用 appx run web ios + hpm 模拟器进行模拟用 appx run qrcode 生成二维码 + 真机扫码进行调试测试期用官方 IDE 连开发环境进行打包打稳定包上传开发环境发布平台用开发环境发布平台生成稳定二维码提供二维码给测试发布期用官方 IDE 连正式环境进行打包用稳定包上传正式环境发布平台在发布平台进行预发验收在发布平台进行提交审核痛点: 这里面有一个最关键的问题是，官方 IDE 的工作流都是基于打包人员本地代码的！并不是通过编译打包平台直接捞取仓库主干里那些经过 codereview 后的代码。一旦打包人员进行打包上传的时候，使用的不是仓库中的最新的正确代码，或者打包人员本地调试的时候有略微改动，忘记了就直接打了稳定包进行发布，这种情况将无法保证发布代码的质量！构建一个 store 初步实现数据仓库多人账本是会员终端团队中最早进行小程序开发的产品，在初期调研准备的时候，参考了微信小程序的一些实战经验。尤其是关于页面组件间通信/关于全局状态管理这块，都有不少成熟的解决方案，比如使用很广泛的基于微信小程序的上层框架 wepy 。但是在支付宝小程序中缺乏这种整体的框架级解决方案，所以我们需要自己来实现一个功能相对简单，能暂时满足基础通信需求的“山寨方案”。同时因为时间问题这个山寨方案支持能力也非常有限，也并不能很好的满足上面的所有痛点，只是解决了最关键的两个问题EventBus来实现跨页面跨组件通信在原始的小程序开发过程中，对跨组件跨页面进行通信有着严格的限制。因为整个小程序的任何页面任何 js 代码都是运行在同一个 JSContext JS上下文中，也就是小程序的 Service Worker 环境中，所以本质上他们是完全可以进行通信只不过是受小程序约束所致。如果我们自己实现一个全局的 eventBus 并挂在 app 对象上，让各个需要发起通信的地方调用 app.event.emit() 发出通知，让需要接收通信的地方调用 app.event.on() 监听通知，就能实现初步的跨小程序自身框架的通信能力//简单思路\r\nclass Observer {\r\n    constructor() {\r\n        //初始化 callback map 字典\r\n    }\r\n    on(eventName, callback) {\r\n  \t\t//将传入 callback 添加到 eventBus 对象的 key 为 eventName 的数组中\r\n\t\t//添加对 eventName 的监听\r\n    }\r\n    emit(eventName, param) {\r\n        //遍历 eventBus 对象的 key 为 eventName 的数组\r\n\t\t//依次调用数组中存放的 callback 传入参数 param\r\n\t\t//发出 eventName 的消息\r\n    }\r\n    clear(eventName) {\r\n        //清理掉 eventBus 对象的 key 为 eventName 的数组中所有值\r\n\t\t//移除对 eventName 所有监听\r\n    }\r\n    off(eventName, callback) {\r\n  \t\t//清理掉 eventBus 对象的 key 为 eventName 的数组中的 callback这个值\r\n\t    //移除对 eventName 的具体某个监听\r\n    }\r\n}\r\nexport default Observer;\r\n但这种模式存在着一定的弊端，因为 eventBus 的通知模式是一种一对多的调用模式，并不适合设计出能支持返回值的 eventBus ，所以如果需要跨页面跨组件通信，获取一定的返回数据，则需要通过2条消息，一去，一回来实现。eventBus 虽然具备一定的弊端，但却是自己实现响应式 mvvm 的核心。如果想要构建出超过小程序页面 page 自身的 data & axml 的 mvvm 能力，那么至少需要在构建起这么一套 eventBus。但受限于业务的时间非常紧迫，在确定能满足了一期多人账本的需求的情况下，并没有深入对 eventBus 进行进一步优化与扩展。后续因为了解到 LunaX 的即将发布，是一套整体的小程序框架解决方案，以后也不打算持续优化，准备将多人账本项目着手迁移到 LunaX 上（下文会介绍）全局状态的管理与控制在多人账本的需求中，确实存在需要全局管理一些通用数据，并且被全局各处页面 axml 使用通用数据的情况，比如 UserName / UserAvatar / WindowHeight / DeviceInfo 等。又因为这些数据大多来自异步的 JSApi 所以存在 app 初始化后数据并未准备好，异步请求回来后必需响应式的同步刷新所有可能出现并渲染出来的元素。所以我们的思路就是将 app 下面的 globaData 设计为一个数据仓库，进行统一的维护和管理，想要操作这个仓库里的数据必须通过指定的方法 app.store.commit(key,payload) 来执行，不能通过别的方式。当执行 commit 的时候会通过 eventBus 发出一个 key 变更的通知，来通知各个页面进行数据变更。同时需要 Hook 每个 Page 的生命周期，在 Page OnLoad 的时候，自动的帮助页面开发者添加上 eventBus 的 key 变更的监听，每当 commit 全局发出了通知，监听就会自动生效，将新的 globaData，执行 setData 写入当前 page，从而触发 axml 的页面渲染刷新。app.store 提供 commit 能力，进行数据仓库的统一提交管理每当触发 commit 全局发送对应 key 数据变更的通知app.store 提供 hook 页面的能力，在 OnLoad 时机进行自动化处理将需要的全局仓库里面的数据的 key 通过 setData 写入当前 page对需要的 key 监听其数据仓库变化通知当任意地方触发 commit 发出了对应 key 数据变更的通知从而触发监听将通知带来 key 与 新value 通过 setData 写入当前 page触发页面的响应式渲染更新// 简单思路\r\nclass Store extends Observer {\r\n    constructor() {\r\n        super();\r\n        this.app = null;\r\n    }\r\n    // hook app 的创建，将store自己，自动挂载在 app 对象上，便于随时随地调用\r\n    createApp(options) {\r\n        const {\r\n            onLaunch\r\n        } = options;\r\n        const store = this;\r\n        options.onLaunch = function (...params) {\r\n            store.app = this;\r\n            if (typeof onLaunch === 'function') {\r\n                onLaunch.apply(this, params);\r\n            }\r\n        }\r\n        return options;\r\n    }\r\n\t// 当调用 commit 的时候，更新 globalData 的值，同时 emit 发出通知\r\n    commit(action, payload) {\r\n        this.app.globalData[action] = payload;\r\n        this.emit(action, payload);\r\n    }\r\n    // hook page 的生命周期，将用户需要的 globalData key 设置到 page 的 data 之中\r\n\t// 同时设置监听，监听来自 commit 的 key 变化通知，更新 page 的 data\r\n    createPage(options) {\r\n        const {\r\n            globalData = [],\r\n                watch = {},\r\n                onLoad,\r\n                onUnload\r\n        } = options;\r\n        const store = this;\r\n        const globalDataWatcher = {};\r\n        const watcher = {};\r\n        // 劫持onLoad 绑定监听\r\n        options.onLoad = function (...params) {\r\n            \r\n            store[bindWatcher](globalData, watch, globalDataWatcher, watcher, this);\r\n            if (typeof onLoad === 'function') {\r\n                onLoad.apply(this, params);\r\n            }\r\n        }\r\n        // 劫持onUnload 解绑监听\r\n        options.onUnload = function () {\r\n            store[unbindWatcher](watcher, globalDataWatcher);\r\n            if (typeof onUnload === 'function') {\r\n                onUnload.apply(this);\r\n            }\r\n        }\r\n        delete options.globalData;\r\n        delete options.watch;\r\n        return options;\r\n    }\r\n    // hook component 的生命周期，功能作用类似 page\r\n    createComponent(options) {\r\n        // 具体实现参考 page\r\n    }\r\n    // 绑定监听的具体操作\r\n    [bindWatcher](globalData, watch, globalDataWatcher, watcher, instance) {\r\n        const instanceData = {};\r\n        let that = this;\r\n        globalData.forEach((prop)=>{\r\n          instanceData[prop] = that.app.globalData[prop];\r\n          globalDataWatcher[prop] = payload => {\r\n            instance.setData({\r\n              [prop]: payload\r\n            })\r\n          }\r\n          that.on(prop, globalDataWatcher[prop]);\r\n        })\r\n        \r\n        for (let prop in watch) {\r\n            watcher[prop] = payload => {\r\n                watch[prop].call(instance, payload);\r\n            }\r\n            this.on(prop, watcher[prop])\r\n        }\r\n        instance.setData(instanceData);\r\n    }\r\n\t// 解绑监听的具体操作\r\n    [unbindWatcher](watcher, globalDataWatcher) {\r\n        // 页面卸载前 解绑对应的回调 释放内存\r\n        for (let prop in watcher) {\r\n            this.off(prop, watcher[prop]);\r\n        }\r\n        for (let prop in globalDataWatcher) {\r\n            this.off(prop, globalDataWatcher[prop])\r\n        }\r\n    }\r\n}\r\nconst store = new Store();\r\nexport default store;\r\n这种思路其实还是存在弊端的，因为只解决了所有页面/组件，对于 global 数据仓库里的依赖，以及响应式渲染。如果想进一步解决，page A 对 page B 的 data 响应式数据依赖，乃至 component C 对 page A 的 data 响应式数据依赖，则需要进一步加强数据仓库 store 的管理范围，不仅仅维护 globalData 的数据， 还要将每个页面或者每个组件，都抽象出一个 store 子仓库，统一被 global store 进行管理，这样 app 的 store ，page 的 store ，component 的 store，相互之间通过父子关系构成了一个以 global store 为根的树型解构，从而实现所有页面与所有组件间的数据管理。而每个子仓库的数据字段为了避免重名不好识别，通过 pagename-keyname 或者 pagename-componentname-keyname 来当作 keypath 进行区分管理。不只构建一个 global store，为每个 page 每个 component 分别构建一个store以 global store 为根，以界面嵌套关系为层级，将每个 store 关联起来，形成一个 store 树整个树统一进行管理，统一进行 commit 提交后数据更新以及 event 发送以 keypath 作为不同 store 节点下的数据字段区分响应式的实现跨页面跨组件的数据更新以及界面变更渲染但受限于业务的时间非常紧迫，在确定能满足了一期多人账本的需求的情况下，并没有深入对 store 进行进一步优化与扩展。后续因为了解到 LunaX 的即将发布，是一套整体的小程序框架解决方案，他内部的 Lux 完全的吸收了前端 Vuex 的能力已经非常出色，所以后续就不打算进一步完善我们自研的 store ，准备将多人账本项目着手迁移到 LunaX + Lux 上（下文会介绍）LunaX 的小程序上层开发组件库LunaX 是一套从支付宝 h5 Hybrid 中心的提供的前端页面组件库 Luna 演进出的面向小程序的组建库。里面有着丰富的工具以及脚手架 cli 支持Lux 数据仓库管理插件 – 小程序最佳实践的核心LunaX 内置了一套数据仓库管理组件 Lux ，相比较我们自己初步实现的简单 store 数据管理 ， Lux有着更全面的能力支持，包括 state ，getter，mutation ，action 等仓库能力，以及 commit ，dispatch 的仓库操作，可以完全实现像 Vuex 那样以前端成熟的开发模式来进行小程序开发。Mock 数据能力LunaX 也提供了强大的 Mock 组件，支持无论是 rpc 还是 http 还是 jsapi 的无侵入 mock 能力。支持白名单、黑名单过滤，支持网络延迟模拟等多种功能工具组件库组件库中封装了丰富的常用工具能力。包括带缓存，防重复提交，有统一交互的 rpc。封装了 Tracert，用于 SPM 埋点。封装了 clue，用于日志上报，监控报警。获取凤蝶区块数据。对 storage 增加了时间戳，解决兼容问题。等等实用功能cli 脚手架通过 luna-appx 的脚手架创建项目，配置好了统一的 .editorconfig, .eslintc, .gitignore，以及 ts 校验等配置。并且支持完全接入 basementLux 单 store 数据仓库实践在前端开发种 Vue 与数据仓库 Vuex 是一种被广泛运用的开发框架。而 Lux 的设计初衷就是设计出一套核心 Api 与 Vuex 完全保持一致，但又可以脱离 Vue 单独在任意环境（自然包括小程序环境）使用的数据仓库 store。Lux 这种思路吸收了很多 Redux 的设计思想，就像 Redux 也可以在非 React 环境下使用一样，并且也支持中间件与插件机制。由于 Lux 的核心 Api 与 Vuex 完全保持一致，在使用上几乎可以还原 Vuex 的开发模式，所以如果之前接触 Vuex 不多，可以先看一下官方文档： Vuex 官方文档 来了解基本概念，再参考 Lux 官方文档 来了解如何使用。基本上数据仓库，主要就是 state 状态的概念，用来存储一切数据，而为了操作数据，衍生出了 getter ， mutation ， action 几种操作 ， getter 用来对 state 的数据进行加工计算 ， mutation 用 commit 触发来同步提交 state 变更， action 用 dispatch 触发来异步执行操作。同时为了能将数据仓库的 state 与小程序的 axml 渲染进行 mvvm 关联，实现响应式数据刷新，Lux 提供了 connect 和 connect4c 2个方法用来 hook 小程序页面/组件的生命周期实现绑定关系，并且在 connect 的时候，可以通过传入 mapConfig 来灵活的自定义关联控制。Lux 的基本使用模式一个小程序页面创建好就会包含四个基本文件，.acss .axml .js .json。如上图，为了使用 Lux 专门给页面创建一个数据仓库目录 store 来重点维护所有数据相关的逻辑代码，并把业务逻辑按着 Vuex 的设计思想抽象成四大块。// store/index.js 文件\r\nexport default {\r\n    state: {\r\n    \tXX:xx\r\n    },\r\n    getters: {\r\n    \r\n    },\r\n    mutaions: {\r\n    \tsetXXData(commit,payload){\r\n  \t\t\t//同步 提交某个 state 更新\r\n\t\t}\r\n\t\t\t   \r\n    },\r\n    actions: {\r\n    \trequestXXRpc({commit},payload){\r\n  \t\t\t//异步 执行某些操作，在返回后再次调用 commit 提交数据更新\r\n\t\t\txxRpcPromise.then((result)=>{\r\n  \t\t\t\tcommit('setXXData',result)\r\n\t\t\t})\r\n\t\t}\r\n    },\r\n};\r\n数据仓库已经创建好了，想要在 page 中进行使用就需要将 store 与 page 进行 connect 并且挂载到 page 对象上，能方便 page 对象操作仓库。通过 mapStatesToData 与 mapGettersToData 两个配置信息，进行可选可控的绑定操作，这样就丢弃了 page 自己的 data ，而是通过数据仓库来关联 axml 数据渲染。并且在 page.js 中一般情况下只处理 UI 响应等代码，一旦涉及到数据信息状态等内容的修改或者变更，同步的变更用 commit 提交给仓库处理，异步的任务用 dispatch 提交给仓库处理其实绑定操作就是把数据仓库的 getter 和 states 自动添加到了 page 的 data 中，并且还可以响应式同步更新，只不过对使用者无感知// 修改 page.js 进行绑定\r\nimport { connect } from '@alipay/lux'\r\nimport store from './store';\r\n\r\nconst options = {\r\n  onLoad(options) {\r\n      //触发mutation\r\n\t  this.$commit('mutation name',data)\r\n  },\r\n  onShow(options) {\r\n\t  //触发action\r\n\t  this.$dispatch('mutation name',data)\r\n  },\r\n};\r\n\r\nconst mapStatesToData = {\r\n    //state map 代码 todo\r\n\t//但凡经过 map 过的 state 都可以直接在 axml 中使用，并且响应式同步刷新变化\r\n\txxData: state => state.xxData,\r\n};\r\nconst mapGettersToData = {\r\n    //getter map 代码 todo\r\n\t//但凡经过 map 过的 getter 都可以直接在 axml 中使用，并且响应式同步刷新变化\r\n\txxGetter: 'xxGetter',\r\n};\r\nconst storeConfig = {\r\n    mapGetters: mapGettersToData,\r\n    mapState: mapStatesToData,\r\n};\r\n\r\n//将 store 与他的配置 storeConfig 和 page 进行绑定\r\nPage(connect(store, {\r\n  mapState: mapStateToData,\r\n  mapActions: mapActionsToProps\r\n})(options));\r\n进行一个初始化Lux 单 store 与多 store 的选择其实在 Lux 官方文档 中已经有介绍这两种模式的使用差异了，这里再多废话一下多 store：一个 page 一个 store. 隔离性好, 页面间不会相互干扰单 store：整个小程序 App 只有一个 store. 交互性强, 页面间共用同一个 store 每一个 page 一个 module（子 store ）, module 间可相互 dispatch/commit这时候最关键就需要回想一下我们之前的那些个痛点了store 相关的痛点全局状态管理：既然是全局，多store 肯定不满足，还是单 store 最合适跨页面跨组件通信：既然是组件页面之间交互，更需要单 store 来支持computed 计算能力：哪种模式都通过 getter 支持了计算能力store 无关的痛点数据 Mock 能力：LunaX 有 Mock 组件研发部署工作流问题：LunaX 有对接 basementLux 官方文档中对于单 store 和多 store 模式给的样例代码与使用说明都相对比较简单，整个多人账本算是一个比较复杂的一个项目，在实践中趟了很多坑，也找 LunaX 团队的同学交流，探讨过。在这详细的把整个项目的单 store 实践整理一下，也补上很多细节上容易产生的坑和问题。Lux 的多人账本单 store 实践单 store 最核心的就是把每一个 page 的子 store 当作一个 module 挂载到 app 的根 store 之下，而把有需要的 component 的子 store 当作一个 module 挂载到 page 的子 store下。最终所有的子 store 型成一个像树一样的整体，也就是挂载在 app 之下的根 storecomponent 如果没那么复杂可以考虑自己不实现子store，但可以 connect 链接到整个 store 下，从而能实现虽然自己没 store ，但可以自由的 map 别的 page，app 的 state 与 getter构建 App 根 storeLux 的单 store 使用方式是，单独对整个 App 构建一个 store 对象，然后用这个 store 对象通过 Provider 方法将整个 store 挂载在 App 对象上。之后如果想给 page 或者 component 进行 connect 子store 操作，执行 connect 使用的方法和多 store 略有不同。要求使用者必须在 connect 的时候不要输入子 store 对象，而是直接输入 mapConfig，在 connect 的时候真正绑定到 page 对象上的实际上都是这个根 store。每个 page 的子 store，不需要在页面 connect 的时候挂在 page 上，而是应该作为根 store 初始化的时候的一部分，一起放在根 store 里进行创建。import * as Lux from '@alipay/lux';\r\n//导入各个页面的子store\r\nimport home from './pages/home/store';\r\nimport billBookDetail from './pages/billBookDetail/store';\r\nimport createBillBook from './pages/createBillBook/store';\r\n//更多其他 store\r\n//创建根 store 对象\r\nexport default new Lux.Store({\r\n  state: {\r\n    xx:xx\r\n  },\r\n  getters: {\r\n    \r\n  },\r\n  mutations: {\r\n    \r\n  },\r\n  actions: {\r\n    \r\n  },\r\n//将导入的子store 设置到根store下，成为一体\r\n  modules: {\r\n    home,\r\n    createBillBook,\r\n    billBookDetail,\r\n\t//... 更多\r\n  }\r\n}, {\r\n  produce,//不可变配置，后续聊\r\n  plugins: []//Lux 插件模块，后续聊\r\n});\r\n可以看到根 store 自己就是一个仓库，可以有 state 以及 getter，mutation，action。在此处可以当作全局变量的仓库，管理全局数据，也可以开放一些全局接口（action）供任意地方调用每一个页面自己的子 store ，可以放到根 store 的 modules 字段里，形成了树状结构的第一层叶子节点。如果业务需要有些复杂的 component 也需要有自己的子 store，那么应该放到他的上层 page 页面子 store 对象的 module 里，形成树状解构的第二层叶子节点。以此类推嵌套型的 component 操作。最后将根 store 绑定到 App 上，操作非常简单， App(Provider(store)(appOptions)); 一行代码即可import { luna } from './common/jsapi';\r\nimport { Provider } from '@alipay/lux';\r\nimport store from './app.store';\r\n\r\nconst appOptions = {\r\n  onLaunch() {\r\n    checkVersion();\r\n    this.$dispatch('getUserInfo');\r\n    this.$dispatch('getDeviceInfo');\r\n  },\r\n};\r\n//调用 Provider 进行绑定\r\nApp(Provider(store)(appOptions));\r\npage 与单 store 的挂载与绑定将子 store 绑定到 page 的操作，和多 store 绑定姿势略有差异import { connect } from '@alipay/lux';\r\n\r\nconst options = {\r\n  onLoad(options) {},\r\n  onShow(options) {},\r\n};\r\n\r\nconst mapStatesToData = {};\r\nconst mapGettersToData = {};\r\nconst storeConfig = {\r\n    mapGetters: mapGettersToData,\r\n    mapState: mapStatesToData,\r\n};\r\n// 注意此处，已经不需要应用 store 并且传给 connect 了\r\n// 只需要传 mapConfig\r\nPage(connect(storeConfig)(options));\r\n归根结底是上面提到的，单 store 模式下，挂载每个 page 下面的 store 依然是根 store，每个page 通过根上面，用 page 的名字就能找到自己对应的 store，用别人 page 的名字也能找到别人对应的 store ，从而能进一步实现多个 page 之间的仓库操作，无论是读取数据，还是写入数据，甚至是派发方法（dispatch action）单 store 下的数据映射connect 默认将 store 的所有状态 map 到了 data 上并监听所有状态变化 默认将所有的 actions map 到了 option, 通过 this.$xxxAction 调用在 Lux 的文档中介绍着上面这句话，意思是如果完全写 mapState，Connect 也会默认将 store 中所有 state 全都 map 到 page 的 data 上。整个 store 也会照常工作。但是！在单 store 模式下，这句话需要重新解读。单 store 是一个树型的结构，所以不同节点 store 的 state 需要从 rootState 通过节点名 pageName来查找，比如 rootState.pageName.xxData。因为所有的 page 绑定的都是根节点，所以 mapStates 的入参 state 代表的是根节点，当前 page 的名字叫 billBookDetail，通过根节点 state.billBookDetail 来映射当前子 store 数据。如果你希望当前页面可以在 axml 里直接使用其他 store 的 state 数据。也可以通过这个根 state 找到其他 store ，直接 map 后使用const mapStatesToData = {\r\n  //当前页面自己的数据\r\n  showGuide: state => state.billBookDetail.showGuide,\r\n  isTotalNumOutIn: state => state.billBookDetail.isTotalNumOutIn,\r\n  editName: state => state.billBookDetail.editName,\r\n  memberList: state => state.billBookDetail.memberList,\t\t\t\t\t \r\n  //其他页面的数据，直接在当前页面中使用\r\n  curUserInfo: state => state.home.curUserInfo,\r\n  //根 store 的 state数据也可以使用\r\n  deviceInfo: state => state.deviceInfo,\r\n};\r\n\r\nconst mapGettersToData = {}\r\n\r\nconst storeConfig = {\r\n  mapGetters: mapGettersToData,\r\n  mapState: mapStatesToData\r\n};\r\nstate 的映射单/多 store 有所差异，getter 的映射一样存在差异。单 store 下为了区分每个子节点 store 各自的 getter 方法，需要用 keyPath 来识别 getter 方法，keyPath 的格式是 pageName/getterName，所以在进行 map 映射的时候，应该用这种 keyPath 来映射。同样你也可以把其他 store 的getter 映射到当前 page 上const mapStatesToData = {}\r\n\r\nconst mapGettersToData = {\r\n  //当前 page 是 billBookDetail，keyPath 是 billBookDetail/getterName\r\n  bookDetailForShow: 'billBookDetail/bookDetailForShow',\r\n  memberInfoForShow: 'billBookDetail/memberForShow',\r\n  transListForShow: 'billBookDetail/transListForShow',\r\n  dataStatus: 'billBookDetail/dataStatus',\r\n  canWrite: 'billBookDetail/canWrite',\r\n  //打算使用 home 页面的 getter\r\n  curUserForShow: 'home/curUserForShow',\r\n  //打算使用根 store 的 getter\r\n  maxScreenHeight: 'maxScreenHeight',\r\n};\r\n\r\nconst storeConfig = {\r\n  mapGetters: mapGettersToData,\r\n  mapState: mapStatesToData\r\n};\r\n在 store 中跨页面跨组件通信从上面的代码样例中可以看到，我们已经能做到初步的跨页面组件间通信了，就是当前页面/组件，可以任意使用其他 store 的 state、getter，来进行自己的渲染，并且享受响应式的页面刷新。但这还不够，我们还希望进一步进行更多的跨页面跨组件通信由于 store.js 的文件和 page.js 的文件，js上下文不太一致。所以在 store.js 的文件中访问和操作整个单 store 的方式也和 page.js 不一样state就是存放当前子 store 数据的地方，并没有什么逻辑代码，不涉及跨组件通信mutation定义为同步修改当前仓库 state 的方法，因此所有都靠传入参数控制，只修改自己，因此不涉及跨组件通信getter是用来计算一些数据，提供给外部进行读取，是一种读操作。在 getter 中是有跨页面跨组件读数据的需求的。 pageA 页面的一个 getter 值，可以不仅由 pageA 页面的 state 数据来运算，还可以由其他任意子 store 节点的 state 和 getter 来进行数据运算// Lux 源码中对 getter 函数的声明描述\r\nexport type Getter<S, R> = (state: S, getters: any, rootState: R, rootGetters: any) => any;\r\n通过对 Lux 的 .ts 声明文件进行观察发现，getter 函数，参数其实包括4个对象，我们在简单 demo 中的使用上，很习惯 getter 只写一个入参，省略了其他三个。就是这三个可以做到在 getter 中访问并读取到其他子 store 的数据。所以一个最完整的 getter 写法应该是getters: {\r\n    minRpxHeight(state, getters, rootState, rootGetters) {\r\n      if (rootState.deviceInfo) {\r\n        let rate = 750 / rootState.deviceInfo.windowWidth;\r\n        let rpxHeight = rootState.deviceInfo.windowHeight * rate;\r\n        let statusBarHeight = rootState.deviceInfo.statusBarHeight * rate;\r\n        let barHeight = rootState.deviceInfo.titleBarHeight * rate;\r\n        let headZone = 28 + 44 + 26 + 100 + 100;// 顶部css计算\r\n        let result = rpxHeight - headZone - statusBarHeight - barHeight;\r\n        return result;\r\n      } else {\r\n        return 0;\r\n      }\r\n    },\r\n}\r\naction是用来描述一个仓库可以被外界调用的操作行为，既可以进行读操作，也可以进行写操作。在 action 中也有跨页面跨组件通信的需求，并且这个需求更大一些，既需要支持对外部仓库的访问读取操作，又需要支持提交执行的操作。export interface ActionContext<S, R> {\r\n  dispatch: Dispatch;\r\n  commit: Commit;\r\n  state: S;\r\n  getters: any;\r\n  rootState: R;\r\n  rootGetters: any;\r\n}\r\n\r\ntype ActionHandler<S, R> = (injectee: ActionContext<S, R>, payload: any) => any;\r\ninterface ActionObject<S, R> {\r\n  root?: boolean;\r\n  handler: ActionHandler<S, R>;\r\n}\r\n\r\nexport type Action<S, R> = ActionHandler<S, R> | ActionObject<S, R>;\r\n通过对 Lux 代码中 .ts 文件的声明可以看出来，action 接受2个入参，第一个入参是一个对象 ActionContext ，第二个入参是实际传入的参数 payload。而 ActionContext 的定义又包括了6个对象，前两个用来执行提交和调用等操作，后四个用来进行访问读取操作。读取操作：state，getters，rootState，rootGetters 和 getter 中的使用一模一样就不做赘述了重点说一下前两个 commit 和 dispatch。这两个2个方法的常规使用方法都是第一个参数为名字，第二个参数为传参。这里只用 commit 举例，dispatch 类似在单 store 模式下，action 上下文中使用 commit 无需指定 keyPath，commit(‘memberList’,listData)，即可直接提交给自己的 mutation，但如果此时希望跨仓库进行提交，可以加入第三个参数 {root:true}。然后使用 keyPath 当作名字进行 commit。因此一个完整的 action 写法应该是这样。actions: {\r\n    async refreshData({commit,dispatch,state,getters,rootState,rootGetters},payload) {\r\n  \t  // 获取某个网络请求 rpc promise\r\n      let req = reqHomePage();\r\n      req.then((result) => {\r\n  \t\t//数据提交给当前页面的 updateData mutation\r\n        commit('updateData', result);\r\n\t\t//数据提交给另一个页面的 updateUser mutation\r\n\t    commit('user/updateUser',result.user,{root:true});\r\n\t\t//触发当前页面的 saveLocalStorage 另一个 action ，进行网络数据缓存 \r\n\t\tdispatch('saveLocalStorage',result);\r\n\t\t//触发另一个页面的 saveUserCache 另一个 action ，进行用户数据缓存\r\n\t\tdispatch('user/cacheUser',result.user,{root:true});\r\n      }).catch(() => {\r\n        commit('updateDataError');\r\n      });\r\n    },\r\n}\r\n在 page 中跨页面跨组件通信上文说道，因为 page 与 store 的 js 上下文是不太一样的，所以在 page 中跨仓库通信也是略有不同。因为 page 的上下文 this 上挂载的整个单 store 的根，所以在 page 中无论是否是与自己页面的子 store 交互，还是与其他页面的子 store 交互，都必须通过名字访问 or 通过 keyPath 提交执行。通过 this.$store 访问整个单 store。在 page.js 中不止可以访问各个仓库的 state ，也可以访问 getter。都是通过各个仓库的名字来查找并访问onLoad(options) {\r\n  //访问home子仓库下的userName state\r\n  this.$store.state.home.userName;\r\n  //访问book自仓库下的billListForShow getter\r\n  this.$store.getters.book.billListForShow\r\n},\r\n通过 this.$commit 与 this.$dispatch ，用 keyPath 直接提交给任意子仓库 mutation or action。需要补充的是，在 page.js 中是强制 {root:false} 的，所以即便提交给自己页面的仓库也不能简写省略 keyPath。（这和在store里不同）onShow() {\r\n  //提交给 home 子仓库下的 userInfo mutation\r\n  this.$commit('home/userInfo',userinfo);\r\n  //提交给 billBookDetail 子仓库下的 refreshBookDetail action\r\n  this.$dispatch('billBookDetail/refreshBookDetail');\r\n},\r\nLux 的辅助插件Lux 还提供了3个辅助插件，和一个 immutable js 的配置Lux 的插件logger 插件：用来在任意 state 发生变化的时候打印调试信息，包含了 preState 和 nextStatebatch 插件：可以做到连续多次 commit 提交，可以合并成一次 commit 提交，来实现更好的性能watcher 插件：可以做到更好的监听 state 变化，然后触发监听回掉，进行更细粒度的局部监听局部更新不可变数据为了更好的管理 store 数据仓库，只允许通过 mutation 更改 state 不允许其他任何代码方式直接操作 state ，也为了更高效的计算 state 变化的 diff，Lux 支持可以自定义不可变数据的方案。可以考虑使用 immer.js（脚手架默认集成） 也可以考虑自己实现 deepClone 来做到不可变数据// 将插件配置到根 app.store.js 上\r\nimport * as Lux from '@alipay/lux';\r\nimport createLogger from '@alipay/lux/plugins/logger';\r\nimport createBatched from '@alipay/lux/plugins/batched';\r\nimport createWatch from '@alipay/lux/plugins/watch';\r\n\r\n//配置默认集成的 immer 不可变数据\r\nimport { produce } from 'immer';\r\nimport debounce from 'lodash.debounce';\r\n//构建 logger 插件\r\nconst logger = createLogger({\r\n  predicate: m => m.type !== 'add/updateInputValue'\r\n});\r\n//构建 batch 插件\r\nconst batched = createBatched(debounce(notify => notify(), 10));\r\n//构建 watcher 插件\r\nconst watcher = createWatch();\r\n\r\nexport default new Lux.Store({\r\n  state: {},\r\n  getters: {},\r\n  mutations: {},\r\n  actions: {},\r\n  modules: {\r\n    home,\r\n    createBillBook,\r\n\t...\r\n  }\r\n}, {\r\n  produce, // 注册使用 immer\r\n  plugins: [\r\n    logger,// 注册使用插件\r\n    batched,//也可以不用\r\n    watcher,\r\n  ]\r\n});\r\n代码文件规范多人账本项目，在全面实践 LunaX 的过程中对于代码文件的整理逐渐形成了一定的规范约束。可以参考一下借鉴一下components 共用组件总目录：公用组件不实现自己的 store ，遵照原生小程序开发模式。因为引入 store 会导致要把 组件 store 引入到每一处用到子 store 节点下，极大程度的让组件在使用上变得复杂公共组件可以视需求而定，进行 mapConfig 来将根 store 绑在 component 上下文pages 页面逻辑总目录：pageA 页面目录： 一个页面的所有文件component 页面组件：这里用于存放该页面专用的页面组件，如果组件逻辑复杂，可以有自己的子 store，文件结构同 page storestore 仓库目录：用于存放，子 store 主逻辑，与其他数据处理逻辑index.js 文件：子 store 主逻辑rpc.js 文件：用于生成 rpc promise 的逻辑，如果页面接口简单甚至没有，可以省略，写在 index.js 中storage.js 文件：用于生成本地存储 promise 的逻辑，可以省略pageA.js 文件： 进行 store 的 mapConfigpageA.axml pageA.acss pageA.json 文件：常规小程序 page文件pageB 页面目录app.js 小程序主入口文件：绑定单 store 到 appapp.store.js 根store文件：单 store 的构建以及插件配置LunaX 的其他工具前面就已经提到过 LunaX 不仅由 Lux 数据仓库这个组件，还有这其他丰富组件Mock 组件小程序本地 mock 方案mock 在本地维护，切换非常方便灵活mock 支持种类丰富支付宝 or 淘宝的 rpc，mtop公开或内部的 http 接口，同步或异步的 jsapi凤蝶的区块数据IDE，模拟器，真机都可以使用跟原 luna-mock 使用方法基本一致非常详细的 log 记录需要说明的是，原文档中提到在模拟器中进行 mock 存在一定瑕疵，需要侵入一些代码才可以，现在已经不需要了，直接使用即可。使用 LunaX 构建的小程序项目，整个 mock 工具都已经配置好了Rpc 的 mock 最常用，直接通过 module.exports 导出一个硬编码对象即可同步 JSApi 使用和 Rpc 一致，module.exports 导出一个硬编码对象异步 JSApi 使用起来略有差异，需要导出一个方法，把硬编码对象放到 return 结果中去const defaultInfo = {'nickName': '我', 'avatar': '../../assets/images/head.png'};\r\nmodule.exports = function (opts) {\r\n  return {\r\n    success: defaultInfo,\r\n  };\r\n};\r\n小程序埋点// 埋单个数据\r\nluna.log.info('SOME_INFO', infoData)\r\n// 埋多个数据\r\nluna.log.info('SOME_INFO', [infoData1, infoData2])\r\n// 埋 spm 点位\r\nconst tracert = new luna.Tracert({\r\n  spmAPos: 'a230', // spma位，必填\r\n  spmBPos: 'b7449', // spmb位，必填\r\n  bizType: 'AntDevTools', // 业务类型，必填\r\n  logLevel: 2, // 默认是2\r\n  chInfo: luna.config.app // 渠道\r\n});\r\ntracert.logPv();        // 记录 pv\r\ntracert.click('c17943.d32288');   // 点击埋点\r\ntracert.expo('c17943.d32327');  // 曝光埋点\r\n凤蝶区块凤蝶区块用于一些运营活动的配置，小程序也可以通过凤蝶的 path 读取凤蝶区块，从而做到不发版改换配置效果。 getH5data(‘path’) 方法返回的是一个 promise，在 promise 执行完毕后，凤蝶区块数据通过 json 返回网络请求 RpcLunaX 封装了 rpc 方法，统一处理了 Rpc 的缓存，转菊花方案，默认错误失败处理方案，防重复提交，限流展示等处理。LunaX Rpc"}
{"title": "你可能不知道的小程序（上篇） ", "author": "Rolan", "pub_time": "2018-11-27 00:21", "article_content": "为了让大家更好的理解小程序的一些限制和做一些优化，下面从小程序的基础架构讲起，如有不对的地方，望指正，请轻喷 :smile:一. 页面栈限制最多10层首先，我们看看下图，小程序的架构如下：我们可以看到，一个页面使用一个 WebView 线程进行渲染。 如果于页面栈有 10 层，则会开启 10 个 WebView 线程，占多一点内存，所以对页面栈进行了限制。那如果在10层页面栈的限制内，由于页面的内容过于复杂，内存爆了怎么办？ 小程序内部有一个回收机制，如果内存紧张时，会回收掉一部分 WebView 。很多人可能会觉得， 10 层页面栈基本已经够用了，无须关注这方面的限制了。但是如果出现循环引用的话，用户反复点击，则很容易出现爆栈的情况。 如下图：所以，在开发之前，提前梳理好页面之间的跳转，合理使用 navigator ，redirectTo, navigateBack …… 是非常重要的。当然，作为一个程序员，我并不想在跳转的时候去时时刻刻的关注我有没有正确引用，有没有超出10层页面栈。 完全可以对小程序的跳转做一个封装。因为只有 wx.navigateTo 才会使页面栈 + 1 ，那我们只要对这个方法做一层兜底处理即可。 如下代码：const PAGE_LIMIT = 10\r\nconst pages = getCurrentPages()\r\nif(pages.length >= PAGE_LIMIT) {\r\n  // 使用 wx.redirectTo 方法\r\n}\r\n复制代码这样就可以随心所欲的跳来跳去了。二. JsCore小程序的逻辑层是在 JsCore 中运行的。限制如下：没有 Window、Document 对象，也就无法使用 基于 DOM 的一些库. 暂无解决方法。还是从一张图说起：不同于页面的渲染，所有的脚本逻辑都是跑在同一个 JsCode 线程里面，类似于路由中改变 Hash 值。 因此也会引起下面一些常见的坑需要自己清理页面的 setTimeout 或者 setInterval 定时器如果要求页面每次出现都是最新的数据，则要把拉取数据的逻辑放在 onShow 中执行，别放在 onload 中。若追求“极致化体验”，在用户切到下一个页面的时候，可以在 onHide 中 abort 掉没有请求成功的接口，把即将处理的 setData 去掉，可以减轻最新页面的逻辑，让最新页面最快渲染展示。三. 原生组件层级最高像 canvas , video ，input ，map ，picker …… 组件，官方直接使用原生组件，渲染方式如下图：从上图很容易就可以看出，Navtive 组件的层级是最高的，那么仅仅去改变 z-index 也无法让其他组件覆盖原生组件。还好，官方给出了一个解决方案：使用 cover-view cover-image 将希望层级变高的组件也包裹成“原生组件”四. 独特的网络请求，本地存储独特的 Storage 存储以用户纬度隔离，同一个设备，A 无法访问 B 用户的数据。持久缓存，只有在用户关掉小程序才会删除，如果空间不足，会进行 LRU ，也就是不经常使用的小程序的数据缓存区域会被全部清空。在体验版、开发版、和线上版都共用一套，并不会隔离。没有 CookieRequest uploadFile downloadFile 并发最多10个请求只支持 HTTPS WSS如果以往在移动端, PC 的接口会使用 Cookie 进行一些处理，那在小程序中使用该接口就比较尴尬了。因此，我们可以在小程序中也模拟出 Cookie ，如下图：在 Storage 中隔离一个字段，用来做 Cookie ，下面用了一个小技巧，把 Cookie 的内容存放于内存中，而非每次都从 storage 中读取。let cookie = (function(){\r\n    return wx.getStorageSync('cookies');\r\n}())\r\nconst Cooke = {\r\n  getCookie(){}, //从内存中获取cookie\r\n  setCookie(){}, // 设置cookie\r\n  setCookieInHeader(){}, //根据response的Header设置cookie\r\n  removeCookie() {},  //删除cookie\r\n  isExpired() {} //判断是否过期\r\n}\r\n复制代码然后，我们在每次 Request 成功后，解析 Header 中 SET-COOKIE 属性设置 Cookie ，在每一次请求的时候，手动在 Header 中设置 Cookie 。这样就完美地模拟浏览器的 Cookie 概念了。并发请求处理设置一个队列，如果请求处理完毕，则移出队列，如果当前数组超过10个请求，则进入等待状态。大概代码如下：class Request {\r\n    constructor() {\r\n        this.maxLimit = 10;\r\n        this.requestQueue = []; // 请求队列\r\n        this.requestIng = 0; //当前并发数\r\n    }\r\n    request () {\r\n        // 判断是否超出并发数\r\n        if(this.requestIng >= this.maxLimit) {\r\n            // 推入请求队列\r\n        }else {\r\n            this.requestIng ++;\r\n            // 执行成功后 - 1 ,从 requestQueue 中取出重新请求\r\n        }\r\n    }\r\n}\r\n复制代码五. setData好吧，还是从一张图说起，显然，我们可以看出，每一次 setData 都是一次线程通信。线程通信成本很高，非常耗时间，因此官方明确的给出了建议：将多次 setData 合并成一次进行调用只 setData 对象改变的某个值data: {\r\n    array: {\r\n        changeData: '我改变了',\r\n        noChangeData: '我没有改变'\r\n    },\r\n},\r\nthis.setData({\r\n    'array.changeData':'changed data'\r\n})\r\n复制代码与界面渲染无关的字段不要放在 data 中data: {\r\n    view: '与界面相关的数据'\r\n},\r\nnoRelaView: '与界面无关'\r\n复制代码@Author：beidan"}
{"title": "微信小程序从入坑到放弃之坑八：textarea在苹果手机中的大Bug ", "author": "Rolan", "pub_time": "2018-11-27 00:42", "article_content": "首次在这里写点东西，还请各位大佬担待点。摘要：昨天的placeholder-class只是希望各位看官注意，而今天的textarea就绝对是一个超级大坑！而且如果看官手中没有苹果手机测试的话，这个可就真的是个坑了！为啥？难道要等到用户向你反馈你们产品有bug？？？......上一篇的《微信小程序从入坑到放弃之坑七：input组件的占位符placeholder》，没啥大坑，而这篇的textarea可就不一样了！这绝对是一个超大的Bug！！！在上一节的设计稿中，详细地址那块儿就是一个textarea组件。如图：其他无关的就不说了，我们直接进入正题。一、textarea在模拟器、安卓和苹果中的效果为了便于观察textarea组件的尺寸范围，我们给textarea设置一个背景色。如图：（一个带背景色的textarea组件示例代码一个带背景色的textarea组件示例代码）然后保存后看下模拟器、安卓手机和苹果手机中的效果吧。如图：（textarea在模拟器和安卓及苹果手机上的效果textarea在模拟器和安卓及苹果手机上的效果）看到区别了吗？如果没有，再来张大图。如图：（textarea在苹果手机上距离顶部有空隙textarea在苹果手机上距离顶部有空隙）二、不就是个padding吗？！对于有前端基础的看官来说，一眼就知道这是什么原因。是的，按照正常逻辑，这个空隙就是由padding引起的。2.1、wxml代码<textarea style=\"background:#666;padding:0\" value=\"加padding就有用了吗？\"></textarea>代码写完了，我们再用苹果手机看下效果。如图：（微信小程序里的textarea设置padding为0时在苹果手机中没有生效）微信小程序里的textarea设置padding为0时在苹果手机中没有生效可以看到，此时这个padding:0在苹果手机上并没有生效！奇了怪了，难道textarea不支持padding吗？于是，我又将padding的值修改成40px，此时在安卓手机上的效果如下：（设置padding为40时在安卓手机中有效设置padding为40时在安卓手机中有效）我们可以看到，此时安卓手机上是有效的，再来看看苹果手机吧，如图：（设置padding为40时在苹果手机中也有效）咦，怎么又有效果了？！那这个苹果手机到底支持不支持微信小程序里的textarea组件的padding属性呢？要说不支持吧，修改成40时也有效，要说支持吧，改成0又无效！这就有点坑爹了！三、微信小程序里的textarea确实有bug为了便于测试，这回我们直接测一组吧。效果如图：（测试发现在微信小程序中，苹果手机对padding的值有临界点）看到了吗？当值小于或等于0时，在苹果手机中压根就没有任何反应！虽然正常的网页中padding的值是不能为负的！但此时连0!important都无能为力！！！四、此坑有什么影响可能有些看官还不知道这坑有什么影响，拿我们的设计稿来说。我们写的页面总得与设计稿一致吧！那些现在问题就来了，这个textarea组件在安卓和苹果上的表现都不一样，要想在两种手机上展现效果一样，必须得对苹果单独处理才行！否则，我们在安卓上布局是好的，到了苹果手机上面，就已经错位了！所以，这就是个超级大坑！要不是因为艺灵我用二手的iphone 6s测试，这个bug估计还不知道什么时候才能知道呢！如果是等到用户反馈才知道，这可是件多么坑爹的事情！！！五、微信小程序中textarea内边距的坑通吃iphone各版本看官可能会说：“都什么年代了，艺灵你还用个破6s来测试！”行，为了验证此bug并非只是iphone 6s才有，于是我又召唤了我的小伙伴们。聊天如图：（微信小程序中textarea的内边距bug在iphone各版本上都存在）这回就问你服不服，iphone X，壕不？X都阵亡了！！！六、如何解决？搞过微信小程序的看官都知道，在小程序里面不像正常网页那样可以随便写js，在这里一切都要受限制！微信小程序官方也有对应的文档，文档地址：developers.weixin.qq.com/miniprogram/dev/api/system/system-info/wx.getSystemInfo.html?search-key=wx.getSystemInfo 。官方的文档向来都这样，要么不给案例，要么就简短的写下。现在的机型那么多，鬼知道怎么判断啊！于是我又在网上搜索后找到了现成的判断小程序是用安卓还是IOS打开的方法，原文地址：blog.csdn.net/niesiyuan000/article/details/80325988。顺便补充一句，微信官方提供的判断依旧不全面，最新出来的苹果手机还没有完全支持！相关的坑可以在官方社区的问答中找到。坑！坑！坑！坑！坑！坑！坑！"}
{"title": "API接口手工防御被恶意调用和接口被攻击 ", "author": "Rolan", "pub_time": "2018-11-28 00:16", "article_content": "通常情况下的api接口防护有如下几种：使用HTTPS防止抓包，使用https至少会给破解者在抓包的时候提高一些难度接口参数的加解密，通过md5加密数据+时间戳+随机字符串(salt)，然后将MD5加密的数据和时间戳、原数据均传到后台，后台规定一个有效时长，如果在该时长内，且解密后的数据与原数据一致，则认为是正常请求;也可以采用aes/des之类的加密算法，还可以加入客户端的本地信息作为判断依据本地加密混淆，以上提到的加解密数据和算法，不要直接放在本地代码，因为很容易被反编译和破解，建议放到独立模块中去，并且函数名称越混淆越难读越安全。User-Agent 和 Referer 限制api防护的登录验证，包括设备验证和用户验证，可以通过检查session等方式来判断用户是否登录api的访问次数限制，限制其每分钟的api调用次数，可以通过session或者ip来做限制定期监测，检查日志，侦查异常的接口访问在开发web端程序时，如果你的服务是放在外网的，你是无法完全阻止别人模拟客户端来调用你的web api的。因为你的所有前端代码用户都能直接或间接的看到。而在开发小程序项目时，前端的小程序代码是上传到微信服务器的，其他人想要直接看到或拿到源代码的难度较大，因此小程序端相对安全些;为什么要做接口防护和权限校验?有时候，黑客通过抓包或者其他方式即可获得到后台接口信息，如果不做权限校验，黑客就可以随意调用后台接口，进行数据的篡改和服务器的攻击。因此，为了防止恶意调用，后台接口的防护和权限校验非常重要。小程序如何进行接口防护?要进行小程序的接口防护，首先需要了解小程序的登录过程，如下图所示整个的流程如下：小程序端通过wx.login()获取到code后发送给后台服务器后台服务器使用小程序的appid、appsecret和code，调用微信接口服务换取session_key和openid(openid可以理解为是每个用户在该小程序的唯一识别号)后台服务器自定义生成一个3rd_session，用作openid和session_key的key值，后者作为value值，保存一份在后台服务器或者redis或者mysql，同时向小程序端传递3rd_session小程序端收到3rd_session后将其保存到本地缓存，如wx.setStorageSync(KEY,DATA)后续小程序端发送请求至后台服务器时均携带3rd_session，可将其放在header头部或者body里后台服务器以3rd_session为key，在保证3rd_session未过期的情况下读取出value值(即openid和session_key的组合值)，通过openid判断是哪个用户发送的请求，再和发送过来的body值做对比(如有)，无误后调用后台逻辑处理返回业务数据至小程序端ps：会话密钥session_key 是对用户数据进行加密签名的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。session_key主要用于wx.getUserInfo接口数据的加解密，如下图所示什么是sessionId?在微信小程序开发中，由wx.request()发起的每次请求对于服务端来说都是不同的一次会话。啥意思呢?就是说区别于浏览器，小程序每一次请求都相当于用不同的浏览器发的。即不同的请求之间的sessionId不一样(实际上小程序cookie没有携带sessionId)。如下图所示：实际上小程序的每次wx.request()请求中没有包含cookie信息，即没有sessionId信息。那么我们能否实现类似浏览器访问，可以将session保存到后台服务器呢?答案是肯定的。我们可以在每次wx.request()中的header里增加## java的写法，Jsessionid只是tomcat的对sessionId的叫法，其实就是sessionId \r\n \r\nheader:{'Cookie': 'JSESSIONID=' + sessionId} \r\n \r\n## thinkjs3.0 的写法 \r\n \r\nheader:{'Cookie': 'thinkjs=' + sessionId} \r\n效果如下图所示：在thinkjs3.0的后台代码中，sessionId被保存到了cookie里，可以通过const session_id = this.cookie('thinkjs') \r\n提取到sessionId的值具体ThinkJS的实现代码首先创建sever端的代码，如下图所示(cd到根目录，运行：thinkjs new server \r\n创建后台代码"}
{"title": "文字超出显示区域后隐藏并显示省略号 ", "author": "Rolan", "pub_time": "2018-11-28 00:29", "article_content": "单行文字超出后隐藏首先容器需要有固定的宽高，其次加入以下代码即可。view {\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n}多行文字超出后隐藏容器不需要有固定的宽高，只需加入以下代码即可。无需指定高度，只需指定最多显示几行，属性 -webkit-line-clamp。本示例中最多显示3行，超出3行后，在第三行末尾用省略号代替显示。view {\r\n  display: -webkit-box;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  word-break: break-all;\r\n  -webkit-box-orient: vertical;\r\n  -webkit-line-clamp: 3;\r\n}"}
{"title": "微信小程序--路由拦截器 ", "author": "Rolan", "pub_time": "2018-11-28 00:42", "article_content": "背景由于最近公司要求开发小程序,一直很感兴趣,也是趁着这次机会,边文档边开发,遇到一些好玩的东西,留此作为笔记介绍在开发小程序,构建路由时,因为需要权限判断,最常见的就是在路由跳转时判断用户是否有权限访问或使用该功能,而在官网找了很久也没有看到,诸如 vue-router 的 beforeEach 那样的路由拦截器,但是拦截是肯定需要的,所以自己写了一个代码直接上代码拦截器\r\nconst appGlobalData = getApp().globalData;\r\n/**\r\n * routerFillter --全局路由拦截器\r\n * @function\r\n * @param{Object} pageObj 当前页面的page对象\r\n * @param{Boolean} flag 是否开启权限判断\r\n */\r\nexports.routerFillter = function (pageObj, flag = false) {\r\n  if (flag) {\r\n    let _onShow = pageObj.onShow\r\n    pageObj.onShow = function () {\r\n      let that = this\r\n    // 这一步是自己定义获取登录状态的,只是个判断权限的\r\n      appGlobalData.getSignPrms.then((res) => {\r\n        // 改回this指针\r\n        res.status && _onShow.call(that)\r\n      }, (err) => {\r\n        // 用户未登录，重定向个人页\r\n        wx.switchTab({\r\n          url: '/pages/manage/manage'\r\n        })\r\n      })\r\n    }\r\n  }\r\n  return Page(pageObj)\r\n}使用// 小程序 .js文件\r\n// 官方写法\r\nPage({\r\n  data: {\r\n\r\n  }\r\n})\r\n// 将Page替换\r\nimport { routerFillter } from '../../utils/routerFillter.js';\r\nrouterFillter({\r\n  // 内部一样\r\n}, true)其实原理很简单,就是在微信小程序注册页面接受一个初始化对象前拦截做些处理,我这里判断无权限时,更改原pageObj的 onShow生命周期函数,改为重定向去登陆页,操作完再return 出微信小程序注册页面所需的Page({pageObj})就行,原理很简单,思路证实可行存在问题问题是有的,就是因为我更改的是onShow生命周期,而小程序在触发onShow时,页面已经展示了,导致页面可能会先闪现一次页面,才会重定向到登陆页,也想过更改onLoad生命周期,但是也是有问题的,因为有些页面如果设置了缓存,会导致onLoad只触发一次,也就是说,只能拦截一次(很尴尬)所以这篇文章即是分享一种方法,也是寻求一种解决方案"}
{"title": "微信小程序的wx-charts插件-tab选项卡 ", "author": "Rolan", "pub_time": "2018-11-29 00:18", "article_content": "微信小程序的wx-charts插件-tab选项卡效果://index.js\r\nvar wxCharts = require('../../utils/wxcharts-min.js');\r\nconst app = getApp();\r\nvar ringChart = null;\r\nPage({\r\n  data: {\r\n    selected: true,\r\n    selected1: false\r\n  },\r\n  torecord() {\r\n    wx.navigateBack({\r\n      delta: 1,\r\n    })\r\n  },\r\n  onLoad: function (e) {\r\n    //  高度自适应\r\n    var windowWidth = '', windowHeight = '';    //定义宽高\r\n    try {\r\n      var res = wx.getSystemInfoSync();    //试图获取屏幕宽高数据\r\n      windowWidth = res.windowWidth / 750 * 690;   //以设计图750为主进行比例算换\r\n      windowHeight = res.windowWidth / 750 * 550    //以设计图750为主进行比例算换\r\n    } catch (e) {\r\n      console.error('getSystemInfoSync failed!');   //如果获取失败\r\n    }\r\n    ringChart = new wxCharts({\r\n      canvasId: \"ringCanvas\",\r\n      type: \"ring\",\r\n      series: [\r\n        { data: 20, },\r\n        { data: 30, },\r\n        { data: 60, }\r\n      ],\r\n      width: windowWidth,\r\n      height: windowHeight,\r\n      dataLabel: false,\r\n      legend: false,\r\n    });\r\n  },\r\n\r\n  selected: function (e) {\r\n    this.setData({\r\n      selected1: false,\r\n      selected: true\r\n    })\r\n  },\r\n\r\n  selected1: function (e) {\r\n    this.setData({\r\n      selected: false,\r\n      selected1: true\r\n    })\r\n  }\r\n})<view class=\"head\">\r\n  <view class=\"head_item {{selected?'head_itemActive':''}}\" bindtap=\"selected\">个人</view>\r\n  <view class=\"ring\"></view>\r\n  <view class=\"head_item {{selected1?'head_itemActive':''}}\" bindtap='selected1'>设置</view>\r\n</view>\r\n<view class=\"main {{selected?'show':'hidden'}}\">\r\n  <canvas canvas-id=\"ringCanvas\" disable-scroll=\"true\" class=\"canvas\"></canvas>\r\n  <cover-view class='text'>\r\n   黄\r\n  </cover-view>\r\n</view>\r\n<view class=\"main {{selected1?'show':'hidden'}}\">\r\n  <text>for sutdnet month attend</text>\r\n</view>page {\r\n  background-color: rgba(239, 239, 240, 1);\r\n}\r\n\r\n.text {\r\n  position: absolute;\r\n  top: 380rpx;\r\n  left: 356rpx;\r\n}\r\n\r\n.canvas {\r\n  width: 100%;\r\n  height: 550rpx;\r\n  margin: 30rpx;\r\n}\r\n\r\n.head_item {\r\n  width: 374rpx;\r\n  text-align: center;\r\n  font-size: 34rpx;\r\n  color: #999;\r\n  letter-spacing: 0;\r\n}\r\n\r\n.head_itemActive {\r\n  color: rgba(87, 213, 200, 1);\r\n}\r\n\r\n.ring {\r\n  width: 2rpx;\r\n  height: 100%;\r\n  background-color: rgba(204, 204, 204, 1);\r\n}\r\n\r\n.head {\r\n  width: 100%;\r\n  height: 100rpx;\r\n  background-color: rgba(255, 255, 255, 1);\r\n  border-bottom: 1rpx solid rgba(204, 204, 204, 1);\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  position: fixed;\r\n  top: 0;\r\n  z-index: 10;\r\n}\r\n\r\n.main {\r\n  position: absolute;\r\n  width: 100%;\r\n  height: 100%;\r\n  display: block;\r\n  box-sizing: border-box;\r\n  padding-top: 100rpx;\r\n  top: 0;\r\n}\r\n\r\n.show {\r\n  display: block;\r\n  text-align: center;\r\n}\r\n\r\n.hidden {\r\n  display: none;\r\n  text-align: center;\r\n}往后余生，唯独有你简书作者：达叔小生90后帅气小伙，良好的开发习惯；独立思考的能力；主动并且善于沟通简书博客： https://www.jianshu.com/u/c785ece603d1结语下面我将继续对 其他知识 深入讲解 ，有兴趣可以继续关注小礼物走一走 or 点赞"}
{"title": "小程序分屏加载实践 ", "author": "Rolan", "pub_time": "2018-11-30 00:02", "article_content": "在小程序不断迭代的时候，很容易遇到首屏渲染问题。这种问题，可能出现的原因是：小程序包太大，资源需要加载；网络环境太差，下载速度太慢；渲染节点太多，渲染耗时。针对小程序首次加载包的问题，小程序提出了分包加载的功能，这里不做详细描述，可以去看下官方文档这里我选择的是针对渲染节点去做优化。技术方案在微信的API文档里面，有一个判断节点与可视区域的APIIntersectionObserver 对象，用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见这个时候就在想，能不能建立 IntersectionObserver 跟组件之间的关系，使得组件进入可视区域的时候，就显示自己的内容，否则隐藏自己，这样达到动态加载模块的目的。// 伪代码\r\n// 建立监听\r\nelement.observer()\r\n\r\n// 处理进入\r\nobserver.handleEnterView(() => {\r\n  callback() // 处理回调\r\n  disconnect() // 销毁\r\n})\r\n\r\n\r\n复制代码<!-- component -->\r\n<view class=\"component\">\r\n  <view class=\"component-header\"></view>\r\n  <view class=\"component-observer\" wx:if=\"{{ observer_status}}\"></view>\r\n  <view class=\"component-content\" wx:else>\r\n    <!-- your content -->\r\n  </view>\r\n</view>\r\n复制代码开发阶段建立了基本技术方案之后，就开始到代码层面了Component({\r\n  data: {\r\n    observer_status: true\r\n  },\r\n  // 在ready写是因为组件在这个时候，才在视图层布局完成\r\n  ready () {\r\n    // 因为我们是把设备的整个可视区域当成了观参照区域，所以这里直接选择relativeToViewport，如果需要其他的观察区域可以调用relativeTo选择参照区域\r\n    this.observer = this.createIntersectionObserver().relativeToViewport()\r\n    // 我这里的做法是，只要观察的节点进入了可视区域，就显示自己本身的内容\r\n    // 实际上这个observer的回调触发时机是观察节点进入或者离开可视区域，我这里选择的是，只要执行了就显示这个区域，并且关闭这个观察\r\n    this.observer.observe('.observer', (res) => {\r\n      this.setData({\r\n        observer_status: false\r\n      })\r\n      this.observer.disconnect()\r\n      this.observer = null\r\n    })\r\n  },\r\n  detached () {\r\n    // 如果未进入可视区域就离开了，也需要销毁自己的观察\r\n    this.observer && this.observer.disconnect()\r\n  }\r\n})\r\n复制代码优化你们以为这就完了么，并没有。对于一个小程序页面，它是可以由template或者Component组成的。对于template来说，需要在Page里面定义，而且如果观察的东西比较多的话，需要设置 observeAll:all ，但是官方文档里面有说同时选中过多节点，将影响渲染性能。对于组件开发来说，如果每个组件都这样写的话，是否也会跟 observerAll:all 一样影响渲染性能，还不清楚，如果确实会影响的话也只能减少观察对象，或者把做一个大容器去观察。但是如果每个组件都这样写的话也会非常的繁琐。这个时候，组件的好处就来了。在定义组件的时候，有一个很神奇的属性，他就是 behaviors。简单点说，他其实就是一个代码复用机制。直接使用 behaviors 可以使得组件自动获得某些方法，属性。利用这个特性，就可以在组件里面少写很多代码了。// mixin.js\r\nmodule.exports = Behavior({\r\n  data: {\r\n    observer_status: true\r\n  },\r\n  ready () {\r\n    this.observer = this.createIntersectionObserver().relativeToViewport()\r\n    // 自己统一好observer节点的class\r\n    this.observer.observe('.component-observer', (res) => {\r\n      this.setData({\r\n        observer_status: false\r\n      })\r\n      this.observer.disconnect()\r\n      this.observer = null\r\n    })\r\n  },\r\n  detached () {\r\n    this.observer && this.observer.disconnect()\r\n  }\r\n})\r\n复制代码// Component.js\r\nlet mixin = require('你的mixin路径')\r\nComponent({\r\n  behaviors: [mixin]\r\n})\r\n复制代码<!-- Component.wxml -->\r\n<view class=\"component\">\r\n  <view class=\"component-header\"></view>\r\n  <view class=\"component-observer\" wx:if=\"{{ observer_status}}\"></view>\r\n  <view class=\"component-content\" wx:else>\r\n    <!-- your content -->\r\n  </view>\r\n</view>\r\n复制代码或者你可以把整个observer做成组件，这样去减少observer的数量，内聚一些模块<!-- Observer.wxml -->\r\n<view class=\"observer\">\r\n  <view class=\"observer-element\" wx:if=\"{{ observer_status}}\"></view>\r\n  <view class=\"observer-content\" wx:else>\r\n    <slot/>\r\n  </view>\r\n</view>\r\n复制代码需要注意的是对于组件来说，如果observer的话就需要一个观察节点，并且这个观察节点必须是高度不为0的可视对象，如果又想有高度又不想影响页面位置的话可以用一些hack的方法.component-observer {\r\n  height: 1rpx;\r\n  margin-top: -1rpx;\r\n}\r\n\r\n复制代码后续一些讨论在使用 IntersectionObserver 的时候，有试过用 hidden 属性。但是实际上， hiiden 也是会被渲染出来的，只是不显示而已，并不会造成页面加载速度的提升效果图这里是随便拿的一个demo去弄的，需要的话可以点击 这里或者浏览小程序代码片段 https://developers.weixin.qq.com/s/oV1RFfmY7H4W使用之前使用之后如果图片不动的话可以点击查看 可以看得出是提升是相当明显的后续进阶图片lazyload方案image有一个 lazy-load 的属性，但是它只能在page以及在scroll-view使用，如果在其他地方的话是不是也可以用这个去做呢<!-- image-compponent -->\r\n<view class=\"observer-picture\">\r\n  <image src=\"{{ _src }}\"></image>\r\n</view>\r\n复制代码// image-component js\r\nComponent({\r\n  properties:{\r\n    imageSrc: {\r\n      type: String,\r\n      value: '',\r\n    },\r\n\r\n  },\r\n  data: {\r\n    _src: \"default_image\"\r\n  },\r\n  ready () {\r\n    // 伪代码\r\n    observer('.observer-picture')\r\n      .then(() => {\r\n        this.setData({\r\n          _src: this.properties.imageSrc\r\n        })\r\n      })\r\n  }\r\n})\r\n复制代码"}
{"title": "开发小程序的一些小经验 ", "author": "Rolan", "pub_time": "2018-11-30 00:13", "article_content": "图片在微信小程序中可以说是一个神奇的存在。在web开发中，我们会利用图片的自适应比如百分比而省去不少麻烦，因为高度会自适应。但是小程序中的图片都有一个初始大小，而且是固定的，无论你的图片多大多小，都是统一的 320px*240px 。虽然作为组件的图片支持平铺，剪切等呈现效果，但是容器大小都是固定的，所以每次使用 image 我们要想办法控制图片的大小。css控制（大小固定的图片）用CSS控制一部分固定比例的图片，我们可以使用微信自带的单位 rpx 来固定。image{\r\n  width: 128rpx;\r\n  height: 128rpx;\r\n}\r\n复制代码动态计算（用于多种不同尺寸的图片）如果遇到了内容页这种，不知道图片固定尺寸的情况，就只能根据在后端给的图片尺寸，然后在JS中换算，通过setData设置图片大小。this.setData({\r\n  imageWidth: 200,\r\n  imageHeight: 200\r\n})\r\n复制代码<image style=\"width:{{imageWidth}}rpx;height:{{imageHeight}}rpx\" src=\"...\"></image>\r\n复制代码动态布局如果你的页面需要根据当前页面，计算的高度和宽度，那么页面一定会闪以下，因为 wx.getSystemInfo 是异步的。wx.getSystemInfo({\r\n  success (res) {\r\n    console.log(res.pixelRatio)\r\n    console.log(res.windowWidth)\r\n    console.log(res.windowHeight)\r\n  }\r\n})\r\n复制代码如果像解决这个问题，我们可以这样，设置一个isLoaded的参数，等页面加载好了再显示。<block wx:if=\"{{isLoaded}}\">\r\n</block>\r\n<block wx:else>\r\n</block>\r\n复制代码当然还有一个方法叫做同部 wx.getSystemInfoSync ，这样就不会像异步那样闪了。try {\r\n  const res = wx.getSystemInfoSync()\r\n  console.log(res.pixelRatio)\r\n  console.log(res.windowWidth)\r\n  console.log(res.windowHeight)\r\n} catch (e) {\r\n  // Do something when catch error\r\n}\r\n复制代码高度100%问题如何高度百分百，这里如果page相当于html如果不是100%，那么即使内部元素设置高度100%也是无效的，因为百分比是相对父元素而定的。如果这张页面只用于一屏的，那么我们可以page设置高度100%，但是如果这张页面我们只是loading的时候需要100%，那么这个时候我们可以使用vh这个单位，vh相当于把屏幕的高度分为了100份，因此我们100vh就是满屏的意思。.onePageWrapper{\r\n  height: 100vh;\r\n}\r\n复制代码part 2: 复用问题CSS复用问题，wxss复用有时候，我们不想写重复的CSS，但是又不想写在全局app.wxss中。我们只是有几张页面需要共享，这个时候可以创建一个wxss，然后导入当前页面的wxss。就像下方这样导入就可以了。@import'../public.wxss';\r\n复制代码模板复用问题，wxml复用重复两遍以上的都用模板。同样为了解决重复问题，我们可以定义模板，然后引入模板调用模板，这样可以极大地减少重复代码。定义模板时，使用 <template name=\"usertop\"></template> 。<template name=\"usertop\">\r\n<image src='{{userInfo.avatarUrl}}'></image>\r\n<text>{{userInfo.nickName}}</text>\r\n<view>{{userInfo.userRank.name}}</view>\r\n<view class='rankLevelText'>LV<text>{{userInfo.level}}</text></view>\r\n<view class='userExper' style='width:{{userInfo.bar}}'></view>\r\n</template>\r\n复制代码使用模板时，使用 <template is=\"usertop\"/> 。如果是模板的定义和使用在同一张页面上则不需要导入，如果是不同页面则需要使用导入 <import src=\"../tpl/usertop.wxml\" /> 。当然模板是需要传输数据的，我们该如何传递参数呢？很简单，直接 data=\"{{userInfo}}\" ，加上这个参数，我们可以在模板中调用名为 userInfo 的对象了。如果是多个对象？而且想要将函数也传递过去保定呢？可以这样写 data=\"{{userInfo,bindGetUserInfo}}\" ，直接将你想要传递的参数通过 , 分割，掉用的时候 bindgetuserinfo=\"bindGetUserInfo\" 即可。<import src=\"../tpl/usertop.wxml\" />\r\n<template is=\"usertop\" data=\"{{userInfo}}\"/>\r\n复制代码应用组件复用，wxml+wxss+js复用官方文档如果CSS复用和WXML已经不能满足复用的问题，自定义组件满足你。比如有个按钮，每张页面都有，而且都需要点击回应相应的操作，如果每个页面配置，js就需要复制复制复制。如果是自定义组件，直接调用即可。而且自定义组件不仅Page可以调用，组件之间也可以互相调用，只需再json中配置既可以轻松调用。首先是创建组件：然后在json中配置，告诉其他页面我是不是组件，以及配置页面需要用到的组件。{\r\n  \"component\": true,//如果是组件\r\n  \"usingComponents\": {\r\n    \"my-component-btn\": \"/component/my-component-btn\"//调用的组件\r\n  }\r\n}\r\n复制代码配置成功之后，直接在wxml中当作原生组件一般使用：<my-component-btn></my-component-btn>\r\n复制代码part 3:优雅地生成分享有时候会通过canvas来创建分享图片，让用户下载分享。步骤：wx.downloadFile ，所需的远程图片（如果需要）敲黑板！ wx.createCanvasContext 创建一个canvas对象，获取 <canvas canvas-id=\"myCanvas\" style=\"width:750px; height:1098px;\"/> ，这里需要主要注意你所创建的图片要和canvas一样大小，不然出来的图片不完整，如果不在wxml中创建canvas，那么是获取不到生成的图片的。随意画画，和H5的canvas语法差不多wx.canvasToTempFilePath 最后是生成到临时文件，不过这边有一个坑，需要setTimetout一下，应该是eventloop的原因差不多1秒的延迟就可以了。如果直接获取是获取不到图片的。最后使用 wx.previewImage 直接打开图片。drawCanvas: function (url) {\r\n\twx.downloadFile({\r\n\t\turl: url, //仅为示例，并非真实的资源\r\n\t\tsuccess: function (res) {\r\n\t\t\tif (res.statusCode === 200) {\r\n\t\t\t\tconst ctx = wx.createCanvasContext('myCanvas')\r\n\t\t\t\t//随意画画\r\n\t\t\t\tctx.drawImage(res.tempFilePath, 0, 0, 750, 1098)\r\n\t\t\t\tctx.setFontSize(56)\r\n\t\t\t\tctx.setFillStyle(\"#fff\")\r\n\t\t\t\tctx.setTextAlign(\"center\");\r\n\t\t\t\tctx.fillText(\"自定义文字\", 375, 100)\r\n\t\t\t\tctx.draw();\r\n\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\twx.canvasToTempFilePath({\r\n\t\t\t\t\t\tcanvasId: 'myCanvas',\r\n\t\t\t\t\t\tsuccess: function (res) {\r\n\t\t\t\t\t\t\tconsole.log(\"save\");\r\n\t\t\t\t\t\t\twx.previewImage({\r\n\t\t\t\t\t\t\t\tcurrent: '', // 当前显示图片的http链接\r\n\t\t\t\t\t\t\t\turls: [res.tempFilePath]\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tfail: (res) => {\r\n\t\t\t\t\t\t    //失败的操作\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t},1000)\r\n\t\t\t}\r\n\t\t}\r\n\t})\r\n}\r\n复制代码"}
{"title": "微信小程序开发教程第五章：名片夹详情页开发 ", "author": "admin", "pub_time": "2016-10-12 22:39", "article_content": "先看下「名片盒」详情页的效果图：备注下大致需求：顶部背后是轮播图，二维码按钮弹出模态框信息、点击微信栏、点击存入手机，地址栏需要地图展示，名片分享也是模态框指引。首先是轮播图，autoplay 自动播放，interval 轮播的时间，duration 切换速度，可以根据自己需求去添加。Delete：是删除按钮，加载进来是隐藏的，需用户点轮播图进去后，轮播图全屏显示才出来。noClickImg 与 ClickImg：切换全屏与非全屏轮播图，绑定了点击事件 changeClick 来切换，只是改变样式即可。Block：图片列表。Number_img：当前轮播 index（currentNumber），与图片 length 集合（cardnum）。其中 currentNumber：//轮播图发生改变时改变数字//初始化数据Data:{currentNumber:1}slidechange:function(e){var number = e.detail.current;this.setData({currentNumber:number+1})},这里可以看到全屏状态下当关闭按钮被点击后 getBackStyle，把 changeClick 切换到 imgFullScrenn 待命。再次点击返回原样式，切换后事件又走回到 getBackStyle 了，灵活运用。刷新下开发者工具可以看到具体效果如下：详情页可以看到信息基本都是样式一样，可以使用微信提供的循环 block。下面是详情页里面的个人信息数据，如果有信息就显示出来，没有数据的不显示，这里使用//中文信息               var chinaMessage = res.card.groups[0].fields;var personMessage= []               for(var i = 0;i                personMessage.push(chinaMessage[i])               }               //为空或者null是不显示判断              for(var k in personMessage){                if(personMessage[k].value==null || personMessage[k].value==\"\"){                personMessage[k][\"display\"] = \"none\";                }else{                personMessage[k][\"display\"] = \"block\";                }               }具体以 json 数据格式来处理，我们需要做的就是给它绑定 display 的值，然后我们调用即可。微信此版本的 setData 不支持异步更新数据，故而我们在发生真实网络数据请求时一定要在后面加上 forceUpdata()，强制触发视图渲染，否则会出现很多莫名其妙的 bug。这里说明下：如是服务器真实数据。可以看到会报错，可能是 js 的执行顺序，依次往下走，此时网络数据还在请求中。定义一个变量即可。当然这里的数据都是 push 上来的。以下是二维码弹出信息。这是弹出模态框二维码信息，布好局初始化是none状态。那里需要它直接绑定数据即可：This.setData({//模态框名字:”显示？隐藏”})方法是让它显示。需要用他的地方调用方法即可。(支持重复调用)详情页公司位置地图直接调用微信提供的接口实现（群里的 demo 有实现方式）。可以看下实现的效果："}
{"title": "微信小程序开发教程第六章：「名片盒」「我」的页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:46", "article_content": "效果图与需求：用户有多张名片，需要左右切换查看，往下切换是菜单按钮。这里需求两处滑动，用到了微信提供给我们的滑动组件 swiper，并且进行了嵌套使用，第一层是名片展示与菜单按钮的上下滑动，第二层是名片展示的左右滑动（支持互相嵌套使用的，可以放心使用）。Vertical 加上就是纵向滑动，去掉即是左右滑动。整体结构如下所示：点击事件绑定的是数据切换方式，因为需要支持多次点击切换。初始化数据是 nextSlide：再看下 nextSlide 事件。currentSlide 是当前页面的 index，改变它即可完成切换效果，可以看上图初始化数据时设置了 cs 是 0。因而赋值当前 data.cs+1 即可，再把绑定点击事件 clickNext 切换成 nextSlideAgain。再看下 nextSlideAgain 事件，执行的减去 1 个索引，实现多次点击切换效果。具体效果可以看到。点击个人名片进去编辑名片页面，由于需要带参，故而使用的是 wx.navgateTo。可以看下效果：最后上点干货：我们发出第一篇教程的时候有人就注意到这点了，怎么做真实数据交互，下面大家可以了解下。首先进去是 MD5 加密，requster 交互层。怎么引用 MD5.js？当然是模块化 require，被引用的 js 不要忘记 module.exports 出来。下面是 requester.js 引用 MD5.js。ApplicationRoot 是服务器地址（配置服务器时在开发设置页面查看 AppID 和 AppSecret，配置服务器域名）。Require.js 这里 module.exports 是暴露方法出去。这时候在全局 app.js 里面引入 require.js 映射到全局 global，这个 global 是全局的。这时候那个页面需要那个页面就直接去接受吧，模块化是不是很好用？可以完整的看下与后台做数据交互的一个请求实现方式如下：图一是 requester.js 里面的封装。图二是需要调用数据的页面渲染。"}
{"title": "微信小程序开发教程第一章：微信小程序开发实操指南 ", "author": "admin", "pub_time": "2016-10-12 22:49", "article_content": "序言开始开发应用号之前，先看看官方公布的「小程序」教程吧！（以下内容来自微信官方公布的「小程序」开发指南）本文档将带你一步步创建完成一个微信小程序，并可以在手机上体验该小程序的实际效果。这个小程序的首页将会显示欢迎语以及当前用户的微信头像，点击头像，可以在新开的页面中查看当前小程序的启动日志。1. 获取微信小程序的 AppID首先，我们需要拥有一个帐号，如果你能看到该文档，我们应当已经邀请并为你创建好一个帐号。注意不可直接使用服务号或订阅号的 AppID。 利用提供的帐号，登录 https://mp.weixin.qq.com ，就可以在网站的「设置」-「开发者设置」中，查看到微信小程序的 AppID 了。注意：如果我们不是用注册时绑定的管理员微信号，在手机上体验该小程序。那么我们还需要操作「绑定开发者」。即在「用户身份 - 开发者」模块，绑定上需要体验该小程序的微信号。本教程默认注册帐号、体验都是使用管理员微信号。2. 创建项目我们需要通过开发者工具，来完成小程序创建和代码编辑。开发者工具安装完成后，打开并使用微信扫码登录。选择创建「项目」，填入上文获取到的 AppID，设置一个本地项目的名称（非小程序名称），比如「我的第一个项目」，并选择一个本地的文件夹作为代码存储的目录，点击「新建项目」就可以了。为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择「是」，开发者工具会帮助我们在开发目录里生成一个简单的 demo。项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在「编辑」里可以查看和编辑我们的代码，在「调试」里可以测试代码并模拟小程序在微信客户端效果，在「项目」里可以发送到手机里预览实际效果。3. 编写代码点击开发者工具左侧导航的「编辑」，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js 后缀的是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。app.js 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用 MINA 提供的丰富的 API，如本例的同步存储及同步读取本地数据。```//app.jsApp({onLaunch: function () {// 调用 API 从本地缓存中获取数据var logs = wx.getStorageSync('logs') || []logs.unshift(Date.now())wx.setStorageSync('logs', logs)},getUserInfo:function(cb){var that = this;if(this.globalData.userInfo){typeof cb == \"function\" && cb(this.globalData.userInfo)}else{// 调用登录接口wx.login({success: function () {wx.getUserInfo({success: function (res) {that.globalData.userInfo = res.userInfo;typeof cb == \"function\" && cb(that.globalData.userInfo)}})}});}},globalData:{userInfo:null}})```app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。```{\"pages\":[\"pages/index/index\",\"pages/logs/logs\"],\"window\":{\"backgroundTextStyle\":\"light\",\"navigationBarBackgroundColor\": \"#fff\",\"navigationBarTitleText\": \"WeChat\",\"navigationBarTextStyle\":\"black\"}}```app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。```/**app.wxss**/.container {height: 100%;display: flex;flex-direction: column;align-items: center;justify-content: space-between;padding: 200rpx 0;box-sizing: border-box;}```### 4. 创建页面在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径 + 页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js 后缀的文件是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件，.wxml 后缀的文件是页面结构文件。index.wxml 是页面的结构文件：```{{userInfo.nickName}}{{motto}}```本例中使用了 、、 来搭建页面结构，绑定数据和交互处理函数。index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。```//index.js// 获取应用实例var app = getApp()Page({data: {motto: 'Hello World',userInfo: {}},// 事件处理函数bindViewTap: function() {wx.navigateTo({url: '../logs/logs'})},onLoad: function () {console.log('onLoad')var that = this// 调用应用实例的方法获取全局数据app.getUserInfo(function(userInfo){// 更新数据that.setData({userInfo:userInfo})})}})```index.wxss 是页面的样式表：```/**index.wxss**/.userinfo {display: flex;flex-direction: column;align-items: center;}.userinfo-avatar {width: 128rpx;height: 128rpx;margin: 20rpx;border-radius: 50%;}.userinfo-nickname {color: #aaa;}.usermotto {margin-top: 200px;}```页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。index.json 是页面的配置文件：页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。**logs 的页面结构**```{{index + 1}}. {{log}}```logs 页面使用 控制标签来组织代码，在 上使用 wx:for-items 绑定 logs 数据，并将 logs 数据循环展开节点//logs.jsvar util = require('../../utils/util.js')Page({data: {logs: []},onLoad: function () {this.setData({logs: (wx.getStorageSync('logs') || []).map(function (log) {return util.formatTime(new Date(log))})})}})运行结果如下：5. 手机预览开发者工具左侧菜单栏选择「项目」，点击「预览」，扫码后即可在微信客户端中体验。目前，预览和上传功能尚无法实现，需要等待微信官方的下一步更新。如你所见，微信官方给出的开发指南还非常简单，很多细节、代码和功能都没有明确的展示，所以接下来就到博卡君展示实力的时候啦！开发教程正式开始！第一章：准备工作做好准备工作很重要。开发一个微信应用号，你需要提前到微信的官方网站（weixin.qq.com）下载开发者工具。* 下载最新微信开发者工具，打开后你会看到该界面：* 点击「新建 web+」项目，随后出现如下画面：* 该页面内的各项内容需要注意——* AppID：依照官方解释来填。* Appname: 项目最外层文件夹名称，如你将其命名为「ABC」，则之后的全部项目内容均将保存在「/ABC/…」目录下。* 本地开发目录：项目存放在本地的目录。注：再次强调，如果你和团队成员共同开发该项目，则建议你们使用同样的目录名称及本地目录，以确保协同开发的统一性。如果你之前已有项目，则导入过程与以上内容近似，不再赘述。* 准备工作全部完成后，点击「新建项目」按钮，弹出框点「确定」。* 如上图所示，此刻，微信开发者工具已经为你自动构建了一个初始的 demo 项目，该项目内包含了一个微信应用项目所需具备的基本内容和框架结构。点击项目名称（图中即「cards」）进入该项目，就能看到整个项目的基本架构了："}
{"title": "微信小程序开发教程第二章：项目构架 ", "author": "admin", "pub_time": "2016-10-12 23:08", "article_content": "微信目前用户群体非常庞大，微信推出公众号以后，火爆程度大家都看得到，也同样推动着 h5 的高速发展，随着公众号业务的需求越来越复杂，应用号现在的到来也是恰到好处。我们团队具体看了一两次文档后发现，它提供给开发者的方式也在发生全面的改变，从操作 DOM 转为操作数据，基于微信提供的一个过桥工具实现很多 h5 在公众号很难实现的功能，有点类似于 hybrid 开发，不同于 hybrid 开发的方式是：微信开放的接口更为严谨，结构必须采用他提供给我们的组件，外部的框架和插件都不能在这里使用上，让开发者完全脱离操作 DOM，开发思想转变很大。工欲善其事，必先利其器。理解它的核心功能非常重要，先了解它的整个运作流程。生命周期：在index.js里面：开发者工具上 Console 可以看到：在首页 console 可以看出顺序是 App Launch-->App Show-->onload-->onShow-->onReady。首先是整个 app 的启动与显示，app 的启动在 app.js 里面可以配置，其次再进入到各个页面的加载显示等等。可以想象到这里可以处理很多东西了，如加载框之类的都可以实现等等。路由：路由在项目开发中一直是个核心点，在这里其实微信对路由的介绍很少，可见微信在路由方面经过很好的封装，也提供三个跳转方法。* wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。* wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。* wx.navigateBack()：关闭当前页面，回退前一页面。这三个基本上使用足够，在路由方面微信封装的很好，开发者根本不用去配置路由，往往很多框架在路由方面配置很繁琐。组件：此次微信在组件提供方面也是非常全面，基本上满足项目需求，故而开发速度非常快，开发前可以认真浏览几次，开发效率会很好。其它：任何外部框架以及插件基本上无法使用，就算原生的 js 插件也很难使用，因为以前我们的 js 插件也基本上全部是一操作 dom 的形式存在，而微信应用号此次的架构是不允许操作任何 dom，就连以前我们习惯使用的动态设置的 rem.js 也是不支持的。此次微信还提供了 WebSocket，就可以直接利用它做聊天，可以开发的空间非常大。跟公众号对比我们发现，开发应用号组件化，结构化，多样化。新大陆总是充满着惊喜，更多的彩蛋等着大家来发现。接下来开始搞一些简单的代码了！* 找到项目文件夹，导入你的编辑器里面。在这里，我使用了 Sublime Text 编辑器。你可以根据自己的开发习惯选择自己喜欢的编辑器。* 接下来，你需要根据自己的项目内容调整项目结构。在范例项目中，「card_course」目录下面主要包含了「tabBar」页面以及该应用的一些配置文件。* 示例项目的「tabBar」是五个菜单按钮：* 找到「app.json」文件，用来配置这个五个菜单。在代码行中找到「tabBar」：* 你可以根据实际项目需求更改，其中：* 「Color」是底部字体颜色，「selectedColor」是切换到该页面高亮颜色，「borderStyle」是切换菜单上面的一条线的颜色，「backgroundColor」是底部菜单栏背景颜色。文字描述较为抽象，建议你一一调试并查看其效果，加深印象。* 「“list”」下的代码顺序必须依次放置，不能随便更改。* 「”pagePath”」之后的文件名内，「.wxml」后缀被隐藏起来了，这是微信开发代码中人性化的一点——帮你节约写代码的时间，无须频繁声明文件后缀。* 「”iconPath”」为未获得显示页面的图标路径，这两个路径可以直接是网络图标。* 「”selectedIconPath”」为当前显示页面高亮图标路径，可以去掉，去掉之后会默认显示为「”iconPath”」的图标。* 「”Text”」为页面标题，也可以去掉，去掉之后纯显示图标，如只去掉其中一个，该位置会被占用。注意：微信的底部菜单最多支持五栏（五个 icons），所以在你设计微信应用的 UI 和基本架构时就要预先考虑好菜单栏的排布。* 根据以上代码规则，我做好了示例项目的基本架构，供你参考：* 「Json」文件配置好后，「card_course」的基本结构入上图所示，不需要的子集都可以暂时删除，缺少的子集则需要你主动新建。删除子集时记得顺带检查一下「app.json」里的相关内容是否已经一并删除。注意：我个人建议你新建一个「wxml」文件的同时，把对应的「js」和「wxss」文件一起新建好，因为微信应用号的配置特点就是解析到一个「wxml」文件时，会同时在同级目录下找到同文件名的「js」和「wxss」文件，所以「js」文件需及时在「app.json」里预先配置好。编写「wxml」时，根据微信应用号提供的接口编码即可，大部分就是以前的「div」，而我们现在就用「view」即可。需要用其它子集时，可以根据微信提供的接口酌情选择。使用「class」名来设置样式，「id」名在这里基本没有什么用处。主要操作数据，不操作「dom」。* 以上是示例项目首页的「wxml」编码。从图中就可以看出，实现一个页面代码量非常少。* 「Wxss」文件是引入的样式文件，你也可以直接在里面写样式，示例中采用的是引入方式：* 修改代码后刷新一次，可以看到未设背景的「view」标签直接变成了粉色。注意：修改「wxml」和「wxss」下的内容后，直接 F5 刷新就能直接看到效果，修改「js」则需点击重启按钮才能看到效果。* 另外，公共样式可以在「app.wxss」里直接引用。* 「Js」文件需要在「app.json」文件的「”page”」里预先配置好。为了项目结构清晰化，我在示例项目中的「index」首页同级目录新建其它四个页面文件，具体如下：经过以上步骤，案例中的五个底部菜单就全部配置完毕了。"}
{"title": "微信小程序开发教程第三章：项目结构以及配置 ", "author": "admin", "pub_time": "2016-10-12 23:22", "article_content": "找到创建的 demo 文件夹，把项目导入到你的编辑器，这里使用的是Sublime Text编辑器。这个时候需要根据自己的项目需求结构进行更改了，项目根目录下面是首页渲染的几个 tabBar 页面，以及 app 的一些配置文件，如名片盒项目的 tabBar 是 3 个切换菜单我们先找到 app.json 文件打开配置好这几个菜单，配置好 tabBar，这个直接把配置文件改成你自己设计的即可。App.json 里面有几个配置项：* Pages：这个是编写的js文件，后缀.js这里不需要使用，配置好正确路径即可正常调用（若调用不到，在重启微信开发者工具会直接报 page 错误）。* Window：配置顶部的一些样式，文档介绍比较详细。* tabBar：底部的几项配置，见名知意。* networkTimeout：暂时没发现用处，建议看文档。根据实际项目需求进行添加与更改。* iconPath和selectedIconPath：底部菜单按钮图片与得到切换点击高亮。* text：可以去掉，全部去掉会发现底部 tabar 高度会减少很多。 Json 文件配置好后，根据项目进行文件创建。Demo：存放的是假数据，这一期的开发工具支持 require，假数据使用的是 .js 文件形式，里面的数据结构 json 一致，把 data 暴露出去即可然后取数据 require 进来即可，这一点使用很方便；Images：图片路径；Page：除 tabar 以外的页面；Servise：服务交付层（与后台联调真实数据时使用）；Wxss：一些公共的 css 文件；看到这里大家发现每个页面都被连带好三个不同的后缀。分别页面，css，js 目前只能依照这样，是微信应用号的一个规范吧。Wxss 文件是引入你写的样式文件，也可以直接在里面写样式。Js 文件需全部配置到 pages 里面才能生效。"}
{"title": "微信小程序开发教程第四章：首页面开发 ", "author": "admin", "pub_time": "2016-10-12 23:26", "article_content": "进行了各种准备与配置后，来到首页开发。首先需要实现首页效果图如下：Template 名片很多，需要用模板、这里需要微信提供的基础组件大致是 input（搜索框）、action-sheet（右边是个底部下拉菜单，需要下拉菜单）、Scroll-view (右边 ABC 跳转)、（这个目前实现还有点问题，正在攻克中）。View是块元素，整个搜索框的一个样式。* 名片夹：由于该项目主打名片功能，故很多地方使用，所以需要把名片以 template 分离出来。* Template：定义一个模板，name 模板的名字其实是个作用域。* Block：循环控制，名片很多，必须用循环出来，和很多操作数据的前端框架循环差不多。* 支持自定义属性 data，这里用作判断线上名片以及线下名片。* View 里面是一些数据引入，里面是支持三目运算符。引入 template 时非常方便，is 和 name 一样，data 是 nameData 传递过来的数据填充。一切都绑定数据为中心点。取到数据具体操作根据你数据结构：这里的数据结构和 json 数据结构一样，这里如要传到页面的话即是```this.setData({nameData:card_list_name.data.cards,timeData:card_list_time.data.cards});```因为页面遍历的是 nameData,timeData可以看下打印出来的数据结构，根据你的结构进行解析与传递。也可以看下这里对数据的一些操作。（这里须根据定义的 json 数据格式来操作的）名片的样式由于很多页面需要使用放在 common.css 里面，这个 common.css 是所有页面都需要用到，一些初始化设置。它是在 app.wxss 里面引用之后才能被映射到全局 APP。搜索框：其中 bindChange 为输入框发生改变事件。微信提供的 bindchange 在支持方面还有小问题，目前是失去焦点才能触发到此事件的发生，待后续完善吧，先实现功能再说。在 index.js 里面写事件```bindInputChange:function(e){//发生搜索事情var self = this; //this绑定，这个this指向微信的提供windowvar Text = e.detail.value.toUpperCase(); //取到输入的内容if(Text==\"\"){ //如果输入为空 一些东西需要显示 否则不显示show_letter = \"block\";}else{show_letter = \"none\";}this.setData({show_letter:show_letter,showSheet:true});var res = nameData; 获取到传递的数据if(data_type==\"name\"){}else if(data_type==\"time\"){res = timeData; };for(var k in res){ //for-in循环取到data里面的cardsvar data = res[k].cards;for(var i = 0;iIf(data[i].userName!=null && data[i].userName.indexOf(Text)!=-1){data[i][\"display\"] = \"block\"; //存在就是赋值显示}else{data[i][\"display\"] = \"none\"; // 不存在赋值不显示}}}}```菜单栏：做到菜单栏，使用微信提供的下拉菜单组件 action-sheet，它被触发的条件在这里。一切以绑定事件为起点：```bindButtonTapSheet:function(e){//调取底部下拉菜单栏}```还是得先布好局才能被调动Js 配置：Data 初始化数据：这里得取非，直接设置 false 调不出来: 调用事件。调出来还得去掉它啊：如下相同即可取消直接上事件即可。（分为菜单栏外部与底部）//好了，就是这么简单。实现效果简单，体验效果确实非常不错。还需要个 loading 效果（暂时没做动画，后期再考虑。）Loading 布局首页的最外层 view根据微信的生命周期```Onload:function(e){this.setData({toastDisplay:”block”,htmlWrapDisplay:”none”})},onShow:function(e){this.setData({toastDisplay:”none”,htmlWrapDisplay:”block”})}```加载条完成。扫一扫，直接调用拍照功能，从这里看到微信提供的拍照 api 使用起来非常快速，只需根据需求配置即可。点击扫一扫之后，在开发者工具即可看到如下效果。做到这里说明下，dom 长度有限制，页面的结构太长，也是无法渲染的，暂且把公司排序暂时先去掉了。左边的 ABC 跳转（还在继续完善中）。这里还有个左滑删除名片功能，微信没有提供这个在移动端很实用的功能真的比较遗憾"}
{"title": "微信小程序开发教程第八章：分组开发与左滑功能实现 ", "author": "admin", "pub_time": "2016-10-12 23:31", "article_content": "整体思路：进入分组管理页面-->点击新建分组新建进入到未分组页面基本操作进入到已建分组里面底部菜单栏操作-->从名片夹中添加进行操作。理清完基本流程我们开始开发。首先整个布局可以先看下，我再一步步讲。静态布号局后，我们开始实现新增分组效果，当然触发它出现的是显示窗口点击取消消失当里面的输入框内容发生改变时 bindinput 事件，大家别使用 bindchange 事件，这里的 bindchange 事件只有当失去焦点时才会被触发。当输入框事件发生时，确定按钮会变成可以点击状态，为空时，addTeam样式数据绑定。里面有表单就使用了 from。创建分组请求交互。创建分组完成，这里可能很多疑问，为什么不使用微信提供的模态框组件来实现，而是自己实现，其实我也很懒，非常想使用自带的模态框组件，但是发现在模态框里面提交表单好像有点麻烦，直接自定义了。接下来创建好的分组支持左滑删除与重命名，今天重点谈下左滑删除的实现方式。首先需要左滑的是被创建好的分组，未分组是写死的，故而不支持的。左滑删除使用了两个事件 bindtouchstart 与 bindtouchmove，这里必须绑定它的 id，这个 id 都是不同的，我这使用的用户创建完成后在后台生成的一个 id 号，之后我再 block 出来使用在这里，这个 id 都是唯一的，不能是相同的 id。样式布局，父元素是绝对定位，子元素删除是相对定位，鉴于动画效果，我这加了 css3 的动画效果，使滑动带点动画效果。现在我们来看事件构成：Bindtap 点击之后直接是跳转页面。左滑从触摸事件开始，当然需使用的参数在外面最好先定义一下：bindtouchStart 发生后，会执行 bindtouchmove 事件，在这里我们可以判断是否左右滑动：* Var dataId = e.currentTarget.id //获取到前面唯一的id；If(key){ //用户左滑距离很长时会发生多次左滑事件，这里定义一个开关发生第一次之后就关闭它；* Touch是获取触摸点的一些数据，touches 是一个触摸点的数组，每个触摸点包括以下属性：* pageX,pageY：距离文档左上角的距离，文档的左上角为原点 ，横向为 X 轴，纵向为 Y 轴；* clientX,clientY：距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴；* screenX,screenY：距离屏幕左上角的距离，屏幕左上角为原点，横向为X轴，纵向为Y轴；这里使用 clientX,clientY 即可。我们在 bindtouchstart 时记录到开始的点，在 bindtouchmove 记录到触摸结束的点，如果 X 轴滑动大于 Y 轴的，再如果结束点-开始点小于一个数值（这个数组可以自己设置，鉴于灵敏度，我这设置的很小），右滑也是同理。判断到左滑与右滑事件后，我们就需要对当前组件绑定数据了，数据从那里来？可以看下我这数组一个来历，以及怎么被左滑事件里面获取到（我这数据是一个数组，需要在 wxml 里面 block 的）。这时候取到需要的数组，循环出来后，我进行对比，如果数据的 id== 当前被事件操作的 id，那么我给改数组再添加一个 right 向右偏移 15%，否则其他都不偏移，右滑同理，直接全部设置为 0。最后把数据到绑定到页面上来。OK，左滑效果实现。如果出现全部被滚动了，记得在外层加上，X 轴关闭即可。这时候你点击左滑会出现点透效果，官方文档提供给我们一个 catch，不冒泡点击事件，即可完美解决。点击删除事件弹出模态框供用户确定是否删除。这里你点击取消时还要记得把左滑删除按钮去掉可能用户体验会好点。一定记得在 data({modalHidden:true})不然会出现一加载页面即出现了模态框。点击未分组按钮进入到未分组名片列表页面。这个布局完全是 copy 首页过来的，后面只是数据接口有变而已，大家有兴趣可以回过去看下前面的。点击多选，会出现多选框和下面的一些操作按钮。都是些数据绑定，显示与隐藏类的实现比较简单。多选我们直接给 checked 设置 Boole 开关。选择好名片后点击设置分组会弹出新建好的分组列表供用户确定设置到那个分组里面（这里由于后台接口方面还在完善，不继续往下写了）。用户已建分组点击进去的是点击顶部菜单按钮出现下拉菜单栏，这里直接使用微信提供的组件。最后点击从名片夹中添加进入到以下页面：整个布局基本还是和首页面差不多，这里不再多讲，顶部菜单直接多选绑定数据即可。牵扯到表单类的基本全都是 from 表单提交事件。除小部分接口方面欠缺外，写到这里其实分组前端方面效果基本实现。"}
{"title": "微信小程序试用报告：前端源码逻辑和工作流 ", "author": "天下雪", "pub_time": "2016-10-13 16:49", "article_content": "文件基本结构：  　  先看入口app.js，app(obj)注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。其他文件可以通过全局方法getApp()获取app实例，进而直接调用它的属性或方法，例如（getApp().globalData）//app.jsApp({  onLaunch: function () {    //调用API从本地缓存中获取数据    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)  },  getUserInfo:function(cb){    var that = this    if(this.globalData.userInfo){      typeof cb == \"function\" && cb(this.globalData.userInfo)    }else{      //调用登录接口      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {              that.globalData.userInfo = res.userInfo              typeof cb == \"function\" && cb(that.globalData.userInfo)            }          })        }      })    }  },  globalData:{    userInfo:null  }})  　  我理解app.js为入口初始化文件，也是提供全局API拓展的地方。下边分析下自带的几个方法和属性  　  onLaunch钩子函数会在小程序初始化完成后会自动执行一次，然后在小程序生命周期里如果你不主动调用onLaunch，它就不会在执行。  　  var logs = wx.getStorageSync('logs') || []获取本地缓存中的logs属性，如果值为空，那么设置logs=[] 与HTML5中的localStorage作用相似logs.unshift(Date.now()) 当前登录时间添加到数组中  　  wx.setStorageSync('logs', logs) 将数据存入本地缓存，因为wx为全局对象，所以可以在其他文件中直接调用wx.getStorageSync('logs')获取本地缓存数据  　  getUserInfo函数，顾名思义就是获取登录用户信息，相当于此函数提供了获取用户信息的接口，其他页面不调用自然不会执行。其他页面通过getApp().getUserInfo(function(userinfo){console.log(userinfo);})这种方式调用该方法，获取用户信息。getUserInfo:function(cb){//参数为cb,类型为函数    var that = this    if(this.globalData.userInfo){//用户信息不为空      typeof cb == \"function\" && cb(this.globalData.userInfo)//如果参数cb的类型为函数，那么执行cb,获取用户信息；    }else{//如果用户信息为空，也就是说第一次调用getUserInfo，会调用用户登录接口。      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {　　　　　　　　 console.log(res)              that.globalData.userInfo = res.userInfo//把用户信息赋给globalData，如果再次调用getUserInfo函数的时候，不需要调用登录接口              typeof cb == \"function\" && cb(that.globalData.userInfo)//如果参数cb类型为函数，执行cb,获取用户信息            }          })        }      })    }  }   　  globalData对象用来存储全局数据，在其他地方调用  　  然后简要分析下app.json文件,该文件作用是对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等、  　  最重要的是pages属性，必填，为数组，数组内的元素为字符串性文件路径，指定小程序由哪些页面组成，第一项必须是小程序初始页面。 {  \"pages\":[    \"pages/index/index\",    \"pages/logs/logs\"  ],  \"window\":{    \"backgroundTextStyle\":\"light\",    \"navigationBarBackgroundColor\": \"#fff\",    \"navigationBarTitleText\": \"WeChat\",    \"navigationBarTextStyle\":\"black\"  }}  　  然后来看下项目index和logs文件夹。微信小程序初始项目把每个页面相关的js、wxss、wxml放在各自的文件，这样看起来结构清晰明朗很多。  　  先来看index文件夹，即小程序初始页面。index文件夹下为index.js、index.wxml、index.wxss三个小文件。小程序把js、css、html代码分离开来，放在独自的文件里，各司其职。js和样式表文件名必须与当前文件夹的wxml文件名保持一致，这样才能保证js和样式表的效果能够在页面中显现出来。我很欣赏这样的设计理念，整齐划一，职责明确，减轻代码设计复杂度。  　  index.wxml，这就是常见的模板文件，数据驱动，有过前端mvc、mvvm项目开发的对这个一定不会陌生，毕竟这是基于react开发的。　　<!--index.wxml--><view class=\"container\">//视图容器  <view  bindtap=\"bindViewTap\" class=\"userinfo\">//bindtap为容器绑定点击触摸事件，在触摸离开时触发bindViewTap事件处理函数，bindViewTap通过index.js page()设置添加    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>//大双括号的变量来自于index.js的data对象解析成对应的值，而且是实时的    <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>  </view>  <view class=\"usermotto\">    <text class=\"user-motto\">{{motto}}</text>  </view></view>  　  index.js，与reaact用法几无二异，换汤不换药。page()来注册一个页面。接受一个 OBJECT 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。var app = getApp() // 获取入口文件app的应用实例Page({  data: {    motto: 'Hello World',    userInfo: {}  },  //自定义事件处理函数，点击.userinfo的容易触发此函数  bindViewTap: function() {    wx.navigateTo({//全局对象wx的跳转页面方法      url: '../logs/logs'    })  },  onLoad: function () {//发生页面加载时，自动触发该生命周期函数    console.log('onLoad')    var that = this    //调用应用实例的方法获取全局数据    app.getUserInfo(function(userInfo){      //更新数据，页面自动渲染      that.setData({        userInfo:userInfo      })    })  }})  　  index.wxss文件只渲染当前所属页面，会覆盖全局app.wxss同一样式。  　  再分析下logs日志文件夹，logs文件夹下为logs.wxml、logs.js、logs.wxss、logs.json，同理保证同名，才能完成效果渲染。  　  logs.wxml文件<!--logs.wxml--><view class=\"container log-list\">  <block wx:for=\"{{logs}}\" wx:for-item=\"log\">//block容器作用，无其他实际含义。wx:for作用：遍历logs数组，遍历多少次，block块就会复制多少次，for-item等同于为<br>遍历元素起一个变量名，方便引用。<br>    <text class=\"log-item\">{{index + 1}}. {{log}}</text>  </block></view>  　　logs.js 文件//logs.jsvar util = require('../../utils/util.js') //util.js相当于一个函数库，我们可以在这个文件内自定义扩展和封装一些常用的函数和方法Page({  data: {    logs: []  },  onLoad: function () {    this.setData({      logs: (wx.getStorageSync('logs') || []).map(function (log) {//通过wx.getStorageSync获取本地缓存的logs日志数据        return util.formatTime(new Date(log))//日期格式化      })    })  }})　　logs.json文件{    \"navigationBarTitleText\": \"查看启动日志\"   //当前页面配置文件，设置window当前页面顶部导航栏标题等相关内容}　　基本页面结构和逻辑就这么简单，暴露给我们的没有一点令人费解的东西。"}
{"title": "微信小程序教程：app配置指南 ", "author": "天下雪", "pub_time": "2016-10-13 17:20", "article_content": "//app.json页面 {//页面注册，有几个页面都要在pages里面注册\"pages\":[\"pages/index/index\",\"pages/logs/logs\",\"pages/main/main\",\"pages/main1/main1\",\"pages/main2/main2\",\"pages/main3/main3\",],//上导航配置及app背景颜色设置\"window\":{//是否开启下拉刷新\"enablePullDownRefresh\":true,//窗口背景颜色，在上拉刷新，下拉刷新，navigate切换页面时可以看见\"backgroundColor\":\"#eee\",//下拉背景字体、loading 图的样式，仅支持 dark/light,（string形式）\"backgroundTextStyle\":\"light\",//上导航条背景颜色\"navigationBarBackgroundColor\": \"orange\",//上导航标题文字\"navigationBarTitleText\": \"上导航标题文字\",\"navigationBarTextStyle\":\"white\" //上导航标题字体颜色，仅支持white和black },//底部导航配置\"tabBar\": {\"color\": \"#a9b7b7\",//导航字体默认颜色\"selectedColor\": \"#eb4f38\",//导航字体选中时颜色\"borderStyle\": \"black\", //上border颜色，仅支持 black/white（string形式）\"backgroundColor\": \"rgba(0,0,0,0.4)\",//底部导航背景色\"list\": [ //导航列表2-5个{\"pagePath\": \"pages/index1/index1\", //每个导航的网页对应的路径\"text\": \"首页\", //标题\"iconPath\": \"images/wechat.png\", //默认小图标路径\"selectedIconPath\": \"images/wechatHL.png\" //选中时的小图标路径},{\"pagePath\": \"pages/index2/index2\",\"text\": \"日记\",\"iconPath\": \"images/pause.png\",\"selectedIconPath\": \"images/play.png\"},{\"pagePath\": \"pages/index3/index3\",\"text\": \"指南\",\"iconPath\": \"images/pause.png\",\"selectedIconPath\": \"images/play.png\"},]},//网络请求超时时间\"networkTimeout\": {\"request\": 10000,\"downloadFile\": 9000,\"uploadFile\":8000,\"connectSocket\":7000},//是否开启debug模式\"debug\": true}//说明：根据官方文档，上述color和bg-color类型为HexColor即16进制类型，（指定仅支持 black/white，string形式的除外），但实测rbg,rgba和red这些类型目前也支持，但是建议大家还是按文档要求来设置为16进制类型即: #ffffff 类型；////使用时仅需将文件复制下来，根据需求改动即可；////app.json为标准的json文件，所以不能存在有注释，使用的时候需把注释去掉；   //app.js页面App({//当小程序初始化完成时，会触发 onLaunch（全局只触发一次）onLaunch: function () {//onLaunch时调用API从本地缓存中获取数据var logs = wx.getStorageSync('logs') || []logs.unshift(Date.now())wx.setStorageSync('logs', logs)},//获取用户登录信息getUserInfo:function(cb){var that = thisif(this.globalData.userInfo){typeof cb == \"function\" && cb(this.globalData.userInfo)}else{//调用登录接口wx.login({success: function () {wx.getUserInfo({success: function (res) {that.globalData.userInfo = res.userInfotypeof cb == \"function\" && cb(that.globalData.userInfo)}})}})}},//获取后台数据onshow:function(){wx.request({url: 'test.php',data: {x: 'xxx',y: 'yyy'},header: {'Content-Type': 'application/json'},success: function(res) {console.log(res.data)}})},//设置全局数据//本页面通过this.globalData即可取得数据 globalData:{userInfo:null}//其他页面可以通过getApp()获取到小程序实例 //其他页面可以通过getApp().globalData.xxx获取到全局数据})  //app.wxss页面.common {height: 100%;display: flex;flex-direction: column;align-items: center;justify-content: space-between;padding: 200rpx 0;box-sizing: border-box;}//仅支持:类:.commonID:#common标签：common多个标签：common1,common2 伪类::after伪类::before//不支持层级，如.common > view 或者.common view//引入新的单位rpx:rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。及新的rem:rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。//写在app.wxss里面的样式将被设置为公有的，对于其他页面都是可用的"}
{"title": "微信小程序官方文档里看不到的小Tips ", "author": "天下雪", "pub_time": "2016-10-13 17:26", "article_content": "1. WXML(HTML)　　1.1 小程序的WXML没有HTML的宽容度?那么高，单标签必需是 /> 结尾的。不然会报错。　　1.2 官方推荐使用的基础标签是块标签，给了作为文本标签，但是使用其他标签比如div也是可以使用的，并且都是inline标签。并且wxml的parser会把标签上的不在白名单上的属性都去掉，class, id, data 这些应该都在白名单内，但是href什么的是不会有的，所以如果你用传统的html的标签构建页面理论上也是可行的，不过这些都是inline标签，需要自行设定display。　　1.3 scroll-view 的scroll-top, scroll-left 是可以修改scroll-view的滚动位置的。但是用户自己滚动了之后小程序并不会去改变 scroll-top, scroll-left 的赋值（并不是双向同步的）。如果这时使用setData去修改的话，scroll-top, scroll-left 的赋值和上一次的值相同，小程序是不会运用这个修改的，所以表现就是设置没有生效。这时只能先设置一个其他值，再设置回去（这里还可以体现setData方法是同步的）。scroll-view 获取scroll位置，只能通过bindscroll的回调函数获取，所以需要取scroll位置的请自行预存好。scroll-view 还是有webview的 scroll 的臭毛病，在居顶位置如果第一个动作是向下滚动的，会导致之后手怎么滑都滚不动，设置scroll-top 不为0，设个1就好了。　　1.4 input 目前只支持文字居左，其他都是不行的（模拟器可以）。如果你做表单，建议把input等表单元素都放在form中，from触发submit时会返回内部所有表单元素的name-value。不然只能绑定所有表单元素的 change 事情来获取，甚是麻烦。　　1.5 只有  checkbox-group 有 change 事件，单个的checkbox是没有的，如果你只有一个checkbox， 觉得外面套一个checkbox-group麻烦又不美观的话，可以用 switch type=\"checkbox\" 代替。　　1.6 map 组建目前直接在app第一个页面加载会出现加载失败。需要在onLoad之后再加在。可以先wx:if=\"false\" 然后onLoad的之后改成 true 就行了。　　1.7 map, canvas 像是在webview上面盖一个native组件的感觉。它们是没法被overflow 以及 上面盖元素的，你可以认为z-index写多高都没法在他上面。所以不建议在页面上做弹层和蒙层。canvas 无法放在scroll-view中滚动会定位在初始位置，如果你给canvas设置背景颜色的话，你会发现背景色块跟着滚了，图没滚。2. WXSS(CSS)　　2.1 WXSS 和 CSS很像，基本所有的CSS都支持，小程序还提供了 rpx 这个单位。一屏幕宽是750rpx。推荐使用这个来作为布局。不过有一些细小的差别我下面会列出　　2.2 WXSS不支持 大括号嵌套（{{}} ）。所以key-frames，CSS animation 就不可用了，不过transition 是可用的。　　2.3 目前测试引入字体也是不可用的，前面WXML中提到的内容看SVG也是没法使用的。所以icon目前只能用图的方式做了。　　2.4 WXSS中是不能引入本地资源的, 只能使用线上资源（模拟器是可以，但是别信），可以使用base64。　　2.5 WXSS的 rule 是不支持集联的。所以不能 body .main {background:#000;} 这么写。所以写起来还是比较费劲的。每个class都得很长，不然怕重名。不过支持 li.current {color: red;} 这样的写法，支持after， before伪类，但是不支持 first-child last-child nth-child 这类伪类。　　2.6 app.wxss 和每个 page 的wxss 的覆盖关系是: 如果有同名 rule 的话，page 会覆盖 app 的，不是merge是覆盖。　　3. JS　　3.1 JS 的运行环境和view的运行环境是隔离的。JS只能通过事件获取时机和setData方法修改数据来改变view。　　3.2 JS 目前有个很大的问题是无法获取到页面px级的宽度高度, 所有事件回调的单位都是px级的而不是rpx的，但是又不知道当前rpx，px的转换关系。比如过你用canvas画图。你都不知道边界在哪里，这个很蛋疼。　　3.3 上面有说过 setData方法如果上一个值和下一个值相同时，是不会触发view修改的（见1.3）　　3.4 使用 navigate 跳转的时候可以使用queryString的方式跟在相对地址上，onLoad事件会在入参中传入（会转化成object），但是 navigate back的时候没有一个官方给出的数据通讯机制。可以使用getApp() 获取到全局对象，给上面加点东西，自行实现。navigate 最多5个什么的就不说了。　　3.5 canvas getActions被调用之后，actions是会被清空的。即连续调用两次getActions，第二次是空数组。　　3.6 开发者工具是nw写的，我就看了看裙底的源码，开发者工具中WXML确实是有parser再拼装的过程的。但是并不能说明小工具是native的，从css的支持力度到webview的一些bug相似度来看，我还是觉得像webview，但是组件比如map，canvas什么的用的是原生view，然后盖在webview上的感觉。但是不管怎么说 auto-focus 能自动呼出键盘就已经是个很大的好评了。"}
{"title": "微信小程序开发准备：必修课程推荐 ", "author": "天下雪", "pub_time": "2016-10-13 18:06", "article_content": "今天，我们都想学前端！！！1、HTML基础入门带你从最最基础的知识开始，认识 HTML，通过 HTML 文件的结构、常用的标签、元素、属性、样式、超文本等内容让大家对 HTML 有一个完整的认识！2、HTML5基础入门HTML5有很多新特性，这个教程就带你入门了解HTML5的一些新特性。我们知道啊：html是结构 （网页一个架子，显示内容）、css是样式（添加背景图片，边框等来修饰）、js是行为（用户操作，华丽的动画）所以呢，光学HTML肯定是不够滴，还需要学习css和js才行啊。3、CSS速成教程这个教程啊，就是带你入门学习CSS知识的，让你对页面的布局、字体、颜色、背景和其它效果实现更加精确的控制。4、Javascript基础这个教程呢，是教你学习 JavaScript 的语法及事件、对象、DOM 等基础知识，可以让网页按照你的想法“动”起来。以上呢，是基础，基础打牢了才能动手开发呀，但是，光有理论基础是不够的，还需要在实际开发“小程序”之前，做一些项目，练练手，把所学到的基础知识加以运用！5、HTML5两步实现拼图游戏这个项目就是教你使用HTML5和css3实现的九宫格拼图游戏。做出来是这样的：6、SCSS（SASS）画小黄人这个项目呢，教你通过 SCSS（SASS）画一个会眨眼睛的小黄人，主要学习 CSS3。画出来是这样的：7、JavaScript实现玫瑰花这个项目呢，主要是教你用JavaScript语言实现一朵漂亮的玫瑰花。实现出来是这样的："}
{"title": "尝试解决微信小程序分页最后setData数据太大限制的问题 ", "author": "Rolan", "pub_time": "2018-10-17 00:43", "article_content": "前些天，突然接到用户的大量反馈，我们的小程序频繁出现闪退，崩溃的现象。如图，于是马上着手追查问题，首先确定了导致闪退的页面。是在一个有长列表的页面，当上拉加载更多，翻页翻多几页的时候就导致闪退了。经过重重排查（时间问题，这里就不详细描述排查的方法了，大多数用的都是缩小范围排除法啦），最后终于确定了问题所在，原来是在列表中，同事最近新加上的css3动画所致，这里的列表是循环渲染的一个组件，组件中的一个弹窗的弹出和收起，使用动画，但是这里没有加上wx:if,导致了循环渲染该动画，所以翻页翻着翻着就挂掉了。 确定了问题，就很好办了，加上条件判断，只有需要的时候，才渲染弹出弹窗。真机调试，暴力狂刷数据，发现闪退的现象不再出现了，闪退问题解决，然而高兴不到三分钟，又出问题了，发现翻页到十几页的时候，再也刷不动后面的数据了，明明是还有更多数据的。再在开发工具上看查看数据，结果控制台报了这么一个错在真机上为：这是什么问题呢，查看官方文档，发现是有这样的限制的回顾我们的代码，这里的分页加载数据，上拉加载，数据是放在一个for循环里去加载，数据源是一个数组对象。在加载下一页数据时，将下一页的数据拼到当前数组后面。这里是常规的做法。可以看看代码：这里可以看到，每次获取新的一页，都要重新setData新的数组，仔细想想，当这个数组到后面越来越大的时候，很容易就超出了单次设置数据超过1024kb的限制了。那么怎么解决这个问题呢，这里官方文档里面其实有提到一个注意点，既然这里是支持改变数组的某一项，那么分页的问题，可以改变为一个二维数组，还是直接看代码吧。这里的方法则暂时摆脱了单次设置数据多大的问题。当然，要是单页的数据过多，还是会出现问题的。最合适的还是对数据结构进行精简，前端不必要的数据，可以不传过来前端。写在最后，这次第一次写类似的分享，描述还是有些不清晰，以后可以多尝试这样的总结吧。"}
{"title": "微信小程序国密算法实现库sm-crypto ", "author": "Rolan", "pub_time": "2018-10-29 00:43", "article_content": "国密算法是国家密码局制定标准的一系列算法，主要有SM1，SM2，SM3，SM4，密钥长度和分组长度均为128位。其中：SM1 为对称加密。其加密强度与AES相当。该算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。SM2为非对称加密，基于ECC。该算法已公开。由于该算法基于ECC，故其签名速度与秘钥生成速度都快于RSA。ECC 256位（SM2采用的就是ECC 256位的一种）安全强度比RSA 2048位高，但运算速度快于RSA。SM3 消息摘要。可以用MD5作为对比理解。该算法已公开。校验结果为256位。SM4 无线局域网标准的分组数据算法。对称加密，密钥长度和分组长度均为128位。sm-crypto可以在微信小程序中实现SM2、SM3、SM4国密算法。使用安装 sm-crypto从小程序基础库版本 2.2.1 或以上、及开发者工具 1.02.1808300 或以上开始，小程序支持使用 npm 安装第三方包。npm install --save miniprogram-sm-crypto\r\nsm2获取密钥对const sm2 = require('miniprogram-sm-crypto').sm2;\r\n\r\nlet keypair = sm2.generateKeyPairHex();\r\n\r\npublicKey = keypair.publicKey; // 公钥\r\nprivateKey = keypair.privateKey; // 私钥\r\n加密解密const sm2 = require('miniprogram-sm-crypto').sm2;\r\nconst cipherMode = 1; // 1 - C1C3C2，0 - C1C2C3，默认为1\r\n\r\nlet encryptData = sm2.doEncrypt(msgString, publicKey, cipherMode); // 加密结果\r\nlet decryptData = sm2.doDecrypt(encryptData, privateKey, cipherMode); // 解密结果\r\n签名验签const sm2 = require('miniprogram-sm-crypto').sm2;\r\n\r\n// 纯签名 + 生成椭圆曲线点\r\nlet sigValueHex = sm2.doSignature(msg, privateKey); // 签名\r\nlet verifyResult = sm2.doVerifySignature(msg, sigValueHex, publicKey); // 验签结果\r\n\r\n// 纯签名\r\nlet sigValueHex2 = sm2.doSignature(msg, privateKey, {\r\n    pointPool: [sm2.getPoint(), sm2.getPoint(), sm2.getPoint(), sm2.getPoint()], // 传入事先已生成好的椭圆曲线点，可加快签名速度\r\n}); // 签名\r\nlet verifyResult2 = sm2.doVerifySignature(msg, sigValueHex2, publicKey); // 验签结果\r\n\r\n// 纯签名 + 生成椭圆曲线点 + der编解码\r\nlet sigValueHex3 = sm2.doSignature(msg, privateKey, {\r\n    der: true,\r\n}); // 签名\r\nlet verifyResult3 = sm2.doVerifySignature(msg, sigValueHex3, publicKey, {\r\n    der: true,\r\n}); // 验签结果\r\n\r\n// 纯签名 + 生成椭圆曲线点 + sm3杂凑\r\nlet sigValueHex4 = sm2.doSignature(msg, privateKey, {\r\n    hash: true,\r\n}); // 签名\r\nlet verifyResult4 = sm2.doVerifySignature(msg, sigValueHex4, publicKey, {\r\n    hash: true,\r\n}); // 验签结果\r\n\r\n// 纯签名 + 生成椭圆曲线点 + sm3杂凑（不做公钥推导）\r\nlet sigValueHex5 = sm2.doSignature(msg, privateKey, {\r\n    hash: true,\r\n    publicKey, // 传入公钥的话，可以去掉sm3杂凑中推导公钥的过程，速度会比纯签名 + 生成椭圆曲线点 + sm3杂凑快\r\n});\r\nlet verifyResult5 = sm2.doVerifySignature(msg, sigValueHex5, publicKey, {\r\n    hash: true,\r\n    publicKey,\r\n});\r\n获取椭圆曲线点const sm2 = require('miniprogram-sm-crypto').sm2;\r\n\r\nlet poin = sm2.getPoint(); // 获取一个椭圆曲线点，可在sm2签名时传入\r\nsm3const sm3 = require('miniprogram-sm-crypto').sm3;\r\n\r\nlet hashData = sm3('abc'); // 杂凑\r\nsm4加密const sm4 = require('miniprogram-sm-crypto').sm4;\r\nconst key = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10];\r\n\r\nlet encryptData = sm4.encrypt([0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10], key); // 加密\r\n解密const sm4 = require('miniprogram-sm-crypto').sm4;\r\nconst key = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10];\r\n\r\nlet decryptData = sm4.decrypt([0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e, 0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46], key); // 解密\r\n\r\n其他sm-crypto项目地址：https://github.com/wechat-min..."}
{"title": "微信小程序中遇到的多规格问题(一) ", "author": "Rolan", "pub_time": "2018-11-6 00:25", "article_content": "1.效果图2.文件及部分思路index.wxml文件<view class=\"multipleStandard\" bindtap=\"standardSelect\">\r\n  <view class=\"standard\">\r\n    规格:\r\n    <text class=\"item\">颜色</text>    \r\n    <text class=\"item\">颜色</text>    \r\n    <text class=\"item\">颜色</text>    \r\n  </view>\r\n  <image src=\"/images/arrows.png\" class=\"arrows\"></image>\r\n</view>\r\n<view style=\"background:rgb(207, 224, 232); height: 300rpx;margin-top: 50rpx;\"></view>\r\n<view animation=\"{{animationData}}\" class=\"selectStandard\" catchtouchmove=\"noMove\">\r\n  <view class=\"tophead\">\r\n    <view class=\"topimg\">\r\n      <image src=\"{{goods.original_img}}\"></image>\r\n    </view>\r\n    <view class=\"topright\">\r\n      <view class=\"selectClose\">\r\n        <view style=\"color:#ef5426;\">{{standardObject.price}}</view>\r\n        <image src=\"/images/close.png\" bindtap=\"handleClose\"></image>\r\n      </view>\r\n      <view style=\"margin:10rpx 0;color:#999999;\">库存:{{standardObject.store_count}}</view>\r\n      <view>规格: {{mergeStandard}}</view>\r\n    </view>\r\n  </view>\r\n  <view class=\"standard\" wx:for=\"{{commodityStandard}}\" wx:key=\"{{standardIndex}}\" wx:for-index=\"standardIndex\">\r\n    <view class=\"standardTitle\">{{item[0].spec_name}}</view>\r\n    <view class=\"standardItem\">\r\n      <block wx:for=\"{{item}}\" wx:key=\"{{item.item_id}}\">\r\n        <view class=\"selectItem {{isSelect[item.isClick]}}\" bindtap=\"handleStandardClick\" data-standard-index=\"{{standardIndex}}\" data-index=\"{{index}}\" data-id=\"{{item.item_id}}\">{{item.item}}</view>        \r\n      </block>\r\n    </view>\r\n    <view style=\"height:1px; width:100%;background-color:#eeeeee;\"></view>\r\n  </view>\r\n  <view class=\"selectCount\">\r\n    <view class=\"countname\">数量</view>\r\n    <view class=\"countright\">\r\n      <i-input-number value=\"{{commodityNum}}\" min=\"1\" max=\"{{store_count}}\" bindchange=\"handleCommodityNumber\" />\r\n    </view>\r\n  </view>\r\n  <view class=\"submitBtn\" bindtap=\"submitSelected\">\r\n    确定\r\n  </view>\r\n</view>\r\n<i-message id=\"message\" />index.wxss文件.multipleStandard{\r\n  display: flex;\r\n  margin-top: 20rpx;\r\n  padding: 15rpx 20rpx;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  box-shadow: 0 0 10px #ccc;\r\n}\r\n.item{\r\n  margin-right: 15rpx;\r\n}\r\n.arrows{\r\n  width: 16rpx;\r\n  height: 27rpx;\r\n}\r\n\r\n/* 规格弹窗 */\r\n.selectStandard {\r\n  width: 100%;\r\n  height: 1000rpx;\r\n  background-color: #fff;\r\n  position: fixed;\r\n  z-index: 333;\r\n  bottom: -600px;\r\n  border-top-left-radius: 20rpx;\r\n  border-top-right-radius: 20rpx;\r\n}\r\n\r\n/* 头部选中的规格 */\r\n.tophead {\r\n  display: flex;\r\n  margin: 30rpx 3%;\r\n  width: 94%;\r\n  align-items: center;\r\n  text-align: center;\r\n}\r\n\r\n.topimg {\r\n  width: 200rpx;\r\n  height: 200rpx;\r\n}\r\n\r\n.topimg image {\r\n  width: 100%;\r\n  height: 100%;\r\n  border-radius: 20rpx;\r\n  background-color: red;\r\n}\r\n\r\n.topright {\r\n  margin-left: 30rpx;\r\n  font-size: 28rpx;\r\n  text-align: left;\r\n  width: 66%;\r\n}\r\n/* 关闭按钮 */\r\n.selectClose {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n}\r\n\r\n.selectClose image {\r\n  width: 30rpx;\r\n  height: 30rpx;\r\n}\r\n\r\n.standard {\r\n  margin: 0 3%;\r\n  width: 94%;\r\n  font-size: 28rpx;\r\n}\r\n\r\n.standardTitle {\r\n  font-size: 30rpx;\r\n  margin-top: 20rpx;\r\n}\r\n.standardItem {\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n    width: 100%;\r\n}\r\n.selectItem {\r\n  border: solid 1px #666;\r\n  margin: 20rpx;\r\n  padding: 5rpx 23rpx;\r\n  border-radius: 16rpx;\r\n}\r\n/* 规格选中时样式 */\r\n.standardSelected{\r\n  color: #fff;\r\n  background: #f26740;\r\n    background-color:#fe6732;\r\n    border:solid 1px #fe6732;\r\n    margin:20rpx;\r\n    padding:5rpx 23rpx;\r\n    border-radius:16rpx;\r\n}\r\n.standardNormal{\r\n  color: #000;\r\n}\r\n.standardDisable{\r\n  color: #eee;\r\n}\r\n\r\n/* 选择的数量 */\r\n.selectCount {\r\n  margin: 30rpx 3%;\r\n  width: 94%;\r\n  font-size: 28rpx;\r\n}\r\n.countright {\r\n  float: right;\r\n  display: flex;\r\n  text-align: center;\r\n  align-items: center;\r\n}\r\n\r\n.countname {\r\n  margin-bottom: 20rpx;\r\n  font-size: 30rpx;\r\n}\r\n\r\n.submitBtn {\r\n  position: absolute;\r\n  bottom: 0;\r\n  width: 70%;\r\n  margin: 0 15% 20rpx 15%;\r\n  text-align: center;\r\n  z-index: 66;\r\n  height: 80rpx;\r\n  background-color: #fe6732;\r\n  border-radius: 40rpx;\r\n  color: white;\r\n  font-size: 32rpx;\r\n  line-height: 80rpx;\r\n}index.js文件const {\r\n    $Message\r\n} = require('../../component/iview/base/index');\r\nPage({\r\n  data: {\r\n    animationData: {},\r\n    isSelect: [\"standardNormal\", \"standardSelected\", \"standardDisable\"],  /* 用于区别当前的规格是否选中 */\r\n    goods: {\r\n      goods_name: \"男鞋\",\r\n      store_count: 158,\r\n      cost_price: \"10.00\",\r\n      original_img: \"/images/commodity.jpg\",     \r\n    },\r\n    commodityStandard: [\r\n      [\r\n        {\r\n          spec_name: \"颜色\",\r\n          item_id: 535385,\r\n          item: \"白色\",\r\n          src: \"\",\r\n          isClick: 0\r\n        },\r\n        {\r\n          spec_name: \"颜色\",\r\n          item_id: 535386,\r\n          item: \"黑色\",\r\n          src: \"\",\r\n          isClick: 0\r\n        }\r\n      ],\r\n      [\r\n        {\r\n          spec_name: \"尺寸\",\r\n          item_id: 535692,\r\n          item: \"170\",\r\n          src: \"\",\r\n          isClick: 0\r\n        },\r\n        {\r\n          spec_name: \"尺寸\",\r\n          item_id: 535693,\r\n          item: \"180\",\r\n          src: \"\",\r\n          isClick: 0\r\n        }\r\n      ],\r\n      [\r\n        {\r\n          spec_name: \"重量\",\r\n          item_id: 552569,\r\n          item: \"11\",\r\n          src: \"\",\r\n          isClick: 0\r\n        },\r\n        {\r\n          spec_name: \"重量\",\r\n          item_id: 552570,\r\n          item: \"15\",\r\n          src: \"\",\r\n          isClick: 0\r\n        }\r\n      ]\r\n    ],\r\n    standardInfo: [\r\n      {\r\n        id: 1018269,\r\n        key: \"535385_535692_552569\",\r\n        price: \"10.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018270,\r\n        key: \"535385_535692_552570\",\r\n        price: \"20.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018271,\r\n        key: \"535385_535693_552569\",\r\n        price: \"30.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018272,\r\n        key: \"535385_535693_552570\",\r\n        price: \"40.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018273,\r\n        key: \"535386_535692_552569\",\r\n        price: \"50.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018274,\r\n        key: \"535386_535692_552570\",\r\n        price: \"60.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018275,\r\n        key: \"535386_535693_552569\",\r\n        price: \"70.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 20\r\n      },\r\n      {\r\n        id: 1018276,\r\n        key: \"535386_535693_552570\",\r\n        price: \"80.00\",\r\n        productprice: \"0.00\",\r\n        store_count: 18\r\n      }\r\n    ],\r\n    selectedId: [],\r\n    selectedStandard: [],\r\n    standardObject: {},\r\n    commodityNum: 1,\r\n  },\r\n  onLoad: function (options) {\r\n    let goods = this.data.goods;\r\n    let standardObject = this.data.standardObject;\r\n    standardObject.price = goods.cost_price;\r\n    standardObject.store_count = goods.store_count;\r\n        let store_count = goods.store_count;\r\n    this.setData({\r\n      standardObject,\r\n            store_count\r\n    })\r\n  },\r\n  /* 规格选择 */\r\n  standardSelect() {\r\n    var that = this\r\n    var animal1 = wx.createAnimation({\r\n      timingFunction: 'ease-in'\r\n    }).translate(0, -600).step({\r\n      duration: 300\r\n    })\r\n    that.setData({\r\n      animationData: animal1.export(),\r\n    })\r\n  },\r\n  /* 关闭规格选择 */\r\n  handleClose() {\r\n    var that = this\r\n    var animal1 = wx.createAnimation({\r\n      timingFunction: 'ease-in'\r\n    }).translate(0, 600).step({\r\n      duration: 300\r\n    })\r\n    that.setData({\r\n      animationData: animal1.export()\r\n    })\r\n  },\r\n  /* 每个规格的点击事件 */\r\n  handleStandardClick(e) {\r\n    let id = e.currentTarget.dataset.id;\r\n    // 总规格名称索引\r\n    let standardIndex = e.currentTarget.dataset.standardIndex;\r\n    // 单个规格名称索引\r\n    let index = e.currentTarget.dataset.index;\r\n    let commodityStandard = this.data.commodityStandard;\r\n    let standardLength = commodityStandard[standardIndex].length;\r\n\r\n    // 用于存储规格的id\r\n    let selectedId = this.data.selectedId;\r\n    // 用总规格名称索引来存储每个选中的规格id\r\n    selectedId[standardIndex] = id;\r\n\r\n    let selectedStandard = this.data.selectedStandard;\r\n\r\n    // 在点击的时候，只需要对点击的这个规格所在的数组进行循环\r\n    for (let i = 0; i < standardLength; i++) {\r\n      // 找到对应的单个规格索引，并设置isClick及单个规格名称\r\n      if (index == i) {\r\n        commodityStandard[standardIndex][index].isClick = 1;\r\n        selectedStandard[standardIndex] = commodityStandard[standardIndex][index].item;\r\n      } else {\r\n        commodityStandard[standardIndex][i].isClick = 0;\r\n      }\r\n    }\r\n\r\n    // 将id用_连接起来\r\n    let mergeId = selectedId.join('_');\r\n    console.log(mergeId);\r\n    let mergeStandard = selectedStandard.join('  ');\r\n    console.log(mergeStandard);\r\n\r\n    let standardInfo = this.data.standardInfo;\r\n    let standardInfoLength = standardInfo.length;\r\n    // 用于存储选中的规格\r\n    let standardObject = {};\r\n\r\n    for (let i = 0; i < standardInfoLength; i++) {\r\n      if (standardInfo[i].key == mergeId) {\r\n        standardObject = standardInfo[i];\r\n        break;\r\n      } else {\r\n        standardObject = this.data.standardObject;\r\n      }\r\n    }\r\n\r\n    this.setData({\r\n      currentId: id,\r\n      commodityStandard,\r\n      selectedId,\r\n      standardObject,\r\n      mergeStandard,\r\n      selectedStandard,\r\n    })\r\n\r\n  },\r\n  /* 选择数量 */\r\n  handleCommodityNumber(e) {\r\n      let commodityNum = e.detail.value;\r\n      if (commodityNum >= this.data.store_count) {\r\n          commodityNum = this.data.store_count;\r\n      }\r\n      this.setData({\r\n          commodityNum\r\n      })\r\n  },\r\n  /* 保存选择的规格 */\r\n  submitSelected() {\r\n      let selectedStandard = this.data.selectedStandard;\r\n      let length = selectedStandard.length;\r\n      console.log(length)\r\n      if (length == 0) {\r\n          $Message({\r\n              content: '请选择规格',\r\n              type: 'error'\r\n          });\r\n          return false;\r\n      }\r\n      for (let i = 0; i < length; i++) {\r\n          if (length < this.data.commodityStandard.length) {\r\n              $Message({\r\n                  content: '请选择规格',\r\n                  type: 'error'\r\n              });\r\n              break;\r\n          }\r\n          if (selectedStandard[i] == undefined) {\r\n              $Message({\r\n                  content: '请选择规格',\r\n                  type: 'error'\r\n              });\r\n              break;\r\n          }\r\n      }\r\n      $Message({\r\n          content: '选择成功',\r\n          type: 'success'\r\n      });\r\n  },\r\n})我这里提示信息使用了插件iview，可以在官网直接下载后使用iview weapp3.部分思路及改进方法开始想到的是将需合并的id的位置写死，比如，第一个位置就传第一个规格里选中的规格id，第二个位置就传第二个规格里选中的规格id,不过此时有问题，就是后台的id拼接是根据当前规格长度来拼接的，从最短的开始往长的拼接，然后，长度相等的时候，我这边的话，后台是从第一个开始拼接的，而且你选规格时，也可能是随机点的，此时若是采用第一种位置写死的方法就会有问题，因为会找不到对应的合并后的规格id因为我这里一开始用的数据就刚好满足我的设想，但是后面换了个数据后就出现问题了index.wxml文件也做部分修改,可以直接查找下，类名为standardItem<view class=\"standardItem\">\r\n  <block wx:for=\"{{item}}\" wx:key=\"{{item.item_id}}\">\r\n    <view class=\"selectItem {{item.item_id == Specifications[standardIndex]?'standardSelected':'standardNormal'}}\" bindtap=\"handleStandardClick\" data-standard-index=\"{{standardIndex}}\" data-name=\"{{item.item}}\" data-id=\"{{item.item_id}}\">{{item.item}}</view>        \r\n  </block>\r\n</view>*增加另一种模拟数据goods: {\r\n  goods_name: \"男鞋\",\r\n  store_count: 95,\r\n  market_price: \"10.00\",\r\n  shop_price: \"101.00\",\r\n  cost_price: \"10.00\",\r\n  original_img: \"/images/commodity.jpg\",\r\n  store_id: 170,\r\n},\r\ncommodityStandard: [\r\n  [\r\n    {\r\n      spec_name: \"颜色\",\r\n      item_id: 532825,\r\n      item: \"白色\",\r\n      src: \"\",\r\n      isClick: 0\r\n    },\r\n    {\r\n      spec_name: \"颜色\",\r\n      item_id: 532826,\r\n      item: \"黑色\",\r\n      src: \"\",\r\n      isClick: 0\r\n    },\r\n    {\r\n      spec_name: \"颜色\",\r\n      item_id: 532827,\r\n      item: \"红色\",\r\n      src: \"\",\r\n      isClick: 0\r\n    }\r\n  ],\r\n  [\r\n    {\r\n      spec_name: \"大小\",\r\n      item_id: 532828,\r\n      item: \"160\",\r\n      src: \"\",\r\n      isClick: 0\r\n    },\r\n    {\r\n      spec_name: \"大小\",\r\n      item_id: 532829,\r\n      item: \"150\",\r\n      src: \"\",\r\n      isClick: 0\r\n    }\r\n  ],\r\n  [\r\n    {\r\n      spec_name: \"重量\",\r\n      item_id: 552581,\r\n      item: \"10\",\r\n      src: \"\",\r\n      isClick: 0\r\n    }\r\n  ]\r\n],\r\n/* 这里合并规格的信息 */\r\nspec_goods_price: [\r\n  {\r\n    id: 1018286,\r\n    key: \"552581_532828_532825\",\r\n    price: \"10.00\",\r\n    productprice: \"0.00\",\r\n    store_count: 9\r\n  },\r\n  {\r\n    id: 1018287,\r\n    key: \"552581_532828_532826\",\r\n    price: \"20.00\",\r\n    productprice: \"0.00\",\r\n    store_count: 10\r\n  },\r\n  {\r\n    id: 1018288,\r\n    key: \"552581_532828_532827\",\r\n    price: \"30.00\",\r\n    productprice: \"0.00\",\r\n    store_count: 10\r\n  },\r\n  {\r\n    id: 1018289,\r\n    key: \"552581_532829_532825\",\r\n    price: \"40.00\",\r\n    productprice: \"0.00\",\r\n    store_count: 10\r\n  },\r\n  {\r\n    id: 1018290,\r\n    key: \"552581_532829_532826\",\r\n    price: \"50.00\",\r\n    productprice: \"0.00\",\r\n    store_count: 7\r\n  },\r\n  {\r\n    id: 1018291,\r\n    key: \"552581_532829_532827\",\r\n    price: \"60.00\",\r\n    productprice: \"0.00\",\r\n    store_count: 10\r\n  }\r\n],index.js文件onLoad: function (options) {\r\n    let goods = this.data.goods;\r\n    /* 用于存储对应的价格及库存 */\r\n    let standardObject = this.data.standardObject;\r\n    standardObject.price = goods.cost_price;\r\n    standardObject.store_count = goods.store_count;\r\n    \r\n    let spec_goods_price =this.data.spec_goods_price;\r\n    if (spec_goods_price) {\r\n      this.checkPrice(spec_goods_price);\r\n    }\r\n    this.setData({\r\n      standardObject,\r\n    })\r\n},\r\nhandleStandardClick: function (e) {\r\n    // 总规格名称索引\r\n    let standardIndex = e.currentTarget.dataset.standardIndex;\r\n    let id = e.currentTarget.dataset.id;\r\n    /* 存储选中的规格名称 */\r\n    let name = e.currentTarget.dataset.name;\r\n    let selectedStandard = this.data.selectedStandard;\r\n    selectedStandard[standardIndex] = name;\r\n    let mergeStandard = selectedStandard.join('  ');\r\n    let Specifications = this.data.Specifications;\r\n    Specifications[standardIndex] = id;\r\n    console.log(mergeStandard)\r\n    this.setData({\r\n      Specifications,\r\n      mergeStandard,\r\n      selectedStandard,\r\n    })\r\n    this.checkPrice(this.data.spec_goods_price);\r\n},\r\n/*在还未选择完规格时，暂时选用第一个合并后的规格价格及库存*/\r\ncheckPrice: function (spec_goods_price) {\r\n    let standardObject = this.data.standardObject;\r\n    if (!this.checkSpecifications(spec_goods_price)) {\r\n      standardObject.price = spec_goods_price[0].price;\r\n      standardObject.store_count = spec_goods_price[0].store_count;\r\n      this.setData({\r\n        standardObject,\r\n      })\r\n    }\r\n},\r\n/* 保存及校验是否选好了规格 */\r\nsubmitSelected: function (e) {\r\n    let spec_goods_price = this.data.spec_goods_price;\r\n    let i = 0;\r\n    let optionid = \"\";\r\n    if (spec_goods_price) {\r\n        optionid = this.checkSpecifications();\r\n        if (optionid) {\r\n            $Message({\r\n              content: '选择成功',\r\n              type: 'success'\r\n            });\r\n        } else {\r\n            $Message({\r\n              content: '请选择规格',\r\n              type: 'error'\r\n            });\r\n        }\r\n    }\r\n},\r\ncheckSpecifications(spec_goods) {\r\n    let spec_goods_price = spec_goods || this.data.spec_goods_price;\r\n    let Specifications = this.data.Specifications;\r\n    let SpecificationsLength = spec_goods_price[0].key.split(\"_\").length;\r\n    let standardObject = this.data.standardObject;\r\n    if (Specifications.length != SpecificationsLength) {\r\n      return false;\r\n    } else {\r\n      for (let i = 0; i < spec_goods_price.length; i++) {\r\n        /* 若selectSpecifications全为true，则选中了对应的合并后的规格 */\r\n        let selectSpecifications = true;\r\n        for (let j = 0; j < Specifications.length; j++) {\r\n          if (spec_goods_price[i].key.indexOf(Specifications[j]) == -1) {\r\n            selectSpecifications = false;\r\n            break;\r\n          }\r\n        }\r\n        if (selectSpecifications) {\r\n          standardObject.price = spec_goods_price[i].price;\r\n          standardObject.store_count = spec_goods_price[i].store_count;\r\n          this.setData({\r\n            standardObject,\r\n          })\r\n          return spec_goods_price[i].id;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n},利用indexOf来判断合并后的key值，就不用通过写死位置存储规格，然后这里用了动画，可以自己查看官方完档微信创建动画这里的规格啥的，格式可能会是多样的，我这里的话，就是返回这样的格式，其实我还想实现就是根据库存来判断是否可以点击，比如选尺码28，然后可能颜色为黑色的就库存不足，此时，是不能让他点击的，日后会在做下这个功能，欢迎大家在评论区指正，共同进步^_^正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）"}
{"title": "Quikapp快应用【小程序】开发入门教程 ", "author": "Rolan", "pub_time": "2018-11-14 00:44", "article_content": "最近华为牵头国内几大厂商出了小程序Quikapp快应用，这里给大家编写快应用入门教程 首先记住几个网站1、官网：https://www.quickapp.cn 2、文档：https://doc.quickapp.cn/ 3、工具： 使用Visual Studio Code开发 使用WebStorm开发 教程地址（https://doc.quickapp.cn/tutorial/getting-started/code-edit-conf.html） 4.环境： 需安装6.0以上版本的NodeJS，请从NodeJS官网下载5.依赖库 hap-toolkit、hap-tools第一步：安装npm install -g hap-toolkit 安装第二步：hap脚手架生成一个初始项目hap init test1 初始化项目目录 这一步大家别急着npm run server 否则报一下错误报错第三步：安装依赖npm install第四步：运行服务npm run server image.png 还是失败，新出的东西官网还不是很完善，后面应该不会出现，这里花了几分钟找到了原因，项目少了hap-tools库， 这里没看到官网有这个库的介绍，package.json里也没 ap-tools 这个库的引入。 大家输入npm install hap-tools 手动安装下这个库。 安装 然后npm run server 开发者可以通过命令行终端或者调试服务器主页看到提供* 扫描的二维码 开发者通过快应用调试器扫码安装按钮，扫码安装待调试的rpk文件 开发者点击快应用调试器中的开始调试按钮，开始调试成功 完美快应用入门教程 给大家解释下目录说明├── sign rpk包签名模块 │ └── debug 调试环境 │ ├── certificate.pem 证书文件 │ └── private.pem 私钥文件 ├── src │ ├── Common 公用的资源和组件文件 │ │ └── logo.png 应用图标 │ ├── Demo 页面目录 │ | └── index.ux 页面文件，可自定义页面名称 │ ├── app.ux APP文件，可引入公共脚本，暴露公共数据和方法等 │ └── manifest.json 项目配置文件，配置应用图标、页面路由等 └── package.json 定义项目需要的各种模块及配置信息 大家像小程序一样，在这上面开发就好了。Quikapp快应用基于Nodejs内建一个本地服务器运行代码、语言JavaScript，语法支持ES6，如果熟悉vue\\weex一类的MVVM框架，基本可以直接入手。这一章是Quikapp快应用开发入门，有空补上下一章编写第一个快应用。Quikapp快应用、如何接入Bmob后端云？ 既然语言是JavaScript， 直接下载Bmob的JavaScript SDk引入，就可以直接操作后端数据库，配合云函数可以实现Quikapp快应用的接口对接。很快Bmob也会推出快应用的针对性SDK，这样云函数也不需要写了，跟小程序一样无需写一行后端代码，愉快的对接Quikapp快应用了。作者：微信小程序开发 链接：https://www.jianshu.com/p/eacb61ba1ef4"}
{"title": "小程序类似抖音视频整屏切换 ", "author": "Rolan", "pub_time": "2018-11-15 00:15", "article_content": "最近在项目中需要加一个功能，在小程序中将已有的短视频功能，按照抖音的方式来浏览，整屏，可上下滑动切换视频，并添加上滑下滑的动画。思路1.在video标签上添加时间监听。 2.如果1无法成功，就在video上面罩一层 cover-view，在cover-view上添加时间监听。 3.如果上面两种方法都不行，用小程序的onPageScroll页面处理函数来监听页面的滚动。 4.上述三种方法都不行的话，用canvas在video上面罩一层，监听滚动事件。尝试现在video标签上添加了触摸事件的监听，但是无法成功监听到触摸事件。 因为video 是原生组件，层级较高，所以尝试在上面罩一层cover-view，并监听滚动事件，但是同样无法监听。前面两种方法不行，我就采用了onPageScroll来监听页面是否发生滚动。这个方法会拿到当前页面在垂直方向已滚动的距离。scrollindex用来控制滚动，totalNum是滚动的总数，部分代码如下在ios上可以满足需求，能上下滚动，也能加上动画，但是在安卓上却不能动，尝试着在页面json文件中配置滚动相关，但都没办法，所以这个方法也不行了。最后只有canvas这一个办法了，在video组件上面定位一个canvas，在上面添加时间监听，这是发现成功了，可以在控制台看到打印出来的监听 console。实现wxml：下面是wxml代码，主要思路就是让video宽高等于屏幕，点赞评论分享等功能，用cover-view定位到视频上方，在将canvas定位到video上面滚动时滚动的是封面图案，video标签只有一个，滚动更改video的src。wxss:都是一些定位相关的样式没有特殊的样式就不贴图了。不过做的时候这里有个坑，产品希望添加无限的向下滑动视频，可以无限加载，所以最开始我才用的是animation动画，对每一屏根据手指向上或者向下添加动画，这样做的话就无法做到，后来发现可以使用小程序的api，wx.createAnimation()在js中实现。js：onload的时候this.animation = wx.createAnimation();用于切换时创建动画。需要监听的滚动事件js主要做的是判断滚动方向，给wxml通过微信提供的animation方法来动态添加动画，这样就可以实现无限加载的需求了。scrollTop的作用是用来调整video标签位置，因为现在滚动的时候添加滚动的事视频的封面图不是视频本身，需要隐藏视频，假如用wx:if；哎控制的话，会导致视频隐藏在展现之后无法监听之前添加的事件。效果在真机上可以生效，在手机上录了视频不知道怎么传上来，转gif也没找到在mac怎么转。。。最后弄了好久弄出来的，真机和模拟器的效果差异很大，最好在真机测试。目前也不知道有没有更好的办法，菜鸟前端一个～"}
{"title": "青铜选手带你动手撸一个博客小程序给自己（第二期） ", "author": "Rolan", "pub_time": "2018-11-15 00:28", "article_content": "上一篇的的的链接 赖了一个星期了，let us 接着上一篇的搞。在上一篇里搞了一下基础设施建设，这一篇我们...稍微搞那么一丢丢上层建筑。这一篇里本菜鸡想分享的tip小程序登陆逻辑与登陆状态维持的两种姿势发送评论时的一个投机倒把的小“优化”小程序微信登陆与前端登陆状态保存小程序登陆小程序登陆其实是个比较简单的基本操作，但凡是看过微信开发文档的应该都能懂，不过本菜鸡还是想尝试性的分享一下。首先先明确一下 为啥要用微信登陆 ，在本菜鸡看来在这个项目里使用微信登陆主要有三个目的方便用户 ：相比于用户手动注册、填写各种信息、再手动输入账号密码登陆，利用微信登陆用户点一下，就可以完成上面的全部操作，注册、登陆全都由后台利用微信提供的相关的信息完成方便后台用户管理使用微信的相关能力 ：通过微信登陆，后台可以获得唯一标识用户的openid，而这个openid，是后台调用微信相关敏感接口的必填项（例如：微信支付）然后，明确一下微信登陆过程中的几个概念然后，结合本次项目的实际情况捋一下微信登陆的流程调用wx.login方法获取code ，顺手调用一下wx.getUserInfo获取一下用户的基本信息（头像，微信名啥的）调用后端接口，将code与获取的用户信息userInfo（非必需）传递给后端。后端接收到参数，将code拿出来与存在后端的appid、appsecrect拼接成微信登陆链接$url='https://api.weixin.qq.com/sns/jscode2session?appid='.$this->appId.'&secret='.$this->appSecret.'&js_code='.$code.'&grant_type=authorization_code';\r\n复制代码访问该链接获得返回结果（json格式的），验证下是否成功，如果OJBK，就从结果里掏出openid$wxResult=json_decode(curl_get($url),true);\r\n if(!$wxResult||!array_key_exists('openid',$wxResult)){\r\n      return ResultService::failure('获取openid不成功');\r\n }\r\n $openId=$wxResult['openid'];\r\n复制代码其实获得到openid微信登陆已经差不多了，剩下就是怎么用的问题了，下面的步骤是在本次项目的流程，供各位老哥参考根据openid查一下数据库，看看是否是存在， 若存在 ，则说明是老用户，不用新增用户，直接用在步骤3中获取到的由前端传来的userInfo更新一下后台的用户信息即可（头像，省份，微信名啥的）。 若不存在 ，则这是个新用户，把openid与userInfo存到用户表中经过步骤5，库里已经有了这个用户的数据，然后拿用户数据，按照一定规则，生成个token返回给小程序端，小程序端把token存到localStorage里，后端将token与用户信息以键值对的形式存到缓存里，以后小程序请求的时候带着token来，后端根据token查缓存来确定用户登陆状态。至此，本项目中微信登陆的流程搞完了。登陆完的结果就是，后台新增或更新了用户数据，小程序端有了token。小程序登陆状态保持本菜鸡个人觉得常用的保持登陆状态的方法有两种token（个人推荐）session先说第一种，也是本项目采用的方法，其实在上面的步骤5、6已经把这个方法将清楚了，登陆后服务端下发token给小程序端，同时服务端自己也存一份，存哪里就根据实际情况（cache、redis、session啥的都行），然后搞个有效期，过期了就消失得那种。小程序每次请求后端接口的时候把token放到header里后端在处理请求前先把token从header里取出来，拿这个token去查缓存，如果有，就说明用户还在登陆状态，继续往后走，如果没有，则说明用户离线了，就直接返回一下告诉小程序端需要重新登陆，小程序收到后跳转到登录页。第二种也在做网站用户登陆的时候是非常常见的操作，在撸网站的时候，用户登陆后把用户信息存到session里，用户在请求的时候能够从session中取到用户信息，之所以这样是因为，浏览器请求服务器，服务器响应时，会带一个sessionid回去给浏览器，浏览器下次请求时候会自动带着sessionid，服务器会根据sessionid来到相应的会话里，所以能取到session中的用户BUT在小程序中有所不同，这是因为小程序网络访问是用的微信封装的wx.request，而该方法并不会把sessionid存下来，因此，为了能和网站登陆搞成一个逻辑，我们手动存一下sessionid，在下次请求的时候带着sessionid去即可。部分代码如下服务端（PHP）//前面先搞登陆，登陆完了把用户存到session里然后\r\nreturn ResultService::success('',['sessionId'=>session_id()]);\r\n\r\n复制代码小程序端//登陆\r\ndataUtils.userLogin({ code: code, info: JSON.stringify(info) }).then(res => {\r\n        if (res.statusCode == '200') {\r\n          wx.setStorageSync('sessionId', res.data.data.sessionId);\r\n          $Message({\r\n            content: '登陆成功',\r\n            type: 'success'\r\n          });\r\n          this.checkUserLogin();\r\n        }\r\n        else {\r\n          $Message({\r\n            content: '登陆未成功',\r\n            type: 'error'\r\n          });\r\n        }\r\n//请求例子（不同后端header名不一样，比如php的后端就是 PHPSESSID=你的sessionId）\r\nfunction userJoinPromise(data,sessionId){\r\n  let url = 'travel/api/userJoin';\r\n  return getServerDataPromise(url, data, { 'Cookie': 'PHPSESSID=' + sessionId });\r\n}\r\n复制代码下班了下班了，先写到这明天继续撸"}
{"title": "微信小程序之canvas 文字断行和省略号显示 ", "author": "Rolan", "pub_time": "2018-11-15 00:42", "article_content": "文字的多行处理在dom元素中很好办。但是canvas中没有提供方法，只有通过截取指定字符串来达到目的。那么下面就介绍我自己处理的办法：wxml：<canvas canvas-id='word' id='test'></canvas>canvas肯定要一个画板容器啦，记得设置宽高哦，小程序中默认宽高是300px和150pxjs：在page中//处理文字多出省略号显示\r\n    dealWords: function (options) {\r\n        options.ctx.setFontSize(options.fontSize);//设置字体大小\r\n        var allRow = Math.ceil(options.ctx.measureText(options.word).width / options.maxWidth);//实际总共能分多少行\r\n        var count = allRow >= options.maxLine ? options.maxLine : allRow;//实际能分多少行与设置的最大显示行数比，谁小就用谁做循环次数\r\n            \r\n        var endPos = 0;//当前字符串的截断点\r\n        for (var j = 0; j < count; j++) {\r\n            var nowStr = options.word.slice(endPos);//当前剩余的字符串\r\n            var rowWid = 0;//每一行当前宽度    \r\n            if (options.ctx.measureText(nowStr).width > options.maxWidth) {//如果当前的字符串宽度大于最大宽度，然后开始截取\r\n                for (var m = 0; m < nowStr.length; m++) {\r\n                    rowWid += options.ctx.measureText(nowStr[m]).width;//当前字符串总宽度\r\n                    if (rowWid > options.maxWidth) {                        \r\n                        if (j === options.maxLine - 1) { //如果是最后一行\r\n                            options.ctx.fillText(nowStr.slice(0, m - 1) + '...', options.x, options.y + (j + 1) * 18);    //(j+1)*18这是每一行的高度        \r\n                        } else {\r\n                            options.ctx.fillText(nowStr.slice(0, m), options.x, options.y + (j + 1) * 18);\r\n                        }\r\n                        endPos += m;//下次截断点\r\n                        break;\r\n                    }\r\n                }\r\n            } else {//如果当前的字符串宽度小于最大宽度就直接输出\r\n                options.ctx.fillText(nowStr.slice(0), options.x, options.y + (j + 1) * 18);\r\n            }\r\n        }\r\n    },（1） measureText（）.width 这是小程序 测量文本尺寸信息的方法，目前仅返回文本宽度。这里是官方说明（2） (j + 1) * 18   中18表示每一行行高是18，这是我自己定义的行高如果这个数值小于定义的字体大小，多半会出现两行文字重叠的现象，前面的 j+1 表示当前是多少行。整体表示当前行与上一行相比需要加多少距离（3） 在 j===options.maxLine-1 这个表示最后一行的处理情况里面   有slice(0，endPos-1)，为什么这里要减一，是因为省略号也要占宽度，大概是11.5的样子，所以要减掉这个省略号的宽度。因为一般中文字符宽度都和设置的字体大小差不多。如果是英文就要小一点，这里就没有考虑这么精细了。反正减一就是精确度的意思。。。可以自行多减或者少减（4） endPos += m 表示下一次截断的时候是从哪里开始。因为每次去截字符串都是最初的字符串，并没有真正意义上的截断一次之后就是剩下的字符串了，所以要把每次截断的点和上一次截断的点加上，才是最新一次字符串截断的位置。（5） 循环和判断使用的有点多，不知道对性能有没有影响。。。。。。调用的时候：var ctx = wx.createCanvasContext('word');\r\nvar name='窗前明月光，疑是地上霜，举头望明月，低头思故乡。';\r\nthis.dealWords({\r\n    ctx: ctx,//画布上下文\r\n    fontSize: 16,//字体大小\r\n    word: name,//需要处理的文字\r\n    maxWidth: 100,//一行文字最大宽度\r\n    x: 0,//文字在x轴要显示的位置\r\n    y: 0,//文字在y轴要显示的位置\r\n    maxLine: 3//文字最多显示的行数\r\n})\r\nctx.draw(); （1） 这个方法能够处理一行或者多行的情况，就看maxLine设置的大小了。当然如果设置maxLine为0或者-1，就会不显示的。。。看一下效果：（1） canvas我设置的是200 * 200的大小，其它的设置就是上面调用的时候设置的（1） 这是当maxWidth设置为200px的时候的显示情况。 完成 (＾－＾)V"}
{"title": "论如何将 h5 页面快速转换成微信小程序 ", "author": "Rolan", "pub_time": "2018-11-16 00:32", "article_content": "微信小程序自开放出来到现在也有一段时间了，相信其底层架构也被琢磨得差不多了。微信小程序本身是双线程运行的结构，而 h5 页面是单线程的运行模式，因此两者无法直接互通。微信小程序的运行模式如下：微信小程序本身提供了 web-view 组件来支持在微信小程序中嵌入 h5 页面，但是 web-view 组件在使用上还是有一些限制：不支持个人类型与海外类型的小程序、不支持全屏、页面与小程序通信不方便、很多小程序接口无法直接调用等。如果无法使用 web-view，这里还有一条路可以走，利用 h5-to-miniprogram 工具来将 h5 页面转换成小程序。起步假设你已经有一个 h5 页面，包含四个文件：h5 页面\r\n   |---- index.html\r\n   |---- index.css\r\n   |---- index.js\r\n   |---- index.png\r\n复制代码这种结构我们再熟悉不过了，具体每个文件的内容可参考这里： github.com/wechat-mini…。页面渲染出来的效果如下：页面很简单，但是值得一提的时，这个页面引入了 jQuery 库，所以 index.html 和 index.js 是这样的：<!doctype html>\r\n<html lang=\"zh\">\r\n  <head>\r\n    <meta charset=\"utf-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no, minimal-ui\">\r\n    <meta content=\"yes\" name=\"apple-mobile-web-app-capable\">\r\n    <meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\">\r\n    <meta name=\"format-detection\" content=\"telephone=no, email=no\">\r\n    <title>demo</title>\r\n    <style type=\"text/css\">\r\n      html, body {\r\n        width: 100%;\r\n        height: 100%;\r\n      }\r\n    </style>\r\n    <link rel=\"stylesheet\" href=\"./index.css\">\r\n  </head>\r\n  <body>\r\n    <img class=\"logo\" src=\"./index.png\">\r\n    <div class=\"cnt\"></div>\r\n    <script src=\"https://juneandgreen.github.io/test/h5-to-miniprogram-demo/demo2/js/jquery-1.12.4.min.js\"></script>\r\n    <script src=\"./index.js\"></script>\r\n  </body>\r\n</html>\r\n复制代码$(document).ready(function() {\r\n  $('.cnt').text('h5 to miniprogram');\r\n});\r\n复制代码微信小程序里是不暴露 dom/bom 接口的，说想要使用 jQuery 是非常困难的。尽管难以置信，但是确实是有办法的，后面会简述一下原理，让我先继续看下要如何操作。配置因为运行环境的不同，为了在编译时和运行时对两者进行一些兼容操作，我们需要一份配置文件：module.exports = {\r\n  index: 'h5', // 首页\r\n  urlMap: { // 每个页面对应的初始 url\r\n    h5: 'https://weixin.qq.com/index?a=1&b=2#hash',\r\n  },\r\n  resFilter(src, pageKey) {\r\n    // 资源过滤，用于替换 h5 中使用到的资源路径\r\n    return pageKey === 'h5' && src === './index.png' ? 'https://raw.githubusercontent.com/wechat-miniprogram/h5-to-miniprogram-demo/master/h5/index.png' : src\r\n  },\r\n}\r\n复制代码配置文件很简单，就是一个 js 文件，里面包含各种配置项。例如 index 配置项用于配置首页； urlMap 用于配置每个页面的初始 url，这个 url 会被解析到 window.location 中，通常用于页面跳转或单页系统中； resFilter 配置项用于调整资源路径，这里是因为考虑到微信小程序包大小有限制，默认不会去处理图片等资源，所以需要提供一个方法来替换资源路径为网络路径。因为配置文件需要拷贝到微信小程序项目中执行，所以配置文件必须是一个纯净的没有额外依赖的文件（比如 require('fs') 在配置文件中是不允许的）。构建生成有了原始的 h5，有了配置文件，那就可以开始进行转换并生成微信小程序项目了。我们来编写一个构建脚本，起名为 build.js：const path = require('path')\r\nconst toMiniprogram = require('h5-to-miniprogram')\r\n\r\ntoMiniprogram({\r\n  entry: { // 入口 h5 页面路径\r\n    h5: path.join(__dirname, './h5/index.html'),\r\n  },\r\n  output: path.join(__dirname, './miniprogram'), // 输出目录\r\n  config: path.join(__dirname, './config.js'), // 配置文件路径\r\n}).then(res => {\r\n  console.log('done')\r\n}).catch(err => {\r\n  console.error(err)\r\n})\r\n复制代码构建脚本也很简单，引入 h5-to-miniprogram 工具，此工具直接暴露一个 async 方法，调用时将必须的参数传入即可。可以看到参数中的入口配置是一个 key-value 对象，这里的 value 不能理解，就是页面的路径，key 则是页面的名称。例子中这个页面的 key 就是 h5，我们回到上面的配置文件那里就会发现，很多个地方都需要用到这个 key，这个 key 可以作为页面的唯一标识。写完构建脚本后，后续就简单很多了，执行：node build.js\r\n复制代码然后就会看到构建脚本中指定的输出目录—— miniprogram 目录被生成出来。完整的 demo 在这里： github.com/wechat-mini…使用使用官方提供的开发者工具打开 miniprogram 目录，可以看到已经基本达到我们想要的效果了：原理原理其实很简单，h5 页面在浏览器运行的过程就是解析 html 到渲染 dom 树的过程，然后提供一些 dom/bom 接口给 js 调用。那么在小程序中我们把这一套给模拟一遍就行了，方法很暴力，但是却意外的有效：因为给 h5 页面提供了类似浏览器的环境，实现了最底层的适配，所以理论上来说那些通用的框架和库也能支持运行。上面的例子中就表明了 jQuery 是能够运行的，像 react、vue 也是可以做到支持的。微信小程序是双线程的运行模式，视图层专注于渲染，逻辑层专注于逻辑。逻辑层是在一个纯净的 js 线程中跑，那里没有 dom/bom 接口，只能运行页面逻辑层的代码。要模拟浏览器环境，最基本的就是要在逻辑层里模拟出一棵 dom 树，本质上和建立一棵虚拟树类似，因为它并不是真实的 dom 树。整个流程简单来说是这样的：不管是页面中的静态 html 内容还是使用 innerHTML 等接口动态插入的 html 内容都可以走上面的流程来进行 dom 树的创建。dom 树创建比较简单，只是细节比较多，此处的关键是将创建好的 dom 节点映射到微信小程序的自定义组件，利用自定义组件的特性可以轻易的将我们创建好的 dom 树给渲染出来。如果你还不清楚微信小程序的自定义组件是什么的话，可以戳官方文档了解一下。"}
{"title": "小程序云开发之踩到狗尾巴 ", "author": "Rolan", "pub_time": "2018-11-19 00:05", "article_content": "前段时间用了下快狗打车，感觉贼方便，师傅响应速度和服务态度都特别好，搬个家再也没有以前那么痛苦了，女票也是给了大大的赞。正好最近毕业设计选题跟这个类似，参考了云开发文档，真心感觉云函数，云数据库，快且好用，立马开写，快快搞定毕设，好好工作（欢迎hr小姐姐楼层回复撩我）。不料，快速云开发之快狗毕设项目，犹如踩上了狗尾巴，坑坑真多，给各位像我一样，要快速写毕设，快速听女票话搬家的同学，记录一下。先给你们看下运行效果：一、程序骨架的基本构建1.功能的完整实现做个东西首先就是要把它的基本功能实现了，这个是毋庸置疑的。如果你是自己准备做个自己的小 程序，那么你肯定要对自己的小程序应该实现怎样的功能了如指掌，在心里应该把实现功能的流程 预演个几百遍了。这里第一个坑就出现了，我做的那会可没有想这么多，毕竟作为一个愣头青，莽 就完事了，从想法出来到开始动手时间不到1个小时，事实证明这是非常非常不可取的，也充分暴露 了我经验的不足。如果你不想像我一样写到后面一步一坑的话，最好提前想好。2.页面的基本构建作为一个较大的项目，主页结构应该做到结构清晰，语义化良好，尽量使用BEM命名规范，当然你要 是想你的代码写完后自己都看不懂，你就瞎**命名当我没说。整个页面大概采用什么布局也要事先 想想清楚，当然手机端一般都是弹性布局比较好，让你的页面元素可大可小，完美适配不同尺寸的 手机。布局的时候千万不要舍不得用盒子，如果把布局比作是整理衣柜的话，当你的衣服足够 多的话，一两个衣柜显然是无法满足条件的，你的衣服将被堆在一起，凌乱不堪。但是如果你有足 够的衣柜来放置衣服的话，你的衣服将被分门别类放置的整整齐齐。在本小程序中，主页的弹性布 局是将地图部分设置为 flex:1 ，让地图高度随手机大小来变化，而其他部分保持不变来实现的。 但是在实际运行中，却总是出现各种问题，最终我的解决办法是再在页面中总出问题的部分加入了 一个盒子，又在弹性布局里嵌套了一个弹性布局，这样首页的适应性布局就完美实现了。3.数据库的设计云开发的发布，让后端对于数据的操作变的更简单了。微信小程序本质上是数据驱动页面，所以你 想在页面上展示什么，就设置一个对应的数据去关联。然后当我们想改变页面的时候，只需要改动 数据就可以了。由于我这个小程序数据比较简单，并没有把所有的数据都放在云端，我只建立一张 订单表orders。因为订单里展示的信息不多所以只有‘时间’‘发货地’‘收货地’‘价格’几个属性，‘isdone’是用来标 记订单是否完成的，表现在页面中就是订单状态会显示‘已完成’或者‘已取消’4. 选个好组件库这个不是必须的，但是有时候选择到一个适合的组件库用起来真的爽，可以让你的开发事半功倍 我选的是vant(这个我选的就不是很好)，希望你能选上一个让你用完发出一句真香感慨的。二、程序功能的基本实现如果你已经完成了上面的前三步，那你简直比我好太多了！剩下的只不过是将功能一个一个添加上 去罢了。由于本程序的实现使用了大量api，我不会去把这些api一个个详细讲解，这样纯粹是浪费 时间。但是我会把一些实现想法和一些我遇到的坑像大家说明，避免你们像我一样踩坑。1. 实时获取点的坐标并将地址显示在页面仔细看了演示图的同学会发现当我移动地图时，起点的地址是在实时发生变化的，当我停止拖动 地图时，起点的地址就会更新到最新点。那么这个功能是如何实现的呢？其实这里是有一点巧妙的。实际上我用cover-image在地图上标记了一个起点，这个点是一直垂直居中固定在地图的中心的 。这样我只需要获取这个中心点的坐标并使用逆地址解析就能得到这个点的位置描述啦，是不是有 点巧妙。而怎么获取中心点的坐标和完成逆地址解析呢，当然这一切都有腾讯爸爸提供给我们的ap i去完成了。这里有个注意的点就是我们应在用户松开时来显示更新后的地址，bindregionchang这 个可以做到，当 e.type = end 时再显示就可以了，细节虽然小，但是还是不能忽视了。2. 输入地址时要能有模糊搜索提示这个效果主要依赖于腾讯地图小程序jsSDK中的输入关键词提示，调用这个接口我们将可以在返回 值中拿到一个数组，里面包含着我们需要的各种信息。拿到数据是很简单的，但是如何处理它呢？ 这个数组的长度是不固定的，其实很简单我们只需要将拿到的数据setData给一个我们定义的空数 组searchresult，这样所有的数据就到了这个数组里，到时候再去页面上循环这个数组，这样我们 就可以将里面的数据都拿出来并让它们显示在它们该显示的地方，所以这部分的关键在wxml里，下 面是我写的：<view class=\"content\">\r\n  <scroll-view class=\"scrollcontent\" scroll-y style=\"height: {{scrollheight}}rpx;\">\r\n    <block wx:for=\"{{searchresult}}\" wx:key=\"index\">\r\n      <van-cell-group border=\"{{true}}\">\r\n        <van-cell class=\"resultlist\" title=\"{{item.title}}\" border=\"{{true}}\" data-title=\"{{item.title}}\"\r\n        data-location=\"{{item.location}}\" icon=\"location\" label=\"{{item.address}}\" bind:click=\"getlistvalue\"/>\r\n      </van-cell-group>\r\n    </block>\r\n  </scroll-view>\r\n</view>\r\n复制代码3.主页车型切换并带来价格的变化这个需求是让顾客可以自由选择车型，这个有点类似滴滴打车的‘快车’'拼车'‘优享’。刚开始做的 时候我以为这是一个scroll-view和scroll-into-view配合来实现的。等到我把一切基本都实现了的 时候，最后一个效果就是实现滑动切换时划过一定距离就自动进入下一页，不够据距离就回弹。我 想了很多方法来判断，各种js判断各种利用scroll-left都搞不定。直到我无意中在官方文档中看到 了swiper这个组件，这丝般顺滑的滑动切换，距离够了自动下一页，不够就回弹，这不就正是我所 需要的吗，于是我直接删了原来的代码，花了不到半个小时就撸完了这个小组件（核心在于判断cur renttab与index是否相等，注意这个index后面还有大用）。看到这完美效果的我不禁泪流满面。所 以这件事告诉我们当你一直搞不定某个效果时，你应该静下心来想想是不是你开始就弄错了方向， 避免做无用功，浪费时间。接下来奉上我完美实现的代码(wxml和js部分)：wxml:<view class=\"container\">\r\n    <view class=\"container-header\">\r\n    <view class=\"carLists {{currentTab === index ?'on': ''}}\" wx:for=\"{{carName}}\" wx:key=\"index\" data-id=\"{{item.id}}\" data-index=\"{{index}}\" bindtap=\"switchTab\">\r\n      {{item.name}}\r\n    </view>\r\n    </view>\r\n    <block wx:if=\"{{index>0}}\">\r\n        <van-icon name=\"arrow-left\" class=\"arrow-left\" bind:click=\"last\" />\r\n    </block>\r\n    <block wx:if=\"{{index<3}}\">\r\n        <van-icon name=\"arrow\" class=\"arrow\" bind:click=\"next\" />\r\n    </block>\r\n    <swiper class=\"carList\" current=\"{{currentTab}}\" bindchange=\"swiperChange\">\r\n      <block wx:for=\"{{cars}}\" wx:key=\"index\">\r\n        <swiper-item class=\"carview\">\r\n          <image class=\"carImg\" src=\"{{item.image}}\" mode=\"aspectFill\"/>\r\n        </swiper-item>\r\n      </block>\r\n    </swiper>\r\n  </view>\r\n复制代码js:switchTab:function(e){\r\n      if (this.data.currentTab === e.target.dataset.index) {\r\n        return;\r\n    } else {\r\n        this.setData({\r\n            currentTab: e.currentTarget.dataset.index,\r\n            index:e.currentTarget.dataset.index\r\n        })\r\n    }\r\n  },\r\n  \r\n  \r\n  swiperChange:function(e){\r\n    // console.log( e.detail)\r\n    if(e.detail.source == 'touch'){\r\n      this.setData({\r\n        currentTab: e.detail.current,\r\n        index:e.detail.current\r\n    })\r\n    }\r\n   \r\n  },\r\n    next:function(e){\r\n      // console.log(this.data.currentTab,this.data.currentTab)\r\n       if (this.data.currentTab === this.data.index && this.data.currentTab <3 ) {\r\n          this.setData({\r\n            currentTab:this.data.currentTab + 1,\r\n            index:this.data.index +1\r\n          })\r\n        }\r\n       \r\n    },\r\n  \r\n    last:function(e){\r\n      if (this.data.currentTab === this.data.index && this.data.currentTab > 0 ) {\r\n        this.setData({\r\n          currentTab:this.data.currentTab - 1,\r\n          index:this.data.index -1\r\n        })\r\n      }\r\n    }\r\n复制代码4.关于距离及价格的计算之前在输入起点和终点的时候我们可以通过腾讯地图的api拿到两者的具体坐标，这里我采用的距 距离计算没有采用腾讯地图所提供的api(因为有距离限制，仅限10km以内)，这个距离对于我们来说 无疑是太短了，于是我采取了一个通用公式，只要能有两地坐标，便可以算出两地间的距离，这样 一来我们的老司机们就不用再受到距离的限制了。//计算两坐标点之间的距离\r\n      distance: function (lat1, lng1, lat2, lng2) {\r\n        const rad1 = lat1 * Math.PI / 180.0;   \r\n        const rad2 = lat2 * Math.PI / 180.0;   \r\n        const a = rad1 - rad2;   \r\n        const b = lng1 * Math.PI / 180.0 - lng2 * Math.PI / 180.0;  \r\n        const r = 6378137;\r\n        const distance = (r * 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.cos(rad1) * Math.cos(rad2) * Math.pow(Math.sin(b / 2), 2)))).toFixed(0)\r\n        return distance / 1000;//单位转化为公里\r\n      }\r\n复制代码现在我们拿到了距离，但是怎么能让价格根据所选车型来动态变化呢？还记得之前页面里给每个 滑块的index吗？这里我们恰好就可以用它来做一个switch判断，给getPrice函数传入一个index 参数判断不同值并给出不同的计价方式，这样一来价格变会随着车型的切换而变化了。最后我们 的效果就达到了。5.订单完成数据的上传及拉取有了云开发之后数据库的操作简直不要太简单了！取消订单时，在选择完取消订单理由后，们 将向云数据库添加一条数据，只需几条命令我们就可以将我们的数据真正的存在数据库里并保存起 来，听上去是不是很心动呢wx.cloud.init();//初始化\r\nconst db = wx.cloud.database();\r\nconst cancelOrder = db.collection('orders')//orders为手动在云数据库里添加的一张空表\r\n//三步操作后我们就连上了我们的数据库\r\n    cancelOrder.add({\r\n      data:{\r\n        time:globalData.time,\r\n        shipAddr:globalData.address,\r\n        receiveAdrr:globalData.receiveAdrr,\r\n        price:globalData.price,\r\n        isdone:false\r\n      }\r\n    })\r\n复制代码这样订单数据就被我们添加到了数据库里，可以被我们随时访问了。然后在通过一条简单的查 询语句就可以在我的订单里显示了。orders.where({\r\n      _openid:'xxxxxxxx'//用户的openid\r\n    }).get({\r\n      success: res=> {\r\n        this.setData({\r\n          orders:res.data\r\n        })\r\n        // console.log(res.data)\r\n        wx.hideLoading();//加载完成关闭加载框\r\n      }\r\n    })\r\n复制代码最后在页面上循环输出orders里的值就可以得到一堆订单了写在最后一个完整项目的实现确实不是那么简单的，即使是一个简单流程的实现，很多看似简单的东西 里经常藏着大坑，而不同页面之间的联系也是很让人头痛的，我们要从之前那种局部的眼光中跳脱 出来，从更大的层面来看待构建我们的项目骨架。使用组件化，函数化的编程思想可以很好的帮助 我们降低代码的耦合性，增加代码的复用性，使我们的代码结构更清晰。写本篇文章的目的是为了 方便自己以后重构项目的时候看，也是为了给有跟我一样想法，跃跃欲试想撸个完整项目的同学一 个参考，少踩一些坑。最后有什么建议或者文中有什么错误的地方欢迎在评论中指出，互相学习， 共同进步！这是我在掘金发的第一篇文章，看完觉得还不错的同学点个赞再走吧！完整项目点这： 项目地址主要参考:快狗打车拉货搬家微信小程序微信小程序官方文档： developers.weixin.qq.com/miniprogram…腾讯地图api文档： lbs.qq.com/qqmap_wx_js…vant Weapp小程序ui组件库： youzan.github.io/vant-weapp/…"}
{"title": "小程序生命周期分析与注册流程回调 ", "author": "Rolan", "pub_time": "2018-11-19 00:21", "article_content": "从小程序发布到现在，官方api 变动了好几个版本\r\n首先我们先看一下小程序的生命周期\r\napp.js 为小程序的启动入口文件\r\nonLauch: 小程序初始化回掉，生命周期内只执行一次\r\nonShow: 小程序打开或者从后台唤起时的回调\r\nonHide: 小程序从前台进入后台时\r\nonError: 小程序发生脚本错误，或者 api 调用失败时触发，会带上错误信息\r\n页面生命周期：\r\nonLoad:注册页面的时候执行，只执行一次\r\nonShow: 页面在前台展示时执行，显示一次执行一次\r\nonReady: 页面初次渲染完成时执行，冷启动时不执行\r\nonHide: 页面从前台进入后台\r\nonUnload: 页面注销时执行\r\n个人觉得 小程序app中应该增加一个onUnload周期，页面的销毁现实场景个人还没有使用到\r\n===========================================\r\n下面我们来看一下 小程序的注册流程\r\n\r\n针对小程序开发者看下图\r\n\r\n1. 检查是否是登陆接口\r\n2. 判断session\r\n3. wx.login--》获取token\r\n4. 执行原有回掉\r\n好处：让后续开发者 忽略登陆流程逻辑\r\nfunction doLogin(callback, obj) {\r\n    if (obj.isLogin) {\r\n        // 登录接口，直接放过\r\n        // 直接放过，让其走下去\r\n        typeof callback === \"function\" && callback();\r\n    } else if(session) {\r\n        // 缓存中有session\r\n        if(sessionExpireTime && new Date().getTime() > sessionExpire) {\r\n            // 如果有设置本地session缓存时间，且缓存时间已到\r\n            session = '';\r\n            doLogin(callback, obj);\r\n        } else {\r\n            typeof callback === \"function\" && callback();\r\n        }\r\n    } else if (logining) {\r\n        // 正在登录中，请求轮询稍后，避免重复调用登录接口\r\n        flow.wait('doLoginFinished', function () {\r\n            doLogin(callback, obj);\r\n        })\r\n    } else {\r\n        // 缓存中无session\r\n        logining = true;\r\n        obj.count++;\r\n        // 记录调用wx.login前的时间戳\r\n        // 执行login 获取code\r\n        obj._loginStartTime = new Date().getTime();\r\n        console.log('wx.login');\r\n        wx.login({\r\n            complete: function () {\r\n                obj.count--;\r\n                // 记录wx.login返回数据后的时间戳，用于上报\r\n                obj._loginEndTime = new Date().getTime();\r\n                if (typeof reportCGI === \"function\") {\r\n                    reportCGI('wx_login', obj._loginStartTime, obj._loginEndTime, request);\r\n                }\r\n                typeof obj.complete === \"function\" && obj.count == 0 && obj.complete();\r\n            },\r\n            success: function (res) {\r\n                if (res.code) {\r\n                    var data;\r\n                    // codeToSession.data支持函数\r\n                    // 上传服务器操作\r\n                    if (typeof codeToSession.data === \"function\") {\r\n                        data = codeToSession.data();\r\n                    } else {\r\n                        data = codeToSession.data || {};\r\n                    }\r\n                    data[codeToSession.codeName] = res.code;\r\n\r\n                    obj.count++;\r\n                    requestWrapper({\r\n                        url: codeToSession.url,\r\n                        data: data,\r\n                        method: codeToSession.method,\r\n                        isLogin: true,\r\n                        report: codeToSession.report || codeToSession.url,\r\n                        success: function (s) {\r\n                            session        = s;\r\n                            sessionIsFresh = true;\r\n                            // 如果有设置本地session过期时间\r\n                            if(sessionExpireTime) {\r\n                                sessionExpire = new Date().getTime() + sessionExpireTime;\r\n                                wx.setStorage({\r\n                                    key: sessionExpireKey,\r\n                                    data: sessionExpire\r\n                                })\r\n                            }\r\n                            // 执行回掉\r\n                            typeof callback === \"function\" && callback();\r\n                            wx.setStorage({\r\n                                key: sessionName,\r\n                                data: session\r\n                            })\r\n                        },\r\n                        complete: function () {\r\n                            obj.count--;\r\n                            typeof obj.complete === \"function\" && obj.count == 0 && obj.complete();\r\n                            logining = false;\r\n                            flow.emit('doLoginFinished');\r\n                        },\r\n                        fail: codeToSession.fail || null\r\n                    });\r\n                } else {\r\n                    fail(obj, res);\r\n                    console.error(res);\r\n                    // 登录失败，解除锁，防止死锁\r\n                    logining = false;\r\n                    flow.emit('doLoginFinished');\r\n                }\r\n            },\r\n            fail: function (res) {\r\n                fail(obj, res);\r\n                console.error(res);\r\n                // 登录失败，解除锁，防止死锁\r\n                logining = false;\r\n                flow.emit('doLoginFinished');\r\n            }\r\n        })\r\n    }\r\n}\r\n复制代码处理页面登陆交互的两种方式\r\n1. app.js 注册回掉函数，进入page 注册这个回掉函数，登陆完成执行app.logincallback\r\npage.js\r\nconst app = new getApp()\r\nonLoad(){\r\n    app.loginCallback = () => {\r\n        this.init()\r\n    }\r\n}\r\n\r\n复制代码这种方式可以，而且具有页面控制的灵活性，但灵活性带来的就是出错的几率会增大很多\r\n2. 在login页面获取登陆的前一个页面，然后登陆完成后刷新前一个页面状态\r\nlogin.js\r\n\r\nwerequest.login().then(function(){\r\n    let pages = getCurrentPages();\r\n    let Page = pages[pages.length - 1];//当前页\r\n    let prevPage = pages[pages.length - 2];  //上一个页面\r\n    prevPage.onLoad()\r\n})\r\n复制代码个人比较提交这种方式，因为其他页面只需要处理自己的页面逻辑就可以作者：liuzimu链接：https://juejin.im/post/5be53958e51d450b3647e7ae"}
{"title": "微信小程序之店铺评分组件及vue中用svg实现的评分显示组件 ", "author": "Rolan", "pub_time": "2018-11-19 00:32", "article_content": "1.效果图微信中的可以点击及显示，但是，显示的话，在4.2分，4点多分的时候，显示的是半颗星vue中用的是svg实现，所以用的是占比的形式,可以有一点点的星星星图片2.微信实现店铺评分显示及商品评价星星展示子组件index.wxml，可以动态的控制星星的大小<!-- (size * stars.length + (size/2) * 4 + 20 )这里的话，是在可以点击的时候，加上了好评的字体的长度 -->\r\n<view class='starsBox' style='width:{{isClick?(size * stars.length + (size/2) * 4 + 20 ):(size * stars.length)}}rpx;height:{{size}}rpx;'>\r\n  <view class='stars' style='width:{{size * stars.length}}rpx;height:{{size}}rpx;'>\r\n    <block wx:for=\"{{stars}}\" wx:key=\"{{index}}\">\r\n      <image src=\"/images/{{item == 0 ? 'grayStar':item}}.png\" style='width:{{size}}rpx;height:{{size}}rpx;' data-index=\"{{index}}\" catchtap=\"computeScore\"></image>\r\n    </block>\r\n  </view>\r\n  <view wx:if=\"{{isClick}}\" class='text' style='font-size:{{size/2}}rpx;'>\r\n    <text wx:if=\"{{value=='0'}}\" class='pointText'>暂无评分</text>\r\n    <text wx:elif=\"{{value=='1'}}\" class='pointText'>差评</text>\r\n    <text wx:elif=\"{{value<'4'}}\" class='pointText'>中评</text>\r\n    <text wx:else class='pointText'>好评</text>\r\n  </view>\r\n</view>子组件index.wxss.starsBox{\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: flex-start;\r\n}\r\n.stars{\r\n  width: 150rpx;\r\n  height: 50rpx;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: flex-start;\r\n}\r\n.stars image{\r\n  width: 30rpx;\r\n  height: 30rpx;\r\n}\r\n.text{\r\n  color: #ccc;\r\n  margin-left: 20rpx;\r\n}子组件index.jsComponent({\r\n  properties: {\r\n    /* 显示有色星星的个数 */\r\n    value: {\r\n      type: Number,\r\n      value: 0,\r\n      /* 监听value值的变化 */\r\n      observer: function (newVal, oldVal, changedPath) {\r\n        this.init()\r\n      }\r\n    },\r\n    /* 设置星星大小 */\r\n    size: {\r\n      type: Number,\r\n      value: 30\r\n    },\r\n    /* 是否可点击，type为null表示值可以是任意类型 */\r\n    isClick: {\r\n      type: null,\r\n      value: false\r\n    }\r\n  },\r\n  attached() {\r\n    /* 组件生命周期函数，在组件实例进入页面节点树时执行 */\r\n    this.init();\r\n  },\r\n  data: {\r\n    stars: [0, 0, 0, 0, 0]\r\n  },\r\n  methods: {\r\n    init() {\r\n      let star = this.properties.value;\r\n      let stars = [0, 0, 0, 0, 0];\r\n      /* 图片名称，通过设置图片名称来动态的改变图片显示 */\r\n      for (let i = 0; i < Math.floor(star); i++) {\r\n        stars[i] = 'star';\r\n      }\r\n      if (star > Math.floor(star)) {\r\n        stars[Math.floor(star)] = 'halfStar';\r\n      }\r\n      for (let i = 0; i < stars.length; i++) {\r\n        if (stars[i] == 0) {\r\n          stars[i] = 'grayStar';\r\n        }\r\n      }\r\n      this.setData({\r\n        stars\r\n      })\r\n    },\r\n    /* 可点击时，用于计算分数 */\r\n    computeScore(e) {\r\n      let index = e.currentTarget.dataset.index;\r\n      let isClick = this.data.isClick;\r\n      if (isClick) {\r\n        let score = index + 1;\r\n        this.triggerEvent('compute', {\r\n          score\r\n        });\r\n      }\r\n    }\r\n  }\r\n})3.父组件中引用父组件index.wxml<view class=\"score\">\r\n    <view class=\"scoreItem\">\r\n        <score value=\"{{shopGrade}}\" size=\"46\" isClick=\"true\" bindcompute=\"computeGrade\" />\r\n    </view>\r\n    <view class=\"scoreItem\">\r\n        <score value=\"{{shopGrade1}}\" size=\"46\" />    \r\n    </view>\r\n</view>父组件index.json{\r\n    \"usingComponents\": {\r\n        \"score\": \"/component/score/index\"\r\n    }\r\n}父组件index.jsdata: {\r\n    shopGrade: 0,\r\n    shopGrade1: 4.6,\r\n},\r\n/* 评分处理事件 */\r\ncomputeGrade(e) {\r\n    let score = e.detail.score;\r\n    this.setData({\r\n        shopGrade: score\r\n    })\r\n},4.vue中使用svg实现评分首先在vue使用的index.html的模板文件中添加一个rem转换算法，因为我后面用的单位是rem/* 在头部添加 */\r\n<script type=\"text/javascript\">\r\n      document.getElementsByTagName(\"html\")[0].style.fontSize = 100 / 750 * window.screen.width + \"px\";\r\n    </script>然后添加svg.vue文件，这个svg文件可以自己找图片生成，并设置对应的id<template>\r\n    <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" style=\"position:absolute;width:0;height:0;visibility:hidden\">\r\n        <defs>\r\n            <symbol id=\"star\" viewBox=\"0 0 32 32\">\r\n                <path class=\"path1\" d=\"M16 26.382l-8.16 4.992c-1.5 0.918-2.382 0.264-1.975-1.435l2.226-9.303-7.269-6.218c-1.337-1.143-0.987-2.184 0.755-2.322l9.536-0.758 3.667-8.835c0.674-1.624 1.772-1.613 2.442 0l3.667 8.835 9.536 0.758c1.753 0.139 2.082 1.187 0.755 2.322l-7.269 6.218 2.226 9.303c0.409 1.71-0.485 2.347-1.975 1.435l-8.16-4.992z\">\r\n                </path>\r\n            </symbol>\r\n        </defs>\r\n    </svg>\r\n</template>\r\n<script></script>\r\n<style></style>rating.vue文件引用svg.vue<template>\r\n    <div class=\"ratingstar\">\r\n        <section class=\"star_container\">\r\n            <svg class=\"grey_fill\" v-for=\"(num,index) in 5\" :key=\"index\">\r\n                <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#star\"></use>\r\n            </svg>\r\n        </section>\r\n        <div class=\"star_overflow\" :style=\"'width:'+rating*2/10+'rem'\">\r\n            <section class=\"star_container\">\r\n                <svg class=\"orange_fill\" v-for=\"(num,index) in 5\" :key=\"index\">\r\n                    <use xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"#star\"></use>\r\n                </svg>\r\n            </section>\r\n        </div>\r\n        <svgIcon></svgIcon>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n  import svgIcon from '@/components/svg'\r\n  export default {\r\n    components: {\r\n      svgIcon\r\n    },\r\n    data() {\r\n        return {\r\n            rating: 4.2\r\n        }\r\n    },\r\n  }\r\n</script>\r\n<style lang=\"less\" rel=\"stylesheet/less\" scoped>\r\n    .ratingstar {\r\n        position: relative;\r\n        width: 100%;\r\n        .star_overflow {\r\n            overflow: hidden;\r\n            position: relative;\r\n            height: 0.65rem;\r\n        }\r\n        .star_container {\r\n            position: absolute;\r\n            top: 0.05rem;\r\n            width: 1rem;\r\n            display: flex;\r\n            justify-content: flex-start;\r\n            align-items: center;\r\n            .grey_fill {\r\n                width: 0.94rem;\r\n                height: 0.2rem;\r\n                fill: #d1d1d1;\r\n            }\r\n            .orange_fill {\r\n                width: 0.94rem;\r\n                height: 0.2rem;\r\n                fill: #ff9a0d;\r\n            }\r\n        }\r\n    }\r\n</style>都有用到组件，可以查看下方的推荐文章中的购物车中的父子组件传值正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断iOS和Android及PC端实现单行文字及多行文字的省略号微信小程序之购物车和父子组件传值及calc的注意事项纯css实现瀑布流（multi-column多列及flex布局）"}
{"title": "微信小程序多文件递归上传 ", "author": "Rolan", "pub_time": "2018-11-19 00:45", "article_content": "微信小程序官网社区有申明微信小程序无法多文件上传，所以要通过递归进行多文件上传。网上得上传例子都不满足我的要求，如下是我的代码，希望能给予参考。方法upload单文件上传 方法uploadFils多文件上传\r\n  export function uploadFils(url, filePathArr) {\r\n    return uploadFilsSync(url, filePathArr, 0, { success: [], fail: [] });\r\n  }\r\n\r\n  function uploadFilsSync(url, filePathArr, index, result) {\r\n    return upload(url, filePathArr[index++], {})\r\n      .then(res => {\r\n        result.success.push({ index: index, res: res });\r\n        if (index === filePathArr.length) {\r\n          return result;\r\n        } else {\r\n          return uploadFilsSync(url, filePathArr, index, result);\r\n        }\r\n      })\r\n      .catch(err => {\r\n        result.fail.push({ index: index, res: err });\r\n        if (index === filePathArr.length) {\r\n          return result;\r\n        } else {\r\n          return uploadFilsSync(url, filePathArr, index, result);\r\n        }\r\n      });\r\n  }\r\n  \r\n     export function upload(url, filePath, formData = {}) {\r\n    let header = { \"Content-Type\": \"multipart/form-data\" };\r\n    return new Promise((resolve, reject) => {\r\n      wx.uploadFile({\r\n        url: config.server + url,\r\n        header: header,\r\n        filePath: filePath,\r\n        name: \"file\",\r\n        formData: formData,\r\n        success(res) {\r\n          resolve(res.data);\r\n        },\r\n        fail: function(error) {\r\n          reject(error);\r\n        }\r\n      });\r\n    });\r\n  }\r\n  返回结果：index:第几个上传文件,res做为上传结果\r\n\r\n{\r\n    \"success\":[\r\n        {\r\n            \"index\":1,\r\n            \"res\":{\r\n                \"data\":\"123\"\r\n            }\r\n        }\r\n    ],\r\n    \"fail\":[\r\n\r\n    ]\r\n}"}
{"title": "批量生成100万张小程序码？了解一下 ", "author": "Rolan", "pub_time": "2018-11-20 00:01", "article_content": "最近有一个生成很多小程序码的需求，生成的小程序码还要嵌入在指定的图片模板上，就去找轮子，没找到合适的轮子。。无奈之下就决定去撸一个。目前已经完成并发布npm。Github： github.com/Jon-Millent…需求如下图生成带参数的小程序二维码要指定尺寸和位置到模板图上要批量生成若干张开始干活生成带参数的小程序二维码通过官方文档，列出了生成小程序二维码的三种模式createWXAQRCode 获取 小程序二维码 ，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制。官方说明getWXACode 获取 小程序码 ，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制。官方说明getWXACodeUnlimit 获取 小程序码 ，适用于需要的码数量极多的业务场景。通过该接口生成的小程序码，永久有效，数量暂无限制。官方说明这些接口都要通过 access_token 来换取。让我们造个类let AngerWechat = require('anger-wechat') // 微信操作辅助库（自己写的）\r\n\r\nclass miniQrcode {\r\n\r\n   // 存放三种模式的接口\r\n   constructor(config) {\r\n        this.mode = {\r\n          'getWXACode': 'https://api.weixin.qq.com/wxa/getwxacode',\r\n          'getWXACodeUnlimit': 'https://api.weixin.qq.com/wxa/getwxacodeunlimit',\r\n          'createWXAQRCode': 'https://api.weixin.qq.com/cgi-bin/wxaapp/createwxaqrcode',\r\n        }\r\n        \r\n        // 初始化微信辅助库\r\n        this.$wx = new AngerWechat({\r\n          appId: this.config.appId, // appId 必传\r\n          appSecret: this.config.appSecret, // appSecret 必传\r\n        })\r\n        \r\n        // 临时数据存放文件，用于存放access_token，因为access_token有2个小时的生存期，避免重复获取\r\n        this.databasePath = path.join(__dirname, '../', 'database.json')\r\n   }\r\n}\r\n复制代码实现核心方法// 生成核心方法\r\n    async getWxQrcodeInfo(concatConfig){\r\n        // 获取已经存放的文件里的access_token，如果有的话并且有效的话就不用再掉接口\r\n        let innerDatabase = this.getDatabase() \r\n        \r\n        // 如果本地的数据没有access_token 或者超过2个小时 就去请求获取\r\n        if(!innerDatabase.access_token ||  ((new Date().getTime() - innerDatabase.create_time) > 7200000) ) {\r\n            let accessInfo = await this.$wx.getGlobalAccessToken()\r\n            // 获取access_token然后写入文件\r\n            // 具体代码省略\r\n        }\r\n        \r\n        \r\n        // 获取到access_token去请求接口\r\n        \r\n        let qrcodeInfo  = await this.postMan(\r\n            this.getApiUrl(innerDatabase.access_token, concatConfig.mode), // 根据mode来区调用接口\r\n            concatConfig.config // 用户传的参数\r\n        )\r\n        \r\n        let returnData = {\r\n    \r\n        }\r\n    \r\n        if(qrcodeInfo.type.indexOf('image') !== -1) { //类型是图片的就是获取成功了\r\n          // 请求成功 保存图片\r\n          returnData = {\r\n            code: 200,\r\n            image: qrcodeInfo.data,\r\n            error: null\r\n          }\r\n        } else {\r\n          returnData = {\r\n            code: 500,\r\n            error: JSON.stringify(qrcodeInfo.data.toString()),\r\n            image: null\r\n          }\r\n        }\r\n    \r\n        return returnData\r\n    }\r\n复制代码写好后让我们测试一下let qrocode = new miniQrcode({\r\n      appId: 'xxx',\r\n      appSecret: 'xxx'\r\n    });\r\n    let info = await qrocode.getWxQrcodeInfo({\r\n\t  mode: 'getWXACode',\r\n\t  config: {\r\n\t    path: `pages/index/main?id=123456`\r\n\t  },\r\n\t})\r\n   fs.writeFileSync(`./output-juejin-test1.png`, info.image, 'utf8');\r\n复制代码效果：如何测试参数？我在这个已经发布的小程序里面加了个彩蛋，就是长按 红色圈出区域两次 即可调出控制台看参数将二维码合成到模板图片里面这个操作依赖于 sharp 库const sharp = require('sharp');\r\n\r\nclass miniSharp {\r\n\r\n  constructor(templateUrl){\r\n    this.templateUrl = templateUrl\r\n  }\r\n\r\n  // 重置图片大小\r\n  async resizeQrcode(imageBuffer, config){\r\n    return new Promise(resolve => {\r\n\r\n      sharp(imageBuffer).resize(config.width, config.width).toBuffer().then(function(outputBuffer) {\r\n        resolve(outputBuffer)\r\n      });\r\n\r\n    })\r\n  }\r\n  \r\n  // 合并图片\r\n  async concatImage(buffer, config){\r\n    return new Promise(resolve => {\r\n      sharp(this.templateUrl)\r\n        .overlayWith(buffer, {\r\n          top: config.top,\r\n          left: config.left\r\n        }).toBuffer().then(function(outputBuffer) {\r\n          resolve(outputBuffer)\r\n        });\r\n    })\r\n  }\r\n\r\n  // 主函数\r\n  async renderImage(qrcodeBuffer, config){\r\n\r\n    let resizeQrcodeBuffer = await this.resizeQrcode(qrcodeBuffer, config)\r\n    let concatQrocdeBuffer = await this.concatImage(resizeQrcodeBuffer, config)\r\n\r\n    return concatQrocdeBuffer\r\n  }\r\n\r\n}\r\n\r\nmodule.exports = miniSharp\r\n\r\n复制代码测试一下let qrocode = new miniQrcode({\r\n      appId: 'xxxx',\r\n      appSecret: 'xxx'\r\n    });\r\n    \r\n    let mySharp = new miniSharp('./template.png');\r\n\r\n    let info = await qrocode.getWxQrcodeInfo({\r\n      mode: 'getWXACode',\r\n      config: {\r\n        path: `pages/index/main?id=123456`\r\n      },\r\n    })\r\n    \r\n    let renderBuffer = await mySharp.renderImage(info.image, // 二维码图片的 buffer 数组 \r\n    { \r\n      width: 200, // 重新设置二维码宽度\r\n      left: 362, // x轴偏移\r\n      top: 53 // y轴偏移\r\n    })\r\n    \r\n    fs.writeFileSync(`./output-juejin-test1.png`, renderBuffer, 'utf8');\r\n复制代码批量处理正常情况下，批量生成 100 张需要 62.556秒 ，平均每张需要 0.62556秒 ，1万张大概需要 1.73小时 。 批量示例代码关于调试使用微信开发者工具可以进行模拟参数调试测试接口这里我提供了一个测试接口，可以带参数生成线上的小程序码，用来调试[get] http://wx.toolos.cc 参数mode 必传 [createWXAQRCode | getWXACode | getWXACodeUnlimit] 之一注意其他参数对应上面的文档的 mode 对应的参数， path 或者 page 需要 encodeURIComponent一下目前小程序只有一个路径 pages/index/main线上服务器配置低示例http://wx.toolos.cc/?mode=createWXAQRCode&path=pages%2Findex%2Fmain\r\n复制代码关于参数模式createWXAQRCode & getWXACode这两种生成的参数，生成二维码数量有限，参数直接跟在path路径后面，例如：let info = await qrocode.getWxQrcodeInfo({\r\n  mode: 'createWXAQRCode',\r\n  config: {\r\n    page: `pages/index/main?sgr=521314&i=loveyou`\r\n  },\r\n})\r\n复制代码getWXACodeUnlimit这个可以生成无限个，但是只能携带有局限性的参数 scene ，在这里推荐一种解析方式 key:value-key:valuelet info = await qrocode.getWxQrcodeInfo({\r\n  mode: 'getWXACodeUnlimit',\r\n  config: {\r\n    page: `pages/index/main`,\r\n    scene: 'i:loveyou-sgr:521314'\r\n  },\r\n})\r\n复制代码解析示例onLoad (query) {\r\n  // scene 需要使用 decodeURIComponent 才能获取到生成二维码时传入的 scene\r\n  this.scene = decodeURIComponent(query.scene)\r\n  this.queryJson = JSON.stringify(query)\r\n\r\n  // 尝试解析  scene 格式: shop:1-id:2\r\n\r\n  try {\r\n    let oneArr = this.scene.split('-')\r\n    let twoJson = {}\r\n    for(let i=0; i<oneArr.length; i++) {\r\n      let target = oneArr[i].split(':')\r\n      twoJson[target[0]] = target[1]\r\n    }\r\n    this.twoJson = JSON.stringify(twoJson)\r\n\r\n  } catch(e) {\r\n    this.twoJson = e\r\n  }\r\n\r\n},\r\n复制代码在开发者工具中例如下面模拟"}
{"title": "微信小程序在扫一扫进入小程序的时候 安卓手机后台继续运行的常规处理 ... ... ", "author": "Rolan", "pub_time": "2018-11-20 00:26", "article_content": "一般在扫一扫进入小程序是没什么问题的 关于这个话题就不多说 怎么去配置后台 我的博客里面有提到 有兴趣的可以去看看 现在是用户第一次扫码进入之后 退出小程序 在外部扫一扫进入小程序指定界面的时候 安卓手机就出现了一个问题 它会闪烁一下 返回的首页去 而不是我们想要的 因为安卓手机有一个常规的操作 就是微信小程序进入之后 用户退出了 实际它是没有退出的 而是后台挂起了 所以这个状态是没有改变的 所以你再次扫码的时候 它返回的首页直接代码展示吧.........................一扫我想要进入扫码后的界面  苹果手机是没问题  因为它不会给小程序后台运行一个窗口  主要是针对安卓手机以上的代码写法没有错的  就是安卓手机出来第一次可以  在进入就不可以了  或者退出微信  或者把后台窗口关闭就可以   其实只需要添加一句代码就好了  setTimeout((=>{需要跳转的页面}),800)  加多一个延时就好  也可以说模拟一个请求:     这样就可以实现了   觉得好的点一下赞  写的文采不怎么好 哈哈"}
{"title": "「医院 LBS 位置服务」插件：输出LBS室内位置能力，为改善就医服务提供解决方案 ... ", "author": "Rolan", "pub_time": "2018-11-20 00:34", "article_content": "上期，我们在《「腾讯地图」微信小程序插件：提供简单的路线多方案规划服务》一文中介绍了「腾讯地图」小程序插件的意义、使用场景以及使用方法。今天我们会与大家分享一款同样优秀的小程序插件——「医院 LBS 位置服务」插件，从使用场景到使用方法，都将作出详细的介绍。「医院 LBS 位置服务」插件能做什么？去医院看病，找路和排队绝对算是就医过程中最让人头痛的事情，医院科室布局复杂，检查项目繁多，排队更是家常便饭。如果能有一个办法能让患者最快速的找到看病的科室，甚至能在整个就诊过程中规划一条走路少、时间短、排队快的路线，而且在到达相应科室后能够直接用手机在线报到，相信很多患者对医院都会有这样的需求。近日，专注于医疗行业室内外位置服务的道一循新上线了「医院 LBS 位置服务」微信小程序插件，为广大医疗行业小程序开发者提供快速、便捷的 LBS 室内位置能力输出，为上述改善医院患者的就医服务提供了真实的解决方案。「医院 LBS 位置服务」插件提供医院位置信息接口，将医院院内各类科室、设施的位置数字化后提供给小程序使用。通过此插件，小程序开发者即可调用道一循覆盖医院的室内位置信息。目前，已有近 50 家全国百强三甲医院上线道一循院内位置服务系统。「医院 LBS 位置服务」插件的使用场景「医院 LBS 位置服务」插件为各种医疗行业小程序应用提供位置信息输出，支持各类基于位置的应用场景。例如：1. 在线签到：通过「医院 LBS 位置服务」插件判断患者是否在院内科室附近，若在科室附近则直接通过小程序完成自助报到，并进入排队系统等待叫号；2. 最佳就医路径管理：「医院 LBS 位置服务」插件可以为医院统一预约管理系统提供患者实时位置信息，对需要同时执行多项医疗步骤（例如抽血、B 超、心电图等）的患者，配合排队等候信息，合理规划出最佳就医路线；3. 考勤签到：为医护人员的考勤管理系统、会议会诊系统提供位置签到服务；4. 一键告警：针对「医闹」等突发事件，还可利用集成了「医院 LBS 位置服务」插件的小程序快速报警，立即提供事件发生位置，方便安保人员及时处置。如何接入「医院 LBS 位置服务」插件？开发者在小程序插件中搜索「医院 LBS 位置服务」可以搜索到小程序插件，添加使用后按使用文档接入使用：1.申请使用插件。在「小程序管理后台 - 设置 - 第三方服务 - 插件管理」中查找插件名称「医院 LBS 位置服务」（目前最新版本：1.0.6，appid:wx0fb39a1dc27c5e6d），并申请使用。2.引入插件代码后修改配置文件 JSON：{\r\n  \"plugins\": {\r\n    \"ipsPlugin\": {\r\n      \"version\": \"1.0.4\",\r\n      \"provider\": \"wx0fb39a1dc27c5e6d\"\r\n    }  }}3. 使用插件的 JS 接口。如果需要使用插件的 JS 接口，可以使用 requirePlugin 方法：var ipsPlugin = requirePlugin(\"ipsPlugin\")//设置appkey和mapid//ipsDemo提交审核测试时为true，正常使用下为false。ipsDistance为自身位置与目的id的距离设定，如果在同层大于这个距离则出出现导航页面，如果小于这个距离则表示报到成功，出现报到成功页面。ipsPlugin.init({ ipsDemo: false, ipsAppKey: 'fnAs1mE5HP', ipsMapId: 'VhsehJzuZA', ipsDistance: '25'});//设置导航目的idipsPlugin.init({ ipsTargetId: '1111' });\r\n\r\nipsPlugin.init({//报到成功回调ipsReportSuccess: () => {  console.log('报到 成功')  //when success to do...\r\n  },  //点击导航按钮跳转道易寻小程序进行导航回调\r\n  ipsNavi:()=>{    console.log('跳转道易寻小程序进行导航')\r\n    wx.navigateToMiniProgram({\r\n      appId: 'wx0fb39a1dc27c5e6d',      //路径参数由mapId、appKey、要导航的科室id组成\r\n      path: 'pages/index?id=mapId&appKey=appKey&poi=科室id',\r\n    })\r\n  },  //距离目标位置较远或不在同一楼层的回调，用于显示navigator控件去跳转小程序。（由于插件内部无法跳转小程序）\r\n  ipsNeedNavi:()=>{    console.log('需要报到')\r\n  }\r\n});//打开弹框，开启报到  写在需要报道的地方ipsPlugin.open();4. 使用插件的自定义组件。使用插件提供的自定义组件，和使用普通自定义组件的方式相仿。在 JSON 文件定义需要引入的自定义组件时，使用 plugin:// 协议即可，例如：{\r\n  \"usingComponents\": {\r\n    \"show\": \"plugin://ipsPlugin/show\"\r\n  }}在 WXML 文件中添加如下代码，就可以愉快地使用插件进行报道功能了：<show />「医院 LBS 位置服务」插件使用实例目前，「医院 LBS 位置服务」小程序插件已经应用于「道易寻」、「浙江大学医学院附属儿童医院」等小程序，并且更多的开发中的医院小程序也在集成计划当中。在「浙江大学医学院附属儿童医院」小程序中，医院官方小程序通过调用「 医院 LBS 位置服务」插件实现了「在线签到」等功能。1. 使用微信小程序挂号成功后进入功能页面2. 小程序通过「医院 LBS 位置服务」插件识别用户不在就诊科室附近，不能完成报到。3. 使用院内导航引导至就诊科室。4. 小程序通过「医院 LBS 位置服务」插件识别用户已到科室附近，可以进行报到。5. 自动进入排队系统进行排队。如果你想了解更多「医院 LBS 位置服务」插件详情，欢迎访问开发者社区插件版块相应页面（建议电脑访问）："}
{"title": "微信小程序云端解决方案教程四：视频应用场景 ", "author": "天下雪", "pub_time": "2016-10-15 17:12", "article_content": "部署和运行整体架构1. 准备域名和证书2. Nginx 和 Node 代码部署3. 配置 HTTPS4. 域名解析5. 开通 点播服务6. 准备 云数据库MySQL7. 启动新片预告示例 Node 服务8. 启动新片预告 Demo主要功能实现获取视频列表、展示评论、提交评论播放视频新片预告是结合腾讯云点播 VOD和云数据库 MySQL制作的一个微信小程序示例。在代码结构上包含如下两部分：app: 新片预告应用包代码，可直接在微信开发者工具中作为项目打开server: 搭建的Node服务端代码，作为服务器和app通信，提供 CGI 接口示例用于拉取云数据库上的视频列表、评论列表，将评论数据提交到云数据库新片预告主要功能如下：支持分页滚动加载视频列表点击海报跳转至详情页播放视频对视频进行评论展示视频的评论列表部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构1. 准备域名和证书在微信小程序中，所有的网路请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP 中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个 SSL 证书。腾讯云提供域名注册和证书申请服务，还没有域名或者证书的可以去使用域名注册好之后，可以登录微信公众平台配置通信域名了。注意：需要将 www.qcloud.la 设置为上面申请的域名2. Nginx 和 Node 代码部署小程序服务要运行，需要进行以下几步：部署 Nginx，Nginx 的安装和部署请大家自行搜索（注意需要把 SSL 模块也编译进去）配置 Nginx 反向代理到 http://127.0.0.1:9994Node 运行环境，可以安装 Node V6.6.0部署 server 目录的代码到服务器上，如 /data/release/qcloud-applet-video使用 npm install 安装依赖模块使用 npm install pm2 -g 安装 pm2上述环境配置比较麻烦，新片预告的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，推荐大家直接使用。镜像部署完成之后，云主机上就有运行 WebSocket 服务的基本环境、代码和配置了。腾讯云用户可以免费领取礼包，体验腾讯云小程序解决方案。镜像已包含所有小程序的服务器环境与代码，需要体验小程序的朋友无需重复部署3. 配置 HTTPS镜像中已经部署了 nginx，需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx\r\n4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 开通 点播服务新片预告示例的播放资源是存储在 腾讯云点播 上的mp4文件，要使用 点播 服务，需要登录 点播 管理控制台，然后在其中完成以下操作：上传视频资源，点播几乎支持所有主流的视频格式上传转码成功后获取mp4或m3u8源地址目前微信小程序video组件经测试支持mp4和m3u8格式，其中 m3u8 格式只能在手机上使用，开发者可以使用腾讯云点播控制台将视频源转码成 mp4 或 m3u8 格式，并且腾讯云点播会对播放的资源进行CDN加速。6. 准备 云数据库MySQL示例中拉取的视频和评论列表都是存储在 云数据库 上，要使用 云数据库 服务需要完成以下操作购买，注意购买的云数据库需要与云服务器同在一个地域分区初始化流程，本示例选用的是utf8编码点击云数据库 控制台操作栏的登录按钮，登录到phpMyAdmin创建数据库并在当前数据库中导入本示例中的SQL文件注意：导入SQL文件中包含了 点播 上传的视频列表，开发者可以基于云数据库自行开发维护一个视频发布管理系统，因为此内容跟本示例暂不相关，所以不再详述。7. 启动新片预告示例 Node 服务在镜像中，新片预告示例的 Node 服务代码已部署在目录/data/release/qcloud-applet-video下：进入该目录：cd /data/release/qcloud-applet-video\r\n在该目录下有个名为config.js的配置文件（如下所示），按注释修改对应的 MySQL 配置：module.exports = {\r\n    // Node 监听的端口号\r\n    port: '9994',\r\n    ROUTE_BASE_PATH: '/applet',\r\n\r\n    host: '填写开通 MySQL 时分配的内网IP',\r\n    user: '填写MySQL用户名',\r\n    password: '填写MySQL密码',\r\n    database: '填写上一步中创建的MySQL数据名',\r\n};\r\n示例使用pm2管理 Node 进程，执行以下命令启动 node 服务：pm2 start process.json\r\n8. 启动新片预告 Demo在微信开发者工具将新片预告应用包源码添加为项目，并把源文件config.js中的通讯域名修改成上面申请的域名。然后点击调试即可打开新片预告Demo开始体验。主要功能实现获取视频列表、展示评论、提交评论通过node的mysql模块连接mysql，进行查询，插入操作以下是查询评论列表的示例代码const mysql = require('mysql');\r\nconst config = require('../../../config');\r\n\r\nlet vid = this.req.query.vid;\r\nif (!vid) {\r\n    this.res.json({ code: -1, msg: 'failed', data: {} });\r\n    return;\r\n}\r\n\r\n//CDB Mysql配置\r\nlet connection = mysql.createConnection({\r\n    host: config.host,\r\n    password: config.password,\r\n    user: config.user,\r\n    database: config.database\r\n});\r\n\r\n//开启数据库连接\r\nconnection.connect((err) => {\r\n    if (err) {\r\n        this.res.json({ code: -1, msg: 'failed', data: {} });\r\n    }\r\n});\r\n\r\n//查询列表\r\nconnection.query('SELECT * from comment where vid = ? order by id desc', [vid], (err, result) => {\r\n    if (err) {\r\n        this.res.json({ code: -1, msg: 'failed', data: {} });\r\n        return;\r\n    }\r\n\r\n    this.res.json({\r\n        code: 0,\r\n        msg: 'ok',\r\n        data: result,\r\n    });\r\n});\r\n\r\n//查询完后关闭连接\r\nconnection.end();\r\n播放视频<video src=\"{{videoUrl}}\" binderror=\"videoErrorCallback\"></video>\r\n属性名类型说明srcString要播放视频的资源地址binderrorEventHandle当发生错误时触发error事件，event.detail = {errMsg: 'something wrong'}播放视频使用的是video标签，目前官方文档上只给出了两个参数说明，笔者测试了src支持加载mp4和m3u8格式视频，video标签的控制条暂时没办法自定义样式以及隐藏"}
{"title": "Code4Android：微信小程序体验历程：我遇到的问题及解决方法 ", "author": "天下雪", "pub_time": "2016-10-17 10:20", "article_content": "因为自己对小程序也是很有兴趣的，感觉是很有意思的一个东西，所以以QQ练手，做一个高仿QQ的微信小程序，由于本人是Android开发者，平时很少接触前端的一些东西，水平有限，所以代码很多地方是不规范的，做的过程也就是一个学习的过程，一个提高的过程。\r\n这篇文章主要写我在SmallAppForQQ这个项目进展的过程中遇到的一些问题。如果阅读此文的你有一定帮助，很是欣慰，欢迎star项目。\r\n\r\nSmallAppForQQ源码\r\n开发工具\r\n官方demo\r\n\r\n项目结构\r\n文章开头，先简单介绍下项目结构，若没有安装开发工具，可去GitHub:https://github.com/xiehui999/SmallAppForQQ下载。微信小程序项目结构主要有四个文件类型,如下\r\n\r\n\r\nWXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。\r\n\r\n\r\nWXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，\r\n\r\n\r\njs 逻辑处理，网络请求\r\n\r\n\r\njson  小程序设置，如页面注册，页面标题及tabBar。\r\n\r\n\r\n注意：为了方便开发者减少配置项，规定描述页面的这四个文件必须具有相同的路径与文件名。\r\n在根目录下用app来命名的这四中类型的文件，就是程序入口文件。\r\n\r\napp.json必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航条样式，配置默认标题。\r\n\r\napp.js必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。\r\n\r\n\r\napp.wxss全局配置的样式文件，项目非必须。\r\n\r\n\r\n知道小程序基本文件结构，就可以开始研究官方demo了，研究过程中如果有不明白的地方可以去官方文档寻求答案，如果找不到答案或者有疑问，可再此博客留言，相互交流。下面介绍下出现概率较高的几个问题。\r\n常见问题\r\nrpx（responsive pixel）\r\n微信小程序新定义了一个尺寸单位，可以适配不同分辨率的屏幕，它规定屏幕宽为750rpx，如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。\r\n这里写图片描述\r\n\r\n这个项目我用的都是rpx尺寸单位，期间遇到一个很奇葩的问题。在相邻的两条信息直接都会有一个分割线，我将线的高度都设置成1rpx,但是不有个别分割线是不显示的，如下图\r\n这里写图片描述\r\n\r\n看到没在第一条和第二条直接并没有现实这条线，但是其他的都展示了，分割线的属性是一样的，而且在不同的手机上（分辨率不同）不显示的分割线也是不同的，有的分辨率好几条分割线都不显示，不知道这是模拟器的bug还是rpx的bug。最后分割线的高度尺寸单位使用了px,解决了这个问题。\r\n40013错误\r\n这里写图片描述\r\n\r\n在微信小程序刚出来的时候如果输入AppID提示这个信息就表示没有破解，但是现在官方软件更新可以选择无AppID开发，如下图，我们之间选择无AppID，即可解决此错误。建议安装官方开发工具。可去此处找下载链接。\r\n这里写图片描述\r\n\r\n-4058错误\r\n微信小程序创建项目时选择无AppID，创建项目时会生成app.json，app.josn是程序启动最重要的文件，程序的页面注册，窗口设置，tab设置及网络请求时间设置都是在此文件下的。如果你创建的项目目录下没有app.json文件就会报下面的错误。\r\n这里写图片描述\r\n\r\n我们看到上面的错误信息中有个数字-4058，这应该是初入微信小程序遇到最多的错误了，这种一般都是文件缺失，后面有个path，可以对着该路径看看是否存在这个文件。造成这种错误的原因一般都是创建项目选择的目录不正确，或者在app.json注册了一个不存在的页面。当然还有一种情况就是在app.json文件的pages注册的页面是没有创建的，或者你删除了某个页面，但是没有取消注册也会是-4058错误。\r\nPage注册错误\r\n这里写图片描述\r\n\r\n这个错误可能很容易理解，页面注册错误。页面是通过Page对象来渲染的，每个页面对应的js文件必须要创建page，最简单的方式就是在js文件下写入Page({})，在page中有管理页面渲染的生命周期，以及数据处理，事件都在这完成。这个错误引起的原因一般都是刚创建页面，js文件还有有处理或者忘了处理。所以要养成创建页面的同时在js文件先创建Page的习惯.\r\nPage route错误\r\n这里写图片描述\r\n\r\n字面意思就是页面路由错误，在微信中有两种路由方式一种是在wxml文件使用<navigator />组件，一种是调用wx.navigateTo。如下代码：\r\nwxml文件：\r\n<navigator url=\"search/search\">\r\n<view class=\"serach_view_show\" bindtap=\"bindtap\"> 搜索</view>\r\n</navigator>\r\njs文件事件处理函数：\r\n  bindtap:function(event){\r\nwx.navigateTo({\r\n  url: \"search/search\"\r\n})\r\n  }\r\n如果你这样写的话，恭喜你，你就会看到上面提示的错误，这是因为重复调用路由引起的，处理方法就是删除一个路由，删除<navigator />组件或者删除wx.navigateTo。除了上面说的可能导致路由错误外，还有一种情况，类似于下面的代码\r\n<navigator url=\"search/search\">\r\n<navigator url=\"search/search\">\r\n<view class=\"serach_view_show\" bindtap=\"bindtap\"> 搜索</view>\r\n</navigator>\r\n</navigator>\r\n这种也是不允许的，也就是说<navigator/>组件内部不能再嵌套<navigator/>组件。它只能是单层存在的。\r\nDo not have * handler in current page.\r\n这里写图片描述\r\n\r\n大概意思就是当前页面没有此处理，让确定是否已经定义，还指出了错误出现的可能位置pages/message/message,其实这种问题出现一般就是我们在wxml定义了一些处理事件，但是在js文件中没有实现这个时事件的处理方法，就会出现这个错误。那么我们按提示在js文件加上事件处理，如下代码，加上后就不会再有此错误提示。\r\n  bindtap:function(event){\r\nwx.navigateTo({\r\n  url: \"search/search\"\r\n})\r\n  },\r\ntabBar设置不显示\r\n对于tabBar不显示，原因有很多，查找这个错误直接去app.json这个文件，最常见的也是刚学习微信小程序最容易犯的错误无外乎下面几种\r\n注册页面即将页面写到app.json的pages字段中，如\r\n \"pages\":[\r\n\r\n    \"pages/message/message\",\r\n    \"pages/contact/contact\",\r\n    \"pages/dynamic/dynamic\",\r\n     \"pages/dynamic/music/music\",\r\n    \"pages/index/index\",\r\n    \"pages/logs/logs\"\r\n  ]\r\n\r\n\r\ntabBar写法错误导致的不显示，将其中的大写字母B写成小写，导致tabBar不显示。\r\n\r\n\r\ntabBar的list中没有写pagePath字段，或者pagePath中的页面没有注册\r\n\r\n\r\ntabBar的list的pagePath指定的页面没有写在注册页面第一个。微信小程序的逻辑是\"pages\"中的第一个页面是首页，也就是程序启动后第一个显示的页面，如果tabBar的list的pagePath指定的页面都不是pages的第一个，当然也就不会电视tabBar了。\r\n\r\n\r\ntabBar的数量低于两项或者高于五项，微信官方中明确规定tabBar的至少两项最多五项。超过或者少于都不会显示tabBar。\r\n\r\n\r\nnavigationBarTitle显示问题\r\n这里写图片描述\r\n\r\n 通过这个动态图你应该发现问题了，当点击音乐进入音乐界面时，title先显示了WeChatForQQ然后显示的音乐，这个体验肯定是难以接受的，原因是音乐界面的title是在js文件中page的生命周期方法中设置的。 若你不了解生命周期，可以点击查看\r\nPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n    //NavigationBarTitle如果此处和json文件都设置，最后展示此处的标题栏\r\nwx.setNavigationBarTitle({\r\n  title: '音乐'\r\n})\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})\r\n通过注释你应该明白了，设置标题写在了onReady方法中，也就是页面已经渲染完成了，在onReady之前显示的title就是json文件（覆盖关系，如果在子页面json文件设置title会覆盖app.json全局设置）中的title。可能你会说将wx.setNavigationBarTitle写在onLoad函数中，不过如果这样设置是不对的，因为onLoad执行过后才渲染页面，在渲染页面时title会从json文件中读取，导致onLoad设置的title会只在页面渲染之前展示，之后就显示json文件的tile，所以现在你应该明白ttle设置最优的地方就是给子文件写一个json文件，在文件中写入，如果想改变颜色直接在文件中添加就可以，该文件所写的属性值会覆盖app.json中设置的值。\r\n{\r\n    \"navigationBarTitleText\": \"音乐\"\r\n}\r\nwx.navigateTo无法打开页面\r\n一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。请避免多层级的交互方式，或者使用wx.redirectTo\r\n本地资源无法通过 css 获取\r\nbackground-image：可以使用网络图片，或者 base64，或者使用<image/>标签\r\n页面间数据传递\r\n微信小程序路由（页面跳转）是通过API wx.navigateTo或者wxml中<navigator/>组件实现的，不管哪种实现都会有一个重要的参数就是url，它指定了要跳转的页面，并且页面之间数据传递也是通过url来实现的，这个数据传递有点类似于我们使用的get网络请求，把参数都拼接在要跳转界面地址的后面并以“？”连接。然后将要传入的数据以键和值的形式追加在\"?\"后面，多个参数直接用\"&\"符合。如我们点击消息聊天记录，将列表上的数据传到下一个页面，可以这样写。\r\n <navigator url=\"/pages/dynamic/dynamic?title={{item.title}}&message={{item.message}}\">\r\n          <view class=\"item\" >\r\n             <view class=\"item-left\">\r\n                  <image src=\"{{item.url}}\" class=\"image\"/>\r\n             </view>\r\n             <view class=\"item-middle\">\r\n                  <view>\r\n                       <text class=\"title\">{{item.title}}</text>\r\n                  </view>\r\n                  <view>\r\n                      <text class=\"message\">{{item.message}}</text>\r\n                  </view>\r\n            </view>\r\n            <view class=\"item_right\">\r\n                <view><text class=\"time\">{{item.time}}</text></view>\r\n                <view class=\"mark\" wx:if=\"{{item.count>0}}\"><text class=\"text\">{{item.count}}</text></view>\r\n            </view>\r\n         </view>\r\n         <view  class=\"line\"></view>\r\n       </navigator>\r\n而数据接收是在js文件的page里接收的，page生命周期有一个onLoad函数，它就是做一些初始化数据的工作，onLoad函数有一个参数options，我们就可以通过key将数据获取，如下\r\nPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n    isHiddenToast:true\r\n  }\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n    console.log(options.title)\r\n     console.log(options.message)\r\n\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  },\r\n  bindtap:function(event){\r\nwx.navigateTo({\r\n  url: \"/pages/message/search/search\"\r\n})\r\n  },\r\n})\r\n这样就实现了页面间数据传递功能。\r\n好了，今天就写到这了后期若遇到微信小程序其它一些问题，我会追加到此文，若你在开发过程中遇到比较坑的问题已经解决方案，可在本文评论，方便大家。谢谢支持。"}
{"title": "lypeer：一名Android开发者的微信小程序填坑之路《上》 ", "author": "天下雪", "pub_time": "2016-10-17 11:05", "article_content": "前言首先要声明的是，我是一名 Android 开发者，之前基本没有前端开发经验，甚至连 JS ，HTML 都是为了开发小程序现学的一些皮毛——所以文章中所提到的一些点也许在资深前端开发者看来只是小case，但是站在一个 Android 开发者的角度来看确实是大坑。前面就不说太多东西了，文章的末尾再谈谈我对小程序的一些看法——这篇文章主要是谈谈在开发小程序的过程中遇到的一些坑。PS：推荐一下我写的一个微信小程序版的Gank客户端：wechat-weapp-gank正文1，获取小程序开发工具并正确安装？最近在一些地方看到很多人在入小程序坑的第一步就出现了很多的问题，其实很早之前（22号）关于怎样搞定小程序的开发工具就已经有比较好的资料了，大家可以直接去看一下然后照着做，基本上就没啥问题：获取小程序开发工具并正确安装的教程2，直接在微信开发工具上写代码？目前来讲，我们只能在微信的开发工具上编译小程序的代码，但是这并不意味着我们必须要在那个开发工具上写小程序的代码——用过那个开发工具的人就会知道，那个开发工具并没有多好用，代码提示挺弱鸡的，而且没有自动保存是硬伤。那么怎么办呢？我们完全可以在别的工具里面写代码然后在小程序的开发工具里面编译。我试过 sublime 和 webstorm ， 都是可以在上面开发的，但是最后还是发现 ws 更好用。我就不讲 sublime 怎么用了，大家只需要直接在里面打开项目文件夹然后点右下角选择当前的语言就可以了。接下来着重讲一讲如何在 ws 里面编写小程序代码。首先选择小程序的目录在 ws 里面打开，这是很简单的。但是这个时候打开里面的文件之后你会发现，除了 js 代码它能认出来之外，其他的代码他都并不能够认出来——主要是 .wxml 和 .wxss 文件。为什么呢？因为虽然 .wxml 和 .html 文件很像，.wxss 文件和 .css 文件很像，但是编译器并不知道！这样一来，我们就无法在这两种文件里面享受 ws 强大的代码提示功能了——我们能接受这种事么？果断不能！那么接下来我们应该怎么办呢？告诉编译器，.wxml 格式的其实是 HTML 文件，.wxss 格式的其实是 CSS 文件。上图把做这件事的流程讲的很详细了，.wxss 文件的转化同理。这样做了之后，编辑器就会知道他们的真实面目，然后就可以有棒棒的代码提示了（但是请注意，有写微信自己写的东西编辑器不仅没有代码提示反而会报错，不管他就好了）！接下来就可以直接 ws 一个桌面小程序开发工具一个桌面，在 ws 里面写了代码直接划过去点编译了。3，跳转page的时候怎么传递数据？小程序给我们开放了很好的接口来进行页面之间的跳转：但是在这个地方微信官方对于这一个接口并没有太多的描述，只是简简单单的给了我们一行代码：wx.navigateTo({url: \"test ? id = 1\"}); ，其实这里这样写是有些难以理解的——test 是个什么鬼 ? id 是个什么鬼？中间那个问号是个什么鬼？这都是些什么鬼？反正我看到的时候是一头雾水的。不过还好，经过一些摸索，终于知道了他们是啥。首先，代码里的 test 代表要跳转到的 page 的url 地址。比如：那么代码就应该是：wx.navigateTo({url: \"/pages/specific/specific\"});11聪明的人可能已经发现了，上面的代码没有了示例代码里面 ? id = 1 的部分，怎么回事，是我写错了么？并不是。这一部分其实是跳转 page 时用来传值的关键方法，并不必需，但很有用。* ? 是一个分隔符一样的东西，它的后面就是所有要传到目标 page 的值。而这些值是通过键值对来一一对应的，每个键值对之间用 & 隔开。但是要注意的是，似乎这种方式传值只能传 String 过去，不是 String 类型的值传过去之后也会被转化为 String 。*比如，我传了个 array 和 json 过去：var arrayData = [\"firstData\" , \"secondData\"];\r\nvar jsonData = {first: \"firstData\" , second: \"secondData\"};\r\nwx.navigateTo({url: \"/pages/specific/specific ? data: \" + arrayData + \"&json=\" + jsonData});结果目标page里接受到的是：//目标page的onLoad方法\r\nonLoad: function (options) {\r\n        //结果是：firstData , secondData\r\n        console.log(options.data);\r\n        //结果是：f\r\n        console.log(options.data[0]);\r\n        //结果是：[object Object]\r\n        console.log(options.json);\r\n        //结果是：undefined\r\n        console.log(options.data.first);\r\n\r\n        //很显然，被转化了  \r\n}上面其实也演示了如何在目标 page 里面接收传过来的数据，直接在 onLoad() 里面的 options 取就可以了。另外，其实更多的时候我们的需求并不是直接传一个固定的参数到目标 page 里面去，而是根据用户的一些操作传递不同的值到目标 page 里面去，这个时候该怎么办呢？要知道，我们是没有办法获得组件的（这点太坑了，没有 window 和 document）。这个时候，我们可以通过 dataset 来通过绑定组件数据达到目的。什么？你不知道 dataset 是什么东西？多读书，多看报，多看文档少睡觉。4，某些图片无法加载？这个坑真的是深坑，可能很久很久都不会遇到，但是一旦遇到真的很蛋疼。我拿来练手的项目是 Gank.io 的客户端，而 Gank 网站上的图片都是寄放在新浪图床上的，默认的存储的 url 是http://ww{1 || 2 || 3 || 4}.xxxxx.xxxxx.jpg，然后在小程序里死活都加载不出来这些图片！！！我一开始不知道到底是小程序的 <image> 标签的问题还是图片的问题，就找了很多地方的图片来做测试，包括 CSDN 上的，简书上的，github 图床上的，结果是这些图片都可以正常显示——甚至新浪微博上的，一些人的头像，都可以显示！后来我发现，只要 URL 是 ww+数字 开头的图片，都不能正常的显示！这也太坑了。。。后来我就在思考怎么解决这个问题——要么改变 标签，他自身肯定是有问题的，可能对某些来源的图片不太友好；要么改变图片，让它去适应这个 标签。这两方面要改其实都挺难的，但是显然第一种方式基本上是不可能的，就只能在第二种方式上去下功夫。最后经过不断地尝试，我总结了很多规律，最后通过把图片的 URL 由 ww+数字变成 ws+数字 解决了这个问题，让图片得以显示在小程序上。比如：本来的URL：\r\nhttp://ww1.sinaimg.cn/large/610dc034jw1f87z2n2taej20u011h11h.jpg\r\n变换之后的URL：\r\nhttp://ws1.sinaimg.cn/large/610dc034jw1f87z2n2taej20u011h11h.jpg不要问我为什么这样改了就可以显示了，因为我也不知道。。。太神奇了。。。5，this.setData() 显示没这个方法？首先想要说的是，作为一个 Android 开发者，我非常不适应小程序的数据与控件绑定的方式。在 Android 开发的时候，我们是可以直接获得控件然后对控件做数据绑定的工作的，而在小程序里，我并不能够直接获得控件的对象，所有的数据绑定与动态修改只能通过维护 Page 里面的 data{} 以及调用setData() 方法来进行，我不好评判这两种方式的优劣，只能说真的很不习惯。但是有些和我一样以前没怎么接触过前端开发的朋友在做这个的时候就有可能会踩坑了——setData() 是 Page 这个层级上的方法，并不是在任何地方调用 this.setData() 方法都可以顺利的得到我们预期的结果的。比方说：Page({\r\n    onLoad: function (options) {\r\n        wx.request({\r\n            url: Constant.GET_URL,\r\n            success: function (res) {\r\n                this.setData({...});\r\n            }\r\n        });\r\n    },\r\n});我在 wx.request() 的回调接口里面 success() 里面写 this.setData({...})，就不能完成预期操作，程序会报错说没有 setData() 这个方法，因为这个时候 this 获取到的已经并不是 Page 了，上下文已经发生了变化，那么当前层级没有 setData() 方法就很正常了。那么怎么解决这个问题呢？像这样：Page({\r\n    onLoad: function (options) {\r\n        that = this;\r\n        wx.request({\r\n            url: Constant.GET_URL,\r\n            success: function (res) {\r\n                that.setData({...})\r\n            }\r\n        });\r\n    },\r\n});\r\n\r\nvar that;和一开始的区别在于多了一个全局变量 that，并且在 onLoad() 方法里面对它进行了赋值，使它等于 this。这样的话，我们就可以在这个 Page 的任何地方调用 that.setData() 来动态的改变控件的属性了。结语本来是还有一些问题要谈一谈的，但是写到这里篇幅已经挺长的了，就干脆把其他的放到下一篇里面算了。剩下的问题还有：后台接收数据需要表单？小程序并不能很方便的获得数据的表单，甚至 <form>标签获得的数据也不是。解析 HTML 块？没有document，没有window，解析它简直是一种折磨。<form/> 里面无法获取 <picker/> 的取值？明明文档里有说在 <form/> 里面是可以支持 <picker/> 的，结果你会发现死活无法获得他的值。要实现多层列表？有的时候也许需要在一个列表项的每一项下面又有一个子列表，在小程序里怎么做？如何方便愉快的实现类似 Java 里面的静态变量的效果？没有一个专门的类存放 static final 的值供其他地方使用感觉全身都不自在。接下来我想谈一下我对小程序的看法。第一点，不管小程序能不能在未来的时间里在移动端大放异彩，学习它，掌握它，都是没有任何坏处的。第二点，就目前的版本而言，小程序的表现让我有些失望——实在是太过封闭。开发小程序就感觉像是在微信给我们划定的一个小圈子里兜兜转转，在圈里也许我们能得到很良好的开发体验，但是一步都出去不得。第三点，在性能与便捷之间，最终往往会是便捷取胜。第三点，能用 js 开发的，最终都会用 js 开发。多谢各位看官看到这，顺便去点个star吧：wechat-weapp-gank"}
{"title": "lypeer：一名Android开发者的微信小程序填坑之路《下》 ", "author": "天下雪", "pub_time": "2016-10-17 11:12", "article_content": "上一篇是九月二十七日写的，而这一篇我动笔的时间是十月十日（特殊的日子），中间相隔十三天——当然是因为国庆节。说老实话，这十三天里面我都没有碰和小程序有关的东西——毕竟学习小程序的开发也只是起于兴趣，而平时的工作并不会涉及与其相关的东西——但是在这十三天里，我能明显的感受到小程序热正在逐渐的消退，或者说大家正在逐渐以一种较为平和的姿态接受它的存在，其实这是一件好事。期待公测的到来。接下来我就直接进入正题了，另外，文末我想和大家分享一下我的国庆节。PS：这篇文章是接着上一篇文章 一名Android开发者的微信小程序填坑之路《上》 写的，建议没看过上一篇文章的同学先看一下上一篇哈~正文6，后台接收 post 请求要表单？首先问题是：我要向后台 post 一些数据，但是后台需要接收一个表单，我应该怎样获得一个表单或者将本地的数据转换成一个表单呢？在写 wechat-weapp-gank 的提交干货模块的时候，我就遇到了这个问题。一开始我挺纳闷的，明明是把后台需要的数据都给传过去了，结果后台老是跟我说我的数据不对，后来我才发现是因为后台那边要求接收一个表单，而我传过去的是一个 json 数据。于是我就开始了漫长的探索之旅。（就为了这一个问题，从晚上十一点多一直搞到第二天凌晨四点多。。。如果不是有一个群里有个老司机帮忙说不定就死在这个问题上了）首先我想的是能不能把现成的 json 数据直接转化为 form 表单？因为我已经完成了获取要输的信息然后把它变成了 json 数据的工作，如果能直接把 json 对象转化为 form 对象的话我需要对程序做的改动肯定是最小的。然而遗憾的是，似乎并没有可行的方案。（也有可能是因为我 js 功底太差吧，我确实是没有找到相应的方法，要生成一个 form 似乎是需要 document 的，而小程序中我们并不能够得到它）此路不通，另觅他途。在查阅资料的过程中，我发现在 HTML 中似乎是有 这个标签的，然后我就兴冲冲的又去翻阅了一下小程序的官方文档，果不其然，小程序还是很良心的，有这方面的描述：然后我就兴冲冲的去按照官方的介绍用 标签来提交数据，js 里的代码是这样的：formSubmit: function (event) {\r\n        wx.request({\r\n            url: Constant.BASE_URL + \"/add2gank\",\r\n            method: \"POST\",\r\n            //按照官方文档，event.detail.value应该就是  标签获得的数据\r\n            data: event.detail.value,\r\n            complete: function (res) {\r\n                  //省略\r\n            }\r\n        });\r\n}我满心欢喜的以为可以了，结果并不可以。。。后台还是跟我说获得的数据有问题，结果我 console.log() 了看 给我返回的数据，它竟然还是个 json。。。说好的 form 呢！感觉受到了欺骗。濒临崩溃。幸好这时候一个老司机点醒了我：为啥那么纠结在本地数据是什么样子的？归根结底我们是要把数据传到后台去，那么只需要让数据在请求里面是 form 的格式不就 OK 了？所以 form 表单在请求里面是长什么样子的呢？json数据：\r\n{name: \"lypeer\",  gender: \"男\"}\r\nform数据：\r\n\"name=lypeer & gender=男\"123所以只要直接对数据进行操作，不用去管什么鬼 json 对象 form 对象什么的，那位老司机写了个方法，我无耻的直接拿来用了：function json2Form(json) {\r\n    var str = [];\r\n    for(var p in json){\r\n        str.push(encodeURIComponent(p) + \"=\" + encodeURIComponent(json[p]));\r\n    }\r\n    return str.join(\"&\");\r\n}ok，然后就可以用这个方法转换数据后来 post 一发：formSubmit: function (event) {\r\n        console.log(event);\r\n        wx.request({\r\n            url: Constant.BASE_URL + \"/add2gank\",\r\n            header: {\r\n                \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n            },\r\n            method: \"POST\",\r\n            data: Util.json2Form(event.detail.value).concat(\"&debug=false\"),\r\n\r\n            complete: function (res) {\r\n                //省略\r\n            }\r\n        });\r\n}23456789101112131415这里有一点需要注意，必需修改 content-Type 为 application/x-www-form-urlencoded ，不然还是会出问题。通过上面的方式就可以愉快的给后台传表单啦~~~另外关于 这个标签，虽然说他不会直接给我们返回 form 表单，但是我感觉它还是很好用的，可以直接获得里面的很多信息，不用很麻烦的一个一个去获取数据了。不过这个标签也是有一些坑的，下面会讲到它。7，解析 HTML 代码块？有时候我们会有解析 HTML 代码块的需求（爬了一个网页需要解析，或者后台出于某种原因返回给你了一个 HTML 代码块），但是我们能获得的通常是一个 String 值（ json 里返回的），在这种情况下通常我们会想到两种解析方式：直接使用正则匹配字符串或者将其装化成一个 DOM（Document Object Model，文档对象模型，没怎么接触过 JS 的同学可能对这个不太清楚） 然后解析。直接使用正则的方式这里我就不具体说了，这玩意儿在有些时候还是很好用的，但是在有些时候不那么方便，毕竟它不是为了解析 HTML 而生的。而一提到转化为 DOM ， 大家的脑海里就会浮现出这行代码来：var el = document.createElement( 'html' );el.innerHTML = htmlString;//htmlString是一串 HTML 代码的 String 值1212再然后就可以对 el 执行一系列的解析操作了：el.getElementById( idName );el.getElementsByTagName( tagName );......123123毫无疑问，这种方式在大多数情况下是比正则来的简单方便的，毕竟你不需要绞尽脑汁去写合适的正则表达式了。那么问题来了，在小程序里面我们无法直接获得 window 和 document 对象，那么如何把一段 HTML 代码的 String 值转化为 DOM 呢？不知道那些前端老司机是怎么做的，反正我是这么做的：function parseHtml(htmlBlock) {        var parser = new DOMParser();        return parser.parseFromString(htmlBlock, \"text/html\");}12341234我惊讶的发现，虽然微信小程序里面没有 ducument ， window 的概念，但是可以通过 DOMParser 对象来获得一个 document 对象 ……不要问我怎么发现的，这里面的艰辛不足为外人道也。然后我们就可以愉快的通过这个返回的对象来进行一系列解析操作啦~~~8，<form/> 里面无法获取 <picker/> 的取值？在微信小程序的官方文档里，是指明了 <form/> 标签里可以提交 <picker/> 的数据的，但是如果你真的在 <form/> 标签里放了一个 <picker/> 的话，你会发现，童话里都是骗人的。什么鬼！说好的数据呢！！！死活都获取不了数据，甚至还会让整个程序崩掉。并且坑爹的是，在小程序官网上面的那个 DEMO 里面，关于 <form/> 标签的使用有一个例子，例子里面几乎包含了 <form/> 标签中会提取数据的所有控件，就是没有 <picker/> 。那怎么办？这当然是难不倒我的。最终我采取了这样的方式来解决这个问题：<picker bindchange=\"onPickerChanged\" value=\"{{index}}\" range=\"{{array}}\">        <input class=\"picker\" disabled=\"disabled\" name=\"type\" value=\"{{array[index]}}\"/></picker>这是一个 <form/> 标签里面的 <picker/> 标签，我采取的方式是用一个 <input/> 标签来获取 <picker/> 的值，然后让 <form/> 获取 <input/> 的值，从而达到将 <picker/> 里面的值传递给 <form/> 的目的。9，要实现多层列表？在做 wechat-weapp-gank 的每天干货展示的页面的时候，有一个这样的页面需要实现：这个东西说白了就是个两层的列表，在原先做 Android 的时候这个是很容易的，直接嵌套嘛，但是现在做小程序的这个效果还是遇到了一些问题。这其中最大的问题就是在嵌套的过程中究竟在绑定数据的时候应该怎么写——第二个列表应该怎么传数据进去呢？第二个列表的列表项应该怎么获取数据呢？最后我摸索出来的结果是这样的：<view class=\"frame\" wx:for=\"{{data}}\">        <view class=\"tag\">{{item.tag}}</view>        <view wx:for=\"{{item.singleItems}}\">                <view class=\"singleItem\" href=\"{{item.src}}\">{{index}}，{{item.title}}</view>        </view></view>其中 data 是一个数组，它里面装的是一个一个的的 json 数据，每个 json 数据里面又装了 tag，singleItems 等数据，其中 singleItems 又是一个数组，它里面装的也是一个一个的 json 数据，每个 json 数据里装了每个二级列表的 item 所需的数据。具体的可以去我的项目代码里去看，具体的代码路径在这里：post.wxml 和 post.js。10，如何方便愉快的实现类似 Java 里面的静态变量的效果？这点的话纯粹是我的一点执念吧，我是从事 Android 开发的，也有点开发中的小癖好，喜欢把一些字符串弄成全局静态的放到一个专门的地方去。如果是在 Java 里面的话，我喜欢这样做：然后在调用的时候就可以这样做：String appId = Constants.AppSign.V_APP_ID;这样做我觉得很舒服，条理很清晰。但是在微信小程序中想要得到这样的体验就很困难——不过还是让我找到了方法——在小程序里面，是可以通过module.exports 将一个 js 文件模块化，然后让别的 js 文件通过 require( URL ) 引用的，我们可以通过这个特性来实现字符串的全局化，像这样：这样的话，我们就可以在需要使用的时候这样：这个其实不算踩过的坑哈，只是一个 Android 程序员的小执念而已，大家可以无视。。。结语最近在恶补一些前端的东西，感觉我已经快成为一个前端开发工程师了。。。"}
{"title": "微信小程序学习点滴《一》：如何获取时间，页面跳转，传递参数 ... ... ", "author": "天下雪", "pub_time": "2016-10-17 12:18", "article_content": "一：如何获取时间：获取时间直接用 Date.now() 得到一串数字.如下图:获取格式化的时间用 util.formatTime(new Date)util是微信官方demo里面的提供的工具:如下代码function formatTime(date) {  var year = date.getFullYear()  var month = date.getMonth() + 1  var day = date.getDate()  var hour = date.getHours()  var minute = date.getMinutes()  var second = date.getSeconds()  return [year, month, day].map(formatNumber).join('/') + ' ' + [hour, minute, second].map(formatNumber).join(':')}获取到时间如下:二：页面跳转,页面之间传递参数  先上demo图:  为了简化逻辑,所以index.wxml里面只写了两个text.既然是跳转,那就还有其他页面.目录如下:三个页面,但是代码很简单.直接上代码<!--index.wxml-->  <view class=\"btn-area\">    <navigator url=\"../navigator/navigator?title=我是navigate\" >跳转到新页面</navigator>    <navigator url=\"../redirect/redirect?title=我是redirect\" redirect>在当前页打开</navigator>  </view>index.wxml中的URL就是跳转的页面路径.上面代码中就是navigator目录下的navigator页面,title是参数. navigator下redirect属性是值在当前页打开.如果不加redirect就是跳转到新页面.都可以携带参数.<!--navigatort.wxml-->  <view style=\"text-align:center\"> {{title}} </view> 在navigatort.wxml中通过js代码可以获取到title,代码如下.options.title//navigator.js  Page({    onLoad: function(options) {      this.setData({        title: options.title      })    }  }) <!--redirect.wxml-->  <view style=\"text-align:center\"> {{title}} </view> //redirect.js  Page({    onLoad: function(options) {      this.setData({        title: options.title      })    }  })最后上两张跳转后的图.1.跳转到新页面2.在原来的页面打开有没有发现一个细节,在原来的页面打开是不会出现返回按钮的,而跳转到新页面后会出返回按钮.这是因为我写了两个页面.如果indexwxml不是一级页面,这里都会出现返回按钮.当然返回的结果是不一样的:1.跳转到新页面,返回是回到之前的页面;2.在原来页面打开,返回是回到上一级页面."}
{"title": "微信小程序学习点滴《二》：开发者工具快捷键，轮播图 swiper图片组件 ... ", "author": "天下雪", "pub_time": "2016-10-17 13:04", "article_content": "一：开发者工具快捷键微信小程序已经跑起来了.快捷键设置找了好久没找到,完全凭感觉.图贴出来.大家看看.我现在用的是0.10.101100的版本,后续版本更新快捷键也应该不会有什么变化.现在貌似不能修改.如果有同学找到修改的方法,麻烦告诉我微信小程序代码编辑快捷键常用快捷键格式调整Ctrl+S：保存文件Ctrl+[， Ctrl+]：代码行缩进Ctrl+Shift+[， Ctrl+Shift+]：折叠打开代码块Ctrl+C Ctrl+V：复制粘贴，如果没有选中任何文字则复制粘贴一行Shift+Alt+F：代码格式化Alt+Up，Alt+Down：上下移动一行Shift+Alt+Up，Shift+Alt+Down：向上向下复制一行Ctrl+Shift+Enter：在当前行上方插入一行光标相关Ctrl+End：移动到文件结尾Ctrl+Home：移动到文件开头Ctrl+i：选中当前行Shift+End：选择从光标到行尾Shift+Home：选择从行首到光标处Ctrl+Shift+L：选中所有匹配Ctrl+D：选中匹配Ctrl+U：光标回退界面相关Ctrl + \\：隐藏侧边栏二：轮播图 swiper图片组件照着开发文档尝试,总是能有所收获.之前做Android开发,做个轮播图并不简单,用上viewpage再设置圆点,折腾一通之后还一堆bug.今天尝试微信小程序开发做轮播图,真是感动的泪流满面.废话说完了,上图.上图就是一个简易的轮播图,是不是很简易.23333主要是代码也很简单.1.index.wxml<!--index.wxml-->        <swiper class=\"swiper\" indicator-dots=\"true\" autoplay=\"true\" interval=\"5000\" duration=\"1000\">          <block wx:for=\"{{movies}}\" wx:for-index=\"index\">            <swiper-item>              <image src=\"{{item.url}}\" class=\"slide-image\" mode=\"aspectFill\"/>            </swiper-item>          </block>        </swiper>这里有几个属性需要说明.微信小程序开发的循环用到了<block wx:for >我这里是遍历movies[]数组.<swiper-item>就是item2.index.js//index.js    //获取应用实例    var app = getApp()    Page({      data: {        movies:[        {url:'http://img04.tooopen.com/images/20130712/tooopen_17270713.jpg'} ,        {url:'http://img04.tooopen.com/images/20130617/tooopen_21241404.jpg'} ,        {url:'http://img04.tooopen.com/images/20130701/tooopen_20083555.jpg'} ,        {url:'http://img02.tooopen.com/images/20141231/sy_78327074576.jpg'}         ]      },      onLoad: function () {      }    })   3.WXML/**index.wxss**/.swiper {  height: 400rpx;  width: 100%;}.swiper image {  height: 100%;  width: 100%;}WXSS不多说,跟CSS没啥区别.不明白的看看开发文档"}
{"title": "微信小程序学习点滴《三》：开发工具及开发环境配置，尺寸单位rpx与px,rem相互转换 ... ", "author": "天下雪", "pub_time": "2016-10-17 13:11", "article_content": "一：开发工具及开发环境配置1.开发工具下载地址Windows 64位 下载Windows 32位 下载MacOS 下载2.安装过程对于Windows用户直接双击下一步的方式安装即可，此处注意我们使用的版本是官方最新的版本（不需要破解），可以不用AppID，也就是说没有资格的开发者也可以测试。2.1 环境测试以及演示项目2.1.1安装完成过后通过打开我们已经完成的应用测试环境是否正常2.1.2开发者工具安装完成后，打开并使用微信扫码登录。2.1.3选择创建“项目”，填入你在公众平台的`AppID`，如果没有的话可以点击`无AppID`。2.1.4设置一个本地项目的名称（非小程序名称），比如`WeApp Demo`，并选择一个本地文件夹作为存储目录。点击\"添加项目\"2.2  接下来点击`新建项目`就可以在主界面中预览到示例项目了二：尺寸单位rpx与px,rem相互转换1. rpx :微信小程序开发中新出了尺寸单位rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。微信官方建议视觉稿以iPhone 6为标准.2.rem rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。微信小程序开发尺寸单位文档"}
{"title": "微信小程序学习点滴《四》：网络请求 ", "author": "天下雪", "pub_time": "2016-10-17 13:19", "article_content": "微信小程序开发中网络请求必不可少,今天说说最简单的请求.后续会尝试上传下载,Socket这些.1.一个微信小程序，同时只能有5个网络请求连接。这个规定应该是微信为了保证用户体验制定的,毕竟是小程序.2.wx.request(OBJECT)  参数说明:微信小程序支持GET,POST等请求.用method可以设置.以下是GET请求的代码://rate.js  //获取应用实例  var app = getApp()  Page( {    data: {      code: 'USD',      currencyF_Name: '',      currencyT_Name: '',      currencyF: '',      currencyT: '',      currencyFD: 1,      exchange: 0,      result: 0,      updateTime: '',    },    onLoad: function( options ) {      var that = this;        //获取汇率        wx.request( {          url: \"http://op.juhe.cn/onebox/exchange/currency?key=我的appkey&from=CNY&to=\"+code,          success: function( res ) {            that.setData( {              currencyF_Name: res.data.result[0].currencyF_Name,              currencyT_Name: res.data.result[0].currencyT_Name,              currencyF: res.data.result[0].currencyF,              currencyT: res.data.result[0].currencyT,              currencyFD: res.data.result[0].currencyFD,              exchange: res.data.result[0].exchange,              result: res.data.result[0].result,              updateTime: res.data.result[0].updateTime,            })          }        })    }  })上面代码中只需要给出URL即可,onLoad函数在页面初始化时启动,wx.request({})中success的res.data是从后台获取的数据,这一点需要注意.以下是获取的json数据的格式.json的解析都不需要自己做了.我做Android的时候还得用gson或者是fastjson来解析json.微信为我们解决了很多麻烦.微信小程序开发网络请求文档"}
{"title": "微信小程序把玩《一》：window配置，tabBar底部导航，应用生命周期 ... ", "author": "天下雪", "pub_time": "2016-10-17 14:39", "article_content": "小程序工具\" style=\"margin: 0.8em 0px; padding: 0px; box-sizing: border-box; font-weight: 100; color: rgb(51, 51, 51); line-height: 26px; background-color: rgb(255, 255, 255);\">本篇默认已经成功安装微信小程序工具一：Hello WeApp新建项目AppID查看公众开发平台设置查看（https://mp.weixin.qq.com） 项目名称随意填写本地开发项目： 新建一个空的文件夹勾线当前会生成一个项目打开项目更详细的说多了也没啥意义看官网的简易教程非常详细！ https://mp.weixin.qq.com/debug/wxadoc/dev/?t=1474644089807二：window配置window用于设置小程序的状态栏、导航条、标题、窗口背景色。注意在app.json中配置的属性会被子window属性覆盖只需在app.json配置即可三：tabBar底部导航tabBar相对而言用的还是比较多的，但是用起来并没有难，在app.json中配置下tabBar即可，注意tabBar至少需要两个最多五个Item选项主要属性：对于tabBar整体属性设置：对于tabBar中每个Item属性设置：下面是官网一张图对tabBar描述：app.json的配置相对就简单了：四：应用生命周期App() 函数用来注册一个小程序，注意必须在 app.js 中注册，且不能注册多个。 使用方式也跟Android中的Application中初始化一些全局信息以供使用。方法：应用生命周期代码："}
{"title": "微信小程序把玩《二》：页面生命周期，模块化，数据绑定，view组件 ... ... ", "author": "天下雪", "pub_time": "2016-10-17 14:52", "article_content": "五：页面生命周期这里只要熟悉页面的基本生命周期即可，业务在指定生命周期函数内书写。以下是官网给出的生命周期函数方法和状态图上面的生周期函数图对于做Android 或者IOS的来书理解起来应该不是难事，具体怎么掌握只有慢慢尝试和摸索代码处理:这里的代码主需要对使用创建项目时index目录下文件处理下就行,至于跳转后的页面用的还是logs不需要更改！下面贴下代码注释也比较详细index.wxml<!--index.wxml--><view class=\"container\"><!--绑定点击事件-->  <view  bindtap=\"bindViewTap\" class=\"userinfo\">  </view>  <view class=\"usermotto\">  <!--数据绑定-->    <text class=\"user-motto\">{{motto}}</text>  </view></view>index.wxss<!--index.wxml--><view class=\"container\"><!--绑定点击事件-->  <view  bindtap=\"bindViewTap\" class=\"userinfo\">  </view>  <view class=\"usermotto\">  <!--数据绑定-->    <text class=\"user-motto\">{{motto}}</text>  </view></view>index.js//index.js//获取应用实例var app = getApp()Page({  /**   * 通过data初始化数据   */  data: {    motto: '点击上面View跳转',    // userInfo: {}  },  //事件处理函数  bindViewTap: function() {    //通过调用API进行跳转    wx.navigateTo({      url: '../logs/logs'    })  },  /**   * 监听页面开在加载的状态   *    页面加载完成之后就不会在执行   */  onLoad: function () {    console.log('index---------onLoad()')    // //this指的就是本页面对象    // var that = this    // //调用应用实例的方法获取全局数据    // app.getUserInfo(function(userInfo){    //   //更新数据    //   that.setData({    //     userInfo:userInfo    //   })    //   //更新本页面    //   that.update()    // })  },  /**   *  监听页面显示，   *    当从当前页面调转到另一个页面   *    另一个页面销毁时会再次执行   */  onShow: function() {    console.log('index---------onShow()')  },  /**   * 监听页面渲染完成   *    完成之后不会在执行   */  onReady: function() {    console.log('index---------onReaday()');  },  /**   * 监听页面隐藏   *    当前页面调到另一个页面时会执行   */  onHide: function() {    console.log('index---------onHide()')  },  /**   * 当页面销毁时调用   */  onUnload: function() {    console.log('index---------onUnload')  }})六：模块化模块化也就是将一些通用的东西抽出来放到一个文件中，通过module.exports去暴露接口。我们在最初新建项目时就有个util.js文件就是被模块化处理时间的//index.js//获取应用实例var app = getApp()赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                (1)\r\n\r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (2 人)\r\n\r\n\r\n\r\n\r\nlily@\r\n\r\n\r\n\r\ngyx2813\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序把玩《一》：window配置，tabBar底部导航，应用生命周期 ... \n              微信小程序学习《一》：目录文件详解，视图渲染详解 \n            \n             \n            \n                  原作者: 顺子_RTFSC \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序把玩《三》：scroll-view组件，swiper组件，icon组件\n                                    \n                  • 微信小程序把玩《四》：text组件，progress组件，button组件\n                                    \n                  • 微信小程序把玩《六》：picker组件，radio组件，slider组件\n                                    \n                  • 微信小程序把玩《十》：wx.request(object) API，wx.uploadFile(object)\n                                    \n                  • 微信小程序把玩《十一》：Image API，Record API，Audio API\n                                    \n                  • 微信小程序把玩《十二》：Video API，Storage API，location API\n                                    \n                  • 微信小程序把玩《十三》：获取设备信息 API，navigation API，animation API ...\n                                    \n                  • 微信小程序把玩《十四》：canvas API\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSgTJgls', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163747|879651fcbaf1f5455989b7fd1be6f05f|2';"}
{"title": "微信小程序使用Promise实践 ", "author": "天下雪", "pub_time": "2016-10-17 16:06", "article_content": "官方小例子代码getUserInfo:function(cb){\r\n    var that = this\r\n    if(this.globalData.userInfo){\r\n      typeof cb == \"function\" && cb(this.globalData.userInfo)\r\n    }else{\r\n      //调用登录接口\r\n      wx.login({\r\n        success: function () {\r\n          wx.getUserInfo({\r\n            success: function (res) {\r\n              that.globalData.userInfo = res.userInfo\r\n              typeof cb == \"function\" && cb(that.globalData.userInfo)\r\n            }\r\n          })\r\n        }\r\n      })\r\n    }\r\n  },昨天研究了一下微信小程序的例子，看见了熟悉cb了。我们好不容易从cb走向了Promise，如果开发小程序要回到cb中，这是我不能接受的，搞得我昨晚一晚上没有睡好，今年早一大早就到公司想办法解决问题。解决思路\r\n1、直接使用Promise，我试了一下，是可行的，但这受限于运行程序的浏览器。不能保证所有浏览器都支持Promise。\r\n2、使用第三方库，bluebird，Q，Defrered等，这样可以不依赖浏览器实现。\r\n说做就做，我最熟悉的是bluebird，于是先就在工程文件夹下执行npm init\r\nnpm i bluebird --save得到项目结构如下图\r\n\r\n在App.js中写入var Promise = require(\"node_modules/node_modules/js/browser/bluebird.js\");通过调试发现Promise为undfine，解决问题失败！\r\n深入分析\r\n难道真如网上所说不能加载第三方JS？我觉得应该不可能，如果不能使用第三方程序，什么都靠自己写，累都累死。忽然想到一段代码logs.js\r\nvar util = require('../../utils/util.js')\r\n\r\nutil.js\r\nmodule.exports = {\r\n  formatTime: formatTime\r\n}如果能在logs.js中引入util.js，就一定能引第三方包，只是我没有搞清楚这个加载机制。看上面的代码好像是CMD。我想来想去，最终在浏览器发现了这个。define(\"utils/util.js\", function(require, module){var window={Math:Math}/*兼容babel*/,location,document,navigator,self,localStorage,history,Caches;\r\n\r\nmodule.exports = {\r\n  formatTime: formatTime\r\n}\r\n\r\n})这是浏览加载后的代码，通过代码分析，总结出如下经验：\r\n1、原来小程序是自己定义了一套加载机制，不是CMD也不是AMD，到有点与NG相同。\r\n2、小程序会为每个js文件加一个包头，每个包中都增加一个window对象，所以在小程序中，window对象是一个局部变量。\r\n3、document对象不一定有值\r\n4、require是一个函数，module是一个对象这点与CMD一至\r\n再次尝试\r\n要在小程序中使用第三方包，就必须修改加载头。当我打开个bluebird源码时，立马就懵逼了，看不懂。所以就选择了Q，这个简单些，先看没有修改之样的。(function (definition) {\r\n    \"use strict\";\r\n\r\n    // This file will function properly as a <script> tag, or a module\r\n    // using CommonJS and NodeJS or RequireJS module formats.  In\r\n    // Common/Node/RequireJS, the module exports the Q API and when\r\n    // executed as a simple <script>, it creates a Q global instead.\r\n\r\n    // Montage Require\r\n    if (typeof bootstrap === \"function\") {\r\n        bootstrap(\"promise\", definition);\r\n\r\n    // CommonJS\r\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\r\n        module.exports = definition();\r\n\r\n    // RequireJS\r\n    } else if (typeof define === \"function\" && define.amd) {\r\n        define(definition);\r\n\r\n    // SES (Secure EcmaScript)\r\n    } else if (typeof ses !== \"undefined\") {\r\n        if (!ses.ok()) {\r\n            return;\r\n        } else {\r\n            ses.makeQ = definition;\r\n        }\r\n\r\n    // <script>\r\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\r\n        // Prefer window over self for add-on scripts. Use self for\r\n        // non-windowed contexts.\r\n        var global = typeof window !== \"undefined\" ? window : self;\r\n\r\n        // Get the `window` object, save the previous Q global\r\n        // and initialize Q as a global.\r\n        var previousQ = global.Q;\r\n        global.Q = definition();\r\n\r\n        // Add a noConflict function so Q can be removed from the\r\n        // global namespace.\r\n        global.Q.noConflict = function () {\r\n            global.Q = previousQ;\r\n            return this;\r\n        };\r\n\r\n    } else {\r\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\r\n    }\r\n\r\n})(function () {\r\n\"use strict\";这段代码，我立马就看懂了，这就是一个标准的闭包，definition是定义函数，Q一共适配了CommonJS，RequireJS加载，但可惜能过调试，进入了<script>这个分支，原因很简单，有window对象。但此window不是彼window，所以加载失败。想明白了就好改了，改后代码如下：(function (definition) {\r\n    \"use strict\";\r\n    module.exports = definition();\r\n})(function () {\r\n\"use strict\";需要注意的是definition后面一定要带()，表示执行这个函数，我一开始没有执行，结果使用时没有得到Q对象。原因是definition函数返回Q对象，大家看最一行代码。\r\n使用Q改写获取用户\r\nQ的使用很简单，主要改了这样几处地方//app.js\r\nvar Q = require(\"utils/q.js\");\r\nApp({\r\n  onLaunch: function () {\r\n    //调用API从本地缓存中获取数据\r\n    var logs = wx.getStorageSync('logs') || []\r\n    logs.unshift(Date.now())\r\n    wx.setStorageSync('logs', logs)\r\n  },\r\n  globalData:{\r\n    userInfo:null\r\n  },\r\n  login : function() {\r\n    var def = Q.defer();\r\n    wx.login({\r\n      success : function() {\r\n        def.resolve();\r\n      }\r\n    });\r\n    return def.promise;\r\n  },\r\n  getUserInfo : function() {\r\n    var that = this;\r\n    var def = Q.defer();\r\n    \r\n    if( this.globalData.userInfo ) {\r\n      def.resolve(this.globalData.userInfo);\r\n    } else {\r\n      this.login().then(function(){\r\n        wx.getUserInfo({\r\n          success : function( res ) {\r\n            that.globalData.userInfo = res.userInfo;\r\n            def.resolve(res.userInfo);\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    return def.promise;\r\n  }\r\n})//index.js\r\n//获取应用实例\r\nvar app = getApp()\r\nPage({\r\n  data: {\r\n    motto: 'Hello World',\r\n    userInfo: {}\r\n  },\r\n  //事件处理函数\r\n  bindViewTap: function() {\r\n    wx.navigateTo({\r\n      url: '../logs/logs'\r\n    })\r\n  },\r\n  onLoad: function () {\r\n    console.log('onLoad')\r\n    var that = this\r\n    //调用应用实例的方法获取全局数据\r\n    app.getUserInfo().then(function(userInfo){\r\n      that.setData({\r\n        userInfo:userInfo\r\n      })\r\n    });\r\n    console.log(window.document);\r\n  }\r\n})总结\r\n1、不要先入为主，网上的东西不能不信，也不能尽信，尽量去自己尝试。\r\n2、X讯自己造了一个封闭的环境，开放？封闭？这个东西好坏得时间来验证。\r\n3、得理解包加载机制，基础的东西最重要。"}
{"title": "微信小程序学习《一》：目录文件详解，视图渲染详解 ", "author": "天下雪", "pub_time": "2016-10-17 20:38", "article_content": "一、目录文件详解1.首先看下根目录下的app.json的文件，可以看到在”pages”的数组里，里面配置了每个界面，且包含了每个界面文件的目录2.可以看到每个页面需要包含两个文件，一个是js文件，是每个界面的入口，wxml的文件是每个界面的布局文件，那wxss是什么呢？它是每个界面的样式文件。比如：看下图可以看到，创建新的项目有两个界面，一个是index.js界面，一个是logs.js的界面，且都有对应的布局文件（.wxml）和样式文件（.wxss）3.可以看到在logs文件夹中比index文件夹中多出了一个logs.json的文件，这个文件是干嘛的呢？可见，这个文件不是必须的，因为index界面的文件夹中就没有这个文件，logs.json这个文件配置了一个界面的title的信息具体效果可以看下gif图总结1.根目录下的app.js是整个程序的入口，app.json配置整个程序的信息2.一个微信小程序必需包含的文件只需要有app.js和app.json以及对应界面的js文件和布局文件（.wxml）就可以了二、视图渲染一：创建一个页面1.首先我们新建一个项目，在新建的项目中有index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js后缀的文件是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件，.wxml后缀的文件是页面结构文件。好了，然后我们新建一个自己的页面，首先建一个文件夹（myPage），在文件夹下创建对应的布局文件（myPage.wxml）和js文件（myPage.js），最后记得在app.json中配置页面信息，在app.json中需要注意了，在pages的数组里，第一个代表着启动时第一个加载的页面2.然后进入调试界面，点击重启按钮，看下效果，会发现在控制台中弹出了报错的信息，如下：3.看报错的信息，很清楚的知道在myPage.js文件中没有找到Page方法，因此我们在myPage.js文件中调用Page方法，然后调试，重启，就会发现不报错了！4.好了，在第一点中也说到，在app.json中pages的数组里，第一个代表着启动时第一个加载的页面，那好我们把顺序调转一下，就可以验证我们的结论了建议看官方的教程：https://mp.weixin.qq.com/debug/wxadoc/dev/二、组件的使用和数据的绑定1.要了解微信小程序组件的使用，最好的方法就是查看微信小程序的API文档：https://mp.weixin.qq.com/debug/wxadoc/dev/component/可以看到API文档详细的介绍了各种组件的使用，要熟悉组件的使用，最好的方式就是多练了!2.看着文档，把官方文档的例子直接贴进来，然后我们也创建一个text组件，看看效果先吧：结合代码进行分析：js代码：三、渲染标签微信小程序给我提供了两种渲染标签：1.判断标签wx:if和wx:else虽然之前没有接触过js，可是代码也挺容易理解的，逻辑思维跟Android还是有点像，不过想学好，还是要学下js的，所以最近我也会学下js最后我们看下效果图吧，可以看到当位true的时候就显示1 false时显示22.循环标签（wx:for）看下循环标签在布局文件中的使用吧看下效果图：四、样式模板的使用从上面的代码就可以看到，一个界面可能会用到很多布局的代码，可是界面与界面之间可能会有很多重复的样式，然而这些样式的代码，每次都要重新写就很麻烦了，而且也浪费资源，微信小程序像其他开发一样，也有样式模板的使用方式1.使用include的方式包含模板样式 例如：<include src=\"../templates/myText\"  /> 具体的使用看图片：使用这种方式引用模板，实际上就是等同于把templates中的myText的代码全部复制到include这里2.使用import的方式 例如：<!--模板样式的使用  底部样式-->\r\n<import src=\"../templates/footer\"  />\r\n<template is=\"footer1\" />123最后看下效果图： Demo下载地址：Text1.zip"}
{"title": "微信小程序学习《二》：事件详解 ", "author": "天下雪", "pub_time": "2016-10-17 21:01", "article_content": "一、什么是事件?1.一种用户的行为用户长按某一张图片，点击某个按钮，这就是用户的行为，也是事件2.一种通讯方式为什么说事件也是一种通讯方式呢？因为用户点击按钮的时候，这是发生在UI层的，我们的UI要把一些信息发送给我们的逻辑代码，因此也是一种通讯方式二、事件的类别1.点击事件tap2.长按事件longtab3.触摸事件（1）touchstart 开始触摸（2）touchend 结束触摸（3）touchmove 移动触摸（4）touchcancel取消触摸这里就有个问题了，结束触摸和取消触摸有什么区别吗？结束触摸可以理解为是主动的停止的触摸事件，比如我们正在移动一张图片，移动完成后就是结束触摸了，然后可能在移动的过程中，突然有事件来打断了触摸事件，比如电话来了，打断了你的触摸事件，这时候就是取消触摸了4.其他的触摸事件 submit每个控件都有自己的事件三、事件冒泡了解什么是冒泡事件？什么是非冒泡事件？我们可以通过一个例子来理解什么是冒泡事件。1.首先我们先修改下启动界面，启动界面创建三个view组件，分别给他们对应的样式和绑定他们的点击事件，且布局是一层嵌套一层的2.然后在index.wxss文件中写下他们对应的样式3.在index.js文件中写对应的点击事件，在控制台输出对应的log4.最后我们看下效果，仔细观察可以看到，我们点击界面3的时候，控制台输出了3行，分别是clickView1，clickView2，clickView3的点击事件，点击界面2的时候，控制台输出了clickView2和clickView1，这就说明了点击子view的时候，也会响应父view的事件，这就是冒泡事件了，相反的，点击子view，父view不会响应点击事件，这就是非冒泡事件了。那么冒泡事件有哪些呢？上面所提到的点击事件，长按事件，触摸事件都是冒泡事件，其余的都是非冒泡事件四、事件的绑定1.bind上面的冒泡事件的例子就是使用bind的方式来绑定事件的2.catch那么catch绑定事件和bind的绑定事件有什么不同呢？我们通过修改上面的例子来说明，我们把view3的bindtap改为catchtap然后我们看下运行的效果：可以看到，我们使用catch的绑定事件后，点击界面3，是没有触发到父view的点击事件的总结：使用bind的绑定事件，是可以触发冒泡事件的，就是可以触发父view的事件 使用catch是不会触发冒泡事件Demo的下载地址：Demo2.zip"}
{"title": "微信小程序实战教程：火车票查询（含demo） ", "author": "天下雪", "pub_time": "2016-10-17 22:25", "article_content": "界面展示  结合动态图描述一下目前实现的功能：2.1 主页上半部分显示用户头像与用户名（和微信中的信息一致，这部分组件是工具自带的，我们可以修改这部分组件和内容，稍候会提到）；下半部分显示一个经典的问候语“Hello World”，提供一个可点击的按钮“点击获取火车票”；2.2 点击按钮后，通过事先指定的参数（调用了百度APIStore中去哪网火车票查询接口，站-站查询所需参数为始发地、目的地及时间）发送网络请求，将获取到的JSON数据按火车车次为节点进行解析并在新页面显示基本信息（除了详细座位信息），为每个车次提供一个可点击的按钮“点击查看座位信息”；2.3 点击某车次中的座位查询按钮后，会将该车次对应的所有座位信息显示在新页面中；2.4 点击后两个页面左上角的“返回”按钮可回到上一页，这个功能也是工具自带的； 顺便提一下在博客园中插入动画，上面的演示过程是一张格式为gif的图片，像添加普通图片一样操作即可。录制工具使用的是灵者Gif录制，可以指定开始、停止时所需操作与区域等录制信息。  3. 要点分析关于微信小程序工具的使用及初始项目的结构说明，网上资源已经很丰富，这里不打算再啰嗦 下面开始讲讲我个人在学习与开发过程中认为值得分享与记录的点，欢迎大小神们一起讨论与指正，特别是讲得不对或有待改善的地方。下面只给出和讲的点直接相关的代码，整体代码可以到项目工程中去查看，建议大家自己调试一遍。 3.1 indexindex是项目新建时自动生成的，作为小程序的启动页面。3.1.1 index.wxml首页的头像与用户名，从上图的演示过程可以看出我将微信的名字“***”改成了“用户名”：<view  bindtap=\"bindViewTap\" class=\"userinfo\"> 　　<image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image> 　　<text class=\"userinfo-nickname\">用户名</text>  <!-- {{userInfo.nickName}}直接写成“用户名” --></view>用户名部分原本的内容为{{userInfo.nickName}}，{{key_name}}的作用是获取关键字名为key_name对应的值（数据一般以key_name:value的形式定义在wxml文件同目录下js文件的data成员中，后面会讲解），image显示的头像资源也是通过这种方式指定为src=\"{{userInfo.avatarUrl}}\"，程序中产生的数据可以在开发者工具顶部偏右的AppData栏中查看。如果不需要从js文件中获取数据，那么可以像代码中“用户名”那样直接写入数据值，不过一般不推荐这样做，因为像Android等平台App在开发时会将数据值放入strings.xml等文件，目的是为了将数据与布局分离，布局和功能实现代码分离，方便开发与维护。组件中的class项用来设置其样式，属性名对应的样式信息定义在wxss文件中，除了可以使用定义在本目录wxss文件中的样式，还可以使用app.wxss文件中定义的。如果样式只是在某页面中使用，那么建议定义在其目录下的wxss文件中，即局部作用域内；如果是多个页面共同使用，即全局样式，那么一般定义在主程序app.wxss文件中。class样式可以指定组件的宽高、背景颜色等属性，本文不再进行详述。在界面下方添加按钮“点击获取火车票”组件：<view class=\"gettrain-button\" bindtap=\"getTrainInfo\"> 　　<text>点击获取火车票</text> </view>按钮的目标是为了让用户可以点击进行交互，至于使用button、text或其他组件，视具体需求而定。这里是利用text组件，文本内容直接写入了字串“点击获取火车票”，对于只有一个子组件的布局其实可以如下面代码不用嵌套，一层布局搞定。一般来说嵌套层数越少，加载速度越快，这对移动程序的体验是至关重要的。<view class=\"gettrain-button\" bindtap=\"getTrainInfo\"> 　　点击获取火车票 </view>但如果在父容器下有多个子组件共享其定义的样式，那么嵌套可以另代码简洁很多：<view class=\"gettrain-button\"> 　　<text bindtap=\"getTrainInfo\">点击获取火车票</text> 　　<text bindtap=\"getCarInfo\">点击获取汽车票</text> 　　<text bindtap=\"getPlaneInfo\">点击获取飞机票</text> </view>组件若要有点击交互功能，须为其绑定事件响应方法，常用的有单点--bindtap，长按--binglongtap。bindtap=\"getTrainInfo\"，双引号中的文本是方法名称，在js文件中以该名定义方法，做需要的处理即可。3.1.2 index.js 实现wxml布局中按钮“点击获取火车票”绑定的函数功能：//获取火车票函数getTrainInfo: function() {    wx.request({        url: 'http://apis.baidu.com/qunar/qunar_train_service/s2ssearch',        header: {            apikey: '361cf2a2459552575b0e86e0f62302bc',        },        data: {            version: '1.0',            from: '北京',            to: '杭州',            date: '2016-11-15',        },        success: function(res) {            var json = res.data;            //将JSON类型转为String类型用以url参数传递，否则传递后会变成[object Object]            var jsonString = JSON.stringify(json);            wx.navigateTo({                url: '../train/train?trainInfos='+jsonString,            });        },    });},我们先来看看微信小程序官网对于网络请求方法--wx.request(OBJECT)的说明： 一般来说，wx api提供的方法默认会有一个Object参数，需要时传入，不需要时不传便是。不过这对于像我这种Android开发者来说一开始有点不适应，怎么函数调用时都传入一个{...}参数，内部各个项之间用逗号“,”分隔，代码中的url、data等。从代码中看，发起网络请求时传入了图中列出的四项参数：url、header、data及success，不同需求传入的参数也会不同。对于wx.request方法而言，需根据网络请求目标来传参数的是前四项：url、header、data及method。以本案例利用百度APIStore去哪网火车票获取站--站火车票信息来说（http://apistore.baidu.com/apiworks/servicedetail/697.html），其官网给出的接口调用的参数信息与格式如下：将上面两张图中的信息结合起来看，参数是一一对应的：wx url——火车票查询 接口地址；header——请求参数header；data——请求参数urlParam；method——请求方法；因为wx中的method参数默认是GET，和火车票查询接口指定的一致，所以调用时可以省略。而对于最后三个回调函数：success、fail及comlete，代码中添加了success，在请求成功时对数据进行处理。当然，一般的程序还得对请求失败的情况做处理。下面就来分析success方法中的代码，包括JSON数据的转换与新页面的跳转，请求返回的数据以参数res的形式传入到function中。先来看看res中包含了哪些信息，通过代码console.log(res)可以将其打印在工具调试页面的Console项中。request--ok和statusCode--200表示请求成功，所以才会回调success方法。而data对象才是我们需要的数据，更精确地说，data.data.trainList对象才是真正的火车票信息。var json = res.data，获取data对象（网络请求返回的数据一般为JSON格式），赋给变量json；var jsonString = JSON.stringify(json)，将JSON类型对象暂时转换为String类型，用来作为url的参数部分进行传递；一开始在这里耽搁了很久，不进行转换直接传的话在目标页面获取不到想要的数据，下面会说明原因；url: '../train/train?trainInfos='+jsonString，通过url指定的信息跳转到对应页面，如果不需要额外参数，直接写url: '../train/train'；如果只是传递简单的值，可写成url: '../train/train?param=123'；至此，如果网络没有问题，点击按钮便可以进行火车票的查询并携带结果数据跳转到新页面了。 3.2 traintrain是自定义新建的页面，用来显示火车票基本信息，注意新添的页面需在app.json文件中进行配置。\"pages/train/train\",  //火车票车次信息页面 \"pages/seat/seat\"  //车次余票信息页面3.2.1 train.wxml由于站--站火车票所有车次的始发站和终点站是一样，如北京--杭州东，所以先在页面顶部显示站点信息：<text class=\"train-item\">出发地：{{trainList[0].from}}</text><text class=\"train-item\">目的地：{{trainList[0].to}}</text>trainList对象会在js文件中定义成data成员，值为上面最后一张图中的JSON对象--trainList，即火车票车次数组，每个元素包含一个车次的具体信息。接下来显示每个车次的信息，以横线作分隔（由于是以学习和测试为目的，所以就没有在布局的美观上下功夫，大家见谅）：<view class=\"line\"></view><block wx:for=\"{{trainList}}\" wx:for-item=\"train\">    <text class=\"train-item\">{{index+1}}. 车次：{{train.trainNo}}</text>    <text class=\"train-item\">车型：{{train.trainType}}</text>    <text class=\"train-item\">起始时间：{{train.startTime}}</text>    <text class=\"train-item\">到站时间：{{train.endTime}}</text>    <text class=\"train-item\">总时长：{{train.duration}}</text>    <view id=\"trainindex-{{index}}\" class=\"getseat-button\" bindtap=\"getSeatInfo\">        <text>点击查看座位信息</text>    </view>    <view class=\"line\"></view></block>第1、11行很简单，在站点与车次、车次与车次之间添加横线。当布局中的组件个数和js中的数据有关，即在wxml中写死组件不能满足需求时，可以利用block和wx:for来进行组件的动态生成。第2行wx:for=\"{{trainList}}\"表示block块中的组件可以使用数组trainList中的内容，从下标0开始迭代，数据中有几个元素，就会动态生成几套组件。wx:for-item=\"train\"指定数组中元素的名称为train（默认的是item，指定的意义之一是可读性强），后续获取属性值时可通过train.key_name的形式。第3行开始添加组件，类型是text，值为{{index+1}}. 车次：{{train.trainNo}}，前半部分用来标明每个车次的序号，从1开始；而index和item类似，是默认的迭代索引名称，其实就是数组元素当前的下标，从0开始。后面几行添加text组件和第3行差不多，但第8行有两个点说一下：*1 bindtap=\"getSeatInfo\"，绑定一个回调函数，点击时跳转到新页面，显示当前车次对应的座位信息；*2 id=\"trainindex-{{index}}\"，给组件指定id，可以看到之前的组件都没有设置过该属性（不需要就可以不设置），那么什么时候需要呢？其中一种情况，当js中某组件绑定的回调方法需要得知是哪个组件触发了自己的时候，比如第一点中的方法getSeatInfo，要想点击某车次的查看座位信息按钮后显示出对应的座位信息，就得知道点击组件对应的trainList数组下标，而这个需求，正好可以借助id和index属性来实现；3.2.2 train.js首先定义data成员trainList，用来接收index页面传递过来的数据：trainList: []页面启动时若有数据需要载入，那么得添加onLoad方法（一开始自动运行，在其中实现数据的加载与处理），否则可以不添加。onLoad: function(options) {　　var jsonString = options.trainInfos;　　//将字串类型转为JSON类型　　var json = JSON.parse(jsonString);　　this.setData({    　　trainList: json.data.trainList,　　});},当方法的调用者有参数传入时，我们可以通过添加方法参数的形式来获取。对于参数名，自动启方法一般为options，组件回调方法一般为e（event）。第2行获取index页面在打开train页面时传入的火车票信息参数trainInfos。第4行将String类型对象转换回JSON格式，之前在index页面提到过，url传的参数是由JSON格式对象转换过来的String类型。第6行将真正的火车票车次信息数组取出，赋给数据成员trainList。注意：给数据成员赋值时，必须调用页面自身的setData方法，否则就算赋值了也不会同步到wxml文件中去，这一点容易出错且不好定位原因。车次数组得到后，wxml文件就会根据组件的属性设置显示对应的信息。再来看实现按钮“点击查看座位信息”对应的回调方法：getSeatInfo: function(e) {    var prefix = 'trainindex-';    var trainIndex = e.currentTarget.id.substring(prefix.length);    //输出根据组件id获取的车票索引，用以显示详细的座位信息    console.log(trainIndex);    var trainNo = this.data.trainList[trainIndex].trainNo;    var json = this.data.trainList[trainIndex].seatInfos;    //将JSON类型转为String类型用以url参数传递，否则传递后会变成[object Object]，同时传递车次    var jsonString = JSON.stringify(json);    wx.navigateTo({        url: '../seat/seat?'+'trainNo='+trainNo+'&seatInfos='+jsonString,    });},第2、3行获取之前定义的组件id中的index部分，即点击组件对应的trainList数组的下标。当然原先定义时也可以不添加前缀'trainindex-'，完全是为了可读性，因为当项目越来越大时有个一目了然的标示总是不错的。第6、7行分别获取车次信息的列车号与座位信息，他们稍候会被传递到seat页面。第9行同样地将得到的JSON格式对象先转换为String类型，让其可以在url中作为可被正确传递的参数。第11行打开新的页面seat显示座位信息，多个参数之间以“&”符号分隔。3.2.3 train.json主程序中app.json文件除了配置需要调用onLoad方法的页面外，还指定了一些全局的window样式。若某个页面在自己的json文件中没有定义局部的window属性，或根本没有json文件，那默认将使用全局的。项目初始没有为index生成json文件，因为其作为启动页，直接用全局的“WeChat”就好，其实index标题应该是小程序的名称，我们自己真正开发的程序肯定得取另一个名字。可以看到，logs、train及seat都对标题进行了定义，结果就是会覆盖掉全局的值。以train为例，其在json文件中定义标题为“站-站火车查询信息”：{ 　　\"navigationBarTitleText\": \"站-站火车查询信息\" }还有一点，页面的json文件不需要也不能页面配置属性（Pages），只能设置window属性，所以就可以省略window名称，直接像上述代码用{...}形式即可。 3.3 seatseat页面用来显示某车次的座位信息，包括座位等级、票价及余票。通过train页面的分析，相信大家对网络请求，数据在页面与页面、wxml与js文件之间的传递渐渐熟悉了。而seat和train类似，没有什么特别的地方，所以和logs一样这里就不再讲什么了。 4. 小感悟 微信小程序，虽然目前还不知道其在微信的接入口，但应该和订阅号、服务号以及企业号会有所不同。搜索打开使用，用完关闭，没有移动app的安装、下载等过程，微信流量大，轻便、易用等特性是其优点。然而正是因为这个优点，开发者担心这有可能使得小程序不能够像app那样强大，毕竟接入口、审核机制、推广成本以及最大允许内存等这些还未确定的因素对一款应用来说都是至关重要的。对于初学者（如原先搞android开发），暂且不管上面提到的那些，在弄明白应用需求的同时，得迈开并加快对前端知识学习的脚步了。本文项目代码获取地址Github：https://github.com/VincentWYJ/WXAppTrain.git；Blog file：http://files.cnblogs.com/files/tgyf/WXAppTrain.rar；"}
{"title": "新手入手教程微信小程序上手开发和使用总结 ", "author": "天下雪", "pub_time": "2016-10-18 10:23", "article_content": "一、模板　　WXML提供模板组件给我们使用，可以在模板定义公用的代码片段，然后在需要引用的地方进行调用。定义模板　　定义模板使用name属性作为模板的名字，然后在template标签中定义代码片段：123456789101112<template name=\"mytemplate1\">  <view>    <text>firstName:{{firstName}}</text>    <text>lastName: {{lastName}}</text>  </view></template><template name=\"mytemplate2\">  <view wx:for=\"{{persons}}\">  \t<text>firstName:{{item.firstName}}</text>    <text>lastName: {{item.lastName}}</text>  </view></template>使用模板　　使用模板我们用is属性引用定义好的模板，然后把模板所需要的值通过data属性传给模板。比如需要遍历persons数组，我们可以将整个persons作为对象传给模板，也可以遍历persons后将每个对象传给模板，具体取决于所应用的场景。1234<view wx:for=\"{{persons}}\">  <template is=\"mytemplate1\" data=\"{{...item}}\"></template></view><template is=\"mytemplate2\" data=\"{{persons}}\"></template>　　需要的数据结构如下123456789Page({\tdata:{\t\tpersons:[\t\t\t{firstName: 'Hulk', lastName: 'Hu'},\t    \t{firstName: 'Shang', lastName: 'You'},\t    \t{firstName: 'Gideon', lastName: 'Lin'}\t\t]\t}})注意：is属性也可以使用Mustache语法进行动态渲染，决定使用哪个模板data如果传的是对象类型的数据，需要用“…”进行“解构”，在模板中可以直接调用对象的属性；如果是其他数据类型则不需要用“…”二、事件　　什么是事件呢，简单来说，事件就是逻辑层到逻辑层的通讯方式。就是在页面上通过触发某个操作（就是我们说的事件），在逻辑层进行一系列的操作，最终来改变数据。　　比如在一个输入框中用户输入了一段文字，但是data中的数据并没有随之改变，因此我们需要在输入框上绑定对应的输入事件来更改数据。事件分类　　事件也有分类，可以分为冒泡事件和非冒泡事件。“冒泡”这个词很形象的表现了事件向上传递的过程，这两种事件的区别也在于是否会向父节点进行传递。　　一些常用的冒泡事件，除以下的事件外都是非冒泡事件：名称触发touchstart手指开始触摸touchmove手指触摸后移动touchend手指触摸动作结束touchcancel触摸被打断，比如来点，弹框等tap触摸后离开，有点像点击clicklongtap长按，超过350ms才离开事件对象　　当事件函数被调用时，从逻辑层有一个默认的事件对象传到函数中，不同的事件所包含的事件对象的属性有所区别，一些常用的事件对象的属性如下：属性类型说明typeString事件类型timeStampInt从页面加载到事件触发的时间戳targetObject触发事件的组件的一些属性值集合currentTargetObject当前组件的属性值集合touchesArray触摸点信息的数组detailObject额外的信息target和currentTarget区别　　当不存在嵌套时，target和currentTarget没有区别。但是当嵌套触发事件是，current和currentTarget的区别就体现出来了。123456<view class=\"A\" bindtap=\"handle1\">  outer    <view class=\"B\" bindtap=\"handle2\">    inner    </view>  </view>　　点击组件B，当触发handle2事件时，收到target和currentTarget对象是一样，都指向组件B；而当点击组件B触发handle1事件时，target对象指向了组件B，currentTarget对象则组件A。总结一下：target对象指向了所触发事件的对象currentTarget对象指向了绑定事件所在的对象向detail中添加内容　　在组件中定义数据，当触发事件时，这些数据通过事件对象传给逻辑层。书写规则：以“data-”开头，多个字符用“-”连接，不能含有大写，可以绑定多个data值。例如data-element-name，最终会在event.currentTarget.dataset中转为elementName属性，属性的值就是定义的数据。三、异步数据　　小程序还提供发送异步的方法request(object)，发起的是https请求。一个小程序，同时只有有5个网络请求链接。object的参数如下：参数命类型说明urlSring服务器接口地址dataObject请求的参数headerObject设置请求头header，header不能设置ReferermethodString请求方式，默认GETsuccessFunction请求成功的回调方法failFunction请求失败的回调方法completeFunction请求完成的回调方法(请求成功、失败都会调用)　　跟jQuery不同的是，小程序请求的数据不是直接在success方法的res中(res是一个对象，还包括请求成功的状态码等)，而是在res.data中。示例代码如下：12345678910111213wx.request({  url: '/url',  data: {     x: '',     y: ''  },  header: {      'Content-Type': 'application/json'  },  success: function(res) {    console.log(res.data) //接收到的数据  }})"}
{"title": "TNK：微信小程序开发尝鲜 ", "author": "天下雪", "pub_time": "2016-10-18 10:38", "article_content": "微信小程序面世以来受到的关注颇多，直到最近我才动手尝试进行了小程序的开发，总体上感觉还是不错的，有一点不适应的就是要摆脱Web APP开发对DOM的操作。在这里我就把我是如何利用API开发微信小程序的过程写成教程，教大家快速上手体验一次微信小程序的开发。在开始之前我们先来看下成品的效果图准备工作我们先确定想要开发一款什么样的小程序，首先要符合「小」，因为我们这次是要体验小程序的开发，所以尽量不要弄得太复杂；其次是「快」，小程序里需要的数据啊、资源啊，最好是现成就有的，自己写个API什么的这就太耗时了，就不叫快速上手了。所以呢，如果能调用现成的API那是极好的，经过一番挑选，我选择了聚合数据的 历史上的今天 这个API，调用这个API获取数据，我们只要做2个页面就可以完全展示出来了，又「小」又「快」哈XDAPI一枚: 「历史上的今天」微信小程序 开发者工具注: API需要注册之后获得KEY才能使用，具体请查看 聚合数据 官方文档，这里默认各位已经注册并拥有相应API所需的KEY工程结构微信开发者工具的安装和使用在这里就不多作介绍了，有疑问的话可以看微信官方的 简易教程先创建一个工程，依次点击「添加项目」－－「无AppID」，然后填好「项目名称」并选择「项目目录」，点击「添加项目」然后我们来清理一下默认工程的目录结构，删除以下目录和文件pages/logs/\r\npages/index/index.wxss创建以下目录和文件pages/logs/\r\npages/index/index.wxsspages/detail/\r\npages/detail/detail.js\r\npages/detail/detail.wxml\r\npages/templates/\r\npages/templates/item.wxml\r\nres/现在你看到的目录结构应该是这样子的.\r\n├── app.js\r\n├── app.json\r\n├── app.wxss\r\n├── pages\r\n│   ├── detail\r\n│   │   ├── detail.js\r\n│   │   └── detail.wxml\r\n│   ├── index\r\n│   │   ├── index.js\r\n│   │   └── index.wxml\r\n│   └── templates\r\n│       └── item.wxml\r\n├── res\r\n└── utils\r\n    └── util.js这就是我们工程目录的最终结构了，后面还会添加资源进去，但是整体结构还是这样不会改变的修改配置微信小程序是通过修改 app.json 文件改变全局配置的，具体的可配置项请各位自行查阅小程序文档的 配置 一节打开 app.json ，修改成{\r\n  \"pages\":[\r\n    \"pages/index/index\",\r\n    \"pages/detail/detail\"\r\n  ],\r\n  \"window\":{\r\n    \"backgroundTextStyle\":\"light\",\r\n    \"navigationBarBackgroundColor\": \"#3e3e3e\",\r\n    \"navigationBarTitleText\": \"历史今日\",\r\n    \"navigationBarTextStyle\":\"white\"\r\n  },\r\n  \"debug\": true\r\n}我们这里修改了导航栏的背景颜色(navigationBarBackgroundColor)、标题颜色(navigationBarTextStyle)以及标题内容(navigationBarTitleText)，为了方便查看调试信息，我还开启了debug模式全局配置以及搞定啦，接下来正式开始编码首页布局前面已经说了我们要做的是「历史上的今天」这样的一个小程序，所以同一个日期会有很多条目，最常见的布局就是做成列表列表里会有很多的条目，数量是不确定的，所以我们不能在页面里写死了布局，这时候就要用到 模板(template) 了，我们可以在模板中定义代码片段，然后在不同的地方调用我们来定义一个模板，打开 pages/templates/item.wxml ，添加代码<template name=\"tItem\">\r\n    <navigator url=\"../detail/detail?id={{item.e_id}}\">\r\n        <view class=\"ui-list-item ui-pure-item ui-border-b\">\r\n            <view class=\"ui-item-span\"><text>{{item.date}}</text></view>\r\n            <view class=\"ui-item-content ui-nowrap\"><text>{{item.title}}</text></view>\r\n        </view>\r\n    </navigator>\r\n</template>注: 模板的使用细节请参考官方文档 模板 一节接下来打开 pages/index/index.wxml 删掉里面的内容，我们要在这里编写列表页，这里会使用到我们上面定义的模板<import src=\"../templates/item.wxml\"/>\r\n\r\n<scroll-view scroll-y=\"true\" class=\"flex-row ui-list ui-border-t\">\r\n    <template is=\"tItem\" data=\"{{item}}\" wx:for=\"{{events}}\"/>\r\n    <view class=\"ui-tips\">\r\n        <view wx:if=\"{{hidden}}\"><text>没有更多内容了</text></view>\r\n        <view wx:else><text>内容加载中...</text></view>\r\n    </view>\r\n</scroll-view>\r\n\r\n<loading hidden=\"{{hidden}}\">Loading...</loading>可以注意到第一行使用了 import 将模板引入到页面中，然后再使用 is 属性，声明需要使用的模板，用 data 属性传入数据供模板使用注: 模板拥有自己的作用域，只能使用 data 传入的数据为了测试和查看布局效果，我们打开 pages/index/index.js 删除里面的代码，然后添加以下代码手动创建数据传入给页面渲染Page({\r\n  data: {\r\n    hidden: true,\r\n    events: [\r\n      {\r\n        date: \"2016-10-14\",\r\n        title: \"TodayOnHistory, 历史上的今天\"\r\n      },\r\n      {\r\n        date: \"2016-10-14\",\r\n        title: \"TodayOnHistory, 历史上的今天\"\r\n      },\r\n      {\r\n        date: \"2016-10-14\",\r\n        title: \"TodayOnHistory, 历史上的今天\"\r\n      },\r\n      {\r\n        date: \"2016-10-14\",\r\n        title: \"TodayOnHistory, 历史上的今天\"\r\n      },\r\n      {\r\n        date: \"2016-10-14\",\r\n        title: \"TodayOnHistory, 历史上的今天\"\r\n      },\r\n      {\r\n        date: \"2016-10-14\",\r\n        title: \"TodayOnHistory, 历史上的今天\"\r\n      }\r\n    ]\r\n  }\r\n})保存后点击开发工具左侧的编译，即可查看到效果注: 布局会用到图标字体，导入到 res/ 下，样式则写在 app.wxss 全局样式表中，图标字体文件和样式请从源码中获取，这篇教程不作样式的说明详细页面首页的布局已经完成了，暂时放下首页列表，接下来开始编写详细内容的页面打开 pages/detail/detail.wxml ，添加内容如下<view class=\"container\">\r\n    <view class=\"ui-title ui-border-b\"><text>{{detail.title}}</text></view>\r\n    <view class=\"ui-content\"><text>{{detail.content}}</text></view>\r\n    <block wx:for=\"{{detail.picUrl}}\">\r\n        <view>\r\n            <view><image mode=\"aspectFit\" src=\"{{item.url}}\"/></view>\r\n            <view class=\"ui-pic-title\"><text>{{item.pic_title}}</text></view>\r\n        </view>\r\n    </block>\r\n</view>\r\n<loading hidden=\"{{hidden}}\">Loading...</loading>搞定，这个页面就这么简单就OK了，现在我们打开 pages/detail/detail.js 手动添加数据到这个页面中查看效果Page({\r\n  data:{\r\n      hidden: true,\r\n      detail: {\r\n          title: \"历史上的今天\",\r\n          content: \"历史上的今天历史上的今天历史上的今天历史上的今天历史上的今天历史上的今天历史上的今天历史上的今天历史上的今天\",\r\n          picUrl: [\r\n              {\r\n                  url: \"http://sjbz.fd.zol-img.com.cn/t_s320x510c/g5/M00/00/04/ChMkJlfJWJCIYePaAAPdCld59MEAAU-KAP0U3gAA90i450.jpg\",\r\n                  pic_title: \"这是图片标题\"\r\n              }\r\n          ]\r\n      }\r\n  }\r\n})填充数据现在页面布局都已经完成了，是时候调用API编写逻辑层的代码来填充数据到页面上了，在开始之前我们先清理一下无用的代码打开 app.js 删掉无用的函数和属性App({\r\n  \r\n})以上这步是额外步骤，并不影响我们接下来要做的事情打开 utils/util.js 并清空里面的代码，添加如下内容// 查询事件列表的Base URL\r\nconst API_URL_L = \"http://v.juhe.cn/todayOnhistory/queryEvent.php\"\r\n// 查询详细信息的Base URL\r\nconst API_URL_D = \"http://v.juhe.cn/todayOnhistory/queryDetail.php\"\r\n// 申请API获得的KEY\r\nconst API_KEY = \"YOUR API KEY\"\r\n\r\n// 获取事件列表\r\nfunction fetchEvents(today) {\r\n    var promise = new Promise(function(resolve, reject){\r\n        wx.request({\r\n            url: API_URL_L,\r\n            data: {\r\n                key: API_KEY,\r\n                date: today\r\n            },\r\n            header: {\r\n                'Content-Type': 'application/json'\r\n            },\r\n            success: resolve,\r\n            fail: reject\r\n        })\r\n    })\r\n    return promise\r\n}\r\n\r\nfunction getEvents() {\r\n    var tmpDate = new Date()\r\n    var today = tmpDate.getMonth() + 1\r\n    today = today + '/' + tmpDate.getDate()\r\n    return fetchEvents(today)\r\n        .then(function(res) {\r\n            // console.log(res.data.result)\r\n            return res.data.result\r\n        })\r\n        .catch(function(err) {\r\n            console.log(err)\r\n            return []\r\n        })\r\n}\r\n\r\n// 获取详细信息\r\nfunction fetchDetail(e_id) {\r\n    var promise = new Promise(function(resolve, reject){\r\n        wx.request({\r\n            url: API_URL_D,\r\n            data: {\r\n                key: API_KEY,\r\n                e_id: e_id\r\n            },\r\n            header: {\r\n                'Content-Type': 'application/json'\r\n            },\r\n            success: resolve,\r\n            fail: reject\r\n        })\r\n    })\r\n    return promise\r\n}\r\n\r\nfunction getDetail(e_id) {\r\n    return fetchDetail(e_id)\r\n        .then(function(res) {\r\n            // console.log(res.data.result)\r\n            return res.data.result\r\n        })\r\n        .catch(function(err) {\r\n            console.log(err)\r\n            return []\r\n        })\r\n}\r\n\r\nmodule.exports = {\r\n    getEvents: getEvents,\r\n    getDetail: getDetail\r\n}注: 请将 API_KEY 的值替换为你申请到的KEY我们要利用API获取的数据有两种，一是「事件列表」，另一种是事件对应的「详细信息」，上面使用到了 ES6 原生提供的 Promise 对象，具体请参考阮一峰的《JavaScript 标准参考教程（alpha）》中 「Promise对象」 一节最后还用到了 module.exports 对外暴露两个函数，使外部可以调用我们继续打开 pages/index/index.js 文件，修改成这样const util = require('../../utils/util.js')\r\n\r\nPage({\r\n  data: {\r\n    hidden: false,\r\n    events: []\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n    var self = this\r\n    util.getEvents().then(function(data) {\r\n      self.setData({\r\n        hidden: true,\r\n        events: data\r\n      })\r\n    })\r\n  }\r\n})然后打开 pages/detail/detail.js ，修改如下const util = require('../../utils/util.js')\r\n\r\nPage({\r\n  data:{\r\n      hidden: false,\r\n      detail: {}\r\n  },\r\n  onLoad:function(param){\r\n    // 页面初始化 param为页面跳转所带来的参数\r\n    var self = this\r\n    util.getDetail(param.id).then(function(result){\r\n        self.setData({\r\n            detail: result[0]\r\n        })\r\n    })\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n    wx.setNavigationBarTitle({\r\n        title: this.data.detail.title\r\n    })\r\n    this.setData({\r\n        hidden: true\r\n    })\r\n  }\r\n})这里我们调用了 wx.setNavigationBarTitle 方法动态设置导航栏的标题内容，需要注意的是必须在页面渲染完成之后，即 onReady 之后才能调用该方法修改导航栏标题这次教程就到这里结束啦～涉及到的部分知识点并没有详细介绍和说明，如果有不明白的地方请大家根据我给出的链接去查看详细的介绍，此文权当快速上手的一个引子，更加深入的内容以及小程序的其他API的使用，还需要各位亲自去实践，欢迎交流～"}
{"title": "微信小程序架构分析《一》调试技巧，模块构成，理念分析 ", "author": "天下雪", "pub_time": "2016-10-15 17:21", "article_content": "本文分为以下几个部分：小程序调试技巧小程序主要模块构成小程序模块间通信设计理念分析小程序调试技巧微信开发者工具默认禁用了右键打开调试面板功能，我们可以修改开发者工具部分代码移除该限制。找到 app.nw 项目根目录，Mac 下为/Applications/wechatwebdevtools.app/Contents/Resources/app.nw使用 js-beautify 对代码批量格式化：cd /Applications/wechatwebdevtools.app/Contents/Resources/app.nw\r\nfind . -type f -name '*.js' -not -path \"./node_modules/*\" -not -path \"./modified_modules/*\" -exec js-beautify -r -s 2 -p -f '{}' \\;\r\n注释掉文件 app/dist/app.js 44 行和app/dist/components/simulator/webviewbody.js 149 行preventDefault 调用。101100 版本还需要修改 package.json 文件，去掉 --disable-devtools。执行完以上操作就可以右键打开页面的调试面板了，需要特别注意的是，使用 view 页面的面板后会导致 wxml 面板不可用，touch 事件无法响应等种种问题，请慎重使用。通过代码可以发现，在配置目录下添加 config.json 文件，然后加入{isDev:true} 可以启用开发者工具所谓的调试模式， 但是我在配置后程序无法正常启动，只好暂时先放弃这种方式。小程序主要模块构成小程序自身分为两个主要部分独立运行：view 模块和 service 模块。在开发者工具中，它们独立运行于不同的 webivew tag 中。view 模块负责 UI 显示，它由开发者编写的 wxml 和 wxss 转换后代码以及微信提供相关辅助模块组成。 一个 view 模块对应一个 webview 组件（也就是我们常规理解的一个页面）, 小程序支持同时多个 view 存在。view 模块通过 WeixinJSBridge 对象来跟后台通信。service 模块负责应用的后台逻辑，它由小程序的 js 代码以及微信提供的相关辅助模块组成。 一个应用只有一个 service 进程，它同样也是一个页面（至少在开发者工具内如此，上线后可能运行于 WeixinJSCore 之内），与 view 模块不同的是，它在程序生命周期内后台运行，service 模块通过与 view 模块实现不同但接口格式一样的 WeixinJSBridge 对象跟后台通信。小程序模块间通信(开发者工具内各模块通信图)做过微信开发相关的开发者会对 WeixinJSBridge 这个对象有所了解，它就是负责 UI 与后台 进行交互的一个中间层。应用号的 WeixinJSBridge 相比与之前的微信 webview 多出 publish 和 subscribe 两个公共方法来发布和订阅事件，从而进行双向通信。service 模块的 WeixinJSBridge 对象在文件app/dist/weapp/appservice/asdebug.js 中定义， view 层的 WeixinJSBridge 在文件 app/dist/inject/jweixindebug.js 中定义。 尽管两者都使用一样的接口以及使用 postMessage 方法与后台通信，但是其内部所做的事情确是完全不同的， 例如 service 模块可以直接通过 prompt 方法来通过 prompt调起底层组件，而 view 层的 WeixinJSBridge 只能发送消息 (参考 H5与Native交互之JSBridge技术)。我们来看一个典型的交互流程：用户点击界面触发事件对应 view 模块接收事件后将事件封装成所需格式后调用 publish 方法发送:WeixinJSBridge.publish('PAGE_EVENT', data)\r\ndata 参数举例：{\r\n\"data\": {\r\n  \"eventName\": \"onhidetap\",\r\n  \"data\": {\r\n    \"target\": {\r\n      ...\r\n    },\r\n    \"currentTarget\": {\r\n      ...\r\n    },\r\n    \"type\": \"tap\",\r\n    \"timeStamp\": 11457,\r\n    \"touches\": [ ...  ],\r\n    \"detail\": {\r\n      ...\r\n    }\r\n  }\r\n},\r\n\"options\": {\r\n  \"timestamp\": 1475445858336\r\n}\r\n}\r\n后台(开发者工具内为 nwjs 运行环境)将数据处理后发送给 service 模块，数据形如：{\r\n\"to\": \"appservice\",\r\n\"msg\": {\r\n  \"eventName\": \"PAGE_EVENT\",\r\n  \"data\": {\r\n    \"data\": {\r\n      \"eventName\": \"onhidetap\",\r\n      \"data\": {\r\n        \"target\": {\r\n          ...\r\n        },\r\n        \"currentTarget\": {\r\n          ...\r\n        },\r\n        \"type\": \"tap\",\r\n        \"timeStamp\": 75329,\r\n        \"touches\": [ ...  ],\r\n        \"detail\": {\r\n          ...\r\n        }\r\n      }\r\n    },\r\n    \"options\": {\r\n      \"timestamp\": 1475445858336\r\n    }\r\n  },\r\n  \"webviewID\": 0\r\n},\r\n\"command\": \"MSG_FROM_WEBVIEW\"\r\n}\r\nservice 模块的 WeixinJSBridge 内回调函数依据传来数据找到对应 view 的 page 模块后执行 对应名为 eventName 指向的函数回调函数调用 this.setData({hidden: true}) 改变 data，serivce 层计算该页面 data 后向后台发送 send_app_data 和 appdataChange 事件，具体数据格式如下：{\r\n\"appData\": {\r\n  \"page/index\": {\r\n    ...\r\n  }\r\n},\r\n\"sdkName\": \"send_app_data\",\r\n\"to\": \"backgroundjs\",\r\n\"comefrom\": \"webframe\",\r\n\"command\": \"COMMAND_FROM_ASJS\",\r\n\"appid\": \"touristappid\",\r\n\"appname\": \"chat\",\r\n\"apphash\": 70475629,\r\n\"webviewID\": 100000\r\n}\r\n{\r\n\"eventName\": \"appDataChange\",\r\n\"data\": {\r\n  \"data\": {\r\n    \"data\": {\r\n      \"hidden\": true\r\n    }\r\n  },\r\n  \"options\": {\r\n    \"timestamp\": 1475528706311\r\n  }\r\n},\r\n\"sdkName\": \"publish\",\r\n\"webviewIds\": [\r\n  0\r\n],\r\n\"to\": \"backgroundjs\",\r\n\"comefrom\": \"webframe\",\r\n\"command\": \"COMMAND_FROM_ASJS\",\r\n\"appid\": \"touristappid\",\r\n\"appname\": \"chat\",\r\n\"apphash\": 70475629,\r\n\"webviewID\": 100000\r\n}\r\n后台(文件 dist/components/simulator/webviewbody.js) 接收到appDataChange 事件数据后再将数据进行简单封装， 最后转发给到 view 层。 具体数据格式为：{\r\n\"to\": \"webframe\",\r\n\"msg\": {\r\n  \"eventName\": \"appDataChange\",\r\n  \"data\": {\r\n    \"data\": {\r\n      \"data\": {\r\n        \"hidden\": true\r\n      }\r\n    },\r\n    \"options\": {\r\n      \"timestamp\": 1475528706311\r\n    }\r\n  },\r\n  \"sdkName\": \"publish\",\r\n  \"webviewIds\": [\r\n    0\r\n  ],\r\n  \"to\": \"backgroundjs\",\r\n  \"comefrom\": \"webframe\",\r\n  \"command\": \"COMMAND_FROM_ASJS\",\r\n  \"appid\": \"touristappid\",\r\n  \"appname\": \"chat\",\r\n  \"apphash\": 70475629,\r\n  \"webviewID\": 100000,\r\n  \"act\": \"sendMsgFromAppService\"\r\n},\r\n\"command\": \"MSG_FROM_APPSERVICE\",\r\n\"webviewID\": 0,\r\n\"id\": 0.10577065353216675\r\n}\r\nview 层的 WeixinJSBridge 接收到后台的数据，如果 webviewID 匹配则将 data 与现有页面 data 合并， 然后就是 virtual dom 模块进行 diff 和 apply 操作改变 dom。小程序模块间消息传递除了界面事件和应用数据还包括触发原生方法、握手以及生命周期等类型， 尽管处理对象和处理方式不同，大体流程跟上面是一样的。view 模块和 service 模块的 WeixinJSBridge 都使用了 postMessage 接口 (参考MDN 文档) 与后台通信，但是由于该接口无法直接与 nwjs 后台进程通信，所以开发者工具会将 app/dist/contentscript/contentScript.js 文件做为contentScript 注入到 view 模块和 service 模块所在页面，contentScript.js 的代码提供了 message 消息到 chrome.runtime通信接口的转换。微信开发者工具扩展了 devtools 提供了 AppData 面板，开发者可以修改里面数据然后直接看到 view 界面的变化效果。这里修改数据后 nwjs 会将消息发送给 service 层，之后发生的事就跟上面 4 5 6 步一样：service 传递消息给 nwjs，最后到 view 层。设计理念分析小程序这样的分层设计显然是有意为之的，它的中间层完全控制了程序对于界面进行的操作， 同时对于传递的数据和响应时间也做到的监控。一方面程序的行为受到了极大限制， 另一方面微信可以确保他们对于小程序内容和体验有绝对的控制。我们在小程序的 js 代码里面是不能直接使用浏览器提供的 DOM 和 BOM 接口的，这一方面是因为 js 代码外层使用了局部变量进行屏蔽，另一方面即便我们可以操作 DOM 和 BOM 接口，它们对应的 也是 service 模块页面，并不会对页面产生影响。这样的结构也说明了小程序的动画和绘图 API 被设计成生成一个最终对象而不是一步一步执行的样子， 原因就是 json 格式的数据传递和解析相比与原生 API 都是损耗不菲的，如果频繁调用很可能损耗 过多性能，进而影响用户体验。理解了以上机制，再对 view 模块和 service 模块的 WeixinJSBridge 加以改造，我们便不难做到让 小程序跑在自己的环境下，这样就可以做些手机调试以及单页面测试等操作。"}
{"title": "微信小程序架构分析《二》：view 模块和 service 模块的构成 ", "author": "天下雪", "pub_time": "2016-10-15 17:27", "article_content": "你可以在app.nw/app/dist/weapp/tpl/pageFrameTpl.js 和app.nw/app/dist/weapp/tpl/appserviceTpl.js 文件内找到页面的模板。打开微信 web 开发者工具，然后输入 openVendor() 便会打开 WeappVendor这个目录，这里包含了 view 模块和 service 模块使用的几个核心文件：wcc 可执行程序，用于将 wxml 转为 view 模块使用的 js 代码，使用方式为wcc xxx.wxmlwcsc 可执行程序，用于将 wxss 转为 view 模块使用的 css 代码，使用方式为 wcsc xxx.wxssWAService.js 提供 service 模块大部分功能，下面会有详细介绍WAWebview.js 提供 view 模块大部分功能，下面会有详细介绍view 页面详解view 页面的 template 如下：<!DOCTYPE html>\r\n<html lang=\"zh-CN\">\r\n<head>\r\n  <link href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\" rel=\"Shortcut Icon\">\r\n  <meta charset=\"UTF-8\" />\r\n  <meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" />\r\n\r\n  <script>\r\n    var __webviewId__;\r\n  </script>\r\n\r\n  <!-- percodes -->\r\n\r\n  <!--{{WAWebview}}-->\r\n\r\n  <!--{{reportSDK}}-->\r\n\r\n  <!--{{webviewSDK}}-->\r\n\r\n  <!--{{exparser}}-->\r\n\r\n  <!--{{components_js}}-->\r\n\r\n  <!--{{virtual_dom}}-->\r\n\r\n  <!--{{components_css}}-->\r\n\r\n  <!--{{allWXML}}-->\r\n\r\n  <!--{{eruda}}-->\r\n\r\n  <!--{{style}}-->\r\n\r\n  <!--{{currentstyle}}-->\r\n\r\n  <!--{{generateFunc}}-->\r\n</head>\r\n\r\n<body>\r\n  <div></div>\r\n</body>\r\n\r\n</html>\r\n其中 <!-- percodes --> 会在 dev 模式开启后被替换为一个时间锚点，例如：<script>var pageFrameStartTime = new Date();</script>\r\n<!--{{WAWebview}}--> 会被 WAWebview.js 内代码替换<!--{{WAWebview}}--> 到 <!--{{generateFunc}}--> 之间暂时没有被使用到<!--{{generateFunc}}--> 会被 wcc 命令生成后的 js 代码替换除了上面这些，页面上还会被插入页面和应用的 style 标签，如：<link rel=\"stylesheet\" type=\"text/css\" href=\"index.wxss\">\r\n这里的 wxss 文件包含的是原始 wxss 文件转换后的 css以及生成 DOM 的启动脚本：<script>\r\n  document.dispatchEvent(new CustomEvent(\"generateFuncReady\", {\r\n    detail: {\r\n      generateFunc: $gwx('./page/index.wxml')\r\n    }\r\n  }))\r\n</script>\r\nWAWebview.js 文件中的各个模块(行号为 jsbeautify 之后代码行号，开发者工具版本：092300)：1-77 行： WeixinJSBridge 对象兼容层，这个大概只会在调试时用到，因为开发时和运行时页面都会被后台以注入的方式添加 WeixinJSBridge 这个对象。我们可以通过这段代码看到它暴露的方法： invoke invokeCallbackHandleron publish subscribe subscribe subscribeHandler。78-235 行：Reporter 对象，它的作用就是发送错误和性能统计数据给后台236-596 行：wx 对象，页面的核心之一，一方面封装 WeixinJSBridge 的 invokeMethod 方位为易于调用的形式（例如 redirectTo, navigateTo等），另一方面封装 WeixinJSBridge 回调方法，调用者可以使用wx.onAppDataChange(callback) 添加数据变更的回调函数，最后提供wx.publishPageEvent 发送页面事件到后台607-1267 行：wxparser 对象，提供 dom 到 wx element 对象之间的映射操作，提供元素操作管理和事件管理功能1268-1285 行：转发 window 上的 animation 和 transition 相关的动画事件到 exparser1286-1313 行：订阅并转发 WeixinJSBridge 提供的全局事件到 exparser1324-1345 行：转发 window 上的 error 以及各种表单事件到 exparser1347-3744 行：使用 exparser.registerBehavior 和exparser.registerElement 方法注册各种以 wx- 做为标签开头的元素到 exparser3744-4498 行：virtual dom 渲染算法实现，提供 diff apply render 等方法，该模块接口基本与 virtual-dom 一致，这里特别的地方在于它所 diff 和生成的并不是原生 DOM，而是各种模拟了 DOM 接口的 wx element 对象4599-4510 行：插入默认样式到页面从页面 data 到 dom 的主要流程如下：var vtree\r\nvar rootNode\r\n\r\ndocument.addEventListener(\"generateFuncReady\", function(e) {\r\n  var generateFunc = e.detail.generateFunc;\r\n  wx.onAppDataChange(function(obj) {\r\n    // 合并 data 到现有 data\r\n    DataStore.setData(obj.data)\r\n    // 生成 virtual dom 的 javascript plain object\r\n    var props = generateFunc(DataStore.getData())\r\n\r\n    // 第一次渲染\r\n    if (obj.options.firstRender) {\r\n      vtree = createVirtualTree(props, true)\r\n      rootNode = vtree.render()\r\n      rootNode.replaceDocumentElement(document.body)\r\n      wx.initReady()\r\n    } else {\r\n      var other_vtree = createVirtualTree(props, false)\r\n      var patches = vtree.diff(other_vtree)\r\n      patches.apply(rootNode)\r\n      vtree = other_vtree\r\n      document.dispatchEvent(new CustomEvent(\"pageReRender\", {}));\r\n    }\r\n  })\r\n})\r\n上面的 DataStore 对象提供合并和获取当前页面 data 对象的功能，其实现如下：var DataStore = (function() {\r\n  var data = {}\r\n  return {\r\n    getData: function() {\r\n      return data\r\n    },\r\n    setData: function(e) {\r\n      for (var t in e) {\r\n        for (var n = (0, parsePath)(t), o = data, a = void 0, s = void 0, c = 0; c < n.length; c++) Number(n[c]) === n[c] && Number(n[c]) % 1 === 0 ? Array.isArray(o) || (a[s] = [], o = a[s]) : \"[object Object]\" !== Object.prototype.toString.call(o) && (a[s] = {}, o = a[s]), s = n[c], a = o, o = o[n[c]];\r\n        a && (a[s] = e[t])\r\n      }\r\n    }\r\n  }\r\n})()\r\n\r\n// 解析 key 为 data 内对象的路径字符串\r\nfunction parsePath(e) {\r\n  for (var t = e.length, n = [], i = \"\", r = 0, o = !1, a = !1, s = 0; s < t; s++) {\r\n    var c = e[s];\r\n    if (\"\\\\\" === c) s + 1 < t && (\".\" === e[s + 1] || \"[\" === e[s + 1] || \"]\" === e[s + 1]) ? (i += e[s + 1], s++) : i += \"\\\\\";\r\n    else if (\".\" === c) i && (n.push(i), i = \"\");\r\n    else if (\"[\" === c) {\r\n      if (i && (n.push(i), i = \"\"), 0 === n.length) throw new Error(\"path can not start with []: \" + e);\r\n      a = !0, o = !1\r\n    } else if (\"]\" === c) {\r\n      if (!o) throw new Error(\"must have number in []: \" + e);\r\n      a = !1, n.push(r), r = 0\r\n    } else if (a) {\r\n      if (c < \"0\" || c > \"9\") throw new Error(\"only number 0-9 could inside []: \" + e);\r\n      o = !0, r = 10 * r + c.charCodeAt(0) - 48\r\n    } else i += c\r\n  }\r\n  if (i && n.push(i), 0 === n.length) throw new Error(\"path can not be empty\");\r\n  return n\r\n}\r\n可以看到，每次 data 变化之后，小程序就会开始整个页面的 diff patch 过程。对于原生实现的组件， exparser 会在监视到数据变化后发送对应事件到 WeixinJSBridge。service 页面详解service 页面会被被拼接为以下的样子：<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n  <link href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\" rel=\"Shortcut Icon\">\r\n  <script>\r\n  var __wxAppData = {}\r\n  var __wxRoute\r\n  var __wxRouteBegin\r\n  </script>\r\n  <script>var __wxConfig = {\"pages\":[\"page/index\"],\r\n  // app 相关各种配置\r\n  }</script>\r\n  <script src=\"http://70475629.appservice.open.weixin.qq.com/asdebug.js\"></script>\r\n  <script src=\"http://70475629.appservice.open.weixin.qq.com/WAService.js\"></script>\r\n  <script src=\"http://70475629.appservice.open.weixin.qq.com/app.js\"></script>\r\n  <script>\r\n    __wxRoute = 'page/index';\r\n    __wxRouteBegin = true\r\n  </script>\r\n  <script src=\"http://70475629.appservice.open.weixin.qq.com/page/index.js\"></script>\r\n</head>\r\n\r\n<body>\r\n  <script>\r\n    window._____sendMsgToNW({\r\n      sdkName: 'APP_SERVICE_COMPLETE'\r\n    })\r\n  </script>\r\n</body>\r\n\r\n</html>\r\n除了配置和开发者编写的页面、app.js，页面还在加载了 asdebug.js 和 WAService.js 两个文件。asdebug.js 文件位于 nwjs 项目目录下，路径为app/dist/weapp/appservice/asdebug.js。 它包含了两个部分，一个是 WeixinJSBridge 针对 service 模块的实现，另一块是一些方便命令使用的接口， 例如：help() 会告诉你一些可用的函数：该文件只会在开发者工具内被引入，如果小程序在微信内运行，应该会由微信底层提供 WeixinJSBridge。WAService 负责 service 模块的一些核心逻辑，它包含以下部分 (行号为 jsbeautify 之后代码行号，开发者工具版本：092300)：1-78 行： 跟 WAWebview.js 一样的 WeixinJSBridge 兼容模块79-245 行： 跟 WAWebview.js 一样的 Reporter 模块246-1664 行：比 WAWebview.js 中 wx 功能更为丰富 wx 接口模块1665-2304 行：appServiceEngine 模块，提供 Page，App，GetApp 接口2305-2360 行： 为 window 对象添加 AMD 接口 require define现在的 WAService 还有有很多地方依赖 window 对象，所以很有可能它在微信中和开发者工具内一样，依然运行于 webview 标签之内。"}
{"title": "微信小程序架构分析《三》：实现过程以及实时更新 ", "author": "天下雪", "pub_time": "2016-10-15 17:36", "article_content": "小程序实时运行工具 wept 的开发已经基本完成了， 你可以通过我的代码对小程序的 web 环境实现有更全面的认识。下面我将介绍它的实现过程以及实时更新的原理。小程序 web 服务实现我在 wept 的开发中使用 koa 提供 web 服务，以及 et-improve 提供模板渲染。第一步： 准备页面模板我们需要三个页面，一个做为控制层 index.html，一个做为 service 层service.html，还有一个做为 view 层的 view.htmlindex.html:<div class=\"head\">\r\n</div>\r\n<div class=\"scrollable\">\r\n</div>\r\n<div class=\"tabbar-root\">\r\n</div>\r\n<script>\r\n  var __wxConfig__ = {{= _.config}}\r\n  var __root__ = '{{= _.root}}'\r\n</script>\r\n<script src=\"/script/build.js\"></script>\r\nservice.html:<head>\r\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\r\n  <link href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\" rel=\"Shortcut Icon\">\r\n  <script>\r\n  var __wxAppData = {}\r\n  var __wxRoute\r\n  var __wxRouteBegin\r\n  global = {}\r\n  var __wxConfig = {{= _.config}}\r\n  </script>\r\n  <script src=\"/script/bridge.js\" type=\"text/javascript\"></script>\r\n  <script src=\"/script/service.js\" type=\"text/javascript\"></script>\r\n  {{each _.utils as util}}\r\n  <script src=\"/app/{{= util}}\" type=\"text/javascript\"></script>\r\n  {{/}}\r\n  <script src=\"/app/app.js\" type=\"text/javascript\"></script>\r\n  {{each _.routes as route}}\r\n  <script> var __wxRoute = '{{= route | noext}}', __wxRouteBegin = true;</script>\r\n  <script src=\"/app/{{= route}}\" type=\"text/javascript\"></script>\r\n  {{/}}\r\n</head>\r\n<body>\r\n  <script>\r\n    window._____sendMsgToNW({\r\n      sdkName: 'APP_SERVICE_COMPLETE'\r\n    })\r\n  </script>\r\n</body>\r\nview.html:<head>\r\n  <link href=\"https://res.wx.qq.com/mpres/htmledition/images/favicon218877.ico\" rel=\"Shortcut Icon\">\r\n  <meta charset=\"UTF-8\" />\r\n  <meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\" />\r\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"/css/default.css\">\r\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"/app/app.wxss\">\r\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"/app/{{= _.path}}.wxss\">\r\n  <script> var __path__ = '{{= _.path}}'</script>\r\n  <script src=\"/script/ViewBridge.js\" async type=\"text/javascript\"></script>\r\n  <script src=\"/script/view.js\" type=\"text/javascript\"></script>\r\n  <script>\r\n  {{= _.inject_js}}\r\n  </script>\r\n  <script>\r\n    document.dispatchEvent(new CustomEvent(\"generateFuncReady\", {\r\n      detail: {\r\n        generateFunc: $gwx('./{{= _.path}}.wxml')\r\n      }\r\n    }))\r\n  </script>\r\n</head>\r\n<body>\r\n  <div></div>\r\n</body>\r\n第二步： 实现 http 服务用 koa 实现的代码逻辑非常简单：server.js// 日志中间件\r\napp.use(logger())\r\n// gzip\r\napp.use(compress({\r\n  threshold: 2048,\r\n  flush: require('zlib').Z_SYNC_FLUSH\r\n}))\r\n// 错误提醒中间件\r\napp.use(notifyError)\r\n// 使用当前目录下文件处理 404 请求\r\napp.use(staticFallback)\r\n// 各种 route 实现\r\napp.use(router.routes())\r\napp.use(router.allowedMethods())\r\n// 对于 public 目录启用静态文件服务\r\napp.use(require('koa-static')(path.resolve(__dirname, '../public')))\r\n// 创建启动服务\r\nlet server = http.createServer(app.callback())\r\nserver.listen(3000)\r\nrouter.jsrouter.get('/', function *() {\r\n  // 加载 index.html 模板和数据，输出 index 页面\r\n})\r\n\r\nrouter.get('/appservice', function *() {\r\n  // 加载 service.html 模板和数据，输出 service 页面\r\n})\r\n\r\n// 让 `/app/**` 加载小程序所在目录文件\r\nrouter.get('/app/(.*)', function* () {\r\n  if (/\\.(wxss|js)$/.test(file)) {\r\n    // 动态编译为 css 和相应 js\r\n  } else if (/\\.wxml/.test(file)) {\r\n    // 动态编译为 html\r\n  } else {\r\n    // 查找其它类型文件, 存在则返回\r\n    let exists = util.exists(file)\r\n    if (exists) {\r\n      yield send(this, file)\r\n    } else {\r\n      this.status = 404\r\n      throw new Error(`File: ${file} not found`)\r\n    }\r\n  }\r\n})\r\n第三步：实现控制层功能实现完上面两步，就可以访问 view 页面了，但是你会发现它只能渲染，并不会有任何功能，因为 view 层功能依赖于控制层进行的通讯， 如果控制层收不到消息，它不会响应任何事件。控制层是整个实现过程中最复杂的一块，因为官方工具的代码与 nwjs 以及 react 等第三方组件耦合过高，所以无法拿来直接使用。 你可以在 wept 项目的 src 目录下找到控制层逻辑的所有代码，总体上控制层要负责以下几个功能：实现 service 层，view 层以及控制层之间的通讯逻辑依据路由指令动态创建 view （wept 使用 iframe 实现）根据当前页面动态渲染 header 和 tabbar实现原生 API 调用，返回结果给 service 层wept 里面 iframe 之间的通讯是通过 message.js 模块实现的，控制页面（index.html）代码如下：window.addEventListener('message', function (e) {\r\n  let data = e.data\r\n  let cmd = data.command\r\n  let msg = data.msg\r\n  // 没有跟 contentscript 握手阶段，不需要处理\r\n  if (data.to == 'contentscript') return\r\n  // 这是个遗留方法，基本废弃掉了\r\n  if (data.command == 'EXEC_JSSDK') {\r\n    sdk(data)\r\n  // 直接转发 view 层消息到 service，主要是各种事件通知\r\n  } else if (cmd == 'TO_APP_SERVICE') {\r\n    toAppService(data)\r\n  // 除了 publish 发送消息给 view 层以及控制层可以处理的逻辑（例如设置标题），\r\n  // 其它全部转发 service 处理，所有控制层的处理结果统一先返回 service\r\n  } else if (cmd == 'COMMAND_FROM_ASJS') {\r\n    let sdkName = data.sdkName\r\n    if (command.hasOwnProperty(sdkName)) {\r\n      command[sdkName](data)\r\n    } else {\r\n      console.warn(`Method ${sdkName} not implemented for command!`)\r\n    }\r\n  } else {\r\n    console.warn(`Command ${cmd} not recognized!`)\r\n  }\r\n})\r\n具体实现逻辑可以查看 src/command.js src/service.jssrc/sdk/*.js。对于 view/service 页面只需把原来 bridge.js 的window.postMessage 改为 window.top.postMessage 即可。view 层的控制逻辑由 src/view.js 以及 src/viewManage.js 实现，viewManage 实现了 navigateTo， redirectTo 以及 navigateBack 来响应 service 层通过名为 publish 的 command 传来的对应页面路由事件。header.js 和 tabbar.js 包含了基于 react 实现的 header 和 tabbar 模块（原计划是使用 vue，但是没找到与原生 js 模块通讯的 API）sdk 目录下包含了 storage，录音，罗盘模块，其它比较简单一些的原生底层调用我直接写在 command.js 里面了。以上就是实现运行小程序所需 webserver 的全部逻辑了，其实现并不复杂，主要困难在与理解微信这一整套通讯方式。实现小程序实时更新第一步： 监视文件变化并通知前端wept 使用了 chokidar 模块监视文件变化，变化后使用 WebSocket 告知所有客户端进行更新操作。 具体实现位于 lib/watcher.js 和 lib/socket.js, 发送内容是 json 格式的字符串。前端控制层收到 WebSocket 消息后再通过 postMessage 接口转发消息给 view/service 层：view.postMessage({\r\n  msg: {\r\n    data: {\r\n      data: { path }\r\n    },\r\n    eventName: 'reload'\r\n  },\r\n  command: 'CUSTOM'\r\n})\r\nview/service 层监听 reload 事件：WeixinJSBridge.subscribe('reload', function(data) {\r\n  // data 即为上面的 msg.data\r\n})\r\n第二步： 前端响应不同文件变化前端需要对 4 种（wxml wxss json javascript）不同类型文件进行 4 种不同的热更新处理，其中 wxss 和 json 相对简单。wxss 文件变化后前端控制层通知（postMessage 接口）对应页面（如果是 app.wxss 则是所有 view 页面）进行刷新，view 层收到消息后只需要更改对应 css 文件的时间戳就可以了，代码如下：o.subscribe('reload', function(data) {\r\n    if (/\\.wxss$/.test(data.path)) {\r\n    var p = '/app/' + data.path\r\n    var els = document.getElementsByTagName('link')\r\n    ;[].slice.call(els).forEach(function(el) {\r\n      var href = el.getAttribute('href').replace(/\\?(.*)$/, '')\r\n      if (p == href) {\r\n        console.info('Reload: ' + data.path)\r\n        el.setAttribute('href', href + '?id=' + Date.now())\r\n      }\r\n    })\r\n  }\r\n})\r\njson 文件变化首先需要判断，如果是 app.json 我们无法热更新，所以目前做法是刷新页面，对于页面的 json， 我们只需要在控制层上对 header 设置相应状态就可以了 (渲染工作由 react 帮我们处理)：socket.onmessage = function (e) {\r\n  let data = JSON.parse(e.data)\r\n  let p = data.path\r\n  if (data.type == 'reload'){\r\n    if (p == 'app.json') {\r\n      redirectToHome()\r\n    } else if (/\\.json$/.test(p)) {\r\n      let win = window.__wxConfig__['window']\r\n      win.pages[p.replace(/\\.json$/, '')] = data.content\r\n      // header 通过全局 __wxConfig__ 获取 state 进行渲染\r\n      header.reset()\r\n      console.info(`Reset header for ${p.replace(/\\.json$/, '')}`)\r\n    }\r\n  }\r\n}\r\nwxml 使用 VirtualDom API 提供的 diff apply 进行处理。首先需要一个接口获取新的 generateFunc 函数（用于生成 VirtualDom）， 添加 koa 的 router：router.get('/generateFunc', function* () {\r\n  this.body = yield loadFile(this.query.path + '.wxml')\r\n  this.type = 'text'\r\n})\r\n\r\nfunction loadFile(p, throwErr = true) {\r\n  return new Promise((resolve, reject) => {\r\n    fs.stat(`./${p}`, (err, stats) => {\r\n      if (err) {\r\n        if (throwErr) return reject(new Error(`file ${p} not found`))\r\n        // 文件不存在有可能是文件被删除，所以不能使用 reject\r\n        return resolve('')\r\n      }\r\n      if (stats && stats.isFile()) {\r\n        // parer 函数调用 exec 命令执行 wcsc 文件生成 wxml 对应的 javascript 代码\r\n        return parser(`${p}`).then(resolve, reject)\r\n      } else {\r\n        return resolve('')\r\n      }\r\n    })\r\n  })\r\n}\r\n有了接口就可以请求接口，然后执行返回函数进行 diff apply：// curr 为当前的 VirtualDom 树\r\nif (!curr) return\r\nvar xhr = new XMLHttpRequest()\r\nxhr.onreadystatechange = function() {\r\n  if (xhr.readyState === 4) {\r\n    if (xhr.status === 200) {\r\n      var text = xhr.responseText\r\n      var func = new Function(text + '\\n return $gwx(\"./' +__path__+ '.wxml\")')\r\n      window.__generateFunc__ = func()\r\n      var oldTree = curr\r\n      // 获取当前 data 生成新的树\r\n      var o = m(p.default.getData(), false),\r\n      // 进行 diff apply\r\n      a = oldTree.diff(o);\r\n      a.apply(x);\r\n      document.dispatchEvent(new CustomEvent(\"pageReRender\", {}));\r\n      console.info('Hot apply: ' + __path__ + '.wxml')\r\n    }\r\n  }\r\n}\r\nxhr.open('GET', '/generateFunc?path=' + encodeURIComponent(__path__))\r\nxhr.send()\r\njavascript 更新逻辑相对复杂一些, 首先依然是一个接口来获取新的 javascript 代码：router.get('/generateJavascript', function* () {\r\n  this.body = yield loadFile(this.query.path)\r\n  this.type = 'text'\r\n})\r\n然后我们在 window 对象上加入 Reload 函数执行具体的更换逻辑：window.Reload = function (e) {\r\nvar pages = __wxConfig.pages;\r\nif (pages.indexOf(window.__wxRoute) == -1) return\r\n// 替换原来的构造函数\r\nf[window.__wxRoute] = e\r\nvar keys = Object.keys(p)\r\n// 判定是否当前使用中页面\r\nvar isCurr = s.route == window.__wxRoute\r\nkeys.forEach(function (key) {\r\n  var o = p[key];\r\n  key = Number(key)\r\n  var query = o.__query__\r\n  var page = o.page\r\n  var route = o.route\r\n  // 页面已经被创建\r\n  if (route == window.__wxRoute) {\r\n    // 执行封装后的 onHide 和 onUnload\r\n    isCurr && page.onHide()\r\n    page.onUnload()\r\n    // 创建新 page 对象\r\n    var newPage = new a.default(e, key, route)\r\n    newPage.__query__ = query\r\n    // 重新绑定当前页面\r\n    if (isCurr) s.page = newPage\r\n    o.page = newPage\r\n    // 执行 onLoad 和 onShow\r\n    newPage.onLoad()\r\n    if (isCurr) newPage.onShow()\r\n    // 更新 data 数据\r\n    window.__wxAppData[route] = newPage.data\r\n    window.__wxAppData[route].__webviewId__ = key\r\n    // 发送更新事件, 通知 view 层\r\n    u.publish(c.UPDATE_APP_DATA)\r\n    u.info(\"Update view with init data\")\r\n    u.info(newPage.data)\r\n    // 发送 appDataChange 事件\r\n    u.publish(\"appDataChange\", {\r\n      data: {\r\n        data: newPage.data\r\n      },\r\n      option: {\r\n        timestamp: Date.now()\r\n      }\r\n    })\r\n    newPage.__webviewReady__ = true\r\n  }\r\n})\r\nu.info(\"Reload page: \" + window.__wxRoute)\r\n}\r\n以上代码需要添加到 t.pageHolder 函数后才可运行最后在 view 层初始化后把 Page 函数切换到 Reload 函数(当然你也可以在请求返回 javascript 前把 Page 重命名为 Reload) 。<body>\r\n<script>\r\n  window._____sendMsgToNW({\r\n    sdkName: 'APP_SERVICE_COMPLETE'\r\n  })\r\n</script>\r\n</body>\r\n总算是把这个坑填上了。希望通过这一系列的分析带给前端开发者更多思路。"}
{"title": "微信小程序开发教程：Flex布局 ", "author": "天下雪", "pub_time": "2016-10-15 21:22", "article_content": "微信小程序页面布局方式采用的是Flex布局。Flex布局，是W3c在2009年提出的一种新的方案，可以简便，完整，响应式的实现各种页面布局。Flex布局提供了元素在容器中的对齐，方向以及顺序，甚至他们可以是动态的或者不确定的大小的。Flex布局的主要特征是能够调整其子元素在不同的屏幕大小中能够用最适合的方法填充合适的空间。Flex布局的特点:任意方向的伸缩，向左，向右，向下，向上在样式层可以调换和重排顺序主轴和侧轴方便配置子元素的空间拉伸和填充沿着容器对齐微信小程序实现了Flex布局,简单介绍下Flex布局在微信小程序中的使用。伸缩容器设有display:flex或者display:block的元素就是一个flex container(伸缩容器)，里面的子元素称为flex item(伸缩项目)，flex container中子元素都是使用Flex布局排版。display:block 指定为块内容器模式，总是使用新行开始显示，微信小程序的视图容器(view,scroll-view和swiper)默认都是dispaly:block。display:flex:指定为行内容器模式，在一行内显示子元素，可以使用flex-wrap属性指定其是否换行，flex-wrap有三个值:nowrap(不换行),wrap(换行),wrap-reverse(换行第一行在下面)使用display:block(默认值)的代码:  <view class=\"flex-row\" style=\"display: block;\">        <view class=\"flex-view-item\">1</view>        <view class=\"flex-view-item\">2</view>        <view class=\"flex-view-item\">3</view>    </view>显示效果:改换成display:flex的显示效果:可以从效果图看到block和flex的区别，子元素view是在换行显示(block)还是行内显示(flex)。主轴和侧轴Flex布局的伸缩容器可以使用任何方向进行布局。容器默认有两个轴：主轴(main axis)和侧轴(cross axis)。主轴的开始位置为主轴起点(main start)，主轴的结束位置为主轴终点(main end),而主轴的长度为主轴长度(main size)。同理侧轴的起点为侧轴起点(cross start),结束位置为侧轴终点(cross end),长度为侧轴长度(cross size)。详情见下图:注意，主轴并不是一定是从左到右的，同理侧轴也不一定是从上到下，主轴的方向使用flex-direction属性控制,它有4个可选值:row :从左到右的水平方向为主轴row-reverse：从右到左的水平方向为主轴column:从上到下的垂直方向为主轴column-reverse从下到上的垂直方向为主轴如果水平方向为主轴，那个垂直方向就是侧轴，反之亦然。四种主轴方向设置的效果图:图中的实例展示了使用了不同的flex-direction值排列方向的区别。实例代码:<view >    <view class=\"flex-row\" style=\"display: flex;flex-direction: row;\">        <view class=\"flex-view-item\">1</view>        <view class=\"flex-view-item\">2</view>        <view class=\"flex-view-item\">3</view>    </view>    <view class=\"flex-column\" style=\"display:flex;flex-direction: column;\" >        <view class=\"flex-view-item\">c1</view>        <view class=\"flex-view-item\">c2</view>        <view class=\"flex-view-item\">c3</view>    </view></view>运行效果：对齐方式子元素有两种对齐方式：justify-conent 定义子元素在主轴上面的对齐方式align-items 定义子元素在侧轴上对齐的方式jstify-content有5个可选的对齐方式:flex-start 主轴起点对齐(默认值)flex-end 主轴结束点对齐center 在主轴中居中对齐space-between 两端对齐，除了两端的子元素分别靠向两端的容器之外，其他子元素之间的间隔都相等space-around 每个子元素之间的距离相等，两端的子元素距离容器的距离也和其它子元素之间的距离相同。justify-content的对齐方式和主轴的方向有关，下图以flex-direction为row，主轴方式是从左到右,描述jstify-content5个值的显示效果:align-items表示侧轴上的对齐方式:stretch 填充整个容器(默认值)flex-start 侧轴的起点对齐flex-end 侧轴的终点对齐center 在侧轴中居中对齐baseline 以子元素的第一行文字对齐align-tiems设置的对齐方式，和侧轴的方向有关，下图以flex-direction为row,侧轴方向是从上到下,描述align-items的5个值显示效果:有了主轴和侧轴的方向再加上设置他们的对齐方式，就可以实现大部分的页面布局了。案例地址：https://github.com/jjz/weixin-mina/blob/master/pages/flex/flex.wxml"}
{"title": "微信小程序技术教程：集成 Redux ", "author": "天下雪", "pub_time": "2016-10-15 21:48", "article_content": "示例Redux是什么Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux官方文档为什么要使用Redux小程序俨然是一个类似Hybrid App的东西，前面是SPA，小程序提供一些原生功能的接口。现在前端程序规模都比较大，页面状态，数据缓存，需要管理的东西太多。引入Redux可以方便的管理这些状态。并且Redux丰富的周边工具也是很有吸引力的。集成Redux小程序的模块化微信的文档并没有指出如何使用第三方库，所以只能从微信小程序的模块化入手。文档中提到，模块化的关键是：module.exports = function(){}同时，如果我们去观察小程序开发环境的network面板，点击任何一个js，我们可以发现：项目目录中的所有js文件都会自动被加载，无论我们是否在代码中require所以的模块都会被套上下面的代码：define(\"reducers/visibilityFilter.js\", function(require, module){var window={Math:Math}/*兼容babel*/,location,document,navigator,self,localStorage,history,Caches;/*******************//******你写的代码******/                                                                 /********************/})这实际上是类似AMD的加载方式，但是跟标准的AMD又有些不同，缺少了依赖部分的声明。function(require, module){}: 这个函数包裹的是模块的实现，也就是我们自己写的代码，小程序给我们暴露了两个参数require和module，require用来在模块中加载其他模块，module用来将模块中的方法暴露出去：module.exports = function(){}所以只要需要让第三方库的代码使用这种形式的export就可以了。构建Redux的微信小程序包这里主要目标是打一个Redux包，让它可以兼容微信小城的加载方式下载Redux的代码到本地：git clone https://github.com/reactjs/redux.git安装依赖：npm install打包：npm run build:umd && npm run build:umd这些命令的详细内容可以到redux项目的package.json中查看。这些命令是是使用webpack构建UMD模式的包。也就是说所有的代码，包括依赖的库都会被打包到一个文件中，并且自带一段模块加载代码，文件可以在dist目录下找到。带min.js后缀的是minify过的。      4.微调加载方式：用编辑器打开dist目录下的redux.js文件(function webpackUniversalModuleDefinition(root, factory) {    if(typeof exports === 'object' && typeof module === 'object')        module.exports = factory();    else if(typeof define === 'function' && define.amd)        define([], factory);    else if(typeof exports === 'object')        exports[\"Redux\"] = factory();    else        root[\"Redux\"] = factory();})(this, function() {...  })这段代码是用来加载模块的，里面的factory函数的返回的内容是用webpack提供的loader组织起来的redux的代码和第三方依赖。如果我们把这个文件拷贝到小程序中，只需要让程序能正常进入第三行代码，就能把Redux加载进来。将第二行代码：if(typeof exports === 'object' && typeof module === 'object')      修改成：if(typeof module === 'object')这样修改的原因是，在微信小程序的环境中是没有exports变量的，所以就没办法正确进入这个分支，删除之后就可以正确进入了拷贝进工程目录例如，我们拷贝到libs目录下，那么我们在程序中使用时，只要当做是一个本地模块去require就可以了：var redux = require('./libs/redux.js')通过这里的示例，其实我们发现，我们可以通过类似的方法，使用Webpack打包第三方库，就可以集成任何库了。使用Redux我们可以使用Redux的微信小程序绑定库来简化一些代码：wechat-weapp-redux，详细的安装和使用说明可以参照wechat-weapp-redux的README集成Redux-devtools如果没有redux-devtools那么使用redux的效果可能是要减半的。因为微信小程序的开发环境是定制的，暂时没有发现办法直接安装redux-devtool的插件。这里使用remote-redux-devtools，remotedev-server安装remote-redux-devtools原版的remote-redux-devtools使用的一个websocket的依赖会使用原生的WebSocket，小程序是不支持的，所以需要改成小程序的websocket实现。修改好的包在这里：remote-redux-devtools把代码下载到工程目录里面就可以用了。安装和启动remotedev-servernpm install -g remotedev-serverremotedev --hostname=localhost --port=5678          因为没办法用npm安装到本地（开头提到的，微信小程序会尝试去加载项目目录中的所有js），所以这里使用全局安装，第二条命令是启动remotedev-server，hostname和port分别指定为localhost和5678。     3.  集成devtoolconst {createStore, compose} = require('./libs/redux.js');const devTools = require('./libs/remote-redux-devtools.js').default;const reducer = require('./reducers/index.js')function configureStore() {  return createStore(reducer, compose(devTools({    hostname: 'localhost',    port: 5678,    secure: false  })));}module.exports = configureStore;把devtool使用redux的compose加到store中去。hostname和port是指定为之前启动remotedev-server启动时候指定的参数。保存之后重启一下小程序，如果没有报错的话就OK了      4.  打开监视器          可以在浏览器中访问localhost:5678，这是remotedev-server自带的监视器，正常打开的话是这样的：          左边有一个@@INIT说明小程序的redux连接成功了。但是这里这个自带的监视器可能打不开，因为它的一些js包是存在国外的cdn上的，偶尔访问不到。这个时候可以使用http://remotedev.io/local/，点击下面的setting，设置使用本地的server。保存之后刷新页面，应该跟上面显示的结果一样。示例详细的代码示例，可以参照：wechat-weapp-redux-todos"}
{"title": "梁兴臣:微信小程序开发三宗罪和解决方案 ", "author": "天下雪", "pub_time": "2016-10-15 22:33", "article_content": "在微信公布小程序的文档和开发工具后，脉冲软件在第一时间进行了学习和体验，我们发现微信小程序的技术架构和开发体验让我们非常失望。由于微信小程序的运行环境并不是一个标准的浏览器环境，而且微信的封装工作并不完善，所以我们以往开发中的很多经验并不适用。这并非简单的开发习惯不适应，更重要的是我们的开发流程、规范将不适用。微信小程序开发第一宗罪: 无法调用NPM包虽然微信小程序开发工具打包时实现了require函数加载依赖，但并不是完整的CommonJS依赖管理。因为require函数仅仅能够加载项目中的JS文件，而且必须严格定义JS文件路径，路径不支持CommonJS的路径风格。例如如下加载方式都将出错：require('lodash');require('lodash/map');require('./foo');在微信小程序开发工具中，我们必须对应写为如下格式：require('node_modules/lodash/lodash.js');require('node_modules/lodash/map.js');require('./foo.js');虽然我们可以像上面代码一样加载node_modules目录中的库，但是实际运行时却发生了：在调试工具的Network选项卡中，我们看到运行时加载了1000多个文件，总数据量1.8MB，而我们仅仅是在代码中加载了一个lodash库而已！这是因为微信小程序开发工具会将所有项目下的js文件视为项目文件，并进行打包。而实际开发中，我们需要安装很多的NPM扩展库，而这些扩展库中有大量的不需要打包的文件，例如lodash中有上千文件，而我们只需要用到其中的非常少的一部分。另外，在开发中，我们往往需要安装babal、eslient、webpack、grunt等待开发工具，微信小程序开发工具会一视同仁将这些工具的源码也进行打包......实测开发者工具将崩溃！开发者将崩溃！我崩溃！所以不支持NPM包的原因，是微信开发者工具不支持CommonJS标准，不支持CommonJS标准的原因，是微信开发者工具想当然地认为项目目录下的js文件一定是项目文件，所以只实现了简单的require函数，想当然的原因是。。。微信小程序开发第二宗罪: 无法使用Babel转码无法使用Babel转码的原因其实仍然归结于无法加载NPM库。但是后果将十分严重。因为你将不能再安全使用ES6/7特性，你将无法使用async/await函数，你将和无尽的callback做斗争，你该怎样描述自己？回调地狱中的苦逼程序员？如果你看到这里不明白Babel为何物，那么祝贺你，因为不曾见过天堂就不知何为地狱，你无须为不支持ES6/7而烦恼。但一旦你的大脑支持了ES6/7，用过了Babel，你就回不去了，像我一样，无Babel不编码。微信小程序开发第三宗罪: 无法重用组件其实微信小程序开发是并非完全不能重用组件，比如WXML语法中支持import和 include。但是那仅仅是视图模板可重用，并非组件可重用，因为我们认为组件在应当包含视图和逻辑。WXML其实是基于可重用的组件，但是不允许我们自定义组件。如果你有React经验，你就会明白我的意思。例如，你的小程序是个电商APP，项目中有两个页面中同时包含了商品列表组件，比如某分类下商品列表和搜索结果列表，我们知道这两个列表其实仅仅是参数不同而已。但是在小程序开发中，你只能将列表的模板抽象出来，不能将逻辑抽象出来，所以你就需要在两个页面上都实现一遍列表组件的控制逻辑，比如刷新、加载更多。。。我们的实践只吐槽、管杀不管埋是不道德的，既然发现了微信小程序开发中的各种弊端，我们脉冲软件在开发之中总结出了一套流程和工具，专为解决上述三个问题，并免费发布到了开源社区，这就是Labrador。接下来我们一起来尝试一下我们脉冲软件的开发体验。安装Labrador通过命令 npm install -g labrador-cli 全局安装Labrador控制行工具。初始化项目通过如下命令新建一个Labrador项目：mkdir democd demonpm initlabrador init项目初始化完成后，该目录是这个样子的：图中的src是我们的源码目录，node_modules是NPM包目录，dist是目标输出目录。请在开发者工具中新建一个项目，并设置路径到dist目录，请勿设置为demo目录！使用WebStorm或Sublime打开demo目录，开发过程中，我们使用WebStorm或Sublime修改src目录下的源码，请勿直接修改dist目录中的文件，因为dist目录是通过labrador命令生成的。在demo目录中运行 labrador build 命令编译项目，该命令会将src目录下的文件一一处理并生成dist目录下对应的文件。我们也可以运行 labrador watch 命令监控src目录下的文件变化，这样就不用每次修改后手动运行编译命令。加载NPM包我们以lodash包为例，在src/app.js中键入代码 const _ = require('lodash'); 编译后，我们看到dist目录下的文件是这样的：我们看到dist目录下有一个npm/lodash目录，该目录下只有一个lodash.js文件，那么在微信web开发者工具中打包预览，lodash的库将只有这个文件被加载。这一切是怎么发生的？我们看一下dist/app.js的源码，发现源码中const _ = require('lodash'); 被编译为 var _ = require('./npm/lodash/lodash.js'); 然后labrador命令将node_modules/lodash/lodash.js 文件复制到了dist/npm/lodash/lodash.js 。这就是通过labrador可以调用NPM包的原理。重要的是，只有真正用到的js文件才被labrador命令加入到项目目录中。这样一个小小的改进象征着我们的小程序可以便捷调用NPM仓库中海量的扩展库！Babel转码在初始化的示例代码src/app.js中的内容是这样的：图中timer和getUserInfo属性都为async函数，函数体内使用await调用异步操作。labrador 库对微信API进行了封装，使用 const wx = require('labrador'); 覆盖默认的全局变量wx; 封装后的wx对象提供的异步方法返回的都是Promise异步对象，结合async/await函数彻底终结callback，将异步代码同步写，轻松逃离回调地狱！但目前async/await函数是不被浏览器支持的，我们需要使用babel对其转码，labrador编译命令已经内置了babel转码，转码后的代码可以查看dist/app.js，内容过长，不再张贴。重用组件重用组件最需要解决的问题是组件的逻辑代码怎样重用。在实例代码中有一个src/components目录，用来存放项目内的可重用组件，其结构是这样的：子目录src/components/list中存放着一个可重用的组件。list.js / list.less / list.xml 分别对应微信小程序的 js / wxss / wxml 文件。JS为控件的逻辑层，其代码如下：文件导出一个List类，这个组件类拥有像Page一样的生命周期函数onLoad, onReady, onShow, onHide, onUnload 以及setData函数。LESS文件对应微信的WXSS文件，因为微信小程序实现的限制，LESS中无法使用连级选择语法，但是可以定义变量，方便开发。XML文件对应微信的WXML文件，是组件视图描述文件，list.xml内容为：文件中导出一个名为list的template。组件不但可以存放在src/components目录内，还可以单独做成NPM包，这样就可以轻松做到跨项目间的组件共享。组件定义完成后，接下来是在页面中调用，在 src/pages/index/index.js 中有如下代码：代码中首先引入了labrador库替换全局的默认wx对象，并使用labrador.createPage方法代替全局的Page函数声明页面。然后加载List组件类，在页面声明配置中，增加了components属性，并将List组件类实例化传入。labrador.createPage方法是对Page方法的一层封装，目的是在页面初始化时和组件对象进行关联。在 src/pages/index/index.less 中加入代码 @import 'list' 即可调用list组件的样式，如果在src/components/list中找不到list.less，那么编译命令将在NPM包中寻找 node_modules/list/index.less 。在 src/pages/index/index.xml 中加入代码 <component key=\"list\"/> 即可调用list组件的模板文件，component 是Labrador自定义的组件，编译后对应生成 import 和 template。如果在src/components/list中找不到list.xml，那么编译命令将在NPM包中寻找 node_modules/list/index.xml"}
{"title": "新手入门福音：微信小程序试水体验过程 ", "author": "天下雪", "pub_time": "2016-10-16 13:26", "article_content": "1. https://mp.weixin.qq.com注册一个公众号，成为开发者，拿到一个appId。2. 下载微信开发者工具，https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1476197489869。3. 使用微信扫码登录4. 添加一个项目，把注册公众号获得到的appId复制到appId，名称目录填写好后，点击添加项目，显示小程序还处于内测阶段，没有被邀请的用户获取的appId无法使用，尝试认证，但个人用户无法认证（有说关注大于500的可以，一时难以凑齐，弃之），因2013年以后公众号无法升级为服务号，于是又开始注册服务号，因为不是企业，没有各种相关信息，又弃之，最后只能选择无appId进行项目添加，虽少些功能，但也大体可以使用。往一个空的文件夹中添加项目，会自动创建一个获取信息和登录日志的小demo，结构非常清晰（加了几个接口和一个文件夹detail图）.js => .js   .wxml => .html  .wxss => .css  .json => .json 点击调试可以看到效果，头像，昵称，和helloword（因为是扫码登录，开发者工具绑定了开发者信息，所以可以拿到个人信息）。点击左侧编辑可对代码进行编辑，编辑完后保存、编译就可查看新效果。"}
{"title": "微信小程序试水教程：参数传递 ", "author": "天下雪", "pub_time": "2016-10-16 13:42", "article_content": "教程一：参数传递这里我找到两种小程序上的参数传递方式，为了方便，我单独拿出来和大家分享下.一、通过事件进行参数传递先来看眼小程序对事件的定义：#什么是事件?\r\n\r\n这里是列表文本事件是视图层到逻辑层的通讯方式。\r\n这里是列表文本事件可以将用户的行为反馈到逻辑层进行处理。\r\n这里是列表文本事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。\r\n这里是列表文本 事件对象可以携带额外信息，如id, dataset, touches。\r\n很明确的指出了是视图层【wxml】到逻辑层【js】的通信方式，时间对象可以携带额外信息，用这个事件来传递参数肯定没错了，接下来我们就来实际看下例子：视图.wxml  <view id=\"tapTest\" data-hi=\"MINA\" bindtap=\"tapName\"> Click me! </view>\r\n逻辑.jsPage({\r\n  tapName: function(event) {\r\n            console.log(event.target)\r\n  }\r\n})\r\nlog打印可以看到 dataset 里面就是我们设置的data-hi=\"MINA\"的值了。现在我们来看下刚刚我们写的， 首先 bindtap,以bind开头的就是要给他绑定个事件，这个事件的名字就是“=”号后面的数值就是绑定的事件名称，需要在 逻辑【js】层定义上。 然后就是传值了，注意到的朋友可以看到 我们这里写了data-hi 和我们平时写js的传值是同一个定义方法。这个data-*就对应事件的属性target里的dataset 值。这里我们需要调用的话就是event.target.dataset.hi就能取到data-hi所对应的值。这里需要注意下 data的定义名称： 书写方式： 以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.target.dataset 中会将连字符转成驼峰elementType。官方示例：<view data-alpha-beta=\"1\" data-alphaBeta=\"2\" bindtap=\"bindViewTap\"> DataSet Test </view>\r\n\r\nPage({\r\n  bindViewTap:function(event){\r\n    event.target.dataset.alphaBeta == 1 // - 会转为驼峰写法\r\n    event.target.dataset.alphabeta == 2 // 大写会转为小写\r\n  }\r\n})\r\n二、navigator 跳转url传参*.wxml<view class=\"btn-area\">\r\n  <navigator url=\"navigate?title=navigate\" hover-class=\"navigator-hover\">跳转到新页面</navigator>\r\n  <navigator url=\"redirect?title=redirect\" redirect hover-class=\"other-navigator-hover\">在当前页打开</navigator>\r\n</view>\r\n*.js 跳到新页面之后在onload里面直接接收参数，接收方法也就是 options.[参数值]Page({\r\n  onLoad: function(options) {\r\n    this.setData({\r\n      title: options.title\r\n    })\r\n  }\r\n})\r\n好啦，今天就写到这里，我顺便把文档链接写上，上面写的文档里都有。我只是把它们搬出来了，用我的话说了一遍。 …(⊙＿⊙；)…什么是事件navigator"}
{"title": "微信小程序试水教程：富文本转文本 ", "author": "天下雪", "pub_time": "2016-10-16 13:47", "article_content": "最近小程序这么火，我也来搞搞。发现了一个恶心的问题。小程序没有组件能支持富文本内容的，改接口又不太合适，于是有了这问，没技术含量纯粹记录首先我们看眼没有被格式的富文本显示：*.wxml内代码。content是富文本内容    <view>\r\n     <text>{{content}}</text>\r\n    </view>\r\n显示结果：由以上图片看到，小程序无法解析html文件我们需要处理html富文本内容，让其显示好看点下面直接上代码了，主要功能就是利用js的replace 对富文本经行处理，大家可以看一下。一起优化，方便对富文本更好的处理。convertHtmlToText: function convertHtmlToText(inputText) {\r\n    var returnText = \"\" + inputText;\r\n    returnText = returnText.replace(/<\\/div>/ig, '\\r\\n');\r\n    returnText = returnText.replace(/<\\/li>/ig, '\\r\\n');\r\n    returnText = returnText.replace(/<li>/ig, '  *  ');\r\n    returnText = returnText.replace(/<\\/ul>/ig, '\\r\\n');\r\n    //-- remove BR tags and replace them with line break\r\n    returnText = returnText.replace(/<br\\s*[\\/]?>/gi, \"\\r\\n\");\r\n\r\n    //-- remove P and A tags but preserve what's inside of them\r\n    returnText=returnText.replace(/<p.*?>/gi, \"\\r\\n\");\r\n    returnText=returnText.replace(/<a.*href=\"(.*?)\".*>(.*?)<\\/a>/gi, \" $2 ($1)\");\r\n\r\n    //-- remove all inside SCRIPT and STYLE tags\r\n    returnText=returnText.replace(/<script.*>[\\w\\W]{1,}(.*?)[\\w\\W]{1,}<\\/script>/gi, \"\");\r\n    returnText=returnText.replace(/<style.*>[\\w\\W]{1,}(.*?)[\\w\\W]{1,}<\\/style>/gi, \"\");\r\n    //-- remove all else\r\n    returnText=returnText.replace(/<(?:.|\\s)*?>/g, \"\");\r\n\r\n    //-- get rid of more than 2 multiple line breaks:\r\n    returnText=returnText.replace(/(?:(?:\\r\\n|\\r|\\n)\\s*){2,}/gim, \"\\r\\n\\r\\n\");\r\n\r\n    //-- get rid of more than 2 spaces:\r\n    returnText = returnText.replace(/ +(?= )/g,'');\r\n\r\n    //-- get rid of html-encoded characters:\r\n    returnText=returnText.replace(/&nbsp;/gi,\" \");\r\n    returnText=returnText.replace(/&amp;/gi,\"&\");\r\n    returnText=returnText.replace(/&quot;/gi,'\"');\r\n    returnText=returnText.replace(/&lt;/gi,'<');\r\n    returnText=returnText.replace(/&gt;/gi,'>');\r\n\r\n   return returnText;\r\n}\r\n将上面代码放入任意适合的小程序js文件中， 然后在需要处理数据的js文件里，引入文件，下面给出放入app.js文件中的调用示例：var app = getApp()//获取app小程序实例\r\n onLoad: function (options) {\r\n       wx.request({\r\n      url: 'http://example.com/api' + options.id+'.json',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      success: function (res) {\r\n       res.data.content =  app.convertHtmlToText(res.data.content )\r\n         that.setData({\r\n           art: res.data.content\r\n         })\r\n         console.log(res.data)\r\n      }\r\n    })\r\n｝\r\n然后编译刷新下，可以看到结果了：这里可以继续调整下css，使显示得更好看点。"}
{"title": "前端之巅：在Chrome浏览器上运行微信小程序 ", "author": "天下雪", "pub_time": "2016-10-16 17:36", "article_content": "微信小程序的开发框架体验起来，还不错——自带了UI框架。但是问题是它的IDE，表现起来相当的糟糕——其实主要是因为，我当时买WebStorm License买了好多年。所以，我觉得他的IDE真不如我这个付费好用。而且，作为一个拥护自由和开源的“GitHub 中国区首席Markdown程序员”。微信在微信小程序引导着Web开向封闭，我们再也不能愉快地分享我们的代码了。如果我们放任下去，未来的Web世界令人堪忧。好了，废话说完了，本文只是一个Demo的介绍。文章太长不想看，可以直接看Demo哈哈：GitHub: https://github.com/phodal/weapp-webdemo 预览：http://weapp.phodal.com/真实世界下的MINA三基本元素微信小程序的背后运行的是一个名为MINA框架。在之前的几篇文章里，我们介绍得差不多了。现在让我们来作介绍pipeline：Transform WXML和WXSS当我们修改完WXML、WXSS的时候，我们需要重新编译项目才能在浏览器上看到效果。这时候后台就会执行一些transform动作： WCC来转换WXML为一个genrateFun，执行这个方法将会得到一个Virtual DomWXSS就会转换WXSS为CSS——这一点有待商榷。WCC和WXSS，可以从vendor目录下获取到，在“微信Web开发者工具”下敲入help，你就会得到下面的东东：运行openVendor()，你就会得到上面的WCSS、WXSS、WAService.js、WAWebview.js四个文件了。Transform js文件对于JS文件来说，则是一个拼装的过程，如下是我们的app.js文件：它在转换后会变成：我假装你已经知道这是什么了，反正我也不想、也不会解释了~~。同理于：至于它是如何replace或者apend到HTML中，我就不作解释了。MINA如何运行？为了运行一个Page，我们需要有一个Virtual Dom，即用WCC转换后的函数，如：然后在我们的HTML中加一个script，如就会凑发这个事件了。我简单的拆分了WXWebview.js得到了几个功能组件：define.js，这里就是定义AMD模块化的地方exparser.js，用于转换WXML标签到HTML标签exparser-behvaior.js，定义不同标签的一些行为mobile.js，应该是一个事件库，好像我并不关心。page.js，核心代码，即Page、App的定义所在。report.js，你所说的一切都能够用作为你的呈堂证供。virtual_dom.js，一个virtual dom实现结合wcc使用，里面应该还有component.css，也可能是叫weuiwa-wx.js，定义微信各种API以及WebView和Native的地方，和下面的WX有冲突。wx.js，同上，但是略有不同。wxJSBridge.js，Weixin JS Bridge于是，我就用上面的组件来定义不同的位置好了。当我们触发自定义的generateFuncReady事件时，将由virtual_dom.js来接管这次Render：因此，这里就是负责DOM初始化的地方了，这里得到的Dom结果是这样的：而我们写的WXML是这样的：很明显view会被转换为wx-view，text会被转换为wx-text等等，以此类推。这个转换是在virtual dom.js中调用的，调用的方法就是exparser。遗憾的是我现在困在 data 初始化上面了~~，这里面有两套不同的事件系统，有一些困扰。其中有一个是：WeixinJSBridge、还有一个是app engine中的事件系统，两个好像不能互调。使用WebStorm开发在浏览器上运行之前，我们需要简单的mock一些方法，如： window.webkit.messageHandlers.invokeHandler.postMessagewindow.webkit.messageHandlers.publishHandler.postMessageWeixinJSCore.publishHandlerWeixinJSCore..invokeHandler然后把 config.json中的一些内容变成__wxConfig，如： 如这里我们的appname是哈哈哈哈哈哈哈——我家在福建。然后在我们的HTML中引入各个JS文件，啦啦。我们还需要一个自动化的glup脚本来watch wxml和wxss的修改，然后编译，如：说了这么多，你还不如去看代码好了：GitHub: https://github.com/phodal/weapp-webdemo 预览：http://weapp.phodal.com/"}
{"title": "微信小程序canvas篇，实现全过程展示含demo ", "author": "天下雪", "pub_time": "2016-10-16 17:45", "article_content": "Demo效果图如下：                          一、Demo思路来源之所以写了这样一个Demo，是因为很久之前在慕课网看到了一个很好玩很酷炫利用canvas绘制的时钟，于是想着这样炫酷好玩的东西在小程序当中是否也能够得以实现呢？答案肯定是可以的。接下来我将把这个Demo的思路一步一步分享给大家。二、Demo实现1.微信小程序开发环境搭建 http://www.helloxcx.com/jc/devtools/download.html，如果这个地址无法下载，请使用官方地址下载；2.开发环境搭建后利用开发工具创建自己的Demo项目  1）创建项目                   2）添加核心代码countdown.js ，digit.js到index目录下3.核心代码实现(代码中有详细的开发注释)  1）digit.js（这里实现倒计时数字的排列，是一个3维数组）// 数字排列var digit = [  [    [0,0,1,1,1,0,0],    [0,1,1,0,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,0,1,1,0],    [0,0,1,1,1,0,0]  ],//0  [    [0,0,0,1,1,0,0],    [0,1,1,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [1,1,1,1,1,1,1]  ],//1  [    [0,1,1,1,1,1,0],    [1,1,0,0,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,1,1,0],    [0,0,0,1,1,0,0],    [0,0,1,1,0,0,0],    [0,1,1,0,0,0,0],    [1,1,0,0,0,0,0],    [1,1,0,0,0,1,1],    [1,1,1,1,1,1,1]  ],//2  [    [1,1,1,1,1,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,1,1,0],    [0,0,0,1,1,0,0],    [0,0,1,1,1,0,0],    [0,0,0,0,1,1,0],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0]  ],//3  [    [0,0,0,0,1,1,0],    [0,0,0,1,1,1,0],    [0,0,1,1,1,1,0],    [0,1,1,0,1,1,0],    [1,1,0,0,1,1,0],    [1,1,1,1,1,1,1],    [0,0,0,0,1,1,0],    [0,0,0,0,1,1,0],    [0,0,0,0,1,1,0],    [0,0,0,1,1,1,1]  ],//4  [    [1,1,1,1,1,1,1],    [1,1,0,0,0,0,0],    [1,1,0,0,0,0,0],    [1,1,1,1,1,1,0],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0]  ],//5  [    [0,0,0,0,1,1,0],    [0,0,1,1,0,0,0],    [0,1,1,0,0,0,0],    [1,1,0,0,0,0,0],    [1,1,0,1,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0]  ],//6  [    [1,1,1,1,1,1,1],    [1,1,0,0,0,1,1],    [0,0,0,0,1,1,0],    [0,0,0,0,1,1,0],    [0,0,0,1,1,0,0],    [0,0,0,1,1,0,0],    [0,0,1,1,0,0,0],    [0,0,1,1,0,0,0],    [0,0,1,1,0,0,0],    [0,0,1,1,0,0,0]  ],//7  [    [0,1,1,1,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,1,1,0]  ],//8  [    [0,1,1,1,1,1,0],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [1,1,0,0,0,1,1],    [0,1,1,1,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,0,1,1],    [0,0,0,0,1,1,0],    [0,0,0,1,1,0,0],    [0,1,1,0,0,0,0]  ]//9];module.exports = {    digit : digit}  2）countdown.js（这里实现倒计时数字的绘图以及倒计时）var sort = require(\"./digit.js\")  , digit = sort.digit;   // 接收数字排列数组var CANVAS_WIDTH = 375    // canvas宽度  , CANVAS_HEIGHT = 500   // canvas高度  , RADIUS = 8            // 小球半径  , MARGIN_TOP = 60       // 图例距离右边距离  , MARGIN_LEFT = 60;     // 图例距离左边距离/** * [render 数字渲染] * @param  {[type]} time [倒计时时间] * @param  {[type]} cxt  [绘制对象] */function render(time,cxt){  cxt.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);  renderDigit(MARGIN_LEFT , MARGIN_TOP , parseInt(time/10) , cxt );  renderDigit(MARGIN_LEFT + 15*(RADIUS+1) , MARGIN_TOP , parseInt(time%10) , cxt );}/** * [renderDigit 单独小球的绘制] * @param  {[type]} x   [每个小球x轴距离] * @param  {[type]} y   [每个小球y轴距离] * @param  {[type]} num [需要绘制出来的数字] * @param  {[type]} cxt [绘制对象] */function renderDigit(x,y,num,cxt){  for(var i=0;i<digit[num].length;i++){    for(var j=0;j<digit[num][i].length;j++){      if (digit[num][i][j]){        cxt.beginPath();        cxt.arc(x+j*2*(RADIUS+1)+(RADIUS+1) , y+i*2*(RADIUS+1)+(RADIUS+1) , RADIUS , 0 ,2*Math.PI);        cxt.closePath();        cxt.fill();      }    }   }}/** * [loopTime 倒计时绘图] * @param  {[type]} time [倒计时需要绘制的数字] * @param  {[type]} cxt  [绘制对象] */function loopTime(time,cxt){  render(time,cxt);   // 获取当前context上存储的绘图动作  wx.drawCanvas({    canvasId:\"canvas\",    actions:cxt.getActions()  });}/** * [init 倒计时实现] * @param  {[type]} time [倒计时需要绘制的数字] * @param  {[type]} cxt  [绘制对象] */function init(time,cxt){  loopTime(time,cxt)  var loop = setInterval(function(){    time--;    (time < 1 ) && (      clearInterval(loop)    )    loopTime(time,cxt)  },1000);}// 将init方法暴露出去module.exports = {  render:render,  init:init}3）index.js三、Demo源码源码已托管github，地址为：https://github.com/xuqiang521/Wechat"}
{"title": "Runlin微信小程序系列教程一：从零开始写一个demo《上》 ", "author": "天下雪", "pub_time": "2016-10-16 18:55", "article_content": "本文已获得原作者授权微信小程序内测至今也有20天左右，也有很多人作出了很多不错的DEMO并发布到github了。前几日看见了豆瓣电影这个demo，感觉很不错，也跟着做了一个，作为复习巩固文档API用。废话不多说，直接进入正题：第一节只写一个首页的展示，数据用的是自己写的虚拟的数据 新建一个demo，不要使用微信自带的DEMO，直接从零开始写起：首先创建3个文件：app.jsonapp.jsapps.wxss app.json  : 主要写配置项：内容如下，具体的每个key值对应的意思，这里就不再细说了，可以看我之前的配置指南，{\"pages\":[\"pages/index/index\",\"pages/rank/rank\",],\"window\":{\"enablePullDownRefresh\":true,\"backgroundColor\":\"#eee\",\"navigationBarTitleText\": \"上导航标题文字\",\"navigationBarTextStyle\":\"white\" },\"tabBar\": {\"color\": \"#d7ced5\",\"selectedColor\": \"#535f71\",\"borderStyle\": \"white\", \"backgroundColor\": \"#f9f9f9\",\"list\": [ {\"pagePath\": \"pages/index/index\", \"text\": \"推荐电影\", \"iconPath\": \"images/board.png\", \"selectedIconPath\": \"images/board-actived.png\" },{\"pagePath\": \"pages/rank/rank\",\"text\": \"北美票房\",\"iconPath\": \"images/note.png\",\"selectedIconPath\": \"images/note-actived.png\"}]},\"networkTimeout\": {\"request\": 10000,\"downloadFile\": 9000,\"uploadFile\":8000,\"connectSocket\":7000},\"debug\": true} app.js  :  主要用来注册一个小程序的实例 App({onLaunch: function () {},onShow: function () {},onHide: function () {},globalData: 'I am global data'});  app.wxss : 公用样式，基本等同于CSS，暂时不需要写内容。 创建好3个文件后，就可以开始写页面的内容了：新创建2个文件夹images和pages，一个放图片一，个放页面。目前只pages下面再创建2个文件夹index和rank，每个文件下分别创建json,js,wxml,wxss文件，此时目录如下：虽然不一定4个文件类型都需要用到，但为了之后方便，建议还是先创建好，需要用到的时候就比较方便了，不用再去创建。首先写index.js:   (为了模拟循环数组，data下面的moivelist还需要多复制几份，这里只写了一份出来，imgsrc路径要写好) Page({    data:{    moivelist:[{    imgsrc: \"../../images/AN2.jpg\",    title: \"肖申克的救赎\",    introduce: \"The shrakwos RedenpeTion(1994)\",    author: \"弗兰克*德拉立邦\",    rank: \"9.6\"}]},onLoad: function(options) {console.log(1);},onReady: function() {// Do something when page ready.},onShow: function() {// Do something when page show.},onHide: function() {// Do something when page hide.},onUnload: function() {// Do something when page close.},onPullDownRefresh: function() {// Do something when pull down},// Event handler.viewTap: function() {this.setData({text: 'Set some data for updating view.'})}})这里出现了很多on函数事件，对应页面的生命周期每个过程对应的事件，这里暂时先关注data对象小程序是以数据驱动的，页面进来的时候通过动态获取数据，通过{{xxx}}将数据绑定，并将数据渲染到视图层，这里先以一个虚拟的data数据模拟 然后写index.wxml文件：从上面显示的首页的图片来看，主要是1个标题，以及下面一个列表，列表用过循环来渲染出所有的数据标题:  标题比较简单，主要是写css<view class=\"head-title\"><text>豆瓣电影top250</text></view>这里主要讲下面的列表循环，可以发现我们只要写好列表中的第一个就可以了，其他的通过循环来展示列表主要分为左中右三块，分别为图片，内容，以及评分3块<block wx:for=\"{{moivelist}}\">  //循环渲染，wx:for=\"{{ xxx }}\" 代表循环js文件里面的data数据中的xxx<view>//微信循环时会给出每个项目的内容以及每个项目的下标，默认为item和index，item.imgsrc意为对象的（imgsrc）  key值图片：<image class=\"moive-img\" style=\"\" mode=\"\" src=\"{{item.imgsrc}}\" binderror=\"\" bindload=\"\"></image>内容：<view class=\"moive-content\">     <view class=\"content-titile\">        <text >{{item.title}}</text>    </view>    <view class=\"content-introduce\">         <text >{{item.introduce}}</text>    </view>    <view class=\"content-author\">        < text >{{item.author}}</text>\t    </view>\t</view>评分：<text class=\"content-rank\">{{item.rank}}</text></view></block>   基本都这里wxml就结束了，样式主要通过wxss来操作，样式比较简单，就不写了，主要讲一下左中右这三块通过将左中右这三块的父级设置为display:flex;左边和右边都设置为固定rpx，中间设置为flex:1。这样写代表中间这一块的内容占满：左边和右边布局后生下来的空间 ，即左右布局好后，剩多少，flex：1就等于多少。 第一节项目代码见：demo1https://github.com/linrunzheng/wx-samll-demo"}
{"title": "Runlin微信小程序系列教程一：从零开始写一个demo《中》 ", "author": "天下雪", "pub_time": "2016-10-16 18:59", "article_content": "上一节写了一个首页列表的展示，现在我们需要一个效果：点击每个列表项，能后看到更多的细节和大图。在本页面展示或者加个弹窗是基本不可能的了。下面我们就创建一个新的页面来展示更多细节（我们之前已经创建了2个页面，其中rank页面还是空的，这里故意先不写，后面自然会补在）在pages下创建新的文件夹：detail，同时创建4个detail文件js,json,wxml,wxss对于每一个页面都需要写到app.json的pages中，因此要将我们新增的\"pages/detail/detail\"添加到“pages”数组中去。如果新增的页面是底部tabBar栏中的一项，还需要添加到tabBar中的List数组，我们这里是列表点击时的新页面，所以不需要写到list中。我们希望的效果大概是这样的：现在有一个问题时：我如何在点击的时候获取到对应的每一项的数据，并且在新的页面展示出来呢？这里要解决2个问题：###导航；参数的传递；导航 :实现导航的方法有2种，一种是直接利用navigator组件, 另一种是利用导航api，通过给列表添加点击事件，实现wx.navigateTo（保留当前页面，有左上角返回）或者wx.redirectTo（关闭当前页面，没有右上角返回按钮）。为了方便我们这里直接采用组件来写<block wx:for=\"{{moivelist}}\">   //在这之后插入导航标签    <navigator url=\"../detail/detail\">         //url对应文件的路径，不需要写后缀wxml    　　　　xxxxx还是原来的配方xxxxxxxx    </navigator></block>然后我们就可以实现点击跳转的效果了，但是这时候detail.wxml还是空白的。下面开始写detail.wxml<view class=\"container\">    <image class=\"imgs\" style=\"\" mode=\"\" src=\"{{item.images.large}}\" binderror=\"\" bindload=\"\"></image>    <text> {{item.title}} </text>        <text> {{\"评分\"+item.original_title}} </text>     <text> {{\"导演\"+item.directors[0].name}} </text>      <text> {{\"主演\"+item.rating.average}} </text> </view><view>    {{item.summary}}</view>跟之前index一样，我们这里的数据也是从js拿过来，不过这里是从detail.js拿的，但是这个时候detail.js中的data是没有数据的，因为我们希望数据是从index列表的每一项点击时传过来的，而不是我们直接写到detail.js里面的，这个时候就需要用到生命周期函数的onload函数了也就是说，每个页面在Onload时，都可以获取上一个页面传递给你的参数（假如有的话），那么现在要解决2个问题：1是上一个页面如何传给我，2是我如何接收数据。旧页面传递参数：我们刚才在index里面加了一个导航并且 url=\"../detail/detail\" ，需要传递参数时，仅需要在url后面：+?+数据例如：url=\"../detail/detail?id=test\"例如：https://i.cnblogs.com/EditPosts.aspx?opt=1可以发现格式其实就是get提交数据时的格式，写过html表单form的一定很熟悉了，需要提交多个参数时，需要在后面加 & 符号例如： url=\"../detail/detail?id=test1&name=test2&age=12345\"新页面接受数据 (注意只有在Onload时才可以接受传过来的数据)在新页面js中 onLoad: function(options) {console.log(options)} 即可打印出传过来的数据，你会发现这是一个对象，我们需要将这个对象,通过this.setData转化为新页面的数据，//我们这里为什么要用item是因为我们上面的数据绑定用的是{{item.xxx}}, 需要对应好，如果一个发生变动，另一个也要跟着改变//detai.js代码如下：Page({  data:{    title:\"加载中\",    item:{},    loading:false  },    onLoad:function(options){      this.setData({        item:options      })    },    onReady:function(){                 },        onShow:function(){    },        onHide:function(){    },        onUnload:function(){    }})detail.js就算写完了，CSS方面就不写了，比较无脑，没什么好讲的，简单设置一下样式不要太丑即可，整个detail的文件都搞定了。目前我们前面的第二个导航rank还空着呢，从表象上看，rank的格式跟index是一样，仅仅是数据不同，那么我们只要把index的文件复制一份过来就可以了，把模拟的数据改一下即可。虽然可以，但是代码很多重复，下面我们就引进一个新的东西叫模板 template 。定义一个name为test的模板<template name=\"test\">　　<view>hhahahha我是模板{{item}}</view></template>使用时，需要先引入所写的模板所在的位置<template is=\"test\" data={{item:\"你好模板\"}}></template>因此，同样的我们再创建一个文件夹template放模板，同时创建.js和.wxml文件这2个即可。 template.js并不需要数据，只是用来注册一下页面（不注册控制台有报错提示你page.js xxx什么的），将其他页面的.js复制过来，并将data里面的数据和其他的事件都出掉，保留最基本的空数据和空函数。template.wxml内容如下：<template name=\"try\" >    <navigator url=\"../detail/detail?imgsrc={{item.imgsrc}}&title={{item.title}}&author={{item.author}}&introduce={{item.introduce}}&rank={{item.rank}}\">            <view class=\"moive-item\">                    <image class=\"moive-img\" style=\"\" mode=\"\" src=\"{{item.imgsrc}}\" binderror=\"\" bindload=\"\"></image>                        <view class=\"moive-content\">                           <view class=\"content-titile\">                    <text>{{item.title}}</text>                </view>                                    <view class=\"content-introduce\">                     <text>{{item.introduce}}</text>                </view>                                    <view class=\"content-author\">                    <text>{{item.author}}</text>                    </view>                </view>                        <text class=\"content-rank\">{{item.rank}}</text>        </view>     </navigator></template>定义好模板好，将rank.wxml内容写为：<view class=\"head-title\" \">    <text>电影top20</text></view><scroll-view class=\"main\" scroll-y=\"true\" bindscrolltoupper=\"\" bindscrolltolower=\"\" bindscroll=\"\" scroll-into-view=\"\" scroll-top=\"\">      <import src=\"../temple/temple.wxml\"></import>       //引入模板     <block wx:for=\"{{moivelistB}}\">        <template is=\"try\" data=\"{{item}}\"></template>           //使用模板，并通过wx:for将数据循环展示出来     </block>   </scroll-view>将index.wxss和index.js文件复制一份到rank.js，同时将rank.js中data的数据稍微修改一下，不要让数据都跟index的一样.同时将我们的index.wxml中列表也修改为使用上面的模板，至此就基本完成了。回顾一下我们主要的知识点：导航写法，如何传递参数，声明周期函数，如何获取传递过来参数，如何定义和使用模板及使用参数。到此我们使用的都是虚拟的数据，下一篇我们将调用豆瓣提供的接口来调用数据，模拟跟后台的交互。demo2源文件见 https://github.com/linrunzheng/wx-samll-demo"}
{"title": "Runlin微信小程序系列教程一：从零开始写一个demo《下》 ", "author": "天下雪", "pub_time": "2016-10-16 19:14", "article_content": "上一节实现了循环列表数据渲染到视图，并给列表每一项添加了路由导航到新页面查看更多细节，但是目前我们的数据都是虚拟的，现在我们就开始利用微信的request请求来接收豆瓣电影接口提供的数据。API: wx.request(OBJECT)参数有7个，这里主要讲一下几个重要的：url : 请求的地址data: 携带的数据method : 请求方式，默认为getsuccess: 请求成功的回调函数了解了网路请求的方法后，我们就不需要我们原来模拟的那些数据了，把所有的假数据统统干掉，留一个空的数据用来放数据即可。data:{    moivelist:[],    loading:false  }  现在页面进来的时候只展示了一个标题，因为数据为空了循环不出来了，现在需要我们在页面进来的时候发送一个请求来接受数据。豆瓣提供的API：[Title]https://developers.douban.com/wiki/?title=movie_v2#search具体参数和接口请自行查阅，使用方法：https://api.douban.com + 对应的接口 + 参数(如果需要的话)例子：https://api.douban.com/v2/movie/top250我们以请求 排行250 这个接口为例：onLoad: function() {        var url=https://api.douban.com/v2/movie/top250;        var that = this;//确保回调函数this的指向正确,后面会以es6的箭头函数代替        wx.request({            url：url,  //KEY和KEY值相同可简写为url            data: {},  //不要求数据            header: { 'Content-Type': 'application/json' },            //成功时的回调，res为返回值，需要储存到我们的data数据里面            success: function(res) {                that.setData({                    moivelist: res.data.subjects,                    loading: true                })              }           })        }写完后，页面进来的时候就会发送请求，并将数据保存到moiveList,并通过循环把数据展示出来，但是如果网络差的话，会有一段真空期是没有数据的，我们需要给用户一个提示。给页面添加一个loading<loading hidden=\"{{loading}}\">    加载中....</loading>###我们让这个loading一开始就是显示的，当数据加载成功后，才让他消失。我们通过将hidden绑定到{{loading}}上，更改{{loading}}的布尔值来实现这个效果。一开始{{loading}}的值是false的，也就是不隐藏；success后将他设置为true，从而实现这个效果。###这样我们这个页面就做好了，另一个页面同理，改变一下接口就行了，我们主要看一下detail这个文件。###我们现在可以实现网络请求了，在之前我们detail的数据都是外面从列表传过来的，我们是这么写的。<navigator url=\"../detail/detail?imgsrc={{item.imgsrc}}&title={{item.title}}&author={{item.author}}&introduce={{item.introduce}}&rank={{item.rank}}\">我靠这么长一段代码，真的需要吗？我们现在就可以简写了，我们只需要传一个参数就可以了。把template模板里面wxml里面上述代码改成下面的<navigator url=\"../detail/detail?id={{item.id}}\">我们只需要一个这个电影的ID就行了，我们可以根据这个ID自己请求数据//在detail.js的Onload函数中获取到页面传过来的ID onLoad: function(options) {        var that = this;        var address = 'https://api.douban.com/v2/movie/subject/';        wx.request({            url: address + options.id,            data: {},            header: { 'Content-Type': 'application/json' },            success: function(res) {                that.setData({                    item: res.data,                    loading: true                })            }        })    }这样就完成了，现在我们在tabBar新增一个搜索页面。记住新页面都要添加到app.json中，这里就不再阐述了，页面大概这个样子<import src=\"../temple/temple.wxml\"></import><loading hidden=\"{{loading}}\">    加载中....</loading><view class=\"searchWrap\">    <view class=\"inputWrap\">        <icon type=\"search\" size=\"20\"/>         <input placeholder=\"请输入搜索内容\"  value=\"{{content}}\" type=\"text\"  placeholder-style=\"custom-placeholder-style\" placeholder-class=\"custom-placeholder-class\"   bindinput=\"inputing\"  bindblur=\"quick\"/>    </view>      <view class=\"cancel\" bindtap=\"searching\">{{cancel}}</view></view><scroll-view class=\"main\" scroll-y=\"true\" bindscrolltoupper=\"\" bindscrolltolower=\"\" bindscroll=\"\" scroll-into-view=\"\" scroll-top=\"\">    <block wx:for=\"{{moivelist}}\">        <template is=\"try\" data=\"{{item}}\"></template>    </block></scroll-view>  下面的列表跟前面一样，就多个了Input和按钮而已，同样的wxss样式我们就不管了，只看js。主要代码如下：data: {        moivelist: [],        loading: true,        cancel: \"取消\",        search: \"\"    }   ,        inputing: function(event) {        if (event.detail.value) {            this.setData({                cancel: \"搜索\"            })        } else {            this.setData({                cancel: \"取消\"            })        }    },    //失去焦点事件    quick: function(event) {        if (!event.detail.value) {            this.setData({                cancel: \"取消\"            })        } else {            this.setData({                search: event.detail.value            })        }    },    //点击搜索事件    searching: function() {        if (this.data.cancel === \"取消\") {            wx.hideKeyboard()        } else {                      this.setData({                loading: false            })            wx.request({                url: url + this.data.search,                data: {},                header: { 'Content-Type': 'application/json' },                success: function(res) {                    that.setData({                        moivelist: res.data.subjects,                        loading: true                    })                }            })        }    }看起来写了很多，其实就2件事：* 判断Input的值，如果为空，则让按钮的值为“取消”；不为空则为“搜索”。* 根据按钮的值绑定点击事件，为取消则让键盘下去(手机才行）为“搜索”则发送网络请求，并将接收的数据保存以便循环展示出来。到此，几个文件就都写好了，现在来对代码优化一下。1. wxml：我们已经创建了一个通用的模板了，好像没得优化了。2. css : 可以发现我们几个列表都用了一个模板，因此对应的CSS代码也是一样的，我们可以把这部分CSS代码放到app.wxss公共样式里面，其他页面对应的WXSS那部分都可以删除了。3. js:wx.request时用到了基本相同的东西，可以放到一个单独的js里面。创建一个util文件夹，在里面创建一个util.js文件，用来放我们的方法。function getData(address,datas,cb){    wx.request({        url: address,        data:datas,        header: { 'Content-Type': 'application/json' },        success: cb    })}module.exports = {    getData: getData}我们定义了一个方法，并通过module.exports将他导出，其他页面需要使用方法时，需要先导入var util = require(\"../../utils/utils.js\")使用时：util.getData(参数1，参数2，参数3)如：onLoad: function() {        util.getData(url,{},(res)=>{          this.setData({              moivelist: res.data.subjects,              loading: true          })        })    }到此我们整个APP就算基本完成了，后续如果还有补充则再继续添加。代码参见demo4 ， 网址为：https://github.com/linrunzheng/wx-samll-demo"}
{"title": "去除富文本中的html标签及vue、react、微信小程序中的过滤器 ", "author": "Rolan", "pub_time": "2018-11-21 00:38", "article_content": "1.富文本去除html标签去除html标签及 空格let richText = ' <p style=\"font-size: 25px;color: white\">&nbsp; &nbsp; &nbsp; &nbsp;sdaflsjf的丰富及饿哦塞尔</p><span>dsfjlie</span>';\r\n\r\n/* 去除富文本中的html标签 */\r\n/* *、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。*/\r\nlet content = richText.replace(/<.+?>/g, '');\r\nconsole.log(content);\r\n\r\n/* 去除&nbsp; */\r\ncontent = content.replace(/&nbsp;/ig, '');\r\nconsole.log(content);\r\n\r\n/* 去除空格 */\r\ncontent = content.replace(/\\s/ig, '');\r\nconsole.log(content);截取字符串content = formatRichText(content);\r\nconsole.log(content);\r\n\r\n/* 使用substring来截取字符串 */\r\nif (content.length > 10) {\r\n    content = content.substring(0, 10) + '...';\r\n}\r\nconsole.log(content);\r\n\r\n/* 限制字数后添加省略号 */\r\nfunction formatRichText(richText) {\r\n    let temporaryText = '';\r\n    /* 设置多长后添加省略号 */\r\n    const len = 142;\r\n    if (richText.length * 2 <= len) {\r\n        return richText;\r\n    }\r\n    /* 用于记录文字内容的总长度 */\r\n    let strLength = 0;\r\n    for (let i = 0; i < richText.length; i++) {\r\n        temporaryText = temporaryText + richText.charAt(i);\r\n        /* charCodeAt()返回指定位置的字符的Unicode编码，值为128以下时一个字符占一位，当值在128以上是一个字符占两位 */\r\n        if (richText.charCodeAt(i) > 128) {\r\n            strLength = strLength + 2;\r\n            if (strLength >= len) {\r\n                return temporaryText.substring(0, temporaryText.length - 1) + \"...\";\r\n            }\r\n        } else {\r\n            strLength = strLength + 1;\r\n            if (strLength >= len) {\r\n                return temporaryText.substring(0, temporaryText.length - 2) + \"...\";\r\n            }\r\n        }\r\n    }\r\n    return temporaryText;\r\n}2.vue中使用过滤器filters: {\r\n    localData(value) {\r\n        let date = new Date(value * 1000);\r\n        let Month = date.getMonth() + 1;\r\n        let Day = date.getDate();\r\n        let Y = date.getFullYear() + '年';\r\n        let M = Month < 10 ? '0' + Month + '月' : Month + '月';\r\n        let D = Day + 1 < 10 ? '0' + Day + '日' : Day + '日';\r\n        let hours = date.getHours();\r\n        let minutes = date.getMinutes();\r\n        let hour = hours < 10 ? '0' + hours + ':' : hours + ':';\r\n        let minute = minutes < 10 ? '0' + minutes : minutes;\r\n        return Y + M + D + ' ' + hour + minute;\r\n    }\r\n}\r\n\r\n/* 使用，直接在div中添加就可以了，| 前面的是参数，后面的是过滤器 */\r\n<div class=\"time\">{{data.etime | localData}}</div>3.微信小程序中使用过滤器新建.wxs文件var localData = function (value) {\r\n    var date = getDate(value * 1000);\r\n    var Month = date.getMonth() + 1;\r\n    var Day = date.getDate();\r\n    var hours = date.getHours(); //计算剩余的小时\r\n    var minutes = date.getMinutes(); //计算剩余的分钟\r\n    var Y = date.getFullYear() + '-';\r\n    var M = Month < 10 ? '0' + Month + '-' : Month + '-';\r\n    var D = Day + 1 < 10 ? '0' + Day + '' : Day + '';\r\n    var H = hours < 10 ? '0' + hours + ':' : hours + ':'\r\n    var m = minutes < 10 ? '0' + minutes : minutes;\r\n    return Y+M + D + \"   \" + H + m;\r\n}\r\nmodule.exports = {\r\n    localData: localData\r\n}使用,用<wxs />标签来引入，src为路径，module为引入的文件模块名<wxs src=\"./filters.wxs\" module=\"tool\" />\r\n<text class=\"scoreText\">{{tool.filterScore(item.shop.score)}}分</text>直接在.wxml文件中用<wxs></wxs>包裹<wxs module=\"foo\">\r\nvar some_msg = \"hello world\";\r\nmodule.exports = {\r\n    msg : some_msg,\r\n}\r\n</wxs>\r\n<view> {{foo.msg}} </view>4.react中使用react中使用，其实就是定义一个方法import noBanner from '@/assets/storeDetail/no-banner.jpg'\r\nconst filterImg = item => {\r\n    let bgImg;\r\n    if (item.shopimages == null) {\r\n        bgImg = noBanner;\r\n    } else {\r\n        bgImg = item.shopimages[0];\r\n    }\r\n    return bgImg;\r\n};\r\n/* 使用 */  \r\n<img src={filterImg(storeitem)} className={style.topImg} alt=\"\" />正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断iOS和Android及PC端纯css实现瀑布流（multi-column多列及flex布局）实现多行文字及单行的省略号微信小程序之购物车和父子组件传值及calc的注意事项"}
{"title": "微信小程序实现显示和隐藏控件-头像-取值-bindblur事件 ", "author": "Rolan", "pub_time": "2018-11-21 00:56", "article_content": "小程序实现显示和隐藏控件\" style=\"margin: 20px 0px; padding: 0px; font-size: 21px; line-height: 1.5; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; background-color: rgb(255, 255, 255);\">微信小程序实现显示和隐藏控件.wxml: <view class=\" {{showOrHidden?'show':'hidden'}}\"></view>.wxss:.hidden {\r\n  display: none;\r\n}\r\n \r\n.show {\r\n  display: block;\r\n}.js: data: {\r\n    showOrHidden:true,\r\n    //判断显示与否的，true表示显示，反之隐藏\r\n },简洁的方式，利用wx:if的方式.wxml:<view wx:if='{{showOrHidden}}'></view>.js: data: {\r\n    showOrHidden:true,\r\n    //判断显示与否的，true表示显示，反之隐藏\r\n  },点击按钮隐藏view并显示另个view<view class=\"{{showView?'show':'hidden'}}\" >\r\n <button class='show-button' bindtap='showButton'>go</button>\r\n</view>data: {\r\n    showView: true,\r\n},\r\nshowButton:function(){\r\n    var that = this;\r\n    that.setData({\r\n      showView: (!that.data.showView)\r\n    })\r\n }头像<open-data type=\"userAvatarUrl\" class='img'></open-data>     .img {\r\n  width: 200rpx;\r\n  height: 200rpx;\r\n  margin: 20rpx;\r\n  border-radius: 50%;\r\n  display: flex;\r\n  overflow:hidden;\r\n}input输入框和form表单传值和取值方式实现方式\r\ndata-index=\"{{index}}\"\r\ne.currentTarget.dataset.indexform表单取值\r\n<form bindsubmit=\"formSubmit\">与<button formType=\"submit\">\r\n\r\nformSubmit: function(e) {\r\n  var detail = e.detail.value.detail;\r\n}bindblur事件<textarea bindblur=\"bindTextAreaBlur\" auto-height placeholder=\"请输入内容\" value=\"{{ceshi}}\" />"}
{"title": "微信小程序：防止多次点击跳转（函数节流） ", "author": "Rolan", "pub_time": "2018-11-22 00:13", "article_content": "场景在使用小程序的时候会出现这样一种情况：当网络条件差或卡顿的情况下，使用者会认为点击无效而进行多次点击，最后出现多次跳转页面的情况，就像下图（快速点击了两次）：解决办法就是函数节流(throttle)：函数在一段时间内多次触发只会执行第一次，在这段时间结束前，不管触发多少次也不会执行函数。/utils/util.js:function throttle(fn, gapTime) {if (gapTime == null || gapTime == undefined) {gapTime = 1500}let _lastTime = null// 返回新的函数return function () {let _nowTime = + new Date()if (_nowTime - _lastTime > gapTime || !_lastTime) {fn.apply(this, arguments) //将this和参数传给原函数_lastTime = _nowTime}}}/pages/throttle/throttle.wxml:<button bindtap='tap' data-key='abc'>tap</button>/pages/throttle/throttle.jsconst util = require('../../utils/util.js')\r\n \r\nPage({\r\n    data: {\r\n        text: 'tomfriwel'\r\n    },\r\n    onLoad: function (options) {\r\n \r\n    },\r\n    tap: util.throttle(function (e) {\r\n        console.log(this)\r\n        console.log(e)\r\n        console.log((new Date()).getSeconds())\r\n    }, 1000)\r\n})这样，疯狂点击按钮也只会1s触发一次。"}
{"title": "微信小程序http连接访问解决方案 ", "author": "Rolan", "pub_time": "2018-11-6 00:32", "article_content": "HTTP + 加密 + 认证 + 完整性保护 = HTTPS，小程序考虑到信息安全的问题，选用了更为稳定安全的https 来进行信息传递。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。这就导致了许多好用的http  API无法在小程序中被调用。但是也有解决方案。1.中继访问 中继访问有两种方式，一种需要自己拥有一个云服务和域名。拥有域名和云服务器域名完成备案之后下载证书https指引教程如下------> 腾讯云上免费部署HTTPS再讲域名解析到你的云服务器的IP。这样子你的域名就是https的了，小程序可以访问你的服务器了，现在就开始在云服务上实现访问http API 服务实际上只需要面向小程序和API Server 做一个双面响应即可。实现这种功能，显而易见，在服务器上部署一个Web项目是最简单的实现方式：我们以访问豆瓣图书API 为例：https://api.douban.com/v2/book/isbn/豆瓣API虽然是https的，但是来自小程序的访问是被禁止的。下面代码同样适用于http 连接Java代码：这个是通用代码，无论是访问什么APIpackage DataService;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.HttpURLConnection;import java.net.URL;import java.net.URLConnection;import java.sql.ResultSet;import com.google.gson.Gson;/* * Author:陈浩东 * QQ:1025584691 */public class DouBanBook {    //豆瓣接口实现    public static String doPost(String url, String params, Integer connTimeout, Integer readTimeout, String contentType)    {        PrintWriter out = null;        BufferedReader in = null;        String result = \"\";        try        {            URL realUrl = new URL(url);            // 打开和URL之间的连接,根据url            URLConnection conn = realUrl.openConnection();            // 设置通用的请求属性            conn.setRequestProperty(\"accept\", \"*/*\");            conn.setRequestProperty(\"connection\", \"Keep-Alive\");            conn.setRequestProperty(\"user-agent\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)\");            conn.setRequestProperty(\"Content-Type\", contentType == null? \"application/json\" : contentType);            // 发送POST请求必须设置如下两行            conn.setDoOutput(true);            conn.setDoInput(true);            // 设置请求超时时间和读取超时时间            conn.setConnectTimeout(connTimeout == null ? 180 : connTimeout);            conn.setReadTimeout(readTimeout == null ? 180 : readTimeout);            // 获取URLConnection对象对应的输出流，设置utf-8编码            out = new PrintWriter(new OutputStreamWriter(conn.getOutputStream(), \"utf-8\"));            // 发送请求参数            out.print(params);            // flush输出流的缓冲            out.flush();            // 定义BufferedReader输入流来读取URL的响应,设置utf-8编码            in = new BufferedReader(new InputStreamReader(conn.getInputStream(), \"utf-8\"));            String line;            while ((line = in.readLine()) != null)                result += line;        }        catch (Exception e)        {            e.printStackTrace();            result = null;        }        //使用finally块来关闭输出流、输入流        finally        {            try            {                if (out != null)                {                    out.close();                }                if (in != null)                {                    in.close();                }            }            catch (IOException ex)            {                ex.printStackTrace();            }        }        return result;    }}根据访问不同的API，只需要修改Servlet的写法就可以：Servlet：package Servlet;import java.io.IOException;import java.io.Writer;import java.util.HashMap;import java.util.Map;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.google.gson.Gson;import DataService.DouBanBook;/** * Servlet implementation class doubanbook */@WebServlet(\"/doubanbook\")public class doubanbook extends HttpServlet {    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {         request.setCharacterEncoding(\"utf-8\");            response.setContentType(\"text/html;charset=utf-8\");            response.setHeader(\"Access-Control-Allow-Origin\", \"*\");            response.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST\");            String isbn = request.getParameter(\"isbn\")==null?\"no\":request.getParameter(\"isbn\");            String sshpwd = request.getParameter(\"ssh_secret\")==null?\"no\":request.getParameter(\"ssh_secret\");            System.out.println(sshpwd);            System.out.println(isbn);            Map<String, Object> result = new HashMap<String, Object>();            String json = new Gson().toJson(result);            Writer out = response.getWriter();            out.write(DouBanBook.doPost(\"https://api.douban.com/v2/book/isbn/\"+isbn, null, null, null, null));            out.flush();    }    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        // TODO Auto-generated method stub        doGet(request, response);    }}同样，你也可以用Python，php等语言来实现中继访问这个功能。无域名和云服务器对于个人开发者来说，尤其是学生来说，又是是没有条件购买长时间的云服务器的，这个时候我们如果是开发小程序的话，可以用他们提供的空间。使用微信小程序的云开发能力，Node.js 函数，用js 实现服务端的响应，访问非https API。参照写法一：云函数调用方式访问API　　 不知道什么原因，云函数我感觉并不是很稳定，建议有条件的还是用自己的服务器来实现吧。"}
{"title": "A计划小程序的血与泪 ", "author": "Rolan", "pub_time": "2018-11-8 00:21", "article_content": "A计划只是一个代号，不代表任何小程序微信小程序，简称小程序，英文名Mini Program，是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。最近两周由于公司业务需求，本胖主导开发了一款功能简单的小程序—A计划（以下本次开发小程序的代号），可以说这两周本胖都是在浏览小程序官网以及小程序论坛，适应小程序的开发模式以及填开发过程中的大坑小。这里需要说一句，自己平时做demo和开发公司级别的正式项目永远都是两码事哈，本胖这次也是深有体会，很多之前做demo时候只是模棱两可的知识在这次开发中得到了深入认识，还有就是对小程序开放能力的深入理解，知道了小程序能做什么，小程序不能做什么，所以敬以此文记录本胖对小程序的认知，如有错误，烦请指出，谢谢。1 小程序登录以及授权1.1 小程序登录任何项目都会涉及到登录这个问题，在JSP的远古时代登录都是直接由服务端控制，在现在react，vue单页面时代，登录是有客户端控制，所以现在的很多前端框架都会有全路由守护这种东西，能很方便地帮助我们控制路由权限，那么在小程序里面的登录时怎么控制的呢？小程序里面的登录主要分2种A. 利用现有登录体系直接复用现有系统的登录体系，只需要在小程序端设计用户名，密码/验证码输入页面，便可以简便的实现登录，只需要保持良好的用户体验即可。\r\n复制代码B.利用OpenIdOpenId 是一个小程序对于一个用户的标识，利用这一点我们可以轻松的实现一套基于小程序的用户体系，值得一提的是这种用户体系对用户的打扰最低，可以实现静默登录。具体步骤如下：\r\n\r\n1.小程序客户端通过 wx.login 获取 code\r\n\r\n2.传递 code 向服务端，服务端拿到 code 调用微信登录凭证校验接口，微信服务器返回 openid 和会话密钥 session_key ，此时开发者服务端便可以利用 openid 生成用户入库，再向小程序客户端返回自定义登录态\r\n\r\n复制代码这次由于需要获取用户手机号的，所以我们选择了第二种（注意了，个人主体的小程序号是获取不了用户手机号的）。但是这里需要强调的一点是登录和授权获取用户信息（比如手机号，头像，微信步数）是两回事情，不要搞混淆了，登录是可以做到静默登录的，但是很少有小程序只做一个登录的，那会是一个没有灵魂的小程序哈。1.2 授权这里不得不承认，微信是中国流量最大的app，所有小程序才有了生根萌芽的沃土，做小程序就不得不涉及到相关用户权限的授权。A计划小程序这次涉及到授权的地方主要是获取用户手机号，还记得那年夏天微信小程序获取手机号还是可以直接通过API方式直接弹出授权弹框的，这次发现竟然不行了，只好去官网看看改动了哪些（不得不说这也是小程序的不确定性，一家独大，想改就改），发现现在要获取用户手机号只能通过引导用户触发相应的按钮才行。1.3 登录+授权解决方案这次本胖采用的方案是专门用一个页面（login）来进行用户的登录以及授权，这里需要注意的是，你在取微信用户绑定的手机号，需先调用wx.login接口。我们首先需要下面这个button组件用来引导用户触发登录<button type=\"primary\" open-type=\"getPhoneNumber\" bindgetphonenumber=\"getPhoneNumber\">微信登录</button>\r\n复制代码然后需要在login页面的onload事件中发起wx.login()，获取对应的code存起来。 关键的一步到了，在用户点击确定授权的按钮，我们需要监听getPhoneNumber事件getPhoneNumber(e) {\r\n    if (e.detail.iv) {\r\n      this.setData({\r\n        iv: e.detail.iv,\r\n        encryptedData: e.detail.encryptedData\r\n      });\r\n      this.login(this.getPhone);\r\n    }\r\n}\r\n复制代码注意到上面最后一行的代码，是在获取到iv以及encryptedData这两个解密用户手机号必备的变量的时候才去发起登录以及获取对应的手机号前端显示用。可以看到上面的微信登录按钮其实一开始是先做了一个获取用户手机号权限的操作，操作成功后才登录的，如果一开始就登录了，但是用户没有同意授权手机号，那么将变得毫无意义，因为手机号才是小程序需要快捷获取的核心用户信息之一。登录完成后客户端可以获取到一个自定义token。类似于浏览器里面的JSSSESIONID,可以存小程序本地，在需要的时候手动带上就可以了，这一点比不了浏览器可以设置自动带上cookie那么方便。2 生成海报为什么很多小程序里面都会有生成海报呢，其实也是因为小程序不能直接转发到朋友圈，不能直接转发到QQ以及其他社交平台，那么就需要出现海报这个中间传播者。这次A计划小程序里面也有这个功能，于是本胖就愉快地开始了海报的填坑。小程序的海报一般都是通过canvas生成的，也就是填小程序canvas的各种坑哈。2.1 实体机海报空白上图中就是在生成海报的时候出现的实体机空白问题，但是在模拟器里面却不会有，在查阅了很多资料以后发现是图片资源没能及时加载出来，就会造成在drawImg的时候没有真实的图片可以画，当然就是空白了。既然是因为在画图的时候图片没有及时请求到造成的问题，那么解决的方案当然就是在页面初始化的时候就去异步请求图片downloadFile(url, name) {\r\n  wx.downloadFile({\r\n    url: url,\r\n    success: function (res) {\r\n   \r\n    }\r\n  });\r\n}\r\n复制代码2.2 背景图片自适应canvas是需要设置大小的，否则取他的默认大小。但是canvas的单位是px和小程序标准的单位rpx是不同的。所以我们需要动态给canvas区域设置宽高才能让canvas满满填充整个理想区域。createNewImg: function (text) {\r\n  wx.createSelectorQuery().select('#canvas-container').boundingClientRect( (rect) => {\r\n      this.setData({\r\n        canvasW: rect.width,\r\n        canvasH: rect.height\r\n      });\r\n      var width = this.data.canvasW,\r\n        height = this.data.canvasH,     \r\n        context = wx.createCanvasContext('mycanvas');\r\n      context.drawImage(this.data.imgUrl1, 0, 0, width, height);\r\n      context.draw();\r\n    }).exec();\r\n  },\r\n复制代码上面的代码就是用过获取不同屏幕下canvas的包裹元素的宽高然后动态给canvas赋值,然后对应图片的画图也是一个道理，就可以让图片只适应不同屏幕。2.3 文字居中好了，画好了主图本胖就要在主图写字了，需求是写一段文字，字数不定，居中显示。本胖一开始想当然了用了setTextAlign设置了文字的对齐方式，可是一看竟然没有说明用，于是本胖只好想算出所有文字的全部长度，用区域宽度减去文字的长度除以2设置文字的起始X坐标就可以了。context.fillText(`我是吕胖胖`, (width - context.measureText(`我是吕胖胖`).width) / 2, );\r\n复制代码上面代码里面的measureText就是解决问题的核心API。2.4 canvas层级太高 导致ios中海报随着屏幕滑动因为海报主体使用了fixed布局，所以会被固定在屏幕的中间，在模拟器里面测试没有问题，但是在ios上面会出现手指滑动海报，海报会随着页面滑动，这是不是看起来很滑稽。这种现象是因为canvas这东西在小程序里面地位那是相当的高，下面是小程序对canvas的介绍。canvas组件是原生组件，他有如下的限制原生组件的使用限制\r\n由于原生组件脱离在 WebView 渲染流程外，因此在使用时有以下限制：\r\n\r\n原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上。\r\n后插入的原生组件可以覆盖之前的原生组件。\r\n原生组件还无法在 scroll-view、swiper、picker-view、movable-view 中使用。\r\n部分CSS样式无法应用于原生组件，例如：\r\n无法对原生组件设置 CSS 动画\r\n无法定义原生组件为 position: fixed\r\n不能在父级节点使用 overflow: hidden 来裁剪原生组件的显示区域\r\n原生组件的事件监听不能使用 bind:eventname 的写法，只支持 bindeventname。原生组件也不支持 catch 和 capture 的事件绑定方式。\r\n在iOS下，原生组件暂时不支持触摸相关事件。\r\n原生组件会遮挡 vConsole 弹出的调试面板。\r\n在工具上，原生组件是用web组件模拟的，因此很多情况并不能很好的还原真机的表现，建议开发者在使用到原生组件时尽量在真机上进行调试。\r\n复制代码一开始本胖查阅资源后大部分是设置如下disable-scroll='true'\r\n复制代码但是试过后并没有什么软用，最后无意间突然发现了一个好用的属性catchtouchmove='true'\r\n复制代码该属性加在海报最外面的view上面。3 生成小程序码+自定义分析其实微信小程序本身就自带了数据分析，里面有很多比如统计小程序的访问量，访问分析，用户画像等等。当然了，如果你和本胖一样对这些统计不满足的话，你还可以自己定义一些统计。本胖这次的需求是如下生成N个小程序码，然后区别不同渠道的流量3.1 生成多个小程序二维码目前小程序二维码有二种，一种是普通的正方形的（体验版本就是这种），还有一种是小程序官方为了区别其他二维码而专门设置的圆形的体验码，下面所说的体验码都是圆形的体验码，目前只能通过请求小程序官方接口获取。本胖采用的请求A类接口才获取二维码https://api.weixin.qq.com/wxa/getwxacode?access_token=ACCESS_TOKEN\r\n复制代码这个接口需要获取一个叫做access_token的东西下面是获取access_token的接口GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET\r\n复制代码好了，接下来就是愉快地获取二维码了。这时候又一次见识到小程序坑爹的地方了。本胖愉快地写了一个本地ajax请求（一定要post），代码如下：$.ajax({\r\n  method: 'post',\r\n  url: 'https://api.weixin.qq.com/wxa/getwxacode',\r\n  dataType: 'json',\r\n  data: {\r\n    access_token: 本胖的accesss_token\r\n    path: 'pages/index/index?id=1',\r\n  },\r\n  success: (data) => { \r\n    console.log(data);\r\n  }\r\n});\r\n复制代码发现报错，参数为空，再去看官方发现有下面的提示哦哦，原来是要json字符串，而jq默认是contentType是application/x-www-form-urlencoded，于是本胖很快按照提示改成了下面的contentTypecontentType: \"application/json; charset=utf-8\"\r\n复制代码这会总该可以了吧。没想到又是接受不到参数。。。。最后在尝试了很多次以后终于发现了正确的请求方式$.ajax({\r\n  method: 'post',\r\n  url: '/wxa/getwxacode?access_token=本胖的accesss_token',\r\n  dataType: 'json',\r\n  contentType: 'text/plain;charset=UTF-8',\r\n  data: JSON.stringify({\r\n    path: 'pages/index/index?id=1',\r\n  }),\r\n  success: (data) => { \r\n    console.log(data);\r\n  }\r\n});\r\n复制代码有没有很惊喜，有没有很意外。这种设计真的很蛋疼，小程序官方最好给一个请求实例哈。3.2 自定义分析 好了，经历了千辛万苦的尝试，本胖在上一届总算请求到了A计划的小程序圆形码了。接下来就是做自定义分析。所谓自定义分析，在小程序后台管理系统是可以找到的，顾名思义就是我们可以自己定义一些用户行为的分析，比如用户点击某个按钮的次数，用户停留在某些页面的时间等等，可以说是小程序官方留给开发者埋点的口子看了一下关于自定义分析的介绍（文章真的很长很长），知道了自定义分析主要步骤如下1.新建事件\r\n2.选择配置方式\r\n    A.填写配置：不需要任何小程序代码\r\n    B.API上报：需要加对应的小程序代码\r\n3.保存测试或者发布\r\n复制代码注意到了在选择配置方式的时候是有2种的，本胖这次需求是要通过不同的小程序码区别不同渠道的流量，所以选择了第二种。对了，这里需要说明之前在获取小程序码的时候path参数，本胖在路径后面是传了参数的，这个参数就是用来区别不同渠道。然后配置好后，可以获取到对应的上报代码wx.reportAnalytics('statistics', {\r\n  id: '',\r\n});\r\n    \r\n复制代码这里看出本胖是选择了一个名称是statistics的事件名称，然后本胖在A计划小程序的首页的onload事件中加入了以下代码onLoad: function(options) {\r\n  console.log(options);\r\n  wx.reportAnalytics('statistics', {\r\n    id: options.id\r\n  });\r\n}\r\n复制代码那么不同渠道的小程序进入就会获取到不同的id上报给小程序平台，在后台管理中根据不同的渠道id的上报次数来判断不同渠道的流量情况但是，现实有这么美好吗？在体验版的小程序的路径中加入了不同的id，体验了一把，去小程序的后台查看对应的数据（本胖的自定义事件已经发布），有下面的截图看的只是不同id的去重总和数据，并没有不同id对应的数据，也就说通过小程序的自定义分析实现不同小程序码区别不同渠道的想法是不行的，该次尝试以失败告终，也让本胖知道了小程序有哪些是还做不了的，所以说这样的尝试也是有意义的哈。对于这个需求，本胖最终还是打算采用我们自己的服务端来实现不同渠道的流量分析。4 其他坑点哈哈，这一节的标题不知道取什么好了，只好取了这个。4.1 横向滚动做H5的时候，实现横线滚动那是so easy的事情，大家都懂哈，不就是一个熟悉的问题嘛。 但是，这么简单的需求在小程序里面并没有那么简单。<view>\r\n  <scroll-view scroll-x>\r\n  </scroll-view>\r\n</view>\r\n复制代码像上面这样，设置了scroll-x属性就以为当scroll-view 的内容超出scroll-view 时候会出现横向滚动条，但是实际上并不是这样的，还需要下面的设置scroll-view\r\n  white-space: nowrap;\r\n子元素\r\n  display: inline-block;\r\n复制代码white-space:nowrap;这个属性在css里面的意思是规定段落中的文本不进行换行4.2 inupt动态绑定尝试过小程序的都发现他的语法和vue很像，所以上手都是很快的。但是当本胖遇到input的时候果断写了下面的代码<input value=\"{{name}}\">\r\n复制代码想通过这种方式的绑定来动态获取到输入框输入的值。但是现实又是残酷的。人家小程序根本就不支持这种写法。有没有很坑，都向vue学习了90%的语法了，input绑定变量使用评率这么高的竟然不学。吐槽归吐槽，活还是要继续干下去的。只好采用react版方式来动态获取input的输入值了。this.setData({\r\n  val: e.detail.value\r\n});\r\n复制代码4.3 wx.request这是小程序用来获取服务端数据的api，使用频率那也是很高的，但是他在本胖看来主要有2处需要注意的地方1.默认的contentType是application/json，需要自己改写为合适的和服务器端通讯\r\n2.和传统的ajax很像，容易走入回调地狱，可以自己封装成promise形式哈\r\n复制代码5. 小结这篇文章主要是总结了本胖这两周在开发A计划小程序遇到的问题以及对应的解决方案和对微信小程序的一些个人看法。不过，微信小程序的确可以说是前端史上一次重大的突破，其体验，能力（虽然大部分也都是通过使用微信app的能力）都比一般的H5更好更强。而且语法和vue很像，易于上手，开发体验也不错，相应的社区工具都越来越完善了，很期待小程序的未来。这应该是本胖工作2年多来写的最长的一篇技术博文了，二年多时间说过就过，本胖唯有努力使自己的能力与年龄成正相关才行哈。"}
{"title": "青铜选手带你动手撸一个博客小程序给自己 ", "author": "Rolan", "pub_time": "2018-11-8 00:45", "article_content": "看掘金也又一年多了，感叹各位大佬技术6的一批，刚上学的时候也给人搞过一两个小程序，突然心血来潮想总结总结经验，给自己也搞一个爽一爽，顺便也在写一篇，让各位大佬看看还有什么问题，毕竟本屌虚心的一批无图言鸡儿=>成品图菜鸡实践中总结的一些tip小程序登陆获取用户信息（与服务器交互）小程序显示富文本与markdown（使用了towxml）对wx.request的小封装（搞成promise爽一爽）iview weapp组件的使用小程序原生组件的使用针对上拉加载更多的小总结手动实现个简单的假的瀑布流功能需求分类显示博客显示博客内容（富文本/Markdown）用户在微信小程序登陆用户登陆后评论博客显示我爱看的一些书籍信息（特殊服务）一键将书籍发送到kindle（特殊服务）前期准备去UI中国或者其他网站扒拉个看着顺眼的UI设计图（毕竟审美是硬伤）去阿里图标网站找上一套顺眼的图标。选几个用来给小程序的底部tab栏用，由于小程序tab图标切换是靠换图片来实现的，因此可以从阿里图标上每个图标下两份，灰色版的下一份，彩色版的下一份。稍微整理一下图标的命名3. 个人注册个小程序账号（直接去微信公众平台注册，简单的一批），注册完后登陆一下，把appid与appsecrect搞到手4. 数据接口准备（重要的一环，总不能都是空架子把），，根据各位看官的博客后台的实际情况搞，一般都有数据接口的，用来获取文章啥的。这里我用的是自己开发的后端，所以接口什么的都是按需开发的~各位看官要是如果有兴趣可以找我要后台（thinkphp+vue+element搞的管理后台）这个项目用到的接口主要有获取顶部轮播图的接口（getSlides）根据栏目获取栏目下博客的接口（getPostOfCategory）获取文章的接口（getPost）用户登陆接口（wxLogin）用户绑定邮箱的接口（bindMail）发送书籍的接口（sendBook）获取配置的接口（getConfig）获取文章评论的接口用户评论文章的接口 这里要解释一下getConfig，每日推荐、首页博客等一些显示博客的地方说白了其实就是从服务端取不同栏目下的文章，因此需要一个栏目id来调用getPostOfCategory接口，但是又不想把栏目id写死在小程序里，万一哪天心情不好把栏目给删了小程序岂不要改代码？刚好当时做后台的时候搞了一个配置管理的功能，这次刚好用到；专门为小程序新建了一个配置组，把小程序用到的栏目id和其他乱七八糟的东西（比如分页的每页大小，背景图啥的）以key-value的形式存在后端，每次小程序启动的时候从后端获取一下配置存在localStorage里，这样在后台改改配置，小程序显示的栏目自然也就切换了。不瞎bb了开整基础设施根据需求规划一下，在pages文件夹里把所需要的页面右键新建出来由于用到了iview组件和towxml，所以把这俩老哥也给放根目录新建一个netUtils.js（网络层）,封装一下wx.request，放进netUtils里，同时把服务器地址baseUrl也作为常量放在netUtils里，所有的网络访问url都从baseUrl拼接而来，方便切换测试与生成环境再此基础上搞出来一个dataUtils（即数据层），将所有的从服务器获取数据的网络请求行为（全搞成promise）全部放在这里（可选）由于很多页面都会跳转到文章内容页、搜索页等页面，因此后面又搞了一个navUtils.js把常用的跳转都写在这里面，省的每次都在写一遍文件结构：netUtils.js关键部分const BASEURL = \"https://localhost:8888/\";\r\nconst APIURL = \"https://localhost:8888/api/\";\r\n/**\r\n * 封装request\r\n */\r\nconst requestPromise = function ({ url, data, header,\r\n  method = 'GET' }) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: url,\r\n      data: data,\r\n      header: header,\r\n      method: method,\r\n      success: (res) => { resolve(res) },\r\n      fail: (err) => { reject(err) }\r\n    })\r\n  });\r\n};\r\nmodule.exports={\r\n  BASEURL:BASEURL,\r\n  APIURL:APIURL,\r\n  request: requestPromise\r\n}\r\n复制代码dataUtils关键部分let netUtils = require('./netUtils.js');\r\n/**\r\n * 获取服务器数据基本方法\r\n */\r\nfunction getServerDataPromise(url,data,header=null,method='GET'){\r\n  let dataUrl = netUtils.BASEURL+url;\r\n  return new Promise((resolve, reject) => {\r\n    netUtils.request({\r\n      url: dataUrl,\r\n      data: data,\r\n      header:header,\r\n      method:method\r\n    }).then(res => {\r\n      resolve(res);\r\n    }).catch(err => {\r\n      reject(err);\r\n    });\r\n  });\r\n}\r\n/**\r\n * 获取栏目下文章\r\n */\r\nfunction getPostOfCategoryPromise(data) {\r\n  let url ='api/front/portal/getPostOfCategory';\r\n  return getServerDataPromise(url,data);\r\n};\r\n/**\r\n * 获取幻灯片\r\n */\r\nfunction getSlidesPromise(data){\r\n  let url ='api/front/portal/getSlide';\r\n  return getServerDataPromise(url,data);\r\n}\r\n\r\n........各位老哥根据实际情况把自己的接口封装一下搞一搞\r\n\r\n\r\nmodule.exports = {\r\n  getPostOfCategory: getPostOfCategoryPromise,\r\n  getSlides: getSlidesPromise,\r\n  checkToken: checkToken,\r\n  userLogin:userLoginPromise,\r\n  getContent: getContentPromise,\r\n  addComment: addCommentPromise,\r\n  getComment:getCommentPromise,\r\n  getKindleEmail: getKindleEmailPromise,\r\n  bindKindleEmail: bindKindleEmailPromise,\r\n  sendBook: sendBookPromise,\r\n  getNav:getNavPromise,\r\n  search: searchPromise,\r\n  getUser: getUserPromise,\r\n  checkLogin: checkLoginPromise,\r\n  getConfig: getConfigPromise\r\n};\r\n复制代码先搞个首页我的个人习惯是先把页面的js获取数据的部分写好，然后再去写wxml与wxss，有了数据填充，比教容易看出来页面的效果，调试完页面后，在取js把点击事件、跳转等其他的一些代码补全。 前端代码比较简单，就不在这贴了，值得注意的一点是，首页使用了iview的组件，因此在index.json中应先把使用的组件配置一下 index.json{\r\n  \"usingComponents\": {\r\n    \"i-row\": \"../../iview/row/index\",\r\n    \"i-col\": \"../../iview/col/index\",\r\n    \"i-spin\": \"../../iview/spin/index\",\r\n    \"i-icon\": \"../../iview/icon/index\",\r\n    \"i-message\": \"../../iview/message/index\",\r\n    \"i-divider\": \"../../iview/divider/index\"\r\n  },\r\n  \"enablePullDownRefresh\":true\r\n}\r\n复制代码index.jslet netUtils=require('../../utils/netUtils.js');\r\nlet dataUtils=require('../../utils/dataUtils.js');\r\nlet navUtils=require('../../utils/navUtils.js');\r\nconst { $Message } = require('../../iview/base/index');\r\n// pages/index/index.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    IMGURL: netUtils.BASEURL,\r\n// 幻灯片\r\n    slides:[],\r\n// 推荐\r\n    recommends:[],\r\n    recommendPage:1,\r\n    recommendPageSize:5,\r\n    // blog\r\n    blogs: [],\r\n    blogPage: 1,\r\n    blogPageSize: 10,\r\n//config\r\n    slideId: getApp().globalData.StorageDB.get('config.slideId'),\r\n    recommendCategoryId: getApp().globalData.StorageDB.get('config.recommendCategoryId'),\r\n    blogCategoryId:getApp().globalData.StorageDB.get('config.blogCategoryId'),\r\n    hasMore:true\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n    this.getSlides();\r\n    this.getRecommend();\r\n    this.getBlog();\r\n  },\r\n  /**\r\n   * 页面相关事件处理函数--监听用户下拉动作\r\n   */\r\n  onPullDownRefresh: function () {\r\n    this.setData({\r\n      // 推荐\r\n      recommends: [],\r\n      recommendPage: 1,\r\n      recommendPageSize: 5,\r\n      // blog\r\n      blogs: [],\r\n      blogPage: 1,\r\n      blogPageSize: 10,\r\n      hasMore:true\r\n    });\r\n    this.getSlides();\r\n    this.getRecommend();\r\n    this.getKindleBook();\r\n    this.getBlog();\r\n  },\r\n\r\n  /**\r\n   * 页面上拉触底事件的处理函数\r\n   */\r\n  onReachBottom: function () {\r\n    this.getBlog();\r\n  },\r\n  //自定义方法\r\n\r\n  getSlides(){\r\n    dataUtils.getSlides({id:1})\r\n    .then(res=>{\r\n      if(res.data.status=='200'){\r\n        this.setData({\r\n          slides:res.data.data.item\r\n        });\r\n      }\r\n    });\r\n  },\r\n  getRecommend(){\r\n    dataUtils.getPostOfCategory({\r\n      page:this.data.recommendPage,\r\n      pageSize:this.data.recommendPageSize,\r\n      id:this.data.recommendCategoryId\r\n    }).then(res=>{\r\n      if (res.data.status == '200') {\r\n        if(res.data.data.pageData.length==0){\r\n          return;\r\n        }\r\n        let recommendPage = this.data.recommendPage;\r\n        recommendPage = recommendPage + 1;\r\n        let recommends = this.data.recommends.concat(res.data.data.pageData);\r\n        this.setData({\r\n          recommends: recommends,\r\n          recommendPage: recommendPage\r\n        });\r\n      }\r\n      else{\r\n        $Message({\r\n          content: '未获取到数据～',\r\n          type: 'error'\r\n        });\r\n      }\r\n    });\r\n  },\r\n  getBlog() {\r\n    dataUtils.getPostOfCategory({\r\n      page: this.data.blogPage,\r\n      pageSize: this.data.blogPageSize,\r\n      id: this.data.blogCategoryId\r\n    }).then(res => {\r\n      if (res.data.status == '200') {\r\n        if (res.data.data.pageData.length == 0) {\r\n          this.setData({\r\n            hasMore:false\r\n          });\r\n          return;\r\n        }\r\n        let blogPage = this.data.blogPage;\r\n        blogPage = blogPage + 1;\r\n        let blogs = this.data.blogs.concat(res.data.data.pageData);\r\n        let blogLeft=blogs.filter((value,index)=>{return index%2!=0});\r\n        let blogRight = blogs.filter((value, index) => { return index % 2 == 0 });\r\n        this.setData({\r\n          blogs: res.data.data.pageData,\r\n          blogLeft:blogLeft,\r\n          blogRight:blogRight,\r\n          blogPage: blogPage\r\n        });\r\n      }\r\n      else {\r\n        $Message({\r\n          content: '未获取到数据～',\r\n          type: 'error'\r\n        });\r\n      }\r\n    });\r\n  },\r\n  navToContent(e){\r\n    navUtils.navToContent(e.currentTarget.dataset.id);\r\n  },\r\n  navToBlog(){\r\n    wx.switchTab({\r\n      url: '../blog/blog',\r\n    });\r\n  }\r\n})\r\n复制代码代码比较简单（毕竟技术比较菜），值得注意的是这个getBlog方法，该方法获取的是首页上，中下部分的那一坨博客，当页面触底时会会加载更多觉得单纯的排列下来比较平庸，因此想搞个瀑布流，反正没那么多性能和外观要求，所以就搞了个假的瀑布流，具体操作就是在获取到数据后，把数据分成两半，左半边和右半边，在前端也是把这两个数组分别循环一下即可。由于页面有下拉刷新与拉到底部会加载更多，因此，在这的逻辑就是，当触发上拉加载时从服务器获取到数据判断下数据是否为空，若为空则说明无更多数据可加载将hasMore设为false即可，page与blogs数据均不变若不为空则 拼接 到现有数据数组的尾部，同时将页码page在现有基础上+1（即将页码的操作放在每次请求之后，这样每次请求时候无需考虑页码是否+1直接用即可），即先拼接在处理页码最后setData当触发下拉刷新时先将page设置为1，清空现有blogs数据调用getBlog这样做能把下拉刷新与上拉加载的功能均用getBlog来做无需根据情况来判断如何处理（替换or拼接）从服务器请求来的数据第一期结尾罗里吧嗦的有点长了，越写越感觉做的不咋地写的更不咋地，看各位看官凑合的看下把（估计没几个人会看到这个地方...），我也整理整理思路，希望写后续第二期的时候能把想表达的写出来。"}
{"title": "小游戏群聊分享又有新套路，小程序实现全面布局 ", "author": "Rolan", "pub_time": "2018-11-9 00:21", "article_content": "11 月 5 日晚，微信宣称「为了让用户更好地发现和使用基于地理位置的小程序服务」，对附近的小程序进行了升级，新增了分类导航、服务标签、在线客服展示等功能。同时，小程序新增了带有状态的群分享卡片、局域网通信等功能。本次更新几乎将微信小程序的整体布局一一展现：线上连接线下：附近的小程序功能升级。以往更多的是线下扫码进入小程序，而升级后的附近的小程序则更像美团、大众点评，可以实现线上到线下的用户延申。小程序卡片升级：小程序和小游戏的群分享卡片，支持实时显示活动参与人数。原来分享小程序卡片只能邀请好友进入小程序、加入游戏，升级后的卡片分享者及点击用户，均可使用「请提醒我」按钮，接收活动开始提醒，及时获取活动状态。小程序打通物联网：小程序支持与同一局域网内的设备进行网络通信，可实现操控智能硬件、为智能硬件配置网络等功能。关于附近的小程序我们在《微信重磅改版！这是要用「附近的小程序」再造一个美团？》一文中已进行过详解，接下来我们将就小程序卡片与小程序打通物联网两方面做出介绍。群分享小程序卡片升级群分享卡片升级，即分享者及点击过该卡片的参与者，可使用「请提醒我」按钮，在默认的 24 小时内（过期时间戳支持修改）都可以接收活动开始提醒，以及时获取活动状态。当有朋友分享小程序卡片到群聊中，分享者及点击过该卡片的参与者将可以设置「请提醒我」，接下来默认 24 小时内将可以及时接收到动态消息，获得「小程序提醒」，将用户迅速召回小程序。从某种程度上看，动态消息和消息模板有些许相似，他们都能以向用户传达消息为手段召回用户。作为一个新鲜出炉的新能力，动态消息的目前受到的限制并不算小。它的出现也可以看作微信对小程序活动能力的再补充。用户可接受小程序短期活动的动态消息，商家或组织利用小程序举办活动也更加方便。动态消息适合的场景非常多样，多人游戏、活动报名、多人砍价、活动倒数都可以用升级的群分享卡片进行通知和扩散，配合小程序卡片的图片引导用户点击「请提醒我」，小程序就能在活动开始时提示用户「已开始」。我们阅读开发文档后发现，动态消息的固定句型为「成员正在加入，当前 X/Y 人」，X、Y 的定义都为 String（字符串）类型，这意味着，你将可以创造各种「投机」的句型：成员正在加入，当前 2/4 人成员正在加入，当前 二/four 人成员正在加入，当前 请关注我们的微信公众号/zxcx0101人成员正在加入，当前 已有2998人参与拼团，就差你了/ 人这对很多工具类、拼团类小程序和小游戏来说都意义重大。新功能发布后，「小打卡」的开发者就兴奋地表示要和微信群深度绑定，利用群分享卡片，为小程序创造更多价值。小程序打通物联网本次更新最大的创新可能在于：小程序将支持连接包括智能家居等物联网设备。就像在 iPhone 上使用 Home app，在本次更新后，你将可以把你的小程序当作遥控器，在其中实现对智能电灯、智能音箱、路由器、空调等的控制。微信小程序的开发文档中新增了对「局域网通信」的描述，其中第一句为：基础库 2.4.0 提供了 wx.startLocalServiceDiscovery 等一系列 mDNS API，可以用来获取局域网内提供 mDNS 服务的设备的 IP。简单理解 mDNS，即每个进入局域网的主机，如果开启了 mDNS 服务的话，都会向局域网内的所有主机组播一个消息：「我是谁，我的 IP 地址是多少」。然后其他也有该服务的主机就会响应，也会告诉你，「它是谁，它的 IP 地址是多少」。值得注意的是，mDNS 仅是实现了服务发现，所以只能用于控制，而不能用于服务。不仅仅是物联网，「小程序支持与同一局域网内的设备进行网络通信」，也意味着你将来可以像打局域网联机 CS 一样，实现局域网内一起打小游戏。可能会有读者好奇，既然小游戏支持多人同玩，何必再玩局域网联机？我们可以设想一个场景，你在一个酒吧里，老板说：「大家连接好 WiFi，打开 XXX 小程序，点击抽奖按钮，22:00 会准时开奖。」老板需要做的，是下载一个 app，开启 mDNS 服务充当局域网服务器，用于大家加入，而在小程序内实现功能。同样，酒吧老板也可以说：「我们现在组一个小程序版赛车局，大家有兴趣的加入。」从而实现同在一个局域网下的玩家，无需添加微信好友实现多人游戏。小程序给腾讯更多尝试的勇气除了上面提到的大更新，微信小程序也放出了不少小更新：单个小程序最多可跳转 10 个其他小程序；影响用户体验的小程序页面同步旋转也来了，当用户旋转手机时，小程序页面也可同步旋转；开发者对图片的处理也更加方便，当用户选择图片后，开发者用图片压缩接口就可以按需设置压缩比例进行压缩。一大波新能力袭来，开发者们已摩拳擦掌。之前曾被戏称为「微信的增量杀手」的小程序，这次的更新完全不让人失望，隐隐让人觉得小程序或许是「腾讯的布局工具」，帮腾讯尝试各种可能。「附近的小程序」连接线下，腾讯的野心昭昭；小程序控制智能家居，小米等家居厂商想要的生态也能在这里实现；小程序新增动态消息通知，与群绑定分享创造更大价值。在小程序生态初见雏形的今天，小程序给了腾讯更大的勇气，延申自己的边界，触达未及的领域。"}
{"title": "浅析微信支付：查询订单和关闭订单 ", "author": "Rolan", "pub_time": "2018-11-9 00:30", "article_content": "浅析微信支付系列已经更新六篇了哟～，没有看过的朋友们可以看一下哦。浅析微信支付：支付结果通知浅析微信支付：统一下单接口浅析微信支付：微信公众号网页授权声明：这里的查询订单、关闭订单接口仅适用于 小程序支付、公共号支付、扫码支付、APP支付，刷卡支付方式此处并不适用。1、查询订单以下为微信官方的查询订单文档：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_21.1. 应用场景该接口提供所有微信支付订单的查询，商户可以通过查询订单接口主动查询订单状态，完成下一步的业务逻辑。需要调用查询接口的情况：\r\n◆ 当商户后台、网络、服务器等出现异常，商户系统最终未接收到支付通知；\r\n◆ 调用支付接口后，返回系统错误或未知交易状态情况；\r\n◆ 调用刷卡支付API，返回USERPAYING的状态；\r\n◆ 调用关单或撤销接口API之前，需确认支付状态；1.2. 接口链接https://api.mch.weixin.qq.com/pay/orderquery1.3. 是否需要证书不需要1.4. 调用接口查询订单接口需要使用微信订单号或者商户订单号来查询，其他参数为商户平台信息的公共参数，为常量，此处省略解释。微信订单号：transaction_id（微信的订单号，建议优先使用）\r\n商户订单号：out_trade_no（商户系统内部订单号）此两个参数必填其中之一，微信推荐使用微信订单号来查询，下面为实现代码：private void doOrderQuery() {\r\n    System.out.println(\"查询订单\");\r\n    HashMap<String, String> data = new HashMap<String, String>();\r\n    // data.put(\"out_trade_no\", out_trade_no);\r\n    data.put(\"transaction_id\", \"4008852001201608221962061594\");\r\n    try {\r\n        WXPay wxPay = new WXPay(WXPayConfigImpl.getInstance());\r\n        Map<String, String> r = wxPay.orderQuery(data);\r\n        System.out.println(r);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}wxPay.orderQuery方法为封装的sdk方法，具体实现请参考作者github源码。对于商户关键信息的写入，公共方法为wxPay.fillRequestData，实现如下：/**\r\n * 向 Map 中添加 appid、mch_id、nonce_str、sign_type、sign <br>\r\n * 该函数适用于商户适用于统一下单等接口，不适用于红包、代金券接口\r\n *\r\n * @param reqData r\r\n * @return map\r\n * @throws Exception e\r\n */\r\npublic Map<String, String> fillRequestData(Map<String, String> reqData) throws Exception {\r\n    reqData.put(\"appid\", config.getAppID());\r\n    reqData.put(\"mch_id\", config.getMchID());\r\n    reqData.put(\"nonce_str\", WXPayUtil.generateNonceStr());\r\n    if (SignType.MD5.equals(this.signType)) {\r\n        reqData.put(\"sign_type\", WXPayConstants.MD5);\r\n    } else if (SignType.HMACSHA256.equals(this.signType)) {\r\n        reqData.put(\"sign_type\", WXPayConstants.HMACSHA256);\r\n    }\r\n    reqData.put(\"sign\", WXPayUtil.generateSignature(reqData, config.getKey(), this.signType));\r\n    return reqData;\r\n}以上为查询微信订单的使用方式，具体的返回参数请参考官方文档。2、关闭订单以下为微信官方的关闭订单文档：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_32.1. 应用场景以下情况需要调用关单接口：商户订单支付失败需要生成新单号重新发起支付，要对原订单号调用关单，避免重复支付；\r\n系统下单后，用户支付超时，系统退出不再受理，避免用户继续，请调用关单接口。注意：订单生成后不能马上调用关单接口，最短调用时间间隔为5分钟。2.2. 接口链接https://api.mch.weixin.qq.com/pay/closeorder2.3. 是否需要证书不需要2.4. 调用接口关闭订单接口需要使用商户订单号来查询，其他参数为商户平台信息的公共参数，为常量，此处省略解释。商户订单号：out_trade_no（商户系统内部订单号）PS：关单接口只能使用微信订单号来查询，和查询接口不同，下面为实现代码：private void doOrderClose() {\r\n    System.out.println(\"关闭订单\");\r\n    HashMap<String, String> data = new HashMap<String, String>();\r\n    data.put(\"out_trade_no\", out_trade_no);\r\n    try {\r\n        WXPay wxPay = new WXPay(WXPayConfigImpl.getInstance());\r\n        Map<String, String> r = wxPay.closeOrder(data);\r\n        System.out.println(r);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}关单接口的公共参数设置和查询订单一致，这里就不重复解释了，具体的返回参数请参考微信官方文档。PS：关单接口可能会调用失败，已支付、已关闭等场景，所以需要开发者注意官方文档中的错误码，对异常情况进行处理。结语以上为查询订单、关闭订单的调用方式，如果是刷卡支付方式，他的关闭订单接口为撤销订单:reverse，在作者sdk源码中也有具体的实现方式。预告：下一篇文章 申请退款和退款回调接口，敬请期待！！！​如果想要提前一览源码的小伙伴，可以先看看我的 github，地址如下：​https://github.com/YClimb/wxpay-sdk/blob/master/README.md加作者私人微信，作者微信号如下 yclimb，标明 微信支付 可拉入微信支付讨论群与小伙伴一起探讨哦，一定要标明 微信支付 哦～"}
{"title": "大风起兮云飞扬！ 小程序云开发实战奉上 ", "author": "Rolan", "pub_time": "2018-11-12 00:12", "article_content": "小程序云开发发布有一段时间了，最近着手做了一个基于云开发的小程序项目--仿《微博鲜知》，来自新浪的这款全新风格的小程序虽然界面非常简约清新，但是内部还是内藏了很多玄机，在实现的路上遇上了不少坎坷，在这里分享给大家。希望给大家提供一些思路。先展示一下最终结果： 更多图片资源在这里一、 组件化思想开发一个完整的小程序时，我们应该先分析其内部的结构。重复的结构抽离出来作为组件，组件非常的灵活，可以嵌入一个页面或多个页面。在上面的gif图中我们可以看到首页的内容是一个个的新闻块。 虽然这个新闻块只在首页中使用到，但是我还是把它抽离成了一个组件。这样做的好处是页面结构将会更加的清晰，并且耦合度降低，比如想换个主界面风格时，你可以直接换另一个组件添加进来。还有新闻内部页面中，有多个小标题，每个小标题里面嵌入了不等数量的新闻。如果不是采用组件化的话，到时候inner页面的wxml结构就会乱成一锅粥。所以这里的建议是尽量组件化分离开来。对于组件很陌生可以先看我的之前的这篇文章组件化开发tabbar下面是项目的页面与组件目录：二、数据库设计既然是“全栈”，后端肯定要搞搞。后端的核心就是数据。那么我们就先把数据库分析一下。这里我是这样分析的，从页面获得字段，然后再理解数据间的关联，如一对多，一对一。这里我构建了5个集合fresh-mainNews 主页新闻集合subNews字段是一个数列，存储着fresh-subNews Doc的_id，这样就将这两个集合绑定了起来，在后面我们会讲到在云函数中把这两个集合融合起来返回一个新的数据变得完整一些的集合。有人可能会问，云数据库不是noSQL吗，为什么不把所有数据全部整合到一个全部的JSON,那样就可以只调用一次JSON。我的理解是： 我们查询只是需要查询我们想要的数据，不需要的数据可以等需要的时候再根据关联去请求。 比如这个项目中的首页新闻块，每一个新闻块内部都关联着大量的子新闻，第一次加载就全部把这个小程序需要的所有数据都加载出来就有点疯狂了。fresh-subNews 内部页面新闻小标题集合fresh-comments 评论集合fresh-detailNews 详细新闻集合fresh-users 用户集合 这里查看更多的数据库信息三、页面构建讲到这里就该说页面的构建了。页面可以想象成一个架子，一个承载数据的容器。页面通上数据，就变得活起来。MVVM，数据驱动视图。交互靠数据，组件间的通信，组件与页面间的通信都是数据。{{}} -> 就像是流浪法师大招神奇的传送门。后面会将给出一个精彩的组件通信例子（点击目录如何实现标题栏置顶）。四、关于云开发。云开发三大核心：云函数：通俗的理解就是你写的函数在云端运行，可以把复杂的业务逻辑放在云函数里数据库：一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库存储：在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理，可以上传照片下载照片，或者一些其他文件。在这里详细介绍一下操作云函数提取数据库的流程, 这里我们以获取首页数据为例：先在云函数目录新建一个函数：mianNewsGet2. 打开该云函数的index.js 我这里用的是vsCode+node+yarn环境。 open in terminal(在终端中打开)，yarn一下，添加依赖。 或者参考云函数官方文档编写云函数查询数据// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n// 云函数初始化\r\ncloud.init()\r\n//获取数据库句柄\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async () => {\r\n    const mainNewsList = [];\r\n    //向fresh-mainNews集合中获得全部数据、因为数据库里面现在存的数据不多，\r\n    //如果多的话可以设置一个limit以及skip来获取特定数量的数据\r\n    const mainNews = await db.collection(\"fresh-mainNews\").get();  \r\n    for(let i = 0; i < mainNews.data.length; i++) {\r\n      const mainNew = mainNews.data[i];\r\n      let user_id = mainNew.setMan;\r\n      //条件查询 获取特定id的docments\r\n      const user = await db.collection('fresh-users').where({\r\n        _id: user_id\r\n      }).get();\r\n      //限定条件如果有多条，只添加一条进去\r\n      if (user.data.length > 0) {\r\n        mainNew.setMan = user.data[0]\r\n      }\r\n      //这个循环是集合的拼接\r\n      for (let i = 0; i < mainNew.subNews.length; i++) {\r\n        const subNews = await db.collection(\"fresh-subNews\").where({\r\n          _id: mainNew.subNews[i]\r\n        }).get();\r\n        if (subNews.data.length > 0) {\r\n          mainNew.subNews[i] = subNews.data[0]\r\n        }\r\n      }  \r\n      //把拼好的docments挨个放进mainNewsList里面也就是形成了一个全新的\r\n      //融合的数据更为完整的JSON数组   \r\n      mainNewsList.push(mainNew);\r\n    }\r\n    return mainNewsList;\r\n}\r\n复制代码在首页index.js里面onLoad函数里面调用云函数var that = this;\r\n    wx.cloud.callFunction({\r\n    // 声明调用的函数名\r\n      name: 'mainNewsGet',\r\n    // data里面存放的数据可以传递给云函数的event  效果：event.a = 1\r\n      data: {\r\n        a: 1\r\n      }\r\n    }).then(res => {\r\n    //res.result的值是云函数的return的值\r\n    //这里将查询的结果放入mainNewsList中，然后就可以在wxml中调用数据\r\n      that.setData({\r\n        mainNewsList: res.result\r\n      })\r\n    //打印一下结果看看有没有成功获取数据\r\n      console.log(this.data.mainNewsList)\r\n    }).catch(err => {\r\n      console.log(err)\r\n    })\r\n复制代码获取的数据：我们可以看到原本的subNews里面本来存放的是_id的数值，融合后变成_id对应的整个doc变化: [_id1.value,_id2.value~~] ---> [{_id1:value,key1:value1,key2:value2},~~~]云函数的调用，数据库的查询。就是这么简单的四步，云开发的门槛很低，功能也很强大,只要你去尝试，很轻松的就能够实现。五、关于时间格式化。写在utils文件夹里添加xx.jsconst formatTime = date => {\r\n    var dateNow = new Date();\r\n    var date = new Date(date);\r\n    const hour = date.getHours()\r\n    const minute = date.getMinutes()\r\n    var times = (dateNow - date) / 1000;\r\n    let tip = '';\r\n    if (times <= 0) {\r\n        tip = '刚刚'\r\n        return tip;\r\n    } else if (Math.floor(times / 60) <= 0) {\r\n        tip = '刚刚'\r\n        return tip;\r\n    } else if (times < 3600) {\r\n        tip = Math.floor(times / 60) + '分钟前'\r\n        return tip;\r\n    }\r\n    else if (times >= 3600 && (times <= 86400)) {\r\n        tip = Math.floor(times / 3600) + '小时前'\r\n        return tip;\r\n    } else if (times / 86400 <= 1) {\r\n        tip = Math.ceil(times / 86400) + '昨天'\r\n    }\r\n    else if (times / 86400 <= 31 && times / 86400 > 1) {\r\n        tip = Math.ceil(times / 86400) + '天前'\r\n    }\r\n    else if (times / 86400 >= 31) {\r\n        tip = '好几光年前~~'\r\n    }\r\n    else tip = null;\r\n    return tip + [hour, minute].map(formatNumber).join(':')\r\n}\r\n\r\nconst formatNumber = n => {\r\n    n = n.toString()\r\n    return n[1] ? n : '0' + n\r\n}\r\n\r\n//将这个接口暴露\r\nmodule.exports = {\r\n    formatTime: formatTime,\r\n}\r\n复制代码在需要的页面的xx.js里面引入import { formatTime } from '../../utils/api.js';格式化获取的时间数据let mainNewsList = that.data.mainNewsList\r\n      for(let i =0; i < mainNewsList.length;i++) {\r\n        let time = formatTime(mainNewsList[i].time)\r\n    //这是setData()的数组用法，会经常用到\r\n        var str = 'mainNewsList['+i+'].time' \r\n        that.setData({\r\n          [str]:time\r\n        }) \r\n    }\r\n复制代码六、 关于一些很有用但是你可能不知道的小程序技巧全屏显示图片，能够实现多张图片左右滑动并且还有数字索引现在在屏幕上，并且长按还能收藏以及下载(之前不知道这个API还特地做了一个组件来实现类似功能，简直吐血)wx.previewImage({\r\n        current: imgUrl, // 当前显示图片的http链接\r\n        urls: imagePack // 需要预览的图片http链接列表\r\n      })\r\n复制代码非常方便的一个API能够滑动到某个位置wx.pageScrollTo({\r\n    scrollTop: 一个数值（自带px单位）,   //滚动到数值所在的位置\r\n    duration: 50                          //执行滚动所花的时间\r\n    })\r\n复制代码查询节点query.selectAll('类名')及query.select('#id')官方文档var that = this\r\nlet catalogIndex = that.data.catalogIndex;\r\nquery.selectAll('类名').boundingClientRect(function (rects) {\r\n        rects.forEach(function (rect) {\r\n          rect.top     // 节点的上边界坐标st,\r\n//还有一些别的属性，这个查询节点是后面讲到的目录跳转关键API\r\n          })\r\n        })\r\n      }).exec()\r\n    },\r\n复制代码setData()一些技巧。//给数组设置值 还可以有var xx = 'xx['+idx+'].key'的形式\r\nvar doneList = 'doneList['+idx+']'\r\n      that.setData({\r\n        [doneList]: true,\r\n      })\r\n复制代码有时候我们还可以先改变某个数的值再去setData()它，这是setData()的一个很好用的技巧，不过需要去运用一下才好理解 如：dataPack.likeNum = (supLikeNum===-1 ? dataPack.likeNum: supLikeNum);\r\n    this.setData({\r\n      comment: dataPack,\r\n    })\r\n复制代码七、 项目最精彩的两个部分1.点击目录栏页面将相应新闻栏置顶，先看下效果这个效果在别的小程序里面都没有见过，应该是微博鲜知独创的，在这里先对原作者表达一下敬意。内部的构造也是非常巧妙，不同于我们常见的外卖的锚点定位。我们先来分析一波：mvvm，视图是由数据驱动的，我们要透过现象看本质，去思考底层的数据，这样我们很快就会有思路:点击目录栏的item项如果绑定了一个data-idx等于循环的索引，可以在e.currentTarget.dataset.idx拿到这个item的索引。我们把这个数据通过组件通信传递到inner页面,然后在由inner页面把数据转交给subNews并且在inner页面的js中绑定subNews的goTop事件，这样产生了一个catalog组件->inner页面->subNews的关联，数据为item的索引。触发catalog就能够控制subNews组件的移动，是不是还有点绕， ok show the code: 1.catalog/index.wxml<block wx:for=\"{{subNews}}\" wx:for-item=\"subNewsItem\" wx:for-index=\"idx\" wx:key=\"index\">\r\n            <view class=\"subTitle-item\" bind:tap=\"scrollFind\"\r\n    //关键1：绑定item索引\r\n            data-hi=\"{{idx}}\">\r\n <text>{{subNewsItem.title}}</text>\r\n                </view>\r\n        </block>\r\n复制代码获得索引，并绑定inner页面 catalog/index.jsscrollFind: function(e) {\r\n      //点击后 实现inner页面特定新闻小标题置顶\r\n      let curIndex = e.currentTarget.dataset.hi\r\n      // 关键2： 与inner页面取得联系\r\n      var myEventDetail = {index: curIndex} // detail对象，提供给事件监听函数\r\n      var myEventOption = {} // 触发事件的选项\r\n      this.triggerEvent('catalog', myEventDetail)\r\n    }\r\n复制代码inner/inner.js 取得与catalog的通信onCatalog: function(e) {\r\n    e.detail // 自定义组件触发事件时提供的detail对象\r\n    console.log(e.detail.index)\r\n    //关键:3 把索引存储到data\r\n    this.setData({\r\n      catalogIndex : e.detail.index\r\n    })\r\n    \r\n//关键4: 页面可以通过组件的id取得其页面引用组件的方法\r\n// this.subNews=this.selectComponent(\"#subNews\")\r\n    this.subNews.goTop();\r\n  },\r\n复制代码给subNews传catalogIndex，并且标上id<subNews ~省略~ catalogIndex=\"{{catalogIndex}}\" id=\"subNews\"></subNews>\r\n复制代码在subNews中先定义一个图片加载事件，这样在页面加载完成时会触发其绑定的事件，这是来自瀑布流的灵感。可以在图片加载出来的时候触发onImageLoad函数，而在这个函数里我们可以干一些准备的事情。//subNews/index.wxml\r\n//一个看不见的图片，来自瀑布流的灵感，能够产生主动触发的事件\r\n<view style=\"display:none\">\r\n  <image src=\"{{mainImg}}\" bindload=\"onImageLoad\"></image>\r\n</view>\r\n复制代码//subNews/index.js\r\nonImageLoad: function () {\r\n      var that = this\r\n      let offsetList = that.data.offsetList;\r\n      const query = wx.createSelectorQuery().in(this)\r\n//之前讲到过的API获取节点信息，我们把它存储到offsetList偏移量数组，他存储着每一个节点在屏幕的位置，\r\n//配合wx.pageScrollTo可以达到新闻栏置顶的效果\r\n      query.selectAll('.subNews-wrapper').boundingClientRect(function (rects) {\r\n        rects.forEach(function (rect) {\r\n          rect.top     // 节点的上边界坐标\r\n          offsetList.push(rect.top)\r\n          that.setData({\r\n            offsetList,\r\n          })\r\n        })\r\n      }).exec()\r\n    },\r\n复制代码给标题栏绑定上goTop事件goTop: function (e) {\r\n      var that = this\r\n      let catalogIndex = that.data.catalogIndex;\r\n      //这里offsetList是一个data里面的数据，来保存所有的节点的上边距坐标\r\n      let offsetList = that.data.offsetList;\r\n      wx.pageScrollTo({\r\n            scrollTop: offsetList[catalogIndex],   //滚动到具体数值所在的位置\r\n            duration: 50                          //执行滚动所花的时间\r\n          })\r\n    }\r\n复制代码至此，你就实现了这个看似简单却非常巧妙的功能，组件->页面->组件，秀得眼花缭乱。如果还是有些不理解的话，等下可以下载我的代码去看。至于为什么要弄一个图片的加载然后触发那个事件呢，这是因为如果你把获取offsetList偏移量数组的函数放在goTop里的话，进入页面第一次的点击会无效，这样产生的体验肯定是非常不舒服的。2. 点赞优化先展示一下效果：先说一下优化的是什么：点赞效果的延迟极大降低因为点赞的变化是由用户产生的一个交互，传统的观点就是用户点赞->后端更新数据->前端拉取数据->数据驱动视图的变化。真实的体验就是，非常的慢，慢到点击后2秒才能看到点赞的效果，这种差劲的交互简直就是一场灾难。先给传统的、局部刷新优化的，效果还是很差的一段代码：for(let i = 0; i< that.data.comments.length; i++)\r\n        {\r\n    //当点击该个评论时，只更新这一条数据\r\n          if (i == idx) {\r\n            var str = 'comments['+idx+'].likeNum'\r\n            that.setData({\r\n              [str]:res.result.data.likeNum,\r\n            })\r\n            console.log(likeNumList[idx])\r\n          }\r\n        } \r\n复制代码优化后：data: {\r\n    doneList: [],      //是否按下\r\n    likeNumList: [],  //模拟点赞数数组\r\n    likeAdd: 10,      //点赞每次增加数，根据你的设置来，你后端每次加1这里就写1\r\n  },\r\n  \r\nvar doneList = 'doneList['+idx+']'\r\nlikeNumList[idx] = (that.data.comments[idx].likeNum + that.data.likeAdd);\r\n      that.setData({\r\n        likeNumList,\r\n       [doneList]: true,\r\n        likeAdd: that.data.likeAdd+10\r\n      })\r\n复制代码<text class=\"dianzanNum\">{{likeNumList[idx]?likeNumList[idx]:item.likeNum}}</text>\r\n复制代码优化思路是怎么样的呢？用一个数组来存放/模拟更新的数据，如果数字的索引位置被赋值，则页面直接显示这个更新的数字，也是异曲同工之妙。因为用户关心的是数据的变化，我们可以先把数据的变化产生，至于数据后端的变化让他异步慢慢的去做。从这里发散思想，是不是评论功能也能够用这样的思路同样去达到极致的速度与交互体验呢。点赞的延迟几乎为无，体验到点赞的极致快感，让人几乎停不下来~~（暗示一波）篇幅所限，文章到这里就差不多了。项目地址: github-HappyBirdwe-weiboFresh 奉上精心写的项目，细节很不错哟，欢迎大家☆☆☆☆star☆☆☆☆结语：学习的道路上免不了坎坷，希望文章的分享能够为大家提供一些思路，学习的过程减少一点弯路，这就是这篇文章最大的价值，欢迎大家提问及指正。最后在这里感谢一下:腾讯云提供的技术支持☆ 新浪团队的微博鲜知作者☆ 掘金这个优秀的平台☆ 点赞动作超帅的你☆微博鲜知小程序官方传送门：体验真的很不错哦，界面非常简约，大家可以体验一波"}
{"title": "一周学会小程序-日播天气 ", "author": "Rolan", "pub_time": "2018-11-12 00:21", "article_content": "前言：欢迎收看一周学会小程序系列2-日播天气。看了苹果的自带天气软件，发现很简单使用。在小程序上看了一下天气的小程序，没有发现类似的，于是就模仿了一个。虽然模仿的不是很像，请大家不要见笑！主要功能：1. 通过定位或选取位置获取当天详细天气预报（1）天气情况，包括温度「当前温度、最低温度和最高温度」、天气、空气质量、湿度、风向和风速、日出和日落、气压、能见度等； （2）生活指数，包括舒适度、穿衣、感冒、运动、旅游、紫外线强度、洗车、污染扩散等。2. 24小时天气预报3. 7天天气预报细节：增加类似于App的启动页具体功能实现：1.接口部分：使用京东万象提供的免费天气接口（京东万象官网地址）2.页面部分：（1）布局构思：主页面使用小程序推荐flex列布局，使用4个模板（当前天气温度信息模板、24小时模板、7天天气模板、生活指数模板），2个scrollview（24小时、7天天气预报） （2）详细模板使用：以当前天气信息为例（单一样式）：.wxss\r\n<template name=\"nowTemplate\">\r\n  <view class='template-bgview'>\r\n    <view class='temperature-bg'>\r\n      <text class='temperature-text'>{{nowweather.tmp}}</text>\r\n      <text class='temperature-degree'>°</text>\r\n    </view>\r\n\r\n    <view class='weather-bg'>\r\n      <text>{{nowweather.cond.txt}}</text>\r\n      <view class='weather-line'>|</view>\r\n      <view class='aqi-bg'>\r\n        <text class='aqi-text'>{{aqi.aqi + \" \" + aqi.qlty}}</text>\r\n        <!-- <text>{{aqi.aqi}}</text> -->\r\n      </view>\r\n    </view>\r\n\r\n    <view class='winter-bg'>\r\n      <text class='hum-text'>{{\"湿度 \"+nowweather.hum+\"%\" + \"  \"}}</text>\r\n      <text class='wind-text'>{{\"  \" + nowweather.wind.dir+\" \"+nowweather.wind.sc+\"级\"}}</text>\r\n    </view>\r\n  </view>\r\n</template>\r\n\r\n.wxss\r\n.template-bgview {\r\n  width: 100%;\r\n  /* height: 175px; */\r\n  align-items: center;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n}\r\n\r\n.temperature-bg {\r\n  /* align-items: center; */\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: center;\r\n}\r\n\r\n.temperature-text {\r\n  font-size: 160rpx;\r\n  font-weight: lighter;\r\n}\r\n\r\n.temperature-degree {\r\n  font-size: 80rpx;\r\n  font-weight: lighter;\r\n}\r\n\r\n.weather-bg {\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: center;\r\n}\r\n\r\n.weather-line {\r\n  margin-left: 5px;\r\n  color: gray;\r\n}\r\n\r\n.aqi-bg {\r\n  margin-left: 5px;\r\n  background-color: yellow;\r\n  border-radius: 3px;\r\n}\r\n\r\n.aqi-text {\r\nmargin-left: 5px;\r\nmargin-right: 5px;\r\n}\r\n\r\n.winter-bg {\r\n  margin-top: 10px;\r\n  display: flex;\r\n  flex-direction: row;\r\n  justify-content: center;\r\n}\r\n\r\n.hum-text {\r\n  margin-right: 10px;\r\n}\r\n\r\n.wind-text {\r\n  margin-left: 10px;\r\n}\r\n复制代码模板使用： 1.模板页面导入 .wxml<import src=\"../template/now-template.wxml\" />\r\n复制代码.wxss@import \"../template/now-template.wxss\";\r\n复制代码2.外层嵌套view使用<view class='now-view'>\r\n      <template is=\"nowTemplate\" data=\"{{nowweather:weather.now, aqi:weather.aqi}}\" />\r\n    </view>\r\n复制代码以7天天气模板为例（列表样式）： 使用方法相同，具体wxml和wxss代码如下wxml\r\n<template name=\"sevenDays\">\r\n  <view class='template-sevendays'>\r\n    <view class='week' wx:if=\"{{index==0}}\">{{item.week.week+\"  (今天)\"}}</view>\r\n        <view class='week' wx:else>{{item.week.week+\" (\"+item.week.month+\"/\"+item.week.day+\")\"}}</view>\r\n\r\n    <view class='condition' wx:if=\"{{isnight}}\">{{item.cond.txt_n}}</view>\r\n    <view wx:else class='condition'>{{item.cond.txt_d}}</view>\r\n    <view class='hight-temperature'>{{item.tmp.max+\"°\"}}</view>\r\n    <view class='low-temperature'>{{item.tmp.min+\"°\"}}</view>\r\n  </view>\r\n</template>\r\n\r\n\r\nwxss\r\n.template-sevendays {\r\n  width: 100%;\r\n  height: 30px;\r\n  display: flex;\r\n  flex-direction: row;\r\n}\r\n\r\n.week {\r\n  margin-left: 10px;\r\n  flex: 4;\r\n}\r\n\r\n.condition {\r\n  text-align: center;\r\n  flex: 4;\r\n  /* width: 40%; */\r\n}\r\n\r\n.hight-temperature {\r\n  text-align: center;\r\n  flex: 1;\r\n}\r\n\r\n.low-temperature {\r\n  text-align: center;\r\n  flex: 1;\r\n}\r\n复制代码3.数据交互部分：原理：使用腾讯地图api获取当前位置经纬度，通过经纬度调用腾讯的逆地理编码函数获取当前位置信息，然后再通过当前位置获取当前的天气信息。解析天气信息数据，完成页面和数据的交互绑定。 （1）数据解析// 解析天气信息函数 构建数据赋值\r\n  analysisData: function(weather) {\r\n    var that = this;\r\n    var str = JSON.stringify(weather);\r\n    var hourly_forecast = [];\r\n    hourly_forecast.push({\r\n      date: \"现在\",\r\n      cond: weather.now.cond,\r\n      tmp: weather.now.tmp\r\n    });\r\n    // 24小时 数组\r\n    for (var i = 0; i < weather.hourly_forecast.length; i++) {\r\n      var hourDic = weather.hourly_forecast[i];\r\n      hourDic.date = hourDic.date.substr(11, 5);\r\n      hourly_forecast.push(hourDic);\r\n    }\r\n\r\n    // 7天天气 数组\r\n    var daily_forecast = [];\r\n    // 使用forEach遍历\r\n    weather.daily_forecast.forEach(function (dailyDic) {\r\n      dailyDic.week = util.dateLater(dailyDic.date, 0);\r\n      daily_forecast.push(dailyDic);\r\n    });\r\n \r\n    // 生活指数数组 按照指定顺序排列\r\n    var suggestion = [];\r\n    var comf = weather.suggestion.comf;\r\n    comf.title = \"舒适度\";\r\n    comf.id = 0;\r\n    suggestion.push(comf);\r\n\r\n    var drsg = weather.suggestion.drsg;\r\n    drsg.title = \"穿衣\";\r\n    drsg.id = 1;\r\n    suggestion.push(drsg);\r\n\r\n    var flu = weather.suggestion.flu;\r\n    flu.title = \"感冒\";\r\n    flu.id = 2;\r\n    suggestion.push(flu);\r\n\r\n    var sport = weather.suggestion.sport;\r\n    sport.title = \"运动\";\r\n    sport.id = 3;\r\n    suggestion.push(sport);\r\n\r\n    var trav = weather.suggestion.trav;\r\n    trav.title = \"旅游\";\r\n    trav.id = 4;\r\n    suggestion.push(trav);\r\n\r\n    var uv = weather.suggestion.uv;\r\n    uv.title = \"紫外线强度\";\r\n    uv.id = 5;\r\n    suggestion.push(uv);\r\n\r\n    var cw = weather.suggestion.cw;\r\n    cw.title = \"洗车\";\r\n    cw.id = 6;\r\n    suggestion.push(cw);\r\n\r\n    var air = weather.suggestion.air;\r\n    air.title = \"污染扩散\";\r\n    air.id = 7;\r\n    suggestion.push(air);\r\n    this.setData({\r\n      weather: {\r\n        hourly_forecast: hourly_forecast,\r\n        daily_forecast: daily_forecast,\r\n        aqi: weather.aqi.city,\r\n        now: weather.now,\r\n        astro: daily_forecast[0].astro,\r\n        suggestion: suggestion\r\n      },\r\n      updateTimeHidden: false,\r\n      updateTime: weather.basic.update.loc\r\n    });\r\n\r\n    // 2秒后隐藏更新时间\r\n    var timer = setTimeout(function() {\r\n      that.setData({\r\n        updateTimeHidden: true\r\n      });\r\n    }, 2000);\r\n  },\r\n复制代码（2）数据绑定，以7天天气为例<view class='sevendays-bg'>\r\n      <view class='sevendays-title'>7天天气预报</view>\r\n      <scroll-view>\r\n        <block wx:key=\"daily_forecast\" wx:for=\"{{weather.daily_forecast}}\" wx:for-item=\"item\" wx:for-index=\"index\">\r\n          <view class='sevendays-templatebg'>\r\n            <template is=\"sevenDays\" data=\"{{item: item, isnight: isNight, index: index}}\" />\r\n          </view>\r\n        </block>\r\n      </scroll-view>\r\n    </view>\r\n复制代码至此，日播天气就结束了。一周学会小程序，怎么不可能？学的很精通那是有难度的，入门还是可以的，我就是一周就写了这个小程序的。"}
{"title": "微信小程序·云开发初体验 ", "author": "Rolan", "pub_time": "2018-11-12 00:31", "article_content": "微信小程序·云开发初体验简介：2018年9月份微信正式推出云开发平台，一石激起千层浪，什么是云开发？是不是以后就可以和后端研发说拜拜了？是不是未来前端研发就可以一统微信小程序了？想想还有点小激动了呢！2018年9月份微信正式推出云开发平台，一石激起千层浪，什么是云开发？是不是以后就可以和后端研发说拜拜了？是不是未来前端研发就可以一统微信小程序了？啥？我膨胀了吗？我骄傲了吗？我嘴角流口水了吗？只是想想还有点小激动了呢！好了，好了，后端童鞋可以放下手里的刀了，这个微信小程序的云开发暂时还无法全面取代你们在微信端的地位，但是！不得不说给前端开发带来了很大的便利，值得前端童鞋们一探究竟。1.什么是云开发？云开发为开发者提供完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。也就是说，对于一些小程序，我们无需后端搭建服务器，提供数据库，整个项目完全可以由前端开发者来完成。这意味着前端开发者无需考虑如何构建服务器之类的工作，即可完成整个微信小程序了。2.云开发功能简介好了，叨叨了这么多，想必你已经迫不及待的要揭开它神秘的面纱了。2.1 云开发基本步骤（1）俗话说“巧妇难为无米之炊”，首先要做的就是下载微信提供的最新开发工具，网址为您奉上：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html?t=18101520 （2）在启动界面，选择”建立云开发快速启动模板”，就可以看到下面的开发平台了：其中，系统默认会建立两个文件夹，分别为：– cloudfunctions 默认存放云函数的文件夹– miniprogram 默认存放业务代码的文件夹如果你觉得，这是神马名字，能不能起个高大上的名字。只有私人订制版的名字，才能衬托我无与伦比的高贵气质~比如说：李狗蛋和王钢柱…敲黑板，注意了，当你修改名字后，一定要记得在 project.config.json 中对应修改云函数和程序的路径,否则小程序无法找到对应的入口文件而报错。2.2 云开发切换环境细心的童鞋可能发现，云函数的文件夹后面带有一个 cloud-demo 的小尾巴，这个是当前云函数使用的云环境。云环境有啥用处呢？由于云开发是实时上线更新的，假如你已经上线了一版小程序，在本地开发的时候，实时修改该环境下的数据库和云函数逻辑，那么使用同一环境的线上小程序也会变来变去，再想想用户一脸茫然的看着自已动来动去的小程序界面，很调皮是不是？好在，微信给每位开发者提供了两套环境：环境之大，一次用不下，一个上线，一个开发！每套环境的数据库/云函数都是相互独立的，只有在测试环境检查的没有问题了，再部署到线上。那么问题又来了，如何切换使用的云环境呢？右击云函数文件夹，如果之前切换过环境的话，会出现两个候选环境，如果之前没有切换过，则选择更多设置，如下图所示在新打开的界面中选择当前要使用的环境即可。好了，环境准备好后，让我们开始愉快的（踩坑）开发之旅吧！3.云开发的三大”拦路虎”曾经有位名人“沃·滋基硕德” 这样教导我们：“你在奔向成功的路上总是会遇到困难，不要伤心，慢慢就习惯了！”云开发包括三大主要内容：云函数，数据库，存储管理，相当于拦路虎一样，横跨在我们面前，在使用过程中需要注意哪些事项呢？让我娓娓道来：3.1 大虎：云函数何为云函数？云函数是一段运行在云端的代码，无需管理服务器，在开发工具内编写、一键上传部署即可运行后端代码。我们可以在代码区域的云函数文件夹，右击新建 node.js 函数，之后平台会提示我们是否安装依赖：如需在云函数中操作数据库、管理云文件、调用其他云函数等操作，可使用官方提供的 npm 包 wx-server-sdk 进行操作。值得注意的是，一旦忘记安装依赖，在 mac 系统下，则没有挽回的入口，不是说好了，浪子回头金不换吗？连个后悔机会也不给人家！！还好我们可以曲线救国，在本地文件中，找到该云函数的文件夹，打开 CMD 终端执行下面的命令：npm install --save wx-server-sdk@latest\r\n \r\n \r\n然后再上传部署该云函数，这样就可以引入依赖了。云函数的使用方式如下：exports.main = (event, context) => {\r\nlet { userInfo, a, b} = event\r\nlet { openId, appId} = userInfo // 这里获取到的 openId 和 appId 是可信的\r\nlet sum = a + b\r\nreturn {\r\nopenId,\r\nappId,\r\nsum\r\n}\r\n}\r\n \r\n其中 event 包含了小程序端调用该函数时传过来的参数，同时还包含了用户登录态 openId 和小程序 appId 信息；context 对象包含了此处调用的调用信息和运行状态，可以用它来了解服务运行的情况。这里比较重要的是 openId ，客户端的每个用户都会有自己的 openId ，服务端可以根据这些 openId 来区分用户。然而，当我们满心欢喜的想跑通上面获取 openId 的示例时，却发现报错了：看错误提示是没有获取到 login 这个云函数，但是打开云开发平台，该云函数明明存在的呀？而且这是官方给的的示例，怎么会出错呢？这时，停下来来思索一下，因为有两套开发环境，是不是还需要定义小程序端调用的云环境呢？想到这里茅塞顿开，于是在 app.js 文件下初始化云函数的时候，定义好要使用的云开发环境：wx.cloud.init({\r\nenv: '使用云开发环境的ID',\r\ntraceUser: true\r\n}\r\n \r\n类似的，云函数在初始化时，同样需要对云开发环境进行定义，// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init({\r\nenv: 'demo-id'\r\n})\r\nconst db = cloud.database();\r\nexports.main = async (event, context) => {\r\nreturn db.collection('todos').get()\r\n}\r\n \r\n这样，上面的云函数就是调用了 ‘demo-id’ 云环境下的 todos 集合的数据了。注意的是，该调用的环境可以和当前开发环境不是同一套环境。3.2 二虎：数据库数据库的界面如下图所示：改变数据库有四种方法：– 1.云开发平台添加记录；– 2.云开发平台导入数据；– 3.微信小程序端改变数据库；– 4.云函数端改变数据库；正所谓“尺有所短，寸有所长。物有所不足，智有所不明”。这四种方法，各有优点：（1）云开发平台添加记录，简单方便，不足之处在于，每条数据都要逐条输入，不方便；（2）云开发平台导入数据，可以同时导入大量的数据，快速。注意的是，导入的json数据和常规的 json 格式不同，按照对象分割，并且对象之间不存在逗号，如下所示：{\r\n\"_id\":\"todo-identifiant-aleatoire\",\r\n\"_openid\":\"user-open-id\",\r\n\"description\":\"learn cloud database\",\r\n\"done\":false\r\n}\r\n{\r\n\"_id\":\"todo-identifiant-aleatoire-2\",\r\n\"_openid\":\"user-open-id\",\r\n\"description\":\"write a novel\",\r\n\"done\":false\r\n}\r\n \r\n（3）小程序端改变数据库，往往携带业务逻辑，但是受到各种权限的限制。小程序端新增的数据，都会默认带有 _id（用以唯一标志一条记录） 和 openid（用以标志记录的创建者，即小程序的用户）。这样，根据数据库中保存的 openid ，可以区分不同的用户。反过来，某位用户也无法操作其他用户的数据，从而保证了数据的稳定性。（4）云函数端改变数据库，和小程序端类似的，云函数提供函数名称 name，供小程序调用。下面就是小程序端调用云函数的方法：wx.cloud.callFunction({\r\nname: ‘云函数名字',\r\ndata: {\r\n//传入云函数的参数\r\n},\r\nsuccess: res => {\r\n//调用成功后的函数\r\n},\r\nfail: err => {\r\n//调用失败后的函数\r\n}\r\n})\r\n \r\n可以看出，云函数也可以带有业务逻辑，不同于小程序端对数据库的操作，云函数是运行在服务端的，具有至高无上的权利—— 弃 openid 如敝履，置权限于不顾，随心所欲的对数据库进行增！删！改！查！综上所述，我们可以使用在云开发平台的导入功能，初始化 json 数据，利用云开发平台的添加修改功能，对数据进行细节的调整，之后使用微信小程序端操作数据库，向数据库中增加数据，可以自动引入 openid 来区分用户数据，最后如果想获得更大的权利，就使用云函数对数据库进行操作，再把调用的权限抛给小程序端。3.3 三虎：存储管理云开发平台上最后一位拦路虎是云存储管理，它不吵不闹，来者不拒的接收着要保存的数据。其界面如下图所示从上图看出，通过“上传文件”按钮，可以在云开发控制台上传文件。此外，可以通过微信小程序的 uploadFile 函数，上传文件。谨记，一定要使用新建文件夹来规范划分存储的数据，否则后期大量的存储文件将是你挥之不去的噩梦。图中 fileId 即是文件的存储地址，无论是从云开发平台还是从客户端上传的文件，系统都会自动分配给每个文件对应的 fileId。当然也可以通过微信小程序的 uploadFile 函数，上传文件。下面的云函数代码就使用了存储管理中保存的文件，返回给小程序端调用：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\ncloud.init()\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\nconst fileList = [\r\n'cloud://cloud-demo-c5b56e.636c-cloud-demo-c5b56e/swiperImg/img_1.jpg',\r\n'cloud://cloud-demo-c5b56e.636c-cloud-demo-c5b56e/swiperImg/img_2.jpg',\r\n'cloud://cloud-demo-c5b56e.636c-cloud-demo-c5b56e/swiperImg/img_3.jpg'\r\n]\r\nconst result = await cloud.getTempFileURL({\r\nfileList: fileList,\r\n})\r\nreturn result.fileList\r\n}\r\n \r\n上面解释了文件在云端保存的地址，那么在小程序端把文件上传到云存储中的地址又是什么呢？假如在小程序端，实现本地的图片上传到云服务器的功能，首先要获取本地文件的临时路径：wx.chooseImage({\r\n//选择手机图片\r\nchooseEvt(){\r\nlet that = this;\r\nwx.chooseImage({\r\ncount: 1,\r\nsizeType: ['original', 'compressed'],\r\nsourceType: ['album', 'camera'],\r\nsuccess(res) {\r\n// tempFilePath可以作为img标签的src属性显示图片\r\nconst tempFilePaths = res.tempFilePaths[0];\r\nthat.setData({\r\nchooseImg: tempFilePaths\r\n})\r\nthat.uploadImg(tempFilePaths);\r\n}\r\n})\r\n}\r\n \r\n下面是上传到服务器的代码：uploadImg(tempFilePaths){\r\nlet str = tempFilePaths;\r\nlet name = str.split('.').reverse()[1] +'.'+str.split('.').reverse()[0];\r\nlet names = name.split('//')[1];\r\nlet that = this;\r\nwx.cloud.uploadFile({\r\ncloudPath: 'swiperImg/'+names,\r\nfilePath: str, // 小程序临时文件路径\r\nsuccess: res => {\r\nthat.setData({\r\nimageId: res.fileID\r\n})\r\n},\r\nfail: err => {\r\nconsole.log(err)\r\n}\r\n})\r\n}\r\n \r\n其中 wx.cloud.uploadFile 带有的参数 cloudPath 就是上传到服务器的存储地址。既然上面示例中已经给出了结果，我也就不卖关子了，cloudPath 使用的是相对地址，而不是存储地址 “cloud://cloud-demo-c5b56e.636c-cloud-demo-c5b56e/swiperImg/”。另外上传文件的名字为了避免自己定义，使用了上传文件本身的名字。但是！要注意的是， 手机端和电脑端上传文件的路径是不一样的， 我们来看一下，在电脑端上传图片，得到的文件临时地址 tempFilePaths 是\"http://tmp/wx81c95cafc368ba2d.o6zAJsxvC5wiHIIVQOpRPFVOADDM.NLBDb9oLxX1D1f412643685c68c106d42e1757f77691.png\"\r\n \r\n而手机端得到的 tempFilePaths 则是：\"wxfile://tmp_wx81c95cafc368ba2do6zAJsxvC5wiHIIVQOpRPFVOADDMNLBDb9oLxX1D1f412643685c68c106d42e1757f77691.png\"\r\n \r\n可以看出，除了文件头不一样外，手机端得到的地址并没有中间的 “·”，假如像上面的代码一样，按照 “·” 进行分割地址，则手机端得到的 name 就会带有 wxfile:// ，这样保存到云端存储的时候就会一直提示 cloudPath 路径不对，但是在电脑端调试的时候，由于返回的图片临时路径带有多个 “·”， 就不会出现这问题，话说，第一次遇到这个问题的时候，一度怀疑是不是云函数还需要走什么上线流程，才能在手机端看到效果呢。4.说说心里话微信云开发功能，给前端带来独立开发微信小程序的能力。一经发布，便引起广大开发者的关注。由于推出的不久，在开发过程中还有些问题无法找到类似的解答，只能不断的翻阅官方文档和调试。当然还有官方提供的论坛[1]，只是如果着急想要得到解答，还是要靠自己。好了，说了这么多，其实官方文档中的 API，大多都没有介绍。文末给出了官方文档的链接[2]，里面说的很是详细了。 本文旨在使用云开发过程中，总结分享遇到的哪些问题，抛砖引玉，期待各位走过路过的童鞋留言，说一说你在使用微信小程序中的心得。最后，欢迎各位搜索“全站探索”公众号，我们是一群喜欢技术，钻研技术的人，每周都会推送精美的文章，期待您的关注！扩展阅读[1] 微信小程序官方论坛https://developers.weixin.qq.com/community/develop?idescene=2[2] 微信小程序云开发文档https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html文章来源于 全栈探索 微信公众号，"}
{"title": "两种方案开发小程序动画 ", "author": "Rolan", "pub_time": "2018-11-12 00:32", "article_content": "在普通的网页开发中，动画效果可以通过css3来实现大部分需求，在小程序开发中同样可以使用 css3 ，同时也可以通过 api 方式来实现。指路： 小程序animatiom动画APIAPI解读小程序中，通过调用 api 来创建动画，需要先创建一个实例对象。这个对象通过 wx.createAnimation 返回, animation 的一系列属性都基于这个实例对象。创建这个对象let animation = wx.createAnimation({\r\n        duration: 2000,\r\n        delay: 0,\r\n        timingFunction: \"linear\",\r\n    });\r\n复制代码这个 animation 就是通过 wx.createAnimation 之后返回的实例。在创建过程中，可以给这个实例添加一些属性，如以上代码所示，等同于 css3 中 animation:$name 2s linear 的写法。添加动效实例创建完成之后，基于该实例，添加需要的动态效果，动态类型可以查阅文档得知，以最常见的移动，旋转为例：animation.translate($width, 0).rotate($deg);\r\n复制代码结束动画.step() 表示一组动画的结束animation.step();\r\n复制代码导出动画动画效果添加完成了，如何给想要的dom添加动效呢。这里需要用到 .export() 导出动画队列，赋值给某个dom对象。this.setData({ moveOne: animation.export() })\r\n复制代码<view  animation=\"{{moveOne}}\"></view>\r\n复制代码例子以下将通过2组动画，来对比一下 css3 与 api 实现方式的不同。一、模块移动动画动画效果：下图有两组动画，分别为 api 方式（上）与 css3 方式（下）完成的效果，点击move按钮，动画启动。代码实现以下分别为 css3 与 api 的核心代码：css3：<!-- wxml -->\r\n    <view class='border'>\r\n        <view class='css-block {{isMove && \"one\"}}'></view>\r\n        <view class='css-block {{isMove && \"two\"}}'></view>\r\n        <view class='css-block {{isMove && \"three\"}}'></view>\r\n        <view class='css-block {{isMove && \"four\"}}'></view>\r\n    </view>\r\n复制代码// scss\r\n    @mixin movePublic($oldLeft,$oldTop,$left,$top) {\r\n        from {\r\n          transform:translate($oldLeft,$oldTop);\r\n        }\r\n        to {\r\n          transform:translate($left,$top);\r\n        }\r\n    }\r\n    \r\n    @mixin blockStyle($color,$name) {\r\n        background: $color;\r\n        animation:$name 2s linear infinite alternate;\r\n    }\r\n    .one {\r\n        @include blockStyle(lightsalmon,onemove);\r\n    }\r\n    \r\n    @keyframes onemove {\r\n        @include movePublic(50rpx,-25rpx,-150rpx,0rpx);\r\n    }\r\n    \r\n    .two {\r\n        @include blockStyle(lightblue,twomove);\r\n    }\r\n    \r\n    @keyframes twomove {\r\n        @include movePublic(0rpx,25rpx,-50rpx,0rpx);\r\n    }\r\n    \r\n    .three {\r\n        @include blockStyle(lightgray,threemove);\r\n    }\r\n    \r\n    @keyframes threemove {\r\n        @include movePublic(0rpx,25rpx,50rpx,0rpx);\r\n    }\r\n    \r\n    .four {\r\n        @include blockStyle(grey,fourmove);\r\n    }\r\n    \r\n    @keyframes fourmove {\r\n        @include movePublic(-50rpx,-25rpx,150rpx,0rpx);\r\n    }\r\n复制代码// js\r\n    moveFunction(){\r\n        this.setData({\r\n            isMove: true\r\n        })\r\n    }\r\n复制代码css3 中通过动态改变 class 类名来达到动画的效果，如上代码通过 one 、 two 、 three 、 four 来分别控制移动的距离，通过sass可以避免代码过于冗余的问题。 （纠结如何在小程序中使用 sass 的童鞋请看这里哦： wechat-mina-template ）api：moveClick(){\r\n        this.move(-75,-12.5,25,'moveOne');\r\n        this.move(-25,12.5, 0,'moveTwo');\r\n        this.move(25, 12.5,0,'moveThree');\r\n        this.move(75, -12.5,-25,'moveFour');\r\n        this.moveFunction(); // 该事件触发css3模块进行移动\r\n    },\r\n\r\n    // 模块移动方法\r\n    move: function (w,h,m,ele) {\r\n        let self = this;\r\n        let moveFunc = function () {\r\n        let animation = wx.createAnimation({\r\n            duration: 2000,\r\n            delay: 0,\r\n            timingFunction: \"linear\",\r\n        });\r\n    \r\n        animation.translate(w, 0).step()\r\n        self.setData({ [ele]: animation.export() })\r\n        let timeout = setTimeout(function () {\r\n            animation.translate(m, h).step();\r\n            self.setData({\r\n                // [ele] 代表需要绑定动画的数组对象\r\n                [ele]: animation.export()\r\n            })\r\n          }.bind(this), 2000)\r\n        }\r\n        moveFunc();\r\n        let interval = setInterval(moveFunc,4000)\r\n    }\r\n复制代码效果图可见，模块之间都是简单的移动，可以将他们的运动变化写成一个公共的事件，通过向事件传值，来移动到不同的位置。其中的参数 w,h,m,ele 分别表示发散水平方向移动的距离、聚拢时垂直方向、水平方向的距离以及需要修改 animationData 的对象。通过这种方法产生的动画，无法按照原有轨迹收回，所以在事件之后设置了定时器，定义在执行动画2s之后，执行另一个动画。同时 动画只能执行一次 ，如果需要循环的动效，要在外层包裹一个重复执行的定时器到。查看源码，发现 api 方式是通过 js 插入并改变内联样式来达到动画效果，下面这张动图可以清晰地看出样式变化。打印出赋值的 animationData ， animates 中存放了动画事件的类型及参数； options 中存放的是此次动画的配置选项， transition 中存放的是 wx.createAnimation 调用时的配置， transformOrigin 是默认配置，意为以对象的中心为起点开始执行动画，也可在 wx.createAnimation时进行配置。二、音乐播放动画上面的模块移动动画不涉及逻辑交互，因此新尝试了一个音乐播放动画，该动画需要实现暂停、继续的效果。动画效果：两组不同的动画效果对比，分别为 api （上）实现与 css3 实现（下）：代码实现以下分别是 css3 实现与 api 实现的核心代码：css3：<!-- wxml -->\r\n    <view class='music musicTwo musicRotate {{playTwo ? \" \": \"musicPaused\"}} ' bindtap='playTwo'>\r\n        <text class=\"iconfont has-music\" wx:if=\"{{playTwo}}\"></text>\r\n        <text class=\"iconfont no-music\" wx:if=\"{{!playTwo}}\"></text>\r\n    </view>\r\n复制代码// scss\r\n    .musicRotate{\r\n        animation: rotate 3s linear infinite;\r\n    }\r\n    \r\n    @keyframes rotate{\r\n        from{\r\n            transform: rotate(0deg)\r\n        }\r\n        to{\r\n            transform: rotate(359deg)\r\n        }\r\n    }\r\n    \r\n    .musicPaused{\r\n        animation-play-state: paused;\r\n    }\r\n复制代码// js\r\n    playTwo(){\r\n        this.setData({\r\n            playTwo: !this.data.playTwo\r\n        },()=>{\r\n            let back = this.data.backgroundAudioManager;\r\n            if(this.data.playTwo){\r\n                back.play();\r\n            } else {\r\n                back.pause();\r\n            }\r\n        })\r\n    }\r\n复制代码通过 playTwo 这个属性来判断是否暂停，并控制 css 类的添加与删除。当为 false 时，添加 .musicPaused 类，动画暂停。api:<!-- wxml -->\r\n    <view class='music' bindtap='play'  animation=\"{{play && musicRotate}}\">\r\n        <text class=\"iconfont has-music\" wx:if=\"{{play}}\"></text>\r\n        <text class=\"iconfont no-music\" wx:if=\"{{!play}}\"></text>\r\n    </view>\r\n复制代码// js\r\n    play(){\r\n        this.setData({\r\n            play: !this.data.play\r\n        },()=>{\r\n            let back = this.data.backgroundAudioManager;\r\n            if (!this.data.play) {\r\n                back.pause();\r\n               // 跨事件清除定时器\r\n               clearInterval(this.data.rotateInterval);\r\n            } else {\r\n                back.play();\r\n                // 继续旋转，this.data.i记录了旋转的程度\r\n                this.musicRotate(this.data.i);\r\n            }\r\n        })\r\n    },\r\n    musicRotate(i){\r\n        let self = this;\r\n        let rotateFuc = function(){\r\n            i++;\r\n            self.setData({\r\n                i:i++\r\n            });\r\n            let animation = wx.createAnimation({\r\n                duration: 1000,\r\n                delay: 0,\r\n                timingFunction: \"linear\",\r\n            });\r\n            animation.rotate(30*(i++)).step()\r\n            self.setData({ musicRotate: animation.export() });\r\n        }\r\n        rotateFuc();\r\n        let rotateInterval = setInterval(\r\n            rotateFuc,1000\r\n        );\r\n        // 全局定时事件\r\n        this.setData({\r\n            rotateInterval: rotateInterval\r\n        })\r\n    }\r\n复制代码通过 api 实现的方式是通过移除 animationData 来控制动画，同时暂停动画也需要清除定时器，由于清除定时器需要跨事件进行操作，所以定了一个全局方法 rotateInterval 。api 方式定义了旋转的角度，但旋转到该角度之后便会停止，如果需要实现重复旋转效果，需要通过定时器来完成。因此定义了变量i，定时器每执行一次便加1，相当于每1s旋转30°，对 animation.rotate() 中的度数动态赋值。暂停之后继续动画,需要从原有角度继续旋转，因此变量i需要为全局变量。代码变化下图可以看出， api 方式旋转是通过不断累加角度来完成，而非 css3 中循环执行。对比通过上述两个小例子对比，无论是便捷度还是代码量，通过 css3 来实现动画效果相对来说是更好的选择。 api 方式存在较多局限性：动画只能执行一次，循环效果需要通过定时器完成。无法按照原有轨迹返回，需要返回必须定义定时器。频繁借助定时器在性能上有硬伤。综合以上，推荐通过 css3 来完成动画效果。"}
{"title": "微信小程序组件封装 ", "author": "Rolan", "pub_time": "2018-11-13 00:36", "article_content": "概述自己封装的一个比较简单微信弹窗小组件，主要就是教会大家对微信小组件的用法和理解，因为微信小程序对组件介绍特别少，所以我就把自己的理解分享给大家。一前言相信大家在开发小程序时会遇到某个功能多次使用的情况，比如弹出框。这个时候大家首先想到的是组件化开发，就是把弹出框封装成一个组件，然后哪里使用哪里就调用，对，看来大家都是有思路的人，但是要怎样实现呢。可能你会去看官方文档，但是微信的官方文档也是说的不太清楚，所以写起来也是非常痛苦。今天就和大家一起开发微信组件，坐稳了，老司机要开车了。二具体实现我们先实现个简单的弹窗组件，详情图如下：1.新建component文件夹存放我们的组件，里边存放的就是我们所用的组件，我们今天要做的事弹出框，新建文件夹popup存放我们的组件模板，点击右键选择新建component，就会自动生成组件的模板wxss、wxml、json、js，如图2.我们可以写一些组件样式和布局，跟页面写法类似，我就不多说了，直接把代码贴出 :popup.wxml<view class=\"wx-popup\" hidden=\"{{flag}}\">  <view class='popup-container'>    <view class=\"wx-popup-title\">{{title}}</view>    <view class=\"wx-popup-con\">{{content}}</view>    <view class=\"wx-popup-btn\">      <text class=\"btn-no\" bindtap='_error'>{{btn_no}}</text>      <text class=\"btn-ok\" bindtap='_success'>{{btn_ok}}</text>    </view>  </view></view>复制代码popup.wxss/* component/popup.wxss */.wx-popup {  position: absolute;  left: 0;  top: 0;   width: 100%;  height: 100%;  background: rgba(0, 0, 0, .5);} .popup-container {  position: absolute;  left: 50%;  top: 50%;   width: 80%;  max-width: 600rpx;  border: 2rpx solid #ccc;  border-radius: 10rpx;  box-sizing: bordre-box;  transform: translate(-50%, -50%);   overflow: hidden;  background: #fff;} .wx-popup-title {  width: 100%;  padding: 20rpx;  text-align: center;  font-size: 40rpx;  border-bottom: 2rpx solid red;} .wx-popup-con {  margin: 60rpx 10rpx;  text-align: center;} .wx-popup-btn {  display: flex;  justify-content: space-around;  margin-bottom: 40rpx;} .wx-popup-btn text {  display: flex;  align-items: center;  justify-content: center;  width: 30%;  height: 88rpx;  border: 2rpx solid #ccc;  border-radius: 88rpx;}复制代码样式和布局和布局已经写好了接下来要介绍的就是Component构造器Component构造器可用于定义组件，调用Component构造器时可以指定组件的属性、数据、方法等。定义段类型是否必填描述propertiesObject Map否组件的对外属性，是属性名到属性设置的映射表，属性设置中可包含三个字段， type 表示属性类型、 value 表示属性初始值、 observer 表示属性值被更改时的响应函数dataObject否组件的内部数据，和 properties 一同用于组件的模版渲染methodsObject否组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用，参见组件事件behaviorsString Array否类似于mixins和traits的组件间代码复用机制，参见behaviorscreatedFunction否组件生命周期函数，在组件实例进入页面节点树时执行，注意此时不能调用 setDataattachedFunction否组件生命周期函数，在组件实例进入页面节点树时执行readyFunction否组件生命周期函数，在组件布局完成后执行，此时可以获取节点信息（使用SelectorQuery ）movedFunction否组件生命周期函数，在组件实例被移动到节点树另一个位置时执行detachedFunction否组件生命周期函数，在组件实例被从页面节点树移除时执行relationsObject否组件间关系定义，参见组件间关系externalClassesString Array否组件接受的外部样式类，参见外部样式类optionsObject Map否一些组件选项，请参见文档其他部分的说明Tips:Component 构造器构造的组件也可以作为页面使用。使用 this.data 可以获取内部数据和属性值，但不要直接修改它们，应使用 setData 修改。生命周期函数无法在组件方法中通过 this 访问到。属性名应避免以 data 开头，即不要命名成 dataXyz 这样的形式，因为在 WXML 中， data-xyz=\"\" 会被作为节点 dataset 来处理，而不是组件属性。在一个组件的定义和使用时，组件的属性名和data字段相互间都不能冲突（尽管它们位于不同的定义段中）。component介绍完后就是最为关键的js了popup.js:Component({  options: {    multipleSlots: true // 在组件定义时的选项中启用多slot支持  },  /**   * 组件的属性列表   */  properties: {    title: {            // 属性名      type: String,     // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）      value: '标题'     // 属性初始值（可选），如果未指定则会根据类型选择一个    },    // 弹窗内容    content: {      type: String,      value: '内容'    },    // 弹窗取消按钮文字    btn_no: {      type: String,      value: '取消'    },    // 弹窗确认按钮文字    btn_ok: {      type: String,      value: '确定'    }   },   /**   * 组件的初始数据   */  data: {    flag: true,  },   /**   * 组件的方法列表   */  methods: {    //隐藏弹框    hidePopup: function () {      this.setData({        flag: !this.data.flag      })    },    //展示弹框    showPopup () {      this.setData({        flag: !this.data.flag      })    },    /*    * 内部私有方法建议以下划线开头    * triggerEvent 用于触发事件    */    _error () {      //触发取消回调      this.triggerEvent(\"error\")    },    _success () {      //触发成功回调      this.triggerEvent(\"success\");    }  }})复制代码上边会用到一个triggerEvent下面我们就来介绍下：自定义组件触发事件时，需要使用 triggerEvent 方法，指定事件名、detail对象和事件选项。触发事件的选项包括：选项名类型是否必填默认值描述bubblesBoolean否false事件是否冒泡composedBoolean否false事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部capturePhaseBoolean否false事件是否拥有捕获阶段现在一个弹窗的组件就封装好了接下来就是调用了。调用的时候需要在调用的页面新建一个json文件，json文件里需要配置usingComponents就是引用组件，看代码：index.json{  \"usingComponents\": {    \"popup\": \"/component/popup/popup\"  }}复制代码现在基本上完成了需要的就是在首页引用了。<!--index.wxml--><view class=\"container\">  <view class=\"userinfo\">    <button bindtap=\"showPopup\"> 点我 </button>  </view>  <popup id='popup'       title='小组件'       content='学会了吗'       btn_no='没有'       btn_ok='学会了'      bind:error=\"_error\"        bind:success=\"_success\">  </popup></view>复制代码配置index.js加上点击事件//index.js//获取应用实例const app = getApp() Page({  onReady: function () {    //获得popup组件    this.popup = this.selectComponent(\"#popup\");  },   showPopup() {    this.popup.showPopup();  },   //取消事件  _error() {    console.log('你点击了取消');    this.popup.hidePopup();  },  //确认事件  _success() {    console.log('你点击了确定');    this.popup.hidePopup();  }})复制代码一个弹窗组件就完成了，看下效果："}
{"title": "使用高德地图微信小程序SDK开发案例-输入提示（附源码） ", "author": "Rolan", "pub_time": "2018-11-13 00:40", "article_content": "闲来无事写一篇使用高德地图的微信小程序SDK开发应用的实例。接下来先看需求：我们要做的是，根据用户输入的关键词，给出相应的提示信息，列表中显示地方的名称，地方的详细地址以及对应的经纬度坐标。当然在UI上我们尽量做到理想的视觉与较好的用户体验。最终的效果我们希望是像这样的，如下图：有了目标，我们直接代码撸起来～我们先从高德开放平台获取微信小程序SDK以及开发需要的key。完成一些基础工作后我们先规划下页面布局。我们需要一个输入框可以让用户输入，和一个存放列表的容器来显示提示信息。<input type=\"text\" value='{{inputVal}}' bindinput='input' placeholder='请输入搜索关键字'></input>好了，我们为它添加1个监听事件，bindinput='input'，来监听用户的键盘输入。接着我们来做存放列表的容器。<view class=\"list\">\r\n    <view class=\"list-item\" wx:for=\"{{searchList}}\" >  \r\n        <view class='title'>{{item.name}}</view>\r\n        <view class='address'>{{item.district}}{{item.address}}</view>\r\n    </view>\r\n</view>在接下去调用高德接口的过程中，我们将会从接口中获得一个数组，我们将这个数组赋值给searchList，因此我们需要给容器内的列表项添加for循环。这样就能达到我们预期的效果。接着我们为输入框绑定的监听事件添加对应的方法  input: function (e) {\r\n      this.setData({\r\n        inputVal: e.detail.value\r\n      })\r\n  }同时将输入的关键字赋值给inputVal，这样我们就能在页面上看到我们输入的文字了。获取到输入的关键字，我们就可以将关键字作为参数传到高德提供的接口中，使其返回数据。我们写一个公共方法，将调用接口方法封装起来。//引入高德微信小程序SDK\r\nvar amapFile = require('amap-wx.js');\r\n\r\n//搜索关键字\r\nkeyword: function (){\r\n    var myAmapFun = new amapFile.AMapWX({key: '高德Key'}),that = this;\r\n    myAmapFun.getInputtips({\r\n        keywords:'关键字',\r\n        location: '',\r\n        success: function (data) {\r\n          if (data && data.tips) {\r\n            //将数据赋值到searchList\r\n            that.setData({searchList: data.tips});\r\n          }  \r\n        }\r\n    });\r\n }到此我们写好了接口逻辑，现在我们将整个流程打通；为了提升用户的使用体验，在用户输入关键字的同时触发搜索，实时返回结果。input: function (e) {\r\n      this.setData({\r\n        inputVal: e.detail.value\r\n      });\r\n      //在监听的方法中添加搜索关键字的方法\r\n     this.keyword(e.detail.value);\r\n  }这样，每当用户输入关键字时就能实时得到返回结果。我们从接口中提取想要的数据，在页面上展示。   <view class=\"list-item\" wx:for=\"{{searchList}}\" > \r\n       <image class=\"icon\" mode=\"widthFix\" src=\"../../images/icon.png\"></image> \r\n       <view class='title'>{{item.name}}</view>\r\n       <view class='address'>{{item.district}}{{item.address}}</view>\r\n   </view>为增强UI效果我们添加一些合理的样式和小图标作为美化。到这里我们基本已经完成了大致的需求。但是细节方面我们也需要注意；比如：当用户尚未输入关键，或者关键字长度为0的时候，列表容器应该处于不显示状态。当然我们还可以在输入框上添加清除输入内容的按钮来提升使用体验。或者在输入框的左侧添加城市选择，获取经纬度后传入封装的keyword()方法，就能根据不同的城市来做搜索。"}
{"title": "微信小程序之购物车和父子组件传值及calc的注意事项 ", "author": "Rolan", "pub_time": "2018-11-13 00:57", "article_content": "1.效果图2.子组件实现要实现图中删除的效果，使用组件的形式更好做点，我当时本想直接在pages里实现，不过结果就是，滑动时，所有的商品都显示了删除按钮，除非用数组将每个商品要移动的距离存储起来，不过这样的话就很麻烦，所以我也是用组件来实现的关于微信组件，可以直接点击链接访问官网查看自定义组件子组件index.wxml<view class=\"commodityItem\" bindtouchstart=\"handleTouchStart\" bindtouchmove=\"handleTouchMove\" style=\"transform:translateX({{-rightSpace}}px)\">\r\n  <view class=\"selectedBtn\" bindtap=\"handleSelect\" data-is-selected=\"{{commodity.isselected}}\">\r\n    <view class=\"noSelected\" wx:if=\"{{commodity.isselected==0}}\"></view>\r\n    <image class=\"selectedImg\" wx:else src=\"/images/selected.png\"></image>\r\n  </view>\r\n  <view class=\"commodityInfo\">\r\n    <view class=\"commodityImg\">\r\n      <image src=\"{{commodity.image}}\"></image>          \r\n    </view>\r\n    <view class=\"commodityTitle\">\r\n      <view class=\"title\">{{commodity.title}}</view>\r\n      <view class=\"standard\">规格：{{commodity.standard?commodity.standard:'无'}}</view>\r\n      <view class=\"count\">\r\n        <view class=\"price\">￥{{commodity.price}}</view>\r\n        <view class=\"commodityNum\">\r\n          <i-input-number value=\"{{selectedNum}}\" min=\"1\" max=\"{{commodity.stock}}\" bindchange=\"numChange\" />\r\n        </view>\r\n      </view>\r\n    </view>\r\n  </view>\r\n  <view class=\"deleteBtn\">\r\n    <image class=\"deleteImg\" src=\"/images/delete.png\"></image>\r\n    <text class=\"deleteText\">删除</text>\r\n  </view>\r\n</view>子组件index.wxss/* 商品 */\r\n.commodityItem{\r\n  display: flex;\r\n  position: relative;\r\n  padding: 10rpx 24rpx 20rpx 30rpx;\r\n  box-sizing: border-box;\r\n  background: #fff;\r\n  transition: all .5s;\r\n}\r\n/* 选择按钮 */\r\n.selectedBtn{\r\n  display: flex;\r\n  align-items: center;\r\n  width: 80rpx;\r\n}\r\n.noSelected{\r\n  width: 46rpx;\r\n  height: 46rpx;\r\n  border-radius: 50%;\r\n  border: 1px solid #ef5225;\r\n}\r\n.selectedBtn .selectedImg{\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n/* 商品信息 */\r\n.commodityInfo{\r\n  display: flex;\r\n  width: calc(100% - 80rpx);\r\n}\r\n.commodityImg{\r\n  margin-right: 18rpx;\r\n  width: 220rpx;\r\n  height: 220rpx;\r\n}\r\n.commodityImg image{\r\n  width: 100%;\r\n  height: 100%;\r\n  vertical-align: middle;  \r\n}\r\n/* 商品title */\r\n.commodityTitle{\r\n  width: calc(100% - 220rpx);\r\n}\r\n.title{\r\n  display: -webkit-box;\r\n  width: 100%;\r\n  height: 70rpx;\r\n  line-height:35rpx;\r\n  font-size: 24rpx;\r\n  font-weight:600;\r\n  overflow: hidden;\r\n  -webkit-line-clamp: 2;\r\n  -webkit-box-orient: vertical;\r\n}\r\n.standard{\r\n  padding-top: 16rpx;\r\n  width: 100%;\r\n  height: 90rpx;\r\n  box-sizing: border-box;\r\n}\r\n.count{\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  width: 100%;\r\n  height: 60rpx;\r\n}\r\n\r\n/* 删除按钮 */\r\n.deleteBtn{\r\n  display: flex;\r\n  position: absolute;\r\n  width: 70px;\r\n  height: 100%;\r\n  top: 0rpx;\r\n  right: -70px;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  background: #ef5225;\r\n}\r\n.deleteImg{\r\n  margin-bottom: 10rpx;\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n  vertical-align: middle;\r\n}\r\n.deleteText{\r\n  color: #fff;\r\n}子组件index.json，这里用了iview中的数字输入框{\r\n  \"component\": true,\r\n  \"usingComponents\": {\r\n    \"i-input-number\": \"/component/iview/input-number/index\"\r\n  }\r\n}子组件index.jsComponent({\r\n\r\n  properties: {\r\n    commodity: Object,\r\n  },\r\n\r\n  data: {\r\n    touchStart: null,\r\n    rightSpace: 0,\r\n    selectedNum: 1,\r\n  },\r\n\r\n  methods: {\r\n    /* 商品是否选中 */\r\n    handleSelect() {\r\n            let selectedNum = this.data.selectedNum;\r\n      let commodity = this.data.commodity;\r\n      if(commodity.isselected == 0) {\r\n        commodity.isselected = 1;\r\n      } else {\r\n        commodity.isselected = 0;\r\n      }\r\n            this.triggerEvent('handleselect', { commodity, selectedNum})\r\n    },\r\n    /* 处理触摸滑动开始 */\r\n    handleTouchStart(e) {\r\n      /* 记录触摸滑动初始位置 */\r\n      let touchStart = e.changedTouches[0].clientX;\r\n      this.setData({\r\n        touchStart\r\n      })\r\n    },\r\n    /* 处理触摸滑动 */\r\n    handleTouchMove(e) {\r\n      console.log(e)\r\n      let moveSpace = e.changedTouches[0].clientX;\r\n      let touchStart = this.data.touchStart;\r\n      if (touchStart != null) {\r\n        if (moveSpace - touchStart > 70) {\r\n          this.setData({\r\n            touchStart: null,\r\n            rightSpace: 0\r\n          })\r\n        }\r\n        else if (moveSpace - touchStart < -70) {\r\n          this.setData({\r\n            touchStart: null,\r\n            rightSpace: 70\r\n          })\r\n        }\r\n      }\r\n    },\r\n    numChange(e) {\r\n        let selectedNum = e.detail.value;\r\n        let commodity = this.data.commodity;\r\n        this.setData({\r\n            selectedNum\r\n        })\r\n        this.triggerEvent('handleselect', { commodity, selectedNum})\r\n    }\r\n  }\r\n})3.父组件实现父组件index.wxml，这里用的是假数据，所以操作上会有一些是联调时不必要的操作<view class=\"cart\">\r\n  <view class=\"item\" wx:for=\"{{cartList}}\" wx:key=\"{{items.shopid}}\" wx:for-item=\"items\">\r\n    <view class=\"storeInfo\">\r\n      <image class=\"avatar\" src=\"{{items.logo}}\"></image>\r\n      <view class=\"storeName\">{{items.shopname}}</view>\r\n    </view>\r\n    <view class=\"discount\">满￥100包邮，满10件包邮</view>\r\n    <view class=\"commodity\" wx:for=\"{{items.commodity}}\" wx:key=\"{{item.id}}\">\r\n      <cart-item commodity=\"{{item}}\" bind:handleselect=\"handleSelect\" />\r\n    </view>\r\n  </view>\r\n    <view class=\"count\">\r\n        <view class=\"selectAll\" bindtap=\"handleSelectAll\">\r\n            <view class=\"noSelected\" wx:if=\"{{!isSelectedAll}}\"></view>\r\n        <image class=\"selectedImg\" wx:else src=\"/images/selected.png\"></image>\r\n            <text class=\"selectAllText\">全选</text>\r\n        </view>\r\n        <view class=\"countPrice\">\r\n      <text>合计:</text>\r\n      <text>￥{{countPrice}}</text>\r\n    </view>\r\n        <view class=\"account\">\r\n      <text>结算</text>\r\n      <text>({{countSelectedNum}})</text>\r\n    </view>\r\n    </view>\r\n</view>父组件index.wxsspage{\r\n  background: #f8f8f8;\r\n}\r\n.cart{\r\n    padding-bottom: 100rpx;\r\n  font-size: 26rpx;\r\n}\r\n.item{\r\n  border-bottom: 1px solid #eee;\r\n}\r\n/* 头部店铺信息 */\r\n.storeInfo{\r\n  display: flex;\r\n  padding: 18rpx 0rpx 18rpx 30rpx;\r\n  background: #fff;\r\n  box-sizing: border-box;\r\n}\r\n.storeInfo .avatar{\r\n  width: 56rpx;\r\n  height: 56rpx;\r\n  border-radius: 50%;\r\n  vertical-align: middle;\r\n}\r\n.storeInfo .storeName{\r\n  margin-left: 16rpx;\r\n  line-height: 56rpx;\r\n}\r\n/* 包邮信息 */\r\n.discount{\r\n  padding-left: 30rpx;\r\n  height:50rpx;\r\n  line-height: 50rpx;\r\n  font-size:20rpx;\r\n  color: #666;\r\n  box-sizing: border-box;\r\n}\r\n/* 底部操作 */\r\n.count{\r\n    display: flex;\r\n    position: fixed;\r\n    padding-left: 30rpx;\r\n    bottom: 0;\r\n  left: 0;\r\n    width: 100%;\r\n    height: 100rpx;\r\n    line-height: 100rpx;\r\n  box-sizing: border-box;\r\n  color: #232323;\r\n    background: #eee;\r\n}\r\n/* 全选 */\r\n.selectAll{\r\n    display: flex;\r\n  padding-right: 20rpx;\r\n    align-items: center;\r\n    width: 25%;\r\n  font-size: 30rpx;\r\n}\r\n.selectAll .noSelected{\r\n  width: 46rpx;\r\n  height: 46rpx;\r\n  border-radius: 50%;\r\n  border: 1px solid #ef5225;\r\n}\r\n.selectAll .selectedImg{\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n.selectAllText{\r\n    margin-left: 18rpx;\r\n}\r\n\r\n.countPrice{\r\n    position: absolute;\r\n  top: 0;\r\n  right: 270rpx;\r\n  height: 100%;\r\n  line-height: 100rpx;\r\n  text-align: center;\r\n  font-size: 30rpx;\r\n}\r\n.countPrice text{\r\n  margin-right: 15rpx;\r\n}\r\n.account{\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n    width: 270rpx;\r\n  height: 100%;\r\n  line-height: 100rpx;\r\n  text-align: center;\r\n  font-size: 30rpx;\r\n  background: #ef5225;\r\n  color: #fff;\r\n}父组件index.json，引用子组件{\r\n  \"usingComponents\": {\r\n    \"cart-item\": \"/component/cart/index\"\r\n  }\r\n}父组件index.jsPage({\r\n\r\n  data: {\r\n    cartList: [\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar.jpeg',\r\n        shopid: 11,\r\n        commodity: [\r\n          {\r\n            id: 1,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 10,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }, \r\n          {\r\n            id: 2,\r\n            image:'/images/avatar7.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '10',\r\n            stock: 5,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar5.jpg',\r\n        shopid: 450,\r\n        commodity: [\r\n          {\r\n            id: 3,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '90',\r\n            stock: 10,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          },\r\n          {\r\n            id: 4,\r\n            image:'/images/avatar7.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            price: '100',\r\n            stock: 5,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }, \r\n          {\r\n            id: 5,\r\n            image:'/images/commodity.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 2,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n      {\r\n        shopname: '猫咪小店',\r\n        logo: '/images/avatar.jpeg',\r\n        shopid: 550,\r\n        commodity: [\r\n          {\r\n            id: 6,\r\n            image:'/images/avatar8.jpg',\r\n            title: '雅诗兰黛鲜活焕亮红石榴晚霜50ml 补水保湿 滋润排浊',\r\n            standard: '111 + 黑色',\r\n            price: '100',\r\n            stock: 1,\r\n            quantity: 1,\r\n            isselected: 0,\r\n          }\r\n        ]\r\n      },\r\n    ],\r\n        /* 商品是否全选中 */\r\n        isSelectedAll: false,\r\n        /* 已选中商品的价格 */\r\n        countPrice: 0,\r\n    /* 统计所有选中的商品数量 */\r\n    countSelectedNum: 0,\r\n  },\r\n  /* 处理商品选中 */\r\n  handleSelect(e) {\r\n        let countPrice = 0;\r\n    let countSelectedNum = 0;\r\n    let cartList = this.data.cartList;\r\n    let length = cartList.length;\r\n\r\n        /* 因为是假数据，所以需要循环查找到对应的数据将其替换 */\r\n    for(let i = 0; i < length; i++) {\r\n      for(let j = 0; j < cartList[i].commodity.length; j++) {\r\n                if (cartList[i].commodity[j].id == e.detail.commodity.id) {\r\n          cartList[i].commodity[j] = e.detail.commodity;\r\n          cartList[i].commodity[j].selectedNum = e.detail.selectedNum;\r\n        }\r\n        if (cartList[i].commodity[j].isselected == 1) {\r\n          /* 点击选中的时候，计算价格，要判断下设置的商品选中数量，\r\n           * 我这里的是对点击了的商品才设置了选中的数量，所以需要对没有点击的商品数量设置为1，然后就默认的加一\r\n           */\r\n          if (cartList[i].commodity[j].selectedNum != undefined) {\r\n            countPrice += cartList[i].commodity[j].price * cartList[i].commodity[j].selectedNum;\r\n            countSelectedNum += cartList[i].commodity[j].selectedNum\r\n          } else {\r\n            countPrice += cartList[i].commodity[j].price * 1;\r\n            countSelectedNum += 1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n        /* 对是否全选中进行判断 */\r\n        let isSelectedAll = true;\r\n        for (let i = 0; i < length; i++) {\r\n            for (let j = 0; j < cartList[i].commodity.length; j++) {\r\n                /* 若商品中的isselecetd有为0的就终止循环，直接设置为未全选 */\r\n                if (cartList[i].commodity[j].isselected == 0) {\r\n                    isSelectedAll = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n    this.setData({\r\n      cartList,\r\n            isSelectedAll,\r\n            countPrice,\r\n      countSelectedNum\r\n    })\r\n  },\r\n    /* 全选中商品 */\r\n    handleSelectAll() {\r\n        let isSelectedAll = !this.data.isSelectedAll;\r\n        let cartList = this.data.cartList;\r\n        let length = cartList.length;\r\n    let countPrice = 0;\r\n    let countSelectedNum = 0;\r\n\r\n        /* 遍历数据中的isselected来进行全选的操作 */\r\n        for(let i = 0; i < length; i++) {\r\n            for (let j = 0; j < cartList[i].commodity.length; j++) {\r\n                if(isSelectedAll) {\r\n                    cartList[i].commodity[j].isselected = 1;\r\n          /* 全选的时候，计算价格，要判断下设置的商品选中数量，\r\n           * 我这里的是对点击了的商品才设置了选中的数量，所以需要对没有点击的商品数量设置为1，然后就默认加一\r\n           */\r\n          if (cartList[i].commodity[j].selectedNum != undefined) {\r\n            countPrice += parseInt(cartList[i].commodity[j].price) * cartList[i].commodity[j].selectedNum;\r\n            countSelectedNum += cartList[i].commodity[j].selectedNum;\r\n          } else {\r\n            countPrice += cartList[i].commodity[j].price * 1;    \r\n            countSelectedNum += 1;        \r\n          }\r\n                } else {\r\n                    cartList[i].commodity[j].isselected = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setData({\r\n            isSelectedAll,\r\n            cartList,\r\n      countPrice,\r\n      countSelectedNum\r\n        })\r\n    },\r\n})4.父子组件传值较常用的都是父组件往子组件传值，所以子组件往父组件传值就会不是很熟悉我这里的话，是因为用的假数据，在点击商品选中或者不选中时，需要改变商品里的选中属性，所以用到了子组件往父组件传值，也包括传递选中的商品数量子组件往父组件传值的话，是通过在调用this.triggerEvent()来实现的/* 在父组件中定义方法：bind:handleselect或者也可以直接写成bindhandleselect*/\r\n<cart-item commodity=\"{{item}}\" bind:handleselect=\"handleSelect\" />在子组件中调用this.triggerEvent('handleselect', { commodity, selectedNum})这个this.triggerEvent('handleselect', { commodity, selectedNum })方法中，handleselect的名称要与父组件中引用子组件时绑定的方法名称一样，后面的对象就是传递的值，也可以直接是以直接量的形式传递，然后再父组件中通过e.detail来获取对应的值handleSelect(e) {\r\n    console.log(e.detail)\r\n    console.log(e.detail.commodity)\r\n    console.log(e.detail.selectedNum)\r\n}5.calc的注意事项我以前也遇到过，然后现在再用的时候，一时间把这点给忘了，在看到编译器样式的时候，才猛然想起.user-content{\r\n    padding: 10px 0 10px 50px;\r\n    width: calc(100% - 50px);  /* 计算宽度，'+'或'-'符号前后有空格 */\r\n    height: 18px;\r\n}css中使用calc可以进行简单的运算：单位可以是百分比，px，rem，em等单位使用\"+\",\"-\",\"*\",\"/\"运算符（使用\"+\"或者\"-\"符号时，符号前后必须加上空格）在Firefox浏览器上使用要加上-moz前缀chrome浏览器上使用要加上-webkit前缀（使用\"+\"或者\"-\"符号时，符号前后必须加上空格）6.部分想法其实在样式上还是挺快就完成了，就是在计算商品价格的时候，想了挺久在计算价格时，当时就有点蒙圈，总是想着要怎么判断他是增加数量还是减少数量，然后就陷入死循环的之中。其实不用想她是增加还是减少数量，因为你都是传的是商品的数量，而且在计算时，也是判断了商品是否选中，所以，直接点，计算价格乘以数量就可以了然后选中的商品数量的统计就和计算价格的思路是一样的了正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断iOS和Android及PC端css实现波浪线及立方体微信小程序中遇到的多规格问题(一)实现单行及多行文字省略号"}
{"title": "vue 项目快速输出微信、支付宝、百度小程序 ", "author": "Rolan", "pub_time": "2018-11-14 00:01", "article_content": "上周，Megalo@0.2.0 正式发布，优化了数据更新性能的同时，支持了百度智能小程序，着实激动了一把，这“可能”是目前社区里第一个同时支持三端小程序的 vue 小程序框架。下面我们就来试试他的效果。跟着文档走官方文档的第一部分就是快速入门，顺藤摸瓜，构建一个 megalo 项目。安装$ npm install -g @megalo/cli\r\n复制代码构建$ megalo megalo-yanxuan-demo\r\n复制代码打包以微信小程序为入口$ npm run dev:wechat\r\n复制代码至此一个完整的 megalo 项目就构建好了，接下来我们开始转移源码转移 weex 项目我从以前 weex 的 demo 项目， yanxuan-weex-demo ，为基础进行转移，转移过程中涉及到很多 weex 特有的 api 的移除和转换。网络请求以网络请求为例，weex 是使用的 streamlet stream = weex.requireModule('stream');\r\nexport default {\r\n    methods: {\r\n        GET (api, callback) {\r\n            return stream.fetch({\r\n                method: 'GET',\r\n                type: 'json',\r\n                url: api\r\n            }, callback)\r\n        }\r\n    }\r\n}\r\n复制代码因为小程序都有提供网络请求的 API，所以此处对此进行改造，如下export default {\r\n    methods: {\r\n        GET (api, callback) {\r\n            let { platform } = this.$mp || {},\r\n                request = ()=>{}\r\n            switch(platform) {\r\n                case 'wechat':\r\n                    request = wx && wx.request\r\n                break;\r\n                case 'alipay':\r\n                    request = my && my.httpRequest\r\n                break;\r\n                case 'swan':\r\n                    request = swan && swan.request\r\n                break;\r\n                default:\r\n                break;\r\n            }\r\n            request && request({\r\n                url: api,\r\n                success: callback\r\n            })\r\n        }\r\n    }\r\n}\r\n复制代码类似的还有 toast、message 等组件的改造。组件由于 weex 中的 <recycle-list> 、 <loading> 、 <refresh> 、 <scroller> 等组件在小程序组件内是不存在的，所以有三种解决方案自定义一个同名 vue 组件找小程序可用的组件替换实在不行就砍掉需求吧比如 weex 的 <slider> 组件，可以用小程序的 <swiper> 替换，好在微信、支付宝和百度小程序都有支持。cssWeex 容器默认的宽度 (viewport) 是 750px，小程序以 750rpx 为基。所以直接将需要的 px 转换成 rpx。另外自己实现了 1 像素的 wpx，替换成 px 即可。执行三端效果最后看下改造效果。同时执行三端效果比预想的要好，没有过多的适配出错demo 源码 抛给大家供大家把玩。哪些可以转只要现有工程没有做以下几件事，理论上，都是可以转移的，只需要稍微更新一下格式使用 megalo 暂不支持的 vue 特性涉及浏览器特有的 dom 操作，window、userAgent、location、getElementById 等使用第三方组件库且该组件库使用了 dom 操作使用了 vue-router，暂不支持全局使用 vuex不过，方案都是可以调整的，以上功能在社区均可以找到替代方案。换之即可。"}
{"title": "小程序云开发初体验 ", "author": "Rolan", "pub_time": "2018-11-14 00:25", "article_content": "云开发\r\n开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。\r\n云开发为开发者提供完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。\r\n类似于Bmob后端云或知晓云\r\n云开发的出现，让小程序的开发变得更简单方便，开发人员可以不用去购买搭建服务器，不用操心服务端的稳定性和数据库的安装\r\n\r\n开通云开发\r\n在微信开发工具里，直接点击'云开发'，会引导你开通， 需要注意的是云开发能力从基础库 2.2.3 开始支持\r\n\r\n云开发开通后自动获得一套云开发环境，各个环境相互隔离，每个环境都包含独立的数据库实例、存储空间、云函数配置等资源。每个环境都有唯一的环境 ID 标识，初始创建的环境自动成为默认环境。\r\n有一个免费的基础版\r\n开通云开发后初始默认可拥有最多两个环境。在实际开发中，建议每一个正式环境都搭配一个测试环境\r\n数据库\r\n云开发提供了一个json数据库(可以理解为MongoDB 这类 NoSQL 数据库)，就是一个json格式的对象。 一个数据库有多个集合，相当于关系型数据库的表。 集合数组里有多个对象，每一个对象就是一个记录，相当于关系型数据库中的行。数据库的操作提供了很多API，后面结合例子简单示例说明\r\n[\r\n    {\r\n      \"id\": 342166,\r\n      \"haspromotionTag\": false,\r\n      \"img\": \"http://p1.meituan.net/128.180/movie/740bd990e4af29d537ce324ec2cd08d6300433.jpg\",\r\n      \"version\": \"v2d imax\",\r\n      \"nm\": \"无双\",\r\n      \"preShow\": false,\r\n      \"sc\": 8.9,\r\n      \"globalReleased\": true,\r\n      \"wish\": 125425,\r\n      \"star\": \"周润发,郭富城,张静初\",\r\n      \"rt\": \"2018-09-30\",\r\n      \"showInfo\": \"今天183家影院放映2258场\",\r\n      \"showst\": 3,\r\n      \"wishst\": 0\r\n    },\r\n    {\r\n      \"id\": 1209159,\r\n      \"haspromotionTag\": false,\r\n      \"img\": \"http://p0.meituan.net/128.180/movie/4d9bedd239f41eaf08cd1c4297e4ec7d858156.jpg\",\r\n      \"version\": \"\",\r\n      \"nm\": \"找到你\",\r\n      \"preShow\": false,\r\n      \"sc\": 9,\r\n      \"globalReleased\": true,\r\n      \"wish\": 66559,\r\n      \"star\": \"姚晨,马伊琍,袁文康\",\r\n      \"rt\": \"2018-10-05\",\r\n      \"showInfo\": \"今天182家影院放映1039场\",\r\n      \"showst\": 3,\r\n      \"wishst\": 0\r\n    }\r\n]\r\n复制代码存储\r\n基础版提供了5G的存储容量，可以把文件(图片、视频...)上传到存储空间，在云端管理。直接使用小程序提供的上传下载接口，处理起来非常方便。\r\n云函数\r\n云函数是写后端代码的，云函数里可以操作数据库，操作存储，根据自身的业务需求完成后端代码的实现。云函数，是部署在云端的，但是我们可以在开发工具里编写后端的云函数，完成后再部署到云端，可以说所有逻辑都在一套代码里。\r\n我的第一个云开发小程序\r\n创建云开发项目时，据官方描述，在微信开发工具里，有一个QuickStart选项，但我发现并没有，可能是开发工具版本或其他原因。\r\n\r\n给数据库添加数据\r\n我在猫眼电影拷贝了部分数据，准备倒入小程序云开发的数据库\r\n\r\n可以看到，在控制台，可以自行添加数据，也可以直接倒入一个json文件。我这里选择调用它的API去倒入猫眼json数据\r\n首先我创建了一个名为movies的集合，紧接着调用初始化的方法\r\n\r\napp.js\r\n\r\n...\r\nonLaunch: function () {\r\n    wx.cloud.init()\r\n}\r\n...\r\n复制代码要操作数据库，需要先获取到数据库引用,  同时，获取到我刚创建的movies集合的引用, 由于在其他页面也需要调用，我这里把它们都挂到app的属性上\r\nconst app = getApp()\r\n...\r\napp.$db = wx.cloud.database()\r\napp.$collect_movies = app.$db.collection('movies')\r\n...\r\n复制代码最后， 调用添加的方法\r\ndata.subjects.forEach(o => {\r\n  app.$collect_movies.add({\r\n    data: o\r\n  })\r\n})\r\n复制代码现在云开发控制台数据库里已经有添加的数据了\r\n显示所有电影\r\napp.$collect_movies.where({\r\n  _openid: 'ofgUd0Rb4w8E7Af40N46ExxozS5g'\r\n}).get({\r\n  success: function (res) {\r\n    console.log('res', res)\r\n    that.setData({\r\n      movies: res.data\r\n    })\r\n  }\r\n})\r\n复制代码根据ID查询指定电影\r\napp.$collect_movies.doc('W8Wf4t2AWotkhlzK').get({\r\n    success: function (res) {\r\n      console.log('res',res)\r\n      that.setData({\r\n        movie: res.data\r\n      })\r\n    }\r\n})\r\n复制代码查询9分以上的电影\r\nconst _ = app.$db.command\r\napp.$collect_movies.where({\r\n    sc: _.gte(9)\r\n}).get({\r\n    success: function (res) {\r\n      wx.hideLoading()\r\n      that.setData({\r\n        movies: res.data\r\n      })\r\n    }\r\n})\r\n复制代码获取9分以上或0分的电影\r\nconst _ = app.$db.command\r\napp.$collect_movies.where({\r\n    sc: _.eq(0).or(_.gte(9))\r\n}).get({\r\n    success: function (res) {\r\n      wx.hideLoading()\r\n      that.setData({\r\n        movies: res.data\r\n      })\r\n    }\r\n})\r\n复制代码修改主演名\r\n# 确认修改\r\nconst that = this\r\napp.$collect_movies.doc(this.currentMovieId).update({\r\n  data: {\r\n    star: this.data.actor\r\n  },\r\n  success: function (res) {\r\n    that.initUpdateData()\r\n  }\r\n})\r\n复制代码删除一部电影\r\n# 确定删除\r\ndelAction(e) {\r\n    const that = this\r\n    const id = e.currentTarget.dataset.id\r\n    app.$collect_movies.doc(id).remove({\r\n      success: function (res) {\r\n        that.initUpdateData()\r\n      }\r\n    })\r\n}\r\n复制代码\r\n文件管理\r\n上传图片到云存储\r\n试着把手机相册的图片上传到小程序云存储中，可以在小程序端直接使用提供的api\r\nwx.cloud.uploadFile({\r\n  cloudPath: 'example.png', // 上传至云端的路径\r\n  filePath: '', // 小程序临时文件路径\r\n  success: res => {\r\n    // 返回文件 ID\r\n    console.log(res.fileID)\r\n  },\r\n  fail: console.error\r\n})\r\n复制代码如果单纯从代码量来看，比上传到腾讯自家腾讯云还简单，当然比上传到像阿里云、七牛云这样的平台操作更简单。\r\n上传成功之后，返回的不是图片url, 而是文件id。如果要显示图片或者播放视频，这个文件id，小程序的组件image/video也能识别\r\n <image class=\"movie\" mode=\"widthFix\" src=\"{{ fileId }}\" wx:if=\"{{ fileId }}\"> </image>\r\n复制代码upload() {\r\n    const that = this\r\n    wx.chooseImage({\r\n      count: 1,\r\n      sizeType: ['original', 'compressed'],\r\n      sourceType: ['album', 'camera'],\r\n      success(res) {\r\n        const tempFilePaths = res.tempFilePaths\r\n        console.log(tempFilePaths[0])\r\n        wx.cloud.uploadFile({\r\n          cloudPath: 'test/2.png', // 上传至云端的路径\r\n          filePath: tempFilePaths[0], // 小程序临时文件路径\r\n          success: res => {\r\n            // 返回文件 ID\r\n            console.log(res.fileID)\r\n            that.setData({\r\n              fileId: res.fileID\r\n            })\r\n          },\r\n          fail: console.error\r\n        })\r\n      }\r\n    })\r\n}\r\n复制代码\r\n\r\n根据文件id下载文件\r\ndownloadFile() {\r\n  wx.cloud.downloadFile({\r\n  fileID: 'cloud://ii-1853ca.6969-ii-1853ca/test/2.png',\r\n  success: res => {\r\n    // 返回临时文件路径\r\n    console.log('tempFilePath', res)\r\n    // cloud://ii-1853ca.6969-ii-1853ca/test/2.png\r\n    this.setData({\r\n      downloadFileResult: res\r\n    })\r\n  },\r\n  fail: err => {\r\n    // handle error\r\n  }\r\n})\r\n复制代码根据文件id换取临时网络链接\r\n可以根据文件 ID 换取临时文件网络链接，文件链接有有效期为两个小时\r\nconst that = this\r\nwx.cloud.getTempFileURL({\r\n    fileList: [this.data.fileId],\r\n    success: res => {\r\n      // https://6969-ii-1853ca-1253918415.tcb.qcloud.la/test/2.png\r\n      that.setData({\r\n        fileList: res.fileList\r\n      })\r\n    },\r\n    fail: err => {\r\n      // handle error\r\n    }\r\n})\r\n复制代码云函数\r\n怎么玩？\r\n云函数是运行在Node.js环境下的\r\n首先在小程序项目根目录找到配置文件project.config.json文件，加上一个配置, 指定本地已存在的目录作为云函数的本地根目录\r\n  \"cloudfunctionRoot\": \"./functions/\",\r\n复制代码指定之后神奇的一幕就是图标会变成 “云目录图标”\r\n\r\n子目录都是我通过右键菜单创建一个新的云函数，其中文件名就是云函数名\r\n每创建一个云函数，都会出现弹窗，询问你是否有node环境，确定后会自动打开终端，安装依赖, 所以每一个云函数里面都是这样的：\r\n\r\n在index.js中, 默认是这样的\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n\r\n}\r\n复制代码创建一个相加的云函数\r\n\r\nplus/\r\n\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\n// context 对象包含了此处调用的调用信息和运行状态\r\n// event 指的是触发云函数的事件\r\nexports.main = async (event, context) => {\r\n  return {\r\n    sum: event.a + event.b\r\n  }\r\n}\r\n复制代码在小程序端调用plus云函数, 参数名一眼就看明白，不用解释\r\nwx.cloud.callFunction({\r\n  name: 'plus',\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n  success: function (res) {\r\n    console.log('plus', res.result) // 3\r\n  },\r\n  fail: console.error\r\n})\r\n复制代码调用后报错，是因为没有把创建的云函数上传部署到云端, 如何部署？看下图\r\n\r\n部署成功之后，我们来到云控制台， 发现云函数已经在上面\r\n\r\n回到小程序，再次调用云函数，发现已经可以了, 拿到了预期的值3\r\n获取小程序用户信息\r\n云开发的云函数的独特优势在于与微信登录鉴权的无缝整合。当小程序端调用云函数时，云函数的传入参数中会被注入小程序端用户的 openid，开发者无需校验 openid 的正确性，因为微信已经完成了这部分鉴权，开发者可以直接使用该 openid。与 openid 一起同时注入云函数的还有小程序的 appid\r\n定义云函数\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  return event.userInfo\r\n}\r\n复制代码调用云函数\r\nwx.cloud.callFunction({\r\n    name: 'userInfo',\r\n    success: function (res) {\r\n      console.log('userInfo', res.result)\r\n        /*\r\n          {\r\n            appId:\"wx8dae61dd0ef5c510\",\r\n            openId:\"ofgUd0Rb4w8E7Af40N46ExxozS5g\"\r\n           }\r\n        */\r\n    },\r\n    fail: console.error\r\n})\r\n复制代码异步云函数\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  return new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n      resolve(event.a + event.b)\r\n    }, 3000)\r\n  })\r\n}\r\n复制代码在云函数中我们可以引入第三方依赖来帮助我们更快的开发。云函数的运行环境是 Node.js，因此我们可以使用 npm 安装第三方依赖。比如除了使用 Node.js 提供的原生 http 接口在云函数中发起网络请求，我们还可以使用一个流行的 Node.js 网络请求库 request 来更便捷的发起网络请求。\r\n注意，现在上传云函数时不会在云端自动安装依赖，需要开发者在本地安装好依赖后一起打包上传。\r\n云函数操作数据库\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  // 获取电影集合数据\r\n  return db.collection('movies').get()\r\n}\r\n复制代码云函数调用其他云函数\r\n\r\n定义云函数\r\n\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  return await cloud.callFunction({\r\n    name: 'plus',\r\n    data: {\r\n      a: 1,\r\n      b: 2,\r\n    }\r\n  })\r\n}\r\n复制代码\r\n调用云函数\r\n\r\nwx.cloud.callFunction({\r\n  name: 'cloudFuncCallColundFunc',\r\n  complete: res => {\r\n    console.log('cloudFuncCallColundFunc', res)\r\n  },\r\n})\r\n复制代码云函数日志、测试\r\n可以看到调用的云函数的调用日志\r\n可以直接测试编写好的云函数，传入参数, 点击运行调试按钮即可\r\n云开发初体验总结\r\n云开发大概在8月份公测，9月份发布出来的，现在已经快11月份了，据官方描述，有很多开发人员参与进去，是他们没有预料到的， 同时也被提出了很多吐槽点，小程序的云开发也可以说是在试水阶段，有不少坑，后面肯定会越来越完善。 逐渐成熟，会是一个非常不错的解决方案， 特别是针对那些初创公司。作者：stupidWall链接：https://juejin.im/post/5bea4569e51d455d981bf43e"}
{"title": "小程序选人控件 - 仿企业微信实现多层级无规则嵌套 ", "author": "Rolan", "pub_time": "2018-10-30 00:12", "article_content": "在很多系统中都有选择联系人的需求，市面上也没什么好的参照，产品经理看企业微信的选人挺好用的，就说参照这个做一个吧。。。\r\n\r\n算了，还是试着做吧，企业微信的选人的确做的挺好，不得不佩服。\r\n先看看效果图吧，多层级无规律的嵌套都能搞定\r\n\r\n一、设计解读\r\n\r\n整个界面分为三部分：\r\n\r\n最上面的返回上一层按钮\r\n中间的显示部门、人员的列表\r\n最下面显示和操作已选人员的 footer。\r\n\r\n为什么加一个返回上一层按钮呢？\r\n我也觉得比较丑，但小程序无法直接控制左上角返回键（自定义 Title 貌似可以，没试过），点左上角的返回箭头的话就退出选人控件到上个页面了。\r\n我们的需求是点击一个文件夹，通过刷新当前列表进入下一级目录，感觉像是又进了一个页面，但其实并没有，只是列表的数据变化了。由此实现不定层级、无规律的部门和人员嵌套的支持。\r\n比如先点击了首屏数据的第二个 item，它的 index 是 1 ，就将 1 存入  indexList ；返回上一层时将最后一个元素删除。\r\n当勾选了某个人或部门时，会在底部的框中显示所有已选人员或部门的名字，当文字超过屏幕宽度时可以向右无限滑动，底部 footer 始终保持一行。\r\n最终选择的人以底部 footer 里显示的为准，点击确定时根据业务需要将已选人员数据发送给需要的界面。\r\n二、功能逻辑分析\r\n先看看数据格式\r\n{\r\n  id: TEACHER_ID,\r\n  name: '教师',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: [\r\n    {\r\n      id: TEACHER_DEPARTMENT_ID,\r\n      name: '部门',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_SUBJECT_ID,\r\n      name: '学科',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_GRADECLASS_ID,\r\n      name: '年级班级',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n  ]\r\n}\r\n复制代码所有的数据组成一个数据树，子节点嵌套在父节点下。\r\nid,  name 不说了，parentId 指明它的父节点，children 包含它的所有子节点，checked 用来判断勾选状态，isPeople 判断是部门还是人员，因为两者的图标不一样。\r\n注意：\r\n本控件采用了数据分步加载的模式，除了最上层固定的几个分类，其他的每层数据都是点击具体的部门后才去请求服务器加载本部门下的数据的，然后再拼接到原始数据树上。这样可以提高加载速度，提升用户体验。\r\n我也试了一次性把所有数据都拉下来，一是太慢，得三五秒，二是数据量太大的话（我这里应该是超过1000，阈值多少没测过），setData() 的时候就会报错：\r\n\r\n超过最大长度了。。。所以只能分步加载数据。\r\n当然如果你的数据量小，几十人或几百人，也可以选择一次性加载。\r\n这个控件逻辑上还是比较复杂的，要考虑的细节太多……下面梳理一下主要的逻辑点\r\n主要逻辑点\r\n1. 需要一个数组存储所有被点击的部门在当前列表的索引 index ，这里用 indexList 表示\r\n点击某个部门进入下一层目录时，将被点击部门的 index 索引 push  进 indexList  中。点击返回上一层按钮时，删除  indexList 中最后一个元素。\r\n2. 要动态的更新当前列表 currentList\r\n每进入新的一层，或返回上一层，都需要刷新 currentList 来实现页面的更新。知道下一层数据很容易，直接取被点击 item 的 children 赋值给 currentList 即可。\r\n但如何还原上一层的数据呢？\r\n第一点记录的 indexList 就发挥作用了，原始数据树为 originalList，循环遍历 indexList ，根据索引依次取出每层的 currentList 直到 indexList 的最后一个元素，就得到了返回上一层需要显示的数据。\r\n3. 每一次勾选或取消选中都要更新原始的数据树 originalList\r\n页面是根据每个 item 的 checked 属性判断是否选中的，所以每次改变勾选状态都要设置被改变的 item 的 checked 属性，然后更新 originalList。这样即使返回上一层了，再进到当前层级选中状态还会被保留，否则刷新 currentList 后已选状态将丢失。\r\n4. 列表中选择状态的改变与底部 footer 的双联动\r\n我们期望的效果是，选中currentList 列表的某一项，底部 footer 会自动添加被选人的名字。取消选中，底部 footer 也会自动删除。\r\n也可以通过 footer 来删除已选人，点击 footer 中人名，会将此人从已选列表中删除，currentList 列表中也会自动取消勾选状态。\r\n嗯，这个功能比较耗性能，每一次都需要大量的计算。考虑到性能和速度因素，本次只做了从 footer 删除只更新 currentList 的勾选状态。\r\n什么意思呢？假如有两层，A 和 B，B 是 A 的下一层数据，即 A 是 B 的父节点。在 A 中选中了一个部门 校长室，点击下一层到 B，在 B 中又选了两个人 张三 和 李四，这时底部 footer 里显示的应该是三个： 校长室、 张三 、 李四。此时点击 footer 的 张三 ， footer 会把 张三 删除，中间列表中 张三 会被置为未选中状态，这没问题。但点击 footer 的 校长室 , 在 footer 中是把  校长室 删除了，但再返回到上一层时，中间列表中的 校长室 依然是勾选状态，因为此时没有更新原始数据树 originalList。如果觉得这是个 bug, 可以加个更新 originalList 的操作。这样就要遍历  originalList 的每个元素判断与本次删除的 id 是否相等，然后改变 checked 值，如果数据量很大，会非常慢。我做了妥协……\r\n关键的逻辑就这四块了，当然还有很多小细节，直接看代码吧，注释写的也比较详细。\r\n三、代码\r\n目录结构：\r\n\r\nfooter 文件夹下是抽离出的 footer 组件，userSelect 是选人控件的主要逻辑。把这几个文件复制过去就可以用了。\r\n把 userSelect.js 里网络请求的代码替换为你的请求代码，注意数据的字段名是否一致。\r\nuserSelect 的代码\r\n\r\nuserSelect.js\r\n\r\n\r\nimport API from '../../../utils/API.js'\r\nimport ArrayUtils from '../../../utils/ArrayUtils.js'\r\nimport EventBus from '../../../components/NotificationCenter/WxNotificationCenter.js'\r\n\r\nlet TEACHER_ID = 'teacher';\r\nlet TEACHER_DEPARTMENT_ID = 't_department';\r\nlet TEACHER_SUBJECT_ID = 't_subject';\r\nlet TEACHER_GRADECLASS_ID = 't_gradeclass';\r\nlet STUDENT_ID = 'student';\r\nlet PARENT_ID = 'parent'\r\n\r\nlet TEACHER = {\r\n  id: TEACHER_ID,\r\n  name: '教师',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: [\r\n    {\r\n      id: TEACHER_DEPARTMENT_ID,\r\n      name: '部门',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_SUBJECT_ID,\r\n      name: '学科',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n    {\r\n      id: TEACHER_GRADECLASS_ID,\r\n      name: '年级班级',\r\n      parentId: 'teacher',\r\n      checked: false,\r\n      isPeople: false,\r\n      children: []\r\n    },\r\n  ]\r\n}\r\nlet STUDENT = {\r\n  id: STUDENT_ID,\r\n  name: '学生',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: []\r\n}\r\nlet PARENT = {\r\n  id: PARENT_ID,\r\n  name: '家长',\r\n  parentId: '',\r\n  checked: false,\r\n  isPeople: false,\r\n  children: []\r\n}\r\nlet ORIGINAL_DATA = [\r\n  TEACHER, STUDENT, PARENT\r\n]\r\n\r\nPage({\r\n  data: {\r\n    currentList: [], //当前展示的列表\r\n    selectList: [],  //已选择的元素列表\r\n    originalList: [], //最原始的数据列表\r\n    indexList: [],  //存储目录层级的数组，用于准确的返回上一层\r\n    selectList: [],  //已选中的人员列表\r\n  },\r\n\r\n  onLoad: function (options) {\r\n    wx.setNavigationBarTitle({\r\n      title: '选人控件'\r\n    })\r\n    this.init();\r\n  },\r\n\r\n  init(){\r\n    //用户的单位id\r\n    this.unitId = getApp().globalData.userInfo.unitId;\r\n    //用户类型\r\n    this.userType = 0;\r\n    //上次选中的列表，用于判断是不是取消选中了\r\n    this.lastTimeSelect = []\r\n\r\n    this.setData({\r\n      currentList: ORIGINAL_DATA, //当前展示的列表\r\n      originalList: ORIGINAL_DATA, //最原始的数据列表\r\n    })\r\n  },\r\n\r\n  clickItem(res){\r\n    console.log(res)\r\n    let index = res.currentTarget.id;\r\n    let item = this.data.currentList[index]\r\n\r\n    console.log(\"item\", item)\r\n\r\n    if (!item.isPeople) {\r\n      //点击教师，下一层数据是写死的，不用请求接口\r\n      if (item.id === TEACHER_ID) {\r\n        this.userType = 2;\r\n        this.setData({\r\n          currentList: item.children\r\n        })\r\n      } else if (item.id === TEACHER_SUBJECT_ID) {\r\n        if (item.children.length === 0){\r\n          this._getTeacherSubjectData()\r\n        }else{\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === TEACHER_DEPARTMENT_ID) {\r\n        if (item.children.length === 0) {\r\n          this._getTeacherDepartmentData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === TEACHER_GRADECLASS_ID) {\r\n        if (item.children.length === 0) {\r\n          this._getTeacherGradeClassData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === STUDENT_ID) {\r\n        this.userType = 1;\r\n        if (item.children.length === 0) {\r\n          this._getStudentGradeClassData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else if (item.id === PARENT_ID) {\r\n        this.userType = 3;\r\n        if (item.children.length === 0) {\r\n          this._getParentGradeClassData()\r\n        } else {\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      } else{\r\n        //children的长度为0时，请求服务器\r\n        if(item.children.length === 0){\r\n          this._getUserByGroup(item)\r\n        }else{\r\n          //children的长度不为0时，更新 currentList\r\n          this.setData({\r\n            currentList: item.children\r\n          })\r\n        }\r\n      }\r\n\r\n      //将当前的索引存入索引目录中。索引多一个表示目录多一级\r\n      let indexes = this.data.indexList\r\n      indexes.push(index)\r\n      //是目录不是具体的用户\r\n      this.setData({\r\n        indexList: indexes\r\n      })\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect\r\n      this.setLastTimeSelectList();\r\n    }\r\n  },\r\n\r\n\r\n  //返回按钮\r\n  goBack() {\r\n    let indexList = this.data.indexList\r\n    if (indexList.length > 0) {\r\n      //返回时删掉最后一个索引\r\n      indexList.pop()\r\n      if (indexList.length == 0) {\r\n        //indexList长度为0说明回到了最顶层\r\n        this.setData({\r\n          currentList: this.data.originalList,\r\n          indexList: indexList\r\n        })\r\n      } else {\r\n        //循环将当前索引的对应数组赋值给currentList\r\n        let list = this.data.originalList\r\n        for (let i = 0; i < indexList.length; i++) {\r\n          let index = indexList[i]\r\n          list = list[index].children\r\n        }\r\n        this.setData({\r\n          currentList: list,\r\n          indexList: indexList\r\n        })\r\n      }\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect\r\n      this.setLastTimeSelectList();\r\n    }\r\n  },\r\n\r\n  //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect\r\n  setLastTimeSelectList(){\r\n    this.lastTimeSelect = []\r\n    this.data.currentList.forEach(item => {\r\n      if (item.checked) {\r\n        this.lastTimeSelect.push(item)\r\n      }\r\n    })\r\n  },\r\n\r\n  //获取教师部门数据\r\n  _getTeacherDepartmentData() {\r\n    this._commonRequestMethod(2, 'department')\r\n  },\r\n\r\n  //请求教师的学科数据\r\n  _getTeacherSubjectData(){\r\n    this._commonRequestMethod(2, 'subject')\r\n  },\r\n\r\n  //请求教师的年级班级\r\n  _getTeacherGradeClassData() {\r\n    this._commonRequestMethod(2, 'gradeclass')\r\n  },\r\n\r\n  //请求学生的年级班级\r\n  _getStudentGradeClassData() {\r\n    this._commonRequestMethod(1, 'gradeclass')\r\n  },\r\n\r\n  //请求家长的年级班级\r\n  _getParentGradeClassData() {\r\n    this._commonRequestMethod(3, 'gradeclass')\r\n  },\r\n\r\n  //根据部门查询人\r\n  _getUserByGroup(item){\r\n    let params = {\r\n      userType: this.userType,\r\n      unitId: this.unitId,\r\n      groupType: item.type,\r\n      groupId: item.id\r\n    }\r\n    console.log('params', params)\r\n    getApp().get(API.selectUserByGroup(), params, result => {\r\n      console.log('result', result)\r\n      let list = this.transformData(result.data.data, item.id)\r\n      this.setData({\r\n        currentList: list\r\n      })\r\n      this.addList2DataTree()\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect。写在这里防止异步请求时执行顺序问题\r\n      this.setLastTimeSelectList();\r\n    })\r\n  },\r\n\r\n  //通用的请求部门方法\r\n  _commonRequestMethod(userType, groupType){\r\n    wx.showLoading({\r\n      title: '',\r\n    })\r\n    let params = {\r\n      userType: userType,\r\n      unitId: this.unitId,\r\n      groupType: groupType\r\n    }\r\n    console.log('params', params)\r\n    getApp().get(API.selectUsersByUserGroupsTree(), params, result => {\r\n      console.log('result', result)\r\n      wx.hideLoading()\r\n      let data = result.data.data\r\n      this.setData({\r\n        currentList: data\r\n      })\r\n      this.addList2DataTree();\r\n      //清空上次选中的元素列表，并设置上一层的选中状态给lastTimeSelect。写在这里防止异步请求时执行顺序问题\r\n      this.setLastTimeSelectList();\r\n    })\r\n  },\r\n\r\n  //将请求的数据转化为需要的格式\r\n  transformData(list, parentId){\r\n    //先将数据转化为固定的格式\r\n    let newList = []\r\n    for(let i=0; i<list.length; i++){\r\n      let item = list[i]\r\n      newList.push({\r\n        id: item.id,\r\n        name: item.realName,\r\n        parentId: parentId,\r\n        checked: false,\r\n        isPeople: true,\r\n        userType: item.userType,\r\n        gender: item.gender,\r\n        children: []\r\n      })\r\n    }\r\n    return newList;\r\n  },\r\n\r\n  //将当前列表挂载在原数据树上, 目前支持5层目录，如需更多接着往下写就好\r\n  addList2DataTree(){\r\n    let currentList = this.data.currentList;\r\n    let originalList = this.data.originalList;\r\n    let indexes = this.data.indexList\r\n    switch (indexes.length){\r\n      case 1: \r\n        originalList[indexes[0]].children = currentList\r\n        break;\r\n      case 2:\r\n        originalList[indexes[0]].children[indexes[1]].children = currentList\r\n        break;\r\n      case 3:\r\n        originalList[indexes[0]].children[indexes[1]].children[indexes[2]].children = currentList\r\n        break;\r\n      case 4:\r\n        originalList[indexes[0]].children[indexes[1]].children[indexes[2]].children[indexes[3]].children = currentList\r\n        break;\r\n      case 5:\r\n        originalList[indexes[0]].children[indexes[1]].children[indexes[2]].children[indexes[3]].children[indexes[4]].children = currentList\r\n        break;\r\n    }\r\n\r\n    this.setData({\r\n      originalList: originalList\r\n    })\r\n    console.log(\"originalList\", originalList)\r\n  },\r\n\r\n  //选框变化回调\r\n  checkChange(res){\r\n    console.log(res)\r\n    let values = res.detail.value\r\n    let selectItems = []\r\n    //将值取出拼接成 id，name 格式\r\n    values.forEach(value => {\r\n      let arrs = value.split(\",\")\r\n      selectItems.push({id: arrs[0], name: arrs[1]})\r\n    })\r\n    console.log(\"selectItems\", selectItems)\r\n    console.log(\"lastTimeSelect\", this.lastTimeSelect)\r\n    \r\n    //将本次选择的与上次选择的比对，本次比上次多说明新增了，本次比上次少说明删除了，找出被删除的那条数据，在footer中也删除\r\n    if (selectItems.length > this.lastTimeSelect.length){\r\n      //将 selectList 与 selectItems 拼接并去重\r\n      let newList = this.data.selectList.concat(selectItems)\r\n      newList = ArrayUtils.checkRepeat(newList)\r\n      this.setData({\r\n        selectList: newList\r\n      })\r\n    }else{\r\n      //找出取消勾选的item，从selectList中删除\r\n      //比对出取消勾选的是哪个元素\r\n      let diffItem = {}\r\n      this.lastTimeSelect.forEach(item => {\r\n        let flag = false;\r\n        selectItems.forEach(item2 => {\r\n          if(item.id === item2.id){\r\n            flag = true\r\n          }\r\n        })\r\n        if(!flag){\r\n          diffItem = item\r\n          console.log(\"diff=\", item)\r\n        }\r\n      })\r\n      //找出被删除的元素在 selectList 中的位置\r\n      let list = this.data.selectList\r\n      let delIndex = 0;\r\n      for(let i=0; i<list.length; i++){\r\n        if (list[i].id === diffItem.id){\r\n          delIndex = i;\r\n          break;\r\n        }\r\n      }\r\n      //从list中删除这个元素\r\n      list.splice(delIndex, 1)\r\n      this.setData({\r\n        selectList: list\r\n      })\r\n    }\r\n    console.log(\"selectList\", this.data.selectList)\r\n    //更新 currentList 选中状态并重新挂载在数据树上，以保存选择状态\r\n    this.updateCurrentList(this.data.currentList, this.data.selectList)\r\n  },\r\n\r\n  //footer点击删除回调\r\n  footerDelete(res){\r\n    console.log(res)\r\n    this.setData({\r\n      selectList: res.detail.selectList\r\n    })\r\n\r\n    console.log('selectList', this.data.selectList)\r\n    this.updateCurrentList(this.data.currentList, res.detail.selectList)\r\n  },\r\n\r\n  //点击 footer 的确定按钮提交数据\r\n  submitData(res){\r\n    let selectList = this.data.selectList\r\n    //通过 WxNotificationCenter 发送选择的结果通知\r\n    EventBus.postNotificationName(\"SelectPeopleDone\", selectList)\r\n    //将选择结果存入 app.js 的 globalData\r\n    getApp().globalData.selectPeopleList = selectList\r\n    //返回\r\n    wx.navigateBack({\r\n      delta: 1\r\n    })\r\n    console.log(\"selectdone\", selectList)\r\n  },\r\n\r\n  //更新 currentList 并将更新后的列表挂载在数据树上\r\n  updateCurrentList(currentList, selectList){\r\n    let newList = []\r\n    currentList.forEach(item => {\r\n      let flag = false;\r\n      selectList.forEach(item2 => {\r\n        if (item.id === item2.id) {\r\n          flag = true\r\n        }\r\n      })\r\n      if (flag) {\r\n        item.checked = true\r\n      } else {\r\n        item.checked = false\r\n      }\r\n      newList.push(item)\r\n    })\r\n    this.setData({\r\n      currentList: newList\r\n    })\r\n    this.addList2DataTree()\r\n    this.setLastTimeSelectList()\r\n  }\r\n})\r\n复制代码\r\nuserSelect.wxml\r\n\r\n<view class='container'>\r\n  <view class='btn-wrapper'>\r\n    <button bindtap='goBack'>返回上一层</button>\r\n  </view>\r\n\r\n  <view class='people-wrapper'>\r\n    <scroll-view scroll-y class='scrollview'>\r\n      <checkbox-group bindchange=\"checkChange\">\r\n        <view class='item' wx:for='{{currentList}}' wx:key='{{item.id}}'>\r\n          <checkbox checked='{{item.checked}}' value='{{item.id + \",\" + item.name}}'>\r\n          </checkbox>\r\n          <view id='{{index}}' class='item-content' bindtap='clickItem'>\r\n            <image class='img' wx:if='{{!item.isPeople}}' src='../../../assets/file.png'></image>\r\n            <image class='avatar' wx:if='{{item.isPeople}}' src='../../../assets/avatar.png'></image>\r\n            <text class='itemtext'>{{item.name}}</text>\r\n          </view>\r\n        </view>\r\n      </checkbox-group>\r\n      <view class='no-data' wx:if='{{currentList.length===0}}'>暂无数据</view>\r\n    </scroll-view>\r\n  </view>\r\n  <view class='footer'>\r\n    <footer list='{{selectList}}' binddelete='footerDelete' bindsubmit=\"submitData\"/>\r\n  </view>\r\n</view>\r\n复制代码\r\nuserSelect.wxss\r\n\r\n.container {\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  padding: 20rpx;\r\n  overflow-x: hidden;\r\n  box-sizing: border-box;\r\n  background-color: #fff;\r\n}\r\n\r\n.btn-wrapper {\r\n  width: 100%;\r\n  padding: 0 20rpx;\r\n  box-sizing: border-box;\r\n}\r\n\r\n.btn {\r\n  font-size: 24rpx;\r\n  width: 100%;\r\n}\r\n\r\n.people-wrapper {\r\n  width: 100%;\r\n  margin-top: 10rpx;\r\n  margin-bottom: 100rpx;\r\n}\r\n\r\n.scrollview {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.item {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: row;\r\n  align-items: center;\r\n  padding: 30rpx 0;\r\n  margin: 0 20rpx;\r\n  border-bottom: 1rpx solid rgba(7, 17, 27, 0.1);\r\n}\r\n\r\n.item-content {\r\n  width: 100%;\r\n  display: flex;\r\n  flex-direction: row;\r\n  align-items: center;\r\n  margin-left: 20rpx;\r\n}\r\n\r\n.itemtext {\r\n  font-size: 36rpx;\r\n  color: #333;\r\n  margin-left: 20rpx;\r\n  text-align: center;\r\n}\r\n\r\n.img {\r\n  width: 50rpx;\r\n  height: 40rpx;\r\n}\r\n\r\n.avatar {\r\n  width: 50rpx;\r\n  height: 50rpx;\r\n}\r\n\r\n.footer {\r\n  position: absolute;\r\n  left: 0;\r\n  bottom: 0;\r\n  width: 100%;\r\n}\r\n\r\n.no-data{\r\n  width: 100%;\r\n  font-size: 32rpx;\r\n  text-align: center;\r\n  padding: 40rpx 0;\r\n}\r\n复制代码\r\nuserSelect.json\r\n\r\n{\r\n  \"usingComponents\": {\r\n    \"footer\": \"footer/footer\"\r\n  }\r\n}\r\n复制代码footer 的代码\r\n\r\nfooter.js\r\n\r\n\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    list: {\r\n      type: Array\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n    \r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    delete(res){\r\n      console.log(res)\r\n      let index = res.currentTarget.id\r\n      let list = this.data.list\r\n      list.splice(index,1)\r\n      this.setData({list: list})\r\n      this.triggerEvent(\"delete\", {selectList: list})\r\n    },\r\n\r\n    /**\r\n     * 点击确定按钮\r\n     */\r\n    confirm(){\r\n      this.triggerEvent(\"submit\", \"\")\r\n    }\r\n  }\r\n})\r\n复制代码\r\nfooter.wxml\r\n\r\n<view class='container'>\r\n  <view class='scroll-wrapper'>\r\n    <scroll-view scroll-x style='scroll'>\r\n      <text id='{{index}}' class='text' wx:for='{{list}}' wx:key='{{index}}' bindtap='delete'>{{item.name}}</text>\r\n    </scroll-view>\r\n  </view>\r\n  <text class='btn' bindtap='confirm'>确定</text>\r\n</view>\r\n复制代码\r\nfooter.wxss\r\n\r\n.container {\r\n  width: 100%;\r\n  height: 100rpx;\r\n  display: flex;\r\n  flex-direction: row;\r\n  padding: 20rpx;\r\n  box-sizing: border-box;\r\n  background-color: #fff;\r\n  align-items: center;\r\n  overflow-x: hidden;\r\n  white-space: nowrap;\r\n  border-top: 2rpx solid rgba(7, 17, 27, 0.1)\r\n}\r\n\r\n.scroll-wrapper {\r\n  flex: 1;\r\n  overflow-x: hidden;\r\n  white-space: nowrap;\r\n}\r\n\r\n.scroll {\r\n  width: 100%;\r\n\r\n}\r\n\r\n.text {\r\n  font-size: 32rpx;\r\n  color: #333;\r\n  padding: 40rpx 20rpx;\r\n  margin-right: 10rpx;\r\n  background-color: #f5f5f5;\r\n}\r\n\r\n.btn {\r\n  padding: 10rpx 20rpx;\r\n  background-color: rgb(26, 173, 25);\r\n  border-radius: 10rpx;\r\n  font-size: 32rpx;\r\n  color: #fff;\r\n}\r\n复制代码\r\nfooter.json\r\n\r\n{\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}\r\n复制代码再补一个用到的 ArrayUtils 的代码\r\nexport default{\r\n\r\n  /**\r\n     * 给数组去重\r\n     */\r\n  checkRepeat(list) {\r\n    let noRepList = [list[0]]\r\n    for (let i = 0; i < list.length; i++) {\r\n      let repeat = false\r\n      for (let j = 0; j < noRepList.length; j++) {\r\n        if (noRepList[j].id === list[i].id) {\r\n          repeat = true\r\n          break\r\n        }\r\n      }\r\n      if (!repeat) {\r\n        noRepList.push(list[i])\r\n      }\r\n    }\r\n    return noRepList\r\n  },\r\n\r\n  //删除list中id为 delId 的元素\r\n  deleteItemById(list, delId){\r\n    for (let i = 0; i < list.length; i++) {\r\n      if (list[i].id == delId) {\r\n        list.splice(i, 1)\r\n        return list;\r\n      }\r\n    }\r\n    return list;\r\n  }\r\n\r\n}\r\n复制代码由于时间紧张，还没有把这个控件单独从项目中抽出来写个 Demo，有时间了会给 github 地址的。\r\n代码还有很多可以优化的地方，比如有几个方法太长了，不符合单一职责原则等等，不想改了，以后再优化吧。。\r\n水平有限，各位大侠请轻喷~\r\n有问题或发现 Bug 请在评论区留言，毕竟刚写完就分享出来了，还没经过严格的测试。不过应该没什么大的问题。。。有些细节可能没注意到。\r\n关注下面的标签，发现更多相似文章作者：solocoder链接：https://juejin.im/post/5bd3ec0551882528382d8028"}
{"title": "小程序·云开发初级FAQ ", "author": "Rolan", "pub_time": "2018-10-30 00:23", "article_content": "之前参加过小程序·云开发相关的分享, 在团队内进行了推广, 感觉官方的宣传不够直接, 还是太玄乎了, 这是收集了猫眼娱乐前端工程师的问题, 和相关答疑, 部分问题是和小程序·云开发的同学沟通过的结论主要面向初级前端工程师, 快速了解云开发是怎么回事, 不涉及复杂代码有小程序开发经验理解 server 端基础, 并有少量node.js server端经验1. 小程序云开发是什么?官方文档, 不用着急点, 下面FAQ未提及的可以进来看主要提供两种能力1.1 提供持久存储持久存储是指删除微信或更换手机后, 用户重新打开我们的小程序, 仍旧能让用户看到自己的信息主要通过两种存储容器类mangodb的 数据库存储 , 比如用户提交的文章文件存储 , 比如用户上传的照片1.2 提供简化的server端编程环境云函数简单解释: 在小程序端写上函数名 + 参数, 就能调用远端的一个函数为什么不直接写到小程序端, 而要绕弯子要这样? 最常见的原因是:有些业务逻辑涉及 保密信息 , 不能写在小程序上, 比如: 价格计算, 交易流程有些操作需要 更高的权限 , 比如: 管理员可以删除所有用户的数据.桥接到第三方接口, 小程序https接口域名数量超限, 或者第三方接口不是https接口.2. 直接操作数据库会不会有安全问题云开发的数据库和传统数据库有些区别, 他会自动给每个数据表增加一个 创建人字段 + 表权限设置 , 后续的操作都会基于这些约束, 一般的策略是每个用户只能修改自己创建的信息, 比如自己发的文章每个用户只能读取其他用户的信息, 但不能修改, 比如其他人发的文章每个用户只能读取公共信息, 但不能修改, 比如公告信息, 一般会允许通过管理端修改3. 直接操作文件存储会不会有安全风险类似上一个数据库的权限, 通过 文件创建人 + 文件夹权限设置文件的操作使用服务端生成的唯一ID, 不会被穷举4. 别人会不会调用我的云函数不会, 云函数的网络协议是私有的, 并且有加上数字签名验证这套机制是在微信app内部实现的, 除非微信这套机制被攻破5.云函数是用js写么, 运行环境是什么?是js, 运行环境是nodejs 8.9, 支持async await关键字目前还不支持修改运行环境, 未来应该会支持自选环境6. 使用了云开发, 是不是就不能使用自己的服务端了不是, 两个可以并存, 就当是看起来不一样的异步调用就好// 云开发相关api\r\nwx.cloud.xxxx()\r\n\r\n// 自有服务\r\nwx.request()\r\n复制代码由于是nodejs的运行环境, 所以云函数可以使用http tcp模块, 这样就能通过云函数转发请求到任意域名, 不受小程序端的请求域名限制7. 典型的云函数是什么样的?// 小程序端, 调用\r\nwx.cloud.callFunction({\r\n    name: 'foo',\r\n    data: { a: 1, b: 2 },\r\n    success: function(res) {\r\n        console.log(res.result)\r\n    }\r\n)\r\n\r\n// 云函数, 声明\r\n// cloudfunctionRoot/functions/foo/index.js\r\nexports.main = async function(e, ctx) {\r\n    return e.a + e.b\r\n}\r\n复制代码函数名和目录名对应, 根路径在project.config.json中定义, 详细参考官方文档中的\"我的第一个云函数\"8. 云函数还有什么特殊能力?直接获取用户的openId// index.js\r\nexports.main = (event, context) => {\r\n  return event.userInfo\r\n}\r\n复制代码如要获取用户头像 昵称等信息, 还是需要在小程序端进行授权才行9. 云函数需要我们考虑服务器运维的工作么不需要, 只要开发好上传就行, 运行环境是独立 封闭的, 类 CentOS 7 的环境10. 开发时和线上环境有隔离么提供1个生产环境, 和1个开发环境, 存储和云函数都是独立的这意味着多个开发者并行开发协作可能会有些小麻烦, 同时只能有一套代码在开发环境, 这就只能通过一些工作流程约定, 比如收敛上传权限, 每日自动部署. 应用类似git-flow的分支策略11. 云开发是否提供有定位 地理信息 支付相关业务的支持暂时没有, 这方面的需求还是很强的, 毕竟小程序是提倡线下扫码, 扫码后还是期望能够获取到附近的相关信息, 简单的比如城市 区划, 详细的比如商家小程序云开发的同学目前还在收集这方面的需求12. 什么版本的基础库支持云开发基础库 2.2.3 之后开始支持, 但对于旧版本可以加个配置也能支持app.json/game.json{\r\n  \"cloud\": true\r\n}\r\n复制代码13. 费用呢目前免费, 正在调研计费策略, 可能是按照调用量, 存储量计费netwjx曹宇   https://juejin.im/post/5bcd5df7518825780d09b145"}
{"title": "微信小程序多层嵌套循环，三级数组遍历 ", "author": "Rolan", "pub_time": "2018-10-30 00:32", "article_content": "数据：三层嵌套index.wxml 页面<!-- 菜单标签 -->\r\n<view class='menu_label'>\r\n    <view class='label_ul'>\r\n        <view wx:for=\"{{ menuList }}\" wx:key='' class=\"{{ label_index == index ? 'label_lis' : 'label_li' }}\" bindtap='menuList' id=\"{{ index }}\">{{ item.title }}</view>\r\n    </view>\r\n</view>\r\n\r\n<!-- 图书内容 -->\r\n<view class='book_sec'>\r\n    <view class='book_ul' wx:for=\"{{ bookUl }}\" wx:key='' wx:for-item=\"secUl\"  wx:if=\"{{ label_index == index }}\" id=\"{{ index }}\">\r\n        <view class='book_li' wx:for='{{ secUl.bookSec }}' wx:key='' wx:for-item=\"secLi\">\r\n            <view class='book_ol'>\r\n                <view class='book_ol_li' wx:for='{{ secLi.bookList }}' wx:key='' wx:for-item=\"item\">\r\n                    <view class='book_free b'>免费阅读</view>\r\n                    <image src='{{ item.img }}'></image>\r\n                    <view class='book_people b'>100006人在读</view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n    </view>\r\n</view>\r\n\r\n\r\nindex.js页面Page({\r\n        /**\r\n         * 页面的初始数据\r\n         */\r\n        data: {\r\n            menuList: [\r\n                { title: '全部' },\r\n                { title: '文学' },\r\n                { title: '技术类' },\r\n                { title: '社会科学' },\r\n                { title: '设计' },\r\n                { title: '技术类' },\r\n                { title: '社会科学' },\r\n            ],\r\n            label_index: 0,\r\n            bookUl: [\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img1_icon.png' },\r\n                                { img: '../../img/img2_icon.png' },\r\n                                { img: '../../img/img3_icon.png' },\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img4_icon.png' },\r\n                                { img: '../../img/img5_icon.png' },\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img6_icon.png' },\r\n                                { img: '../../img/img5_icon.png' },\r\n                                { img: '../../img/img4_icon.png' }\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img7_icon.png' }\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n                {\r\n                    bookSec: [\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img7_icon.png' },\r\n                                { img: '../../img/img2_icon.png' },\r\n                                { img: '../../img/img1_icon.png' },\r\n                            ]\r\n                        },\r\n                        {\r\n                            bookList: [\r\n                                { img: '../../img/img3_icon.png' },\r\n                                { img: '../../img/img4_icon.png' },\r\n                                { img: '../../img/img6_icon.png' }\r\n                            ]\r\n                        }\r\n                    ]\r\n                },\r\n            ]\r\n            \r\n            /**\r\n             * 菜单点击切换内容\r\n             */\r\n        \r\n            menuList: function (e) {\r\n                let that = this;\r\n                // console.log(e);\r\n                var id = e.target.id;\r\n                \r\n                that.setData({\r\n                    label_index: id\r\n                })\r\n            } \r\n        },\r\n    })\r\n\r\n如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <input/> 中的输入内容，<switch/> 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。wx:key 的值以两种形式提供1）字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。2）保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。最后效果图作者：MRZYD原文：https://segmentfault.com/a/1190000016818075"}
{"title": "微信小程序之animation底部弹窗动画（两种方法） ", "author": "Rolan", "pub_time": "2018-10-31 00:26", "article_content": "简单分享一下常用的底部弹窗层或下拉框弹出层（代码需要修改）的内容弹窗的动画效果，这里分享的是点击按钮后底部弹窗的动画效果。第一种方式是动态设置显示区域的高度，第二种方法是动态设置显示区域的移动的位置（使用到 transform:translateY ）；（一）实现效果简单说明一下，两种方法实现的效果是一样的，只有点击按钮才能出发弹窗（指定位置），弹窗弹出后，只有点击背景灰色区域弹窗才能收回，点击弹窗内容区域（粉红色部分是不能收回弹窗的），自己可以自定义粉红色部分右上角关闭按钮。（二）实现分析第一种动态设置高度的方法是：需要一个容器为背景色（灰色区域），一个容器为弹窗内容（粉红色区域），两者是独立的，实现的原理是一样的；粉红色区域的话，就是设置好绝对位置（在屏幕的底部）和默认内容的区域样式，动态设置内容区域的高度，比如弹出：一开始高度为0（隐藏了），通过animation设置的动画时间，将高度从0到指定高度，内容慢慢就会显示了，然后保留最后一帧的动画样式就行了；收缩也是一样的道理。第二种动态设置位置的方法是：需要一个容器为背景色（灰色区域），一个容器为弹窗内容（粉红色区域），两者是独立的，实现的原理是一样的；粉红色区域的话，就是设置好绝对位置（在屏幕的底部）和默认内容的区域样式，比如弹出：一开始粉红色区域的位置平移在屏幕外（隐藏了），通过animation设置的动画时间，将粉红色区域从屏幕外平移到屏幕内（默认设置在屏幕底部的位置），内容慢慢就会显示了，然后保留最后一帧的动画样式就行了；收缩也是一样的道理。 代码也有注释哈。（三）实现代码第一种动态设置高度方法实现：1、wxml代码：<button catchtap='clickPup'>点击底部动画弹窗</button>\r\n\r\n<!-- 底部弹窗动画的内容 -->\r\n<view class='pupContent {{click? \"showContent\": \"hideContent\"}} {{option? \"open\": \"close\"}}' hover-stop-propagation='true'>\r\n  <view class='pupContent-top'>测试一下</view>\r\n</view>\r\n<!-- 固定的背景 -->\r\n<view class='pupContentBG {{click?\"showBG\":\"hideBG\"}} {{option?\"openBG\":\"closeBG\"}}' catchtap='clickPup'>\r\n</view>\r\n复制代码2、wxss代码：.pupContentBG {\r\n  width: 100vw;\r\n  height: 100vh;\r\n  position: fixed;\r\n  top: 0;\r\n}\r\n\r\n.pupContent {\r\n  width: 100%;\r\n  background: pink;\r\n  position: absolute;\r\n  bottom: 0;\r\n  box-shadow: 0 0 10rpx #333;\r\n  height: 0;\r\n  z-index: 999;\r\n}\r\n\r\n/* 设置显示的背景 */\r\n\r\n.showBG {\r\n  display: block;\r\n}\r\n\r\n.hideBG {\r\n  display: none;\r\n}\r\n\r\n/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideBGtUp {\r\n  from {\r\n    background: transparent;\r\n  }\r\n\r\n  to {\r\n    background: rgba(0, 0, 0, 0.1);\r\n  }\r\n}\r\n\r\n@keyframes slideBGDown {\r\n  from {\r\n    background: rgba(0, 0, 0, 0.1);\r\n  }\r\n\r\n  to {\r\n    background: transparent;\r\n  }\r\n}\r\n\r\n/* 显示或关闭内容时动画 */\r\n\r\n.openBG {\r\n  animation: slideBGtUp 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n.closeBG {\r\n  animation: slideBGDown 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n/* 设置显示内容 */\r\n\r\n.showContent {\r\n  display: block;\r\n}\r\n\r\n.hideContent {\r\n  display: none;\r\n}\r\n\r\n/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideContentUp {\r\n  from {\r\n    height: 0;\r\n  }\r\n\r\n  to {\r\n    height: 800rpx;\r\n  }\r\n}\r\n\r\n@keyframes slideContentDown {\r\n  from {\r\n    height: 800rpx;\r\n  }\r\n\r\n  to {\r\n    height: 0;\r\n  }\r\n}\r\n\r\n/* 显示或关闭内容时动画 */\r\n\r\n.open {\r\n  animation: slideContentUp 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n.close {\r\n  animation: slideContentDown 0.5s ease-in both;\r\n  /* animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。 */\r\n}\r\n\r\n复制代码3、js代码：data: {\r\n    click: false, //是否显示弹窗内容\r\n    option: false, //显示弹窗或关闭弹窗的操作动画\r\n  },\r\n\r\n  // 用户点击显示弹窗\r\n  clickPup: function() {\r\n    let _that = this;\r\n    if (!_that.data.click) {\r\n      _that.setData({\r\n        click: true,\r\n      })\r\n    }\r\n\r\n    if (_that.data.option) {\r\n      _that.setData({\r\n        option: false,\r\n      })\r\n\r\n      // 关闭显示弹窗动画的内容，不设置的话会出现：点击任何地方都会出现弹窗，就不是指定位置点击出现弹窗了\r\n      setTimeout(() => {\r\n        _that.setData({\r\n          click: false,\r\n        })\r\n      }, 500)\r\n\r\n\r\n    } else {\r\n      _that.setData({\r\n        option: true\r\n      })\r\n    }\r\n  },\r\n\r\n复制代码第二种动态平移内容区域位置方法实现：相对于第一种代码修改的部分：只修改的了粉红色区域的高度和粉红色区域弹出和收回的动画效果：/* 弹出或关闭动画来动态设置内容高度 */\r\n\r\n@keyframes slideContentUp {\r\n  from {\r\n    transform: translateY(100%); /*设置为正数则底部弹出来，负数则相反*/\r\n  }\r\n\r\n  to {\r\n    transform: translateY(0%);\r\n  }\r\n}\r\n\r\n@keyframes slideContentDown {\r\n  from {\r\n    transform: translateY(0%);\r\n  }\r\n\r\n  to {\r\n    transform: translateY(100%);\r\n  }\r\n}\r\n复制代码参考资料：CSS3（三）Animation 入门详解微信小程序CSS3动画下拉菜单感谢阅读。"}
{"title": "小程序的全栈开发新时代 ", "author": "Rolan", "pub_time": "2018-10-31 00:46", "article_content": "本文由heyli发表于云+社区专栏什么是小程序·云开发小程序·云开发是微信团队和腾讯云团队共同研发的一套小程序基础能力，简言之就是：云能力将会成为小程序的基础能力。整套功能是基于腾讯云全新推出的 云开发(Tencent Cloud Base)所研发出来的一套完备的小程序后台开发方案。小程序·云开发为开发者提供完整的云端流程，简化后端开发和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代。该解决方案目前提供三大基础能力支持：存储：在小程序前端直接上传/下载云端文件，在小程序云控制台可视化管理数据库：一个既可在小程序前端操作，也能在云函数中读写的文档型数据库云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写业务逻辑代码未来，我们还会集成更多的服务能力，为小程序提供更强有力的云端支持。如何使用小程序·云开发上面就是小程序·云开发简单的使用图谱：在小程序端，直接用官方提供的接口，在云函数端，直接用官方提供的 Node SDK，就可以操作你云的资源。以前开发小程序所担忧的数据库搭建、文件系统部署，通通没有。你只需要有在小程序开发 IDE 里面的 云开发 ，开通一下，填写环境 ID ，便可以拥有小程序的云能力！当然，其实用云开发，并不排斥原有的后台架构，通过下面的架构，你也可以无缝与原有的后台服务兼容，也简化了一些小程序鉴权的逻辑：接下来，我会分别从小程序端、服务端讲述如何使用这些云资源。使用云能力小程序端客户端，这里是指在小程序端中。如果要使用云开发能力，请做以下配置：在 app.json / game.json 中， 中增加字段 \"cloud\": trueproject.config.json 中增加了字段 cloudfunctionRoot 用于指定存放云函数的目录初始化云开发能力：//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    wx.cloud.init({\r\n        traceUser: true // 用户信息会显示在云开发控制台的用户面板中\r\n    });\r\n  }\r\n});小程序端初始化能力文档在用户管理中会显示使用云能力的小程序的访问用户列表，默认以访问时间倒叙排列，访问时间的触发点是在小程序端调用 wx.cloud.init 方法，且其中的 traceUser 参数传值为 true 。服务端如果你想在云函数中，操作文件、数据库和云函数资源，你可以使用我们提供的服务端 SDK 进行操作。首先，进入到你的某个云函数中，安装以下依赖包：npm i --save tcb-admin-node在云函数中初始化// 初始化示例\r\nconst app = require('tcb-admin-node');\r\n\r\n// 初始化资源\r\n// 云函数下不需要secretId和secretKey。\r\n// env如果不指定将使用默认环境\r\napp.init({\r\n  secretId: 'xxxxx',\r\n  secretKey: 'xxxx', \r\n  env: 'xxx'\r\n});\r\n\r\n//云函数下使用默认环境\r\napp.init()\r\n\r\n//云函数下指定环境\r\napp.init({\r\n  env: 'xxx'\r\n});服务端初始化文档存储云开发提供存储空间、上传文件、下载文件、CDN加速文件访问等能力,开发者可以在小程序端与服务端通过 API 使用这些能力。小程序端// 选择图片\r\nwx.chooseImage({\r\n    success: dRes => {\r\n        // 上传图片\r\n        const uploadTask = wx.cloud.uploadFile({\r\n            cloudPath: `${Date.now()}-${Math.floor(Math.random(0, 1) * 10000000)}.png`, // 随机图片名\r\n            filePath: dRes.tempFilePaths[0], // 本地的图片路径\r\n            success: console.log,\r\n            fail: console.error\r\n        });\r\n    },\r\n    fail: console.error,\r\n});小程序端存储文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\n\r\napp.uploadFile({\r\n    cloudPath: \"cover.png\",\r\n    fileContent: fs.createReadStream(`${__dirname}/cover.png`)\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});;控制台上传好的文件，就会出现在控制台中，如下图。你可以在控制台里删除、下载或者查看图片的详情。你还可以控文件整体的权限，这里还有一些具体的介绍。服务端存储文档数据库小程序云提供文档型数据库 ( document-oriented database )，数据库包含多个集合（相当于关系型数据中的表），集合近似于一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 文档。每条记录都有一个 _id 字段用以唯一标志这条记录、一个 _openid 字段用以标志记录的创建者，即小程序的用户。开发者可以自定义 _id ，但不可在小程序端自定义（在服务端可以） _openid 。 _openid 是在文档创建时由系统根据小程序用户默认创建的，开发者可使用其来标识和定位文档。数据库 API 分为小程序端和服务端两部分，小程序端 API 拥有严格的调用权限控制，开发者可在小程序内直接调用 API 进行非敏感数据的操作。对于有更高安全要求的数据，可在云函数内通过服务端 API 进行操作。云函数的环境是与客户端完全隔离的，在云函数上可以私密且安全的操作数据库。数据库 API 包含增删改查的能力，使用 API 操作数据库只需三步：获取数据库引用、构造查询/更新条件、发出请求。切记，在操作数据库前，请先在控制台中创建 collection 。小程序端const db = wx.cloud.database();\r\n\r\n// 插入数据\r\ndb.collection('photo').add({\r\n    data: {\r\n        photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n        title: '风景'\r\n    }\r\n});\r\n\r\n// 提取数据\r\ndb.collection('photo').get().then((res) => {\r\n    let data = res.data;\r\n    console.log(data);\r\n});\r\n\r\n// 输出\r\n// 在小程序端， _openid 会自动插入到数据库中\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1212341'\r\n}小程序端数据库文档服务端const app = require('tcb-admin-node');\r\napp.init();\r\nconst db = app.database();\r\n\r\ndb.collection('photo').limit(10).get().then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});\r\n\r\n// 输出\r\n// 因为是在服务端，其它用户的也可以提取出来\r\n{\r\n    photo: 'cloud://tcb-xxx/05ca1d38f86f90d66d4751a730379dfa6584dde05ab4-Ma9vMN_fw658.jpg',\r\n    title: '风景',\r\n    _openid: 'oLlMr5FICCQJV-QgVLVzKu1342121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/0dc3e66fd6b53641e328e091ccb3b9c4e53874232e6bf-ZxSfee_fw658.jpg',\r\n    title: '美女',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu12452121'\r\n}\r\n{\r\n    photo: 'cloud://tcb-xxx/104b27e339bdc93c0da15a47aa546b6e9c0e3359c315-L8Px2Y_fw658.jpg',\r\n    title: '动物',\r\n    _openid: 'DFDFEX343xxdf-QgVLVzKu1342121'\r\n}服务端数据库文档控制台可以在控制台里，看到用户操作的数据，你也可以自己在控制台上添加、更新或删除数据。如果数据量庞大，可以设置索引提供查询的效率。数据库也可以通过设置权限，管控每个 collection 。云函数云函数是一段运行在云端的代码，无需管理服务器，在开发工具内一键上传部署即可运行后端代码。开发者可以在云函数内获取到每次调用的上下文（ appid 、 openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（ openid ）。小程序端wx.cloud.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then(res => {\r\n    console.log(res)\r\n}).catch((err) => {\r\n    console.error(err);\r\n});小程序端云函数文档服务端const app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\napp.callFunction({\r\n    name: 'addblog', // 云函数名称\r\n    data: { // 传到云函数处理的参数\r\n        title: '云开发 TCB',\r\n        content: '存储、数据库存、云函数'\r\n    }\r\n}).then((res) => {\r\n    console.log(res);\r\n}).catch((err) => {\r\n    console.error(err);\r\n});服务端云函数文档控制台上传好之后的云函数，都会在这里罗列出来。每次调用云函数，都可以在这里看到日志，还可以构造测试的参数，用于调试。语法糖大部份的接口，目前都支持两种写法，分别是Promise 和 Async/Await，本节以 callFunction作为例子，在 云函数 中介绍这两种写法。 Async/Awai t 本质上是基于 Promise 的一种语法糖，它只是把 Promise 转换成同步的写法而已。Promiseconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = (event, context, callback) => {\r\n    app.callFunction({\r\n        name: 'addblog', // 云函数名称\r\n        data: { // 传到云函数处理的参数\r\n            title: '云开发 TCB',\r\n            content: '存储、数据库存、云函数'\r\n        }\r\n    }).then((res) => {\r\n        console.log(res);\r\n        callback(null, res.data);\r\n    }).catch((err) => {\r\n        callback(err);\r\n    });\r\n};Async/Awaitconst app = require(\"tcb-admin-node\");\r\napp.init();\r\n\r\nexports.main = async (event, context) => {\r\n    let result = null;\r\n\r\n    try {\r\n        result = await app.callFunction({\r\n            name: 'addblog', // 云函数名称\r\n            data: { // 传到云函数处理的参数\r\n                title: '云开发 TCB',\r\n                content: '存储、数据库存、云函数'\r\n            }\r\n        });\r\n    }\r\n    catch (e) {\r\n        return e;\r\n    }\r\n\r\n    return result;\r\n};在云函数里使用，由于是 Node 8.9 或以上的环境，因此天然支持 Async/Await 诘法，但在小程端要使用的话，需要额外引入 Polyfill ，比如这个开源的项目： regenerator开发者资源由于小程序·云开发是基于腾讯云的云开发开发的功能，因此在腾讯云与小程序两边都有不少的开发者资源，这里供大家参阅读：腾讯云开发者资源及文档腾讯云云开发平台官方 Github微信小程序·云开发文档"}
{"title": "小程序tabbar这套方案全搞定！ ", "author": "Rolan", "pub_time": "2018-10-31 00:12", "article_content": "关于微信小程序的tarbar，相信你们都不会陌生 在实现小程序微信原装的tabbar却比较呆板，不够精致，往往不符合自己的要求这个时候怎么办呢这套方案接着！先简单的来说一下主要思想:自定义字体图标组件以及tabbar组件，在tabbar中引用自定义字体图标组件。先说一下这套方案的优点：图片换成字体,体积小,请求减少,性能提高自己定义tabbar,能够从细节各方面达到自己的要求，精确到1像素组件可以根据自己的条件来更换tabbar图标（比如你点进一个页面想把这个页面的tabbar样式自己更换） 总而言之就是自由性很大，精准性良好，能够去随心所欲的打造你的专属tabbar!实现这套方案核心还是自定义组件那就从这开始聊：一个自定义组件由 json wxml wxss js 4个文件组成。一个页面要引用一个组件时只需要在该页面的json配置下添加如下{\r\n//声明引用一个组件 配置好你的组件引用路径\r\n  \"usingComponents\": {\r\n    \"icon\": \"../../components/icon/index\"\r\n  }\r\n}\r\n复制代码然后再页面上添加组件的标签即可。//这样就能够在你的页面中添加组件\r\n<icon type=\"\" color=\"\" size=\"\"/>\r\n复制代码如果对于组件的定义仍有疑惑的可以参考这份文档： 官方关于自定义组件的文档OK 下面我们正式来讲这份方案：先定义字体图标组件，在阿里图标库里面挑选好你所需要的字体选择下载代码。 这里我选择的是其中的_fontclass方案，把iconfont.css内的内容拷贝到你创建的icon目录下的index.wxss3. 将该目录下index.json添加{  \r\n//声明这一组文件设为自定义组件\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}\r\n复制代码在index.wxml中定义该组件的结构<!-- 注意style里面的分号！ -->\r\n<text class=\"iconfont icon-{{type}}\" style=\"color:{{color}}; font-size:{{size}}rpx\" ></text>\r\n复制代码在js里面配置他的属性//这里定义了3个自定义属性他们通过{{}}与wxml中的数据连接起来\r\n Component({\r\n  properties: {\r\n    type: {\r\n      type: String,\r\n      value: ''\r\n    },\r\n    color: {\r\n      type: String,\r\n      value: '#000000'\r\n    },\r\n    size: {\r\n      type: Number,\r\n      value: '45'\r\n    }\r\n  }\r\n})\r\n复制代码到此，字体图标组件搞定。现在开始第二步，搞定tabbar组件。首先做在json中添加配置{\r\n  \"component\": true,\r\n  //声明对字体图标组件的引用\r\n  \"usingComponents\": {\r\n    \"icon\": \"../../components/icon/index\"\r\n  }\r\n}\r\n复制代码写wxml结构<view class=\"weibo-tabbar\" >\r\n//绑定回首页事件，此处的data-hi中的数据是为了传递到e.currentTarget.dataset.hi\r\n//通过这个数据我们可以用来判断是否处于首页，然后在js中配置可以阻扰原地跳转\r\n    <view class=\"item-left\"  bindtap=\"goHome\" data-hi=\"{{isIndex}}\">\r\n            <icon type=\"shouye\" color=\"{{isIndex?'#000000':'#b1b1b1'}}\" size=\"45\"/>\r\n            <text class=\"1\" style=\"color:{{isIndex?'#000000':'#b1b1b1'}}\">首页</text>\r\n    </view>\r\n    <block wx:if=\"{{isInner}}\">\r\n        <view class=\"item-right\" style=\"color:#b1b1b1\" bindtap=\"goShare\">\r\n        <icon type=\"fenxiang\" color=\"gray\" size=\"45\"/>\r\n            <text class=\"2\">分享</text>\r\n        </view>\r\n    </block>\r\n    <block wx:else>\r\n        <view class=\"item-right\"  bindtap=\"goInfo\" data-hi=\"{{isIndex}}\">\r\n        <icon type=\"wode\" color=\"{{isIndex?'#b1b1b1':'#000000'}}\" size=\"45\"/>\r\n            <text class=\"2\" style=\"color:{{isIndex?'#b1b1b1':'#000000'}}\">我的</text>\r\n        </view>\r\n    </block>\r\n</view>\r\n复制代码再配置js属性及方法const app = getApp();\r\nComponent({\r\n  properties: {\r\n    isIndex: { // 是否主页            \r\n      type: Boolean,\r\n      value: false,\r\n    },\r\n    isInner: { //是否内部页面\r\n      type: Boolean,\r\n      value: false,\r\n    },\r\n  },\r\n  data: {\r\n    // 这里是一些组件内部数据\r\n    someData: {}\r\n  },\r\n  methods: {\r\n    // 这里是一个自定义方法\r\n    goHome: (e) => {\r\n      // 判断是否为主页面防止原地跳转\r\n      if(!e.currentTarget.dataset.hi){\r\n        wx.redirectTo({\r\n          url: \"/pages/index/index\"\r\n        })\r\n      }\r\n    },\r\n    goShare: function () {\r\n    },\r\n    goInfo: (e) => {\r\n        if(e.currentTarget.dataset.hi){\r\n        wx.redirectTo({\r\n          url: \"/pages/info/info\"\r\n        })\r\n      }\r\n    }\r\n  }\r\n})\r\n复制代码配置样式wxss.weibo-tabbar {\r\n    bottom: 0;\r\n    height: 97rpx;\r\n    padding: 12rpx 0rpx;\r\n    display: flex;\r\n    width: 100%;\r\n    position: fixed;\r\n    background: #ffffff;\r\n    box-sizing: border-box;\r\n}\r\n//产生优雅的0.5px边框\r\n.weibo-tabbar::after {\r\n    content: \"\";\r\n    position: absolute;\r\n    width: 200%;\r\n    height: 200%;\r\n    top: 0;\r\n    left: 0;\r\n    border-top: 1rpx solid rgba(177, 177, 177, 0.4);\r\n    transform: scale(0.5);\r\n    transform-origin: 0 0;\r\n  }\r\n  //这里用flex布局，移动端flex布局确实很爽\r\n  .weibo-tabbar .item-left, .item-right{\r\n   //这里有一处坑，若不不设置他的层级变大的话\r\n   //你是点不到这个item按钮的，当然也不会产生触碰事件\r\n    z-index: 999;\r\n    width: 50%;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    flex-direction: column;\r\n    font-size: 20rpx;\r\n    color: #b1b1b1;\r\n}\r\n.shouye, .wode {\r\n    height: 45rpx;\r\n    width: 45rpx;\r\n}\r\n复制代码到此你只需要在你的页面优雅的添加一行，就能在你的页面中产生tabbar//此处isIndex是给组件的属性传输值，别属性不添加即为默认属性值\r\n<tabbar isIndex=\"true\"></tabbar>\r\n复制代码结果：哇，看了半天就出这么一个小东西！其实大道至简掌握这套方案能够适配你需要的所有tabbar他的颜色、大小、位置都可以自己掌控，重要的是这个解决方案。最后强调一下里面的一些坑按钮的样式层级z-index要提高属性值与{{}}传输的把握style=\"color:{{color}}; font-size:{{size}}\" 注意里面的;号"}
{"title": "微信小程序之物流状态时间轴 ", "author": "Rolan", "pub_time": "2018-11-1 00:16", "article_content": "一个月左右没更新博客了，最近有点懒了哈（工作上真的忙），很多工作上学习到的东西都没有及时分享出来，有点愧疚，不过自己最近一直在收集资料和学习一些新技术，最主要是想要构建自己的前端技术体系和自定义一个前端规范文档，哈哈哈。说重点啦，微信小程序里面开发的商城模块还挺多的，刚好写了一个物流状态的时间轴，简单分享一下哈。（一）实现效果真机测试的结果（图片忘记缩小了）（二）实现分析页面布局拆分：简单的说：就是父级容器下，左边的子级容器是设置绝对定位（记得父级要设置相对定位哈），然后自己调位置，中间子级容器下放三个子容器（设置时间轴线、点的样式），右边的子级容器设置； wxml代码有备注信息 。（三）实现代码1、wxml代码：<view class='g_con'>\r\n\r\n  <view class='topExpress'>\r\n\r\n    <view class='topExpress-left'>\r\n      <image src='/images/Exchange_goods_map_1.png' style='width:60rpx;height:60rpx;border-radius:50%;'></image>\r\n    </view>\r\n    <view class='topExpress-right'>\r\n      <view class='topExpress-right-top'>圆通速递</view>\r\n      <view class='topExpress-right-middle'>运单号：813291235464788594</view>\r\n      <view class='topExpress-right-bottom'>官方电话 95554 ></view>\r\n    </view>\r\n\r\n  </view>\r\n\r\n  <!-- 物流时间轴 -->\r\n  <view class='expressRecord'>\r\n\r\n\r\n    <!-- 顶部收货地址 -->\r\n    <view class='expressRecord-getAddress'>\r\n      <view class='expressRecord-top'>\r\n        <view class='getAddress-icon'>\r\n          收\r\n        </view>\r\n        <view class='getAddress-text'>[收货地址] 广东省深圳市南山区 南山街道 亿利达大厦</view>\r\n      </view>\r\n    </view>\r\n\r\n    <!-- 顶部收货地址半个时间轴线 -->\r\n    <view class='noReach-online-top-close'></view>\r\n\r\n\r\n    <!-- 单个物流记录点时间轴：当前正在进行的物流状态 -->\r\n    <view class='expressRecord-single-close'>\r\n\r\n      <!-- 左边子容器 -->\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <!-- 正在进行的时间轴上半个时间线 -->\r\n        <view class='online-top-closing'></view>\r\n        <!-- 正在进行的时间轴点 -->\r\n        <view class='dot-closing'></view>\r\n        <!-- 正在进行的时间轴下半个时间线 -->\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <!-- 右边子容器 -->\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-statusing'>运输中</view>\r\n        <view class='expressRecord-status-addressing'>武汉转运中心公司 已发出，下一站 深圳转运中心</view>\r\n      </view>\r\n\r\n      <!-- 相对父级容器绝对定位的日期 -->\r\n      <view class='expressRecord-dating'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          20:39\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n    <!-- 单个物流记录点时间轴：已经过去的物流状态 -->\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'></view>\r\n        <view class='expressRecord-status-address'>武汉转运中心公司 已收入</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          20:37\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'></view>\r\n        <view class='expressRecord-status-address'>湖北省孝感市汉川市公司 已打包</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          14:37\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <view class='online-bottom'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'>已揽件</view>\r\n        <view class='expressRecord-status-address'>湖北省孝感市汉川市公司 已收件</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          14:17\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n\r\n    <view class='expressRecord-single-close'>\r\n      <view class='expressRecord-single-noReach-online-top-close'>\r\n        <view class='online-top-close'></view>\r\n        <view class='dot-close'></view>\r\n        <!-- 起始位置，下半个时间轴线不用 -->\r\n        <view class='online-bottom-start'></view>\r\n      </view>\r\n\r\n      <view class='expressRecord-text'>\r\n        <view class='expressRecord-status'>已发货</view>\r\n        <view class='expressRecord-status-address'>卖家发货</view>\r\n      </view>\r\n\r\n      <view class='expressRecord-date'>\r\n        <view class='expressRecord-date-text'>\r\n          昨天\r\n        </view>\r\n        <view class='expressRecord-date-time'>\r\n          13:50\r\n        </view>\r\n      </view>\r\n    </view>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  </view>\r\n\r\n\r\n\r\n</view>\r\n复制代码2、wxss代码：page {\r\n  background: #f4f4f4;\r\n}\r\n\r\n.g_con {\r\n  width: 100vw;\r\n  overflow-x: hidden;\r\n}\r\n\r\n.topExpress {\r\n  width: 710rpx;\r\n  height: 155rpx;\r\n  background: #fff;\r\n  margin: 10rpx auto;\r\n  display: flex;\r\n  border-radius: 10rpx;\r\n}\r\n\r\n.topExpress-left {\r\n  width: 100rpx;\r\n  height: 100%;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n}\r\n\r\n.topExpress-right {\r\n  font-size: 26rpx;\r\n  color: #333;\r\n  display: flex;\r\n  justify-content: space-around;\r\n  flex-direction: column;\r\n  align-items: flex-start;\r\n  padding: 20rpx 0;\r\n}\r\n\r\n.topExpress-right-middle {\r\n  font-size: 22rpx;\r\n}\r\n\r\n.topExpress-right-bottom {\r\n  font-size: 20rpx;\r\n  color: #666;\r\n}\r\n\r\n.expressRecord {\r\n  width: 710rpx;\r\n  padding-top: 30rpx;\r\n  padding-bottom: 200rpx;\r\n  background: #fff;\r\n  margin: 0 auto;\r\n  border-radius: 10rpx;\r\n}\r\n\r\n.expressRecord-getAddress {\r\n  width: 100%;\r\n  font-size: 22rpx;\r\n  color: #999;\r\n  display: flex;\r\n}\r\n\r\n.expressRecord-top {\r\n  width: 100%;\r\n  display: flex;\r\n  justify-content: flex-start;\r\n  align-items: center;\r\n}\r\n\r\n.getAddress-icon {\r\n  width: 30rpx;\r\n  height: 30rpx;\r\n  border-radius: 50%;\r\n  background: #999;\r\n  font-size: 18rpx;\r\n  color: #fff;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  margin-left: 80rpx;\r\n}\r\n\r\n.getAddress-text {\r\n  margin-left: 20rpx;\r\n}\r\n\r\n.noReach-online-top-close {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #d7d7d7;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.expressRecord-single-close {\r\n  width: 100%;\r\n  height: 122rpx;\r\n  display: flex;\r\n  justify-content: flex-start;\r\n  align-items: center;\r\n  position: relative;\r\n}\r\n\r\n.expressRecord-single-noReach-online-top-close {\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n.online-top-closing {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #d7d7d7;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.online-top-close {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #999;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.dot-closing {\r\n  width: 10rpx;\r\n  height: 10rpx;\r\n  border-radius: 50%;\r\n  margin-left: 90rpx;\r\n  margin-top: 6rpx;\r\n  margin-bottom: 6rpx;\r\n  background: #fe4f33;\r\n}\r\n\r\n.dot-close {\r\n  width: 10rpx;\r\n  height: 10rpx;\r\n  border-radius: 50%;\r\n  margin-left: 90rpx;\r\n  margin-top: 6rpx;\r\n  margin-bottom: 6rpx;\r\n  background: #999;\r\n}\r\n\r\n.online-bottom {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  background: #999;\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.online-bottom-start {\r\n  width: 1rpx;\r\n  height: 50rpx;\r\n  /* background: #999; */\r\n  margin-left: 95rpx;\r\n}\r\n\r\n.expressRecord-text {\r\n  margin-left: 30rpx;\r\n}\r\n\r\n.expressRecord-statusing {\r\n  font-size: 26rpx;\r\n  color: #333;\r\n}\r\n\r\n.expressRecord-status-addressing {\r\n  font-size: 22rpx;\r\n  color: #333;\r\n}\r\n\r\n\r\n.expressRecord-status {\r\n  font-size: 26rpx;\r\n  color: #999;\r\n}\r\n\r\n.expressRecord-status-address {\r\n  font-size: 22rpx;\r\n  color: #999;\r\n}\r\n\r\n.expressRecord-dating {\r\n  position: absolute;\r\n  height: 100%;\r\n  /* top: 0;\r\n  bottom: 0; */\r\n  left: 20rpx;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  flex-direction: column;\r\n  color: #333;\r\n}\r\n\r\n.expressRecord-date {\r\n  position: absolute;\r\n  height: 100%;\r\n  /* top: 0;\r\n  bottom: 0; */\r\n  left: 20rpx;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  flex-direction: column;\r\n  color: #999;\r\n}\r\n\r\n.expressRecord-date-text {\r\n  font-size: 24rpx;\r\n}\r\n\r\n.expressRecord-date-time {\r\n  font-size: 18rpx;\r\n}\r\n\r\n复制代码如果感觉有用的话，点个赞呗，支持一下我哈。"}
{"title": "微信小程序中的ios兼容性问题 ", "author": "Rolan", "pub_time": "2018-11-1 00:32", "article_content": "1.ios中input的placeholder属性字体不居中对placeholder设置line-height及font-size对input设置高度2.ios中滚动卡顿设置-webkit-overflow-scrolling:touch;3.微信小程序中解决ios中new Date() 时间格式不兼容在实现倒计时，根据后台返回的时间格式转换时，后台返回了时间格式为”2018-11-12 11:12:11”，然后利用new Date() 转换时，ios中无法展示，安卓中显示正常let time = '2018-12-10 11:11:11';\r\nlet temporaryTime1 = new Date(time);\r\nthis.setData({\r\n   timeRemain1: temporaryTime1,\r\n})\r\n/* 利用正则表达式替换时间中的”-”为”/”即可 */\r\nlet time = '2018-12-10 11:11:11';\r\nlet temporaryTime = new Date(time.replace(/-/g,'/'));\r\nlet temporaryTime1 = new Date(time);\r\nthis.setData({\r\n    timeRemain: temporaryTime,\r\n    timeRemain1: temporaryTime1,\r\n })4. 微信小程序scroll-view隐藏滚动条方法在wxss里加入以下代码：::-webkit-scrollbar{\r\nwidth: 0;\r\nheight: 0;\r\ncolor: transparent;\r\n}暂时遇到的兼容性就是这么多，会持续更新，若大家有遇到，可在评论区告知下，感谢正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断ios和Android及PC端实现文字的省略号纯css实现瀑布流（multi-column多列及flex布局）"}
{"title": "微信小程序Markdown渲染组件wemark ", "author": "Rolan", "pub_time": "2018-11-1 00:42", "article_content": "wemark可以实现在小程序下渲染Markdown内容，支持图片、表格在内的大部分Markdown特性。特性以小程序自定义组件形式提供，可直接引入使用支持大部分markdown标记的解析、渲染支持代码表格、代码高亮、HTML视频等特性支持使用原生rich-text进行渲染兼容mpvue等开发框架使用1、下载并拷贝wemark目录到小程序根目录2、在页面的配置文件中引用wemark组件{\r\n    \"usingComponents\": {\r\n        \"wemark\": \"../wemark/wemark\"\r\n    }\r\n}\r\n\r\n3、 WXML中使用：<wemark md=\"{{md}}\" link highlight type=\"wemark\"></wemark>\r\n\r\n参数说明：md，必填，需要渲染的Markdown字符串；link，是否解析链接，如果解析，会使用小程序navigator组件展现，可在小程序内跳转，默认为false；highlight，是否对代码进行高亮处理，默认为false；type，渲染方式，wemark会使用wemark的数据结构和模板进行渲染，rich-text会使用小程序内置的rich-text组件进行渲染（不支持链接跳转、视频）。运行效果其他wemark项目地址：https://github.com/TooBug/wemark"}
{"title": "微信小程序仿微信SlideView组件slide-view ", "author": "Rolan", "pub_time": "2018-11-1 00:52", "article_content": "微信小程序仿微信SlideView组件。使用1、安装 slide-view从小程序基础库版本 2.2.1 或以上、及开发者工具 1.02.1808300 或以上开始，小程序支持使用 npm 安装第三方包。npm install --save miniprogram-slide-view\r\n\r\n2、在需要使用 slide-view 的页面 page.json 中添加 slide-view 自定义组件配置{  \r\n    \"usingComponents\": {    \r\n        \"slide-view\": \"miniprogram-slide-view\"\r\n    }\r\n}\r\n3、WXML 文件中引用 slide-view每一个 slide-view 提供两个<slot>节点，用于承载组件引用时提供的子节点。left 节点用于承载静止时 slide-view 所展示的节点，此节点的宽高应与传入 slide-view 的宽高相同。right 节点用于承载滑动时所展示的节点，其宽度应于传入 slide-view 的 slideWidth 相同。<slide-view class=\"slide\" width=\"320\" height=\"100\" slideWidth=\"200\">\r\n  <view slot=\"left\">这里是插入到组内容</view>\r\n  <view slot=\"right\">\r\n    <view>标为已读</view>\r\n    <view>删除</view>\r\n  </view>\r\n</slide-view>\r\n\r\n参数说明：width：Number类型，默认值显示屏幕的宽度，slide-view组件的宽度height：Number类型，默认值0，slide-view组件的高度slide-width：Number类型，默认值0，滑动展示区域的宽度（默认高度与slide-view相同）运行效果其他slide-view项目地址：https://github.com/wechat-min..."}
{"title": "十几行代码就可以让你的微信小程序挂掉 ", "author": "Rolan", "pub_time": "2018-11-4 23:22", "article_content": "mpvue （ github 地址请参见 ）是一个使用Vue.js 开发小程序的前端框架。框架基于 Vue.js核心， mpvue 修改了 Vue.js 的runtime 和compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。由来已久一直以来，我都在用mpvue来编写小程序应用，虽然问题很多，不过都有替代方案。比如在mpvue中，slot（插槽）中的内容不能动态的渲染，那我们可以放弃使用slot内使用动态数据。该问题在github中有多人反应。再比如在mpvue中，自定义指令会直接导致编译报错，那么我们可以放弃使用自定义指令。该问题在github中也有多人反应。但是今天的问题实在太严重，我一定要吐槽一下。bug现象我们在开发过程中，发现在某种情况下，页面UI层的更新时机全部错乱。即 数据变更后，只有在下次的onShow生命周期里有体现（有种“慢一拍”的感觉），整体的感觉就是 页面的展示和交互完全瘫痪 。bug调查我们花了整整一天的时间调查，最后发现问题是 在自定义组件上动态为v-if绑定值赋值上 。将代码精简到十几行就可以复现bug。bug再现记住，这是一个mpvue项目。我在src/pages/目录下新建一个test页面，对应的index.vue文件的代码如下，逻辑很简单，就是利用v-if控制一个组件的显示：<template>\r\n  <test v-if=\"show\"></test>\r\n</template>\r\n<script>\r\nimport test from '@/components/posterTest.vue'\r\nexport default {\r\n  data () {\r\n    return { show: true }\r\n  },\r\n  onShow () {\r\n    this.show = false    //在onShow生命周期里，先将v-if绑定值置位false，2秒再置位true\r\n    setTimeout(() => { this.show = true }, 2000)\r\n  },\r\n  components: { test }\r\n}\r\n</script>复制代码其中引入了posterTest组件。为了调查bug，我将多余的操作处理全部去掉，只有一张图片，它的代码如下：<template lang=\"html\">\r\n  <div class=\"poster\">\r\n    <img src=\"https://interactive-examples.mdn.mozilla.net/media/examples/firefox-logo.svg\" alt=\"\">\r\n  </div>\r\n</template>\r\n<script>\r\nexport default { }\r\n</script>复制代码这个页面只要一加载，2秒后控制台就会报下面的错误。而只要报了这个错误，其他页面也跟着挂了。就像前面提到的一样，结果是灾难性的——页面都挂掉了，双向绑定的更新总像慢了一拍。找到报错的代码，上面还有了一条有意添加的注释（也是vue源码的）所以我怀疑是mpvue在调度上存在问题。解决方法mpvue还是要用的，但是以后不能再用v-if来操作组件的显示了，乖乖用v-show吧。但是话说回来，vue这样的操作可是一点毛病没有的。总结作为框架，作为一个“轮子”，我觉得不应该有这样“后果严重”的bug出现。再退一步说，一个页面的bug能导致到整个应用“瘫痪”，也是很恐怖的。还是要感谢mpvue为我们带来的种种方便。"}
{"title": "微信小程序性能优化方案——让你的小程序如此丝滑 ", "author": "Rolan", "pub_time": "2018-11-4 23:42", "article_content": "首先，问一个问题，当用户点击小程序后发生了什么？上图中的三个状态，我们经常遇到，它们分别对应小程序的下面三个状态：有三个点的白屏（左侧）： 下载代码包的阶段没有三个点的白屏（中间）： 业务代码注入和渲染的阶段加载中（右边）： 业务代码中异步请求数据总的来说，小程序呈现到用户面前，实际上经历了下面两个阶段：运行环境的加载下载代码包下面具体介绍这两个阶段：运行环境预加载这步是微信做的。微信会在用户打开小程序之前就已经准备好环境，用户点击小程序入口后，直接下载小程序的代码包即可。下载代码包启动小程序小程序代码包里面的代码，不是小程序的源代码，而是编译、压缩、打包之后的代码包。下图中，左侧的“ 预加载 ”对应的是运行环境的预加载，右侧的“小程序启动” 对应的是下载代码包启动小程序。小程序提供的运行环境，分为逻辑层（AppService）和 视图层（webView），逻辑层是执行javascript的地方，视图层是渲染页面的地方。当小程序的代码包下载完毕后，业务代码分别注入逻辑层和渲染层。提升加载性能的最最最关键性一点是，控制包的大小，这个也是微信官方的说法。控制包的大小提升体验最直接的方法是 控制小程序包的大小 ，基本上可以说，1M的代码包，下载耗时1秒左右。控制包的大小的措施压缩代码，清理无用的代码图片放在cdn采用分包策略分包预加载独立分包（版本要求有点高）除了上面讲的控制包的大小，对异步请求的优化也很重要。对异步请求的优化onLoad 阶段就可以发起请求，不用等ready请求结果放在缓存中, 下次接着用请求中可以先展示骨架图先反馈，再请求。比如说，点赞的按钮，可以先改变按钮的样式，再 发起异步请求。提升渲染性能setData 干了啥每调用一次setData, 都是逻辑层向渲染层的一次通讯，这个通信还不是直接传给webView, 而是通过走了native层，通讯的开销很大。渲染层收到通讯后，还需要重新渲染出来，所以，emmm, 一次setData带来两次开销：通信的开销 + webview更新的开销。在数据传输时，逻辑层会执行一次 JSON.stringify 来去除掉 setData 数据中不可传输的部分，之后将数据发送给视图层。同时，逻辑层还会将 setData 所设置的数据字段与 data 合并，使开发者可以用 this.data 读取到变更后的数据。减少setData的数据量如果一个数据不能会影响渲染层，则不用放在setData里面合并setData的请求，减少通讯的次数这个很好理解吧列表的局部更新在一个列表中，有 n 条数据，采用上拉加载更多的方式，假如这个时候想对其中某一个数据进行点赞操作，还能及时看到点赞的效果此时，可以采用setData全局刷新，点赞完成之后，重新获取数据，再次进行全局重新渲染，这样做的优点是：方便，快捷！缺点是：用户体验极其不好，当用户刷量100多条数据后，重新渲染量大会出现空白期（没有渲染过来）如果采用布局刷新，将点赞的 id 传过去，知道点的是那一条数据, 将点赞的 id 传过去，知道点的是那一条数据。重新获取数据，查找相对应id的那条数据的下标（ index 是不会改变的），用setData进行局部刷新this.setData({\r\n    list[index] = newList[index]\r\n})\r\n复制代码小心后台页面的js小程序中可能有n个页面，所有的这些页面，虽然都拥有自己的webview(渲染层)， 但是却共享同一个js运行环境。也就是说，当你跳到了另外一个页面（假设是B页面），本页面（假设是A页面）的定时器等js操作仍在进行，并且不会被销毁，并且会抢占B页面的资源。在h5的环境中，当我们跳转到其他页面，老页面的js环境会被自动销毁，定时器什么都被销毁掉了，因此我们不需要关心老页面中，还有哪些js代码可能还会执行。但是在小程序中，我们必须手动的“清理”掉这样的代码。小心onPageScrollpageScroll 事件，也是一次通讯，是webview层向js逻辑层的通讯。这次通讯也是开销较大，如果考虑到这个事件被频繁的调用，回调函数如果有复杂的setData的话，emmmmm， 性能就会很差了。​小心获取节点位置在h5 中的环境中，为了实现懒加载、下拉加载，我们 不得不 去获取节点的位置。为啥说 不得不 ，是因为我们本可以用新的api ——intersectionObject去轻松实现（google等主流浏览器都已经支持了），但是微信的内置X5浏览器很遗憾的不支持。没想到，在小程序的环境中，微信竟然良心发现，支持intersectionObject api, 因此获取节点的信息，尽量还是用这api 吧。尽可能使用小程序组件自定义组件的更新只在组件内部进行，不受页面其他不能分内容的影响；比如一些运营活动的定时模块可以单独抽出来，做成一个定时组件，定时组件的更新并不会影响页面上其他元素的更新；各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用优化心得相比于上面的优化策略，最重要的是找出小程序中的性能瓶颈。在自己的优化实践中，遇到了下面的问题：下拉加载更多，特别特别卡，通过列表局部更新的技巧，发现性能改善不大。 后来发现，是因为首页需要监听scroll事件，导致scroll事件被频繁的触发，回调函数中有耗时操作，导致onreachBottom事件被阻塞了，也就是说，要等大概1~2秒才会去发起下一页的请求。 取消掉scroll事件的监听，原本>4s的加载时间，控制在1s之内。"}
{"title": "微信小程序里自动获得当前手机所在的经纬度并转换成地址 ", "author": "Rolan", "pub_time": "2018-11-4 23:50", "article_content": "效果：我在手机上打开微信小程序，自动显示出我当前所在的地理位置：具体步骤：1. 使用微信jssdk提供的getLocation API拿到经纬度；2. 调用高德地图的api使用经纬度去换取地址的文字描述。\r\nwx.ready(() => {\r\n\r\nwx.getLocation({\r\n\r\ntype: \"gcj02\",\r\n\r\nsuccess: function(res) {\r\n\r\nvar location =\r\n\r\n\"&location=\" + res.longitude + \",\" + res.latitude;\r\n\r\nReservationService.getGeocode(location).then(response => {\r\n\r\nif (\r\n\r\nresponse.data.status === \"1\" &&\r\n\r\nresponse.data.info === \"OK\"\r\n\r\n) {\r\n\r\nself.country =\r\n\r\nresponse.data.regeocode.addressComponent.country;\r\n\r\nself.city = response.data.regeocode.addressComponent.city;\r\n\r\nvar express =\r\n\r\n\"/\" +\r\n\r\nself.country +\r\n\r\n\"|\" +\r\n\r\nresponse.data.regeocode.addressComponent.province +\r\n\r\n\"|\" +\r\n\r\nself.city +\r\n\r\n\"|\" +\r\n\r\nresponse.data.regeocode.addressComponent.district +\r\n\r\n\"|\" +\r\n\r\nresponse.data.regeocode.addressComponent.township +\r\n\r\n\"/g\";\r\n\r\nself.address = response.data.regeocode.formatted_address.replace(\r\n\r\neval(express),\r\n\r\n\"\"\r\n\r\n);\r\n\r\n} else {\r\n\r\n// get location error, plz input address\r\n\r\nalert(\"无法获取地址信息,请稍后再试\");\r\n\r\n}\r\n\r\n});\r\n\r\n}\r\n\r\n});\r\nReservationService.getGeocode的实现：getGeocode(location) {const key = '此处填入您高德地图app的key';return axios.post('https://restapi.amap.com/v3/g...' + key + location);}看下面一个使用高德地图API将经纬度转换成文字描述的地址的例子，使用postman发送请求：API响应：\r\n{\r\n\r\n\"status\": \"1\",\r\n\r\n\"regeocode\": {\r\n\r\n\"addressComponent\": {\r\n\r\n\"city\": [],\r\n\r\n\"province\": \"北京市\",\r\n\r\n\"adcode\": \"110101\",\r\n\r\n\"district\": \"东城区\",\r\n\r\n\"towncode\": \"110101001000\",\r\n\r\n\"streetNumber\": {\r\n\r\n\"number\": \"44号\",\r\n\r\n\"location\": \"116.39795,39.9097239\",\r\n\r\n\"direction\": \"东北\",\r\n\r\n\"distance\": \"117.874\",\r\n\r\n\"street\": \"广场东侧路\"\r\n\r\n},\r\n\r\n\"country\": \"中国\",\r\n\r\n\"township\": \"东华门街道\",\r\n\r\n\"businessAreas\": [\r\n\r\n{\r\n\r\n\"location\": \"116.3998109423077,39.90717459615385\",\r\n\r\n\"name\": \"天安门\",\r\n\r\n\"id\": \"110101\"\r\n\r\n},\r\n\r\n{\r\n\r\n\"location\": \"116.39981058278138,39.92383706953642\",\r\n\r\n\"name\": \"景山\",\r\n\r\n\"id\": \"110101\"\r\n\r\n},\r\n\r\n{\r\n\r\n\"location\": \"116.4118112683418,39.91461494422115\",\r\n\r\n\"name\": \"王府井\",\r\n\r\n\"id\": \"110101\"\r\n\r\n}\r\n\r\n],\r\n\r\n\"building\": {\r\n\r\n\"name\": \"天安门\",\r\n\r\n\"type\": \"风景名胜;风景名胜相关;旅游景点\"\r\n\r\n},\r\n\r\n\"neighborhood\": {\r\n\r\n\"name\": [],\r\n\r\n\"type\": []\r\n\r\n},\r\n\r\n\"citycode\": \"010\"\r\n\r\n},\r\n\r\n\"formatted_address\": \"北京市东城区东华门街道天安门\"\r\n\r\n},\r\n\r\n\"info\": \"OK\",\r\n\r\n\"infocode\": \"10000\"\r\n\r\n}\r\n要获取更多Jerry的原创文章，请关注公众号\"汪子熙\""}
{"title": "mpvue小程序开发 - 生命周期梳理 ", "author": "Rolan", "pub_time": "2018-11-6 00:16", "article_content": "最近在开发小程序，尝试性地使用了一下mpvue框架。mpvue 是一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。mpvue同时维护了Vue和小程序的两套机制，因此需要对两套机制进行关联。这里主要对mpvue的生命周期来进行一些梳理。微信小程序生命周期首先我们需要了解，微信小程序的生命周期：App对象，主要有onLaunch, onShow和onHide。Page对象，主要有onLoad, onShow, onReady, onHide和onUnload。Vue到mpvuempvue的出现使得我们可以用书写Vue实例的方式去声明这两种对象，并使得Vue实例兼容小程序的生命周期。Vue的生命周期主要体现在8个钩子：beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestroy, destroyed。来对比一下Vue和mpvue的生命周期，看一下mpvue做出了什么改变：对比来看，mpvue主要是对created和beforeMount之间的过程做了改变。在Vue中，这个阶段主要作用是将template编译为render函数：而在mpvue中，对于App或Page组件（这里的Is App or Page component应该要解释为“是否为App或Page组件”），为他们初始化小程序的生命周期，并注册App对象或Page对象：这里可以看出来，mpvue中，Vue和小程序生命周期钩子触发的基本顺序是beforeCreate -> created -> onLaunch/onLoad -> onShow -> onReady -> beforeMount -> mounted -> ...实践验证这里有一个入口页面，包含一个通过wx.navigateTo跳转到newPage的按钮。newPage中包含一个card组件，和一个通过wx.navigateBack跳转回入口页面的按钮。在App, newPage和card的各个生命周期钩子输出信息，来观察它们的触发情况和顺序。在App被创建，跳转到newPage前我们可以观察到，app对象首先被创建，触发onLaunch和onShow。在这之后，newPage被create。需要注意的是，此时我们还没有跳转到newPage，也就是说在mpvue中，无论页面是否被访问到，其Vue实例的beforeCreate和created都在app创建后就被触发。第一次跳转到newPage并返回入口页面由于newPage页面的beforeCreate和created已经提前被触发过了，在调用了wx.NavigateTo跳转到newPage时，先触发小程序的生命周期，再触发beforeMount，这时候开始创建子组件card的实例，按照beforeCreate -> created -> onLoad -> onReady -> beforeMount -> mounted 的顺序触发生命周期钩子。（这里组件的onShow为什么没有触发..需要再深入探究一下）在wx.navigateBack时，小程序的生命周期钩子onUnload被触发。但需要注意的是：Vue的生命周期钩子beforeDestroy和destroyed并没有被触发，也就是说小程序中newPage的page对象被卸载了，但newPage和card的Vue实例并没有被销毁。第二次跳转到newPage并返回入口页面newPage和card都已经被create且没有destroy，在再次wx.navigateTo时将直接从onLoad -> onShow -> onReady开始触发，newPage的mount和update过程也会出发，而component之后update过程被触发了。这里可以发现，在onLoad之后还经过了几个阶段，才开始触发Vue实例的生命周期钩子，而上一次保存在内存中的数据并没有被destroy，因此在重新加载的过程中，Vue实例还保存着上一次加载页面时的数据。开发时遇到的问题遇到的问题主要是由create过程在页面加载前就被统一触发引起的。 在使用Vue时，经常在created钩子中获得新的data。因为此时对data的数据观测已经被建立，但是页面内容尚未被挂载，Vue实例可以观测到data的变化并在视图显示出来之前改变其内容。如果在mpvue中，我们想获取页面路由query中的数据，或是想在页面创建时请求接口，我们可能会这样考虑：在created中获取数据？ 在mpvue中，created只被触发一次，且在页面创建前被触发，也就是说query中的数据是无法获得的，再次访问页面时如果数据发生了变化，created中的逻辑也并不会再次执行。推迟到beforeMount？ 从功能上说，在beforeMount获取数据是没有问题的。但由于页面unload时没有触发destroy，在再次加载页面时，Vue实例仍然保存着前一次获得的数据，而页面的onLoad、onShow均在beforeMount之前被触发，实践时会发现，页面在数据更新之前就会被显示出来，旧的数据会在页面中“一闪而过”。在onLoad中获取数据？ 实践证明这的确是一种最稳妥的方法，数据能被正确地设置，页面也不会“闪”。 但是官方文档有这样一句话： 除特殊情况外，不建议使用小程序的生命周期钩子。 这里大概是为了代码的移植性做考虑吧，不知道这里算不算特殊情况呢。使用computed？ 为了避免使用小程序的生命周期钩子，还可以考虑使用computed的来获取query中的内容，而query需要在页面onLoad之后才存在，这里需要注意做一些判断。总结从Vue过度到mpvue还是非常平滑的，特别是在有过小程序开发经验的情况下。但是由于小程序本身和浏览器的差异，使得开发过程中会遇到一些难以理解的问题，将生命周期做一下梳理对更顺利地进行开发是有一些好处的。但是，从这里也可以看到，对于开发小程序来说，mpvue实际上额外地维护了一套Vue的机制，并对小程序的事件、数据进行代理、同步，实际上这个过程可能会造成一些性能上的损耗。再加上mpvue目前还是存在一些缺陷，而小程序也支持了数据绑定、组件化开发，个人认为若是追求高质量的开发还是直接使用原生小程序更优吧~"}
{"title": "利用云开发优化博客小程序（三）——生成海报功能 ", "author": "Rolan", "pub_time": "2018-10-17 00:52", "article_content": "欠下的生成海报的功能终于补上了周末花了点时间把小程序版博客中的生成海报的功能给完成了，对于新手的我来说遇到的问题还是挺多的，这里简单记录下坑。首先看下效果图：思路还是比较简单，主要就是利用微信提供的画布 canvas 来动态构造海报。引导用户保存至本地相册，用于分享。主要涉及小程序画布和图片相关的API，若是不太熟悉的话可以优先参考下文档。资源准备首先需要准备构成海报的一些资源，比如文章的首图，标题，需要分享的小程序码。对于文章的首图，是从腾讯云的对象存储中获取，需要在开发设置中配置好 downloadFile合法域名 ,至于为什么转战腾讯云对象存储可以参考 免费的对象存储——七牛云还是腾讯云获取图片可直接通过 wx.getImageInfo ,对应的API还是比较简单的：wx.getImageInfo({\r\n  src: url,\r\n  success (res) {\r\n    console.log(res.path)\r\n  }\r\n})至于小程序码，目前使用的是小程序本身的，暂时没有动态生成，后期会迭代。直接将小程序码上传至云存储上,获取时也比较简单：wx.cloud.downloadFile({\r\n  fileID: fileID\r\n}).then(res => {\r\n  console.log(res.tempFilePath)\r\n})最后，其他需要在海报上展现的内容，根据实际情况进行获取。生成海报资源准备完之后，就需要利用画布进行构造海报了。在wxml添加canvas元素，需要注意的是避免在页面上展示，可以将位置设置在屏幕之外，比如 top:99999rpx\r\n<view class=\"canvas-box\">\r\n  <canvas style=\"width: 600px;height: 970px;\" canvas-id=\"mycanvas\" />\r\nview>然后需要了解下canvas相关API和属性了。优先创建canvas的绘图上下文 CanvasContext 对象,然后通过CanvasContext中的属性进行绘制，最后通过 draw() 将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中。具体可以参考下面的代码，结合注释和官方文档很容易理解：var context = wx.createCanvasContext('mycanvas');\r\n    context.setFillStyle('#ffffff');//设置填充色\r\n    context.fillRect(0, 0, 600, 970);//填充一个矩形。用 setFillStyle 设置矩形的填充色\r\n    context.drawImage(postImageLocal, 0, 0, 600, 300); //绘制首图\r\n    context.drawImage(qrcodeLoal, 210, 650, 180, 180); //绘制二维码\r\n    context.setFillStyle(\"#000000\");\r\n    context.setFontSize(20);//设置字体大小\r\n    context.setTextAlign('center');//设置字体对齐\r\n    context.fillText(\"阅读文章,请长按识别二维码\", 300, 895);\r\n    context.setFillStyle(\"#000000\");\r\n    context.beginPath() //分割线\r\n    context.moveTo(30, 620)\r\n    context.lineTo(570, 620)\r\n    context.stroke();\r\n    context.setTextAlign('left');\r\n    context.setFontSize(40);\r\n\r\n    if (title.lengh <= 12) {\r\n      context.fillText(title, 40, 360);//文章标题\r\n    } else {\r\n      context.fillText(title.substring(0, 12), 40, 360);\r\n      context.fillText(title.substring(12, 26), 40, 410);\r\n    }\r\n\r\n    context.setFontSize(20);\r\n    if (custom_excerpt.lengh <= 26) {\r\n      context.fillText(custom_excerpt, 40, 470);//文章描述\r\n    } else {\r\n      context.fillText(custom_excerpt.substring(0, 26), 40, 470);\r\n      context.fillText(custom_excerpt.substring(26, 50) + '...', 40, 510);\r\n    }\r\n\r\n    context.draw();这里需要注意的是填写文字时，画布是不会自动换行的，所以这里需要根据字体大小和字体多少来自行控制换行。在填充完canvas之后，通过 wx.canvasToTempFilePath 来生成图片，并保存在临时路径下，具体代码如下：wx.canvasToTempFilePath({\r\n  canvasId: 'mycanvas',\r\n  success: function(res) {\r\n    var tempFilePath = res.tempFilePath;\r\n    wx.hideLoading();\r\n    console.log(\"海报图片路径：\" + res.tempFilePath);\r\n    that.setData({\r\n      showPosterPopup: true,//展示弹窗\r\n      showPosterImage: res.tempFilePath //对应路径\r\n    })\r\n  },\r\n  fail: function(res) {\r\n    console.log(res);\r\n  }\r\n});到这里，最简单的海报生成完成了，接下来就是涉及交互了。交互样式首先利用zanui的 zan-popup 来实现弹出层，还是比较方便的。具体样式就不贴了，可以直接看我的源码。弹出层中加载生成好的海报图片，通过按钮引导用户保存至本地相册，在保存相册时，需要用户授权本地相册的权限，这里需要做好交互，当用户拒绝之后再次想保存时，让他重新授权。当用户取消时，再次提醒：具体代码如下，供参考：/**\r\n * 保存海报图片\r\n */\r\nsavePosterImage: function() {\r\n  let that = this\r\n  wx.saveImageToPhotosAlbum({\r\n    filePath: that.data.showPosterImage,\r\n    success(result) {\r\n      console.log(result)\r\n      wx.showModal({\r\n        title: '提示',\r\n        content: '二维码海报已存入手机相册，赶快分享到朋友圈吧',\r\n        showCancel: false,\r\n        success: function(res) {\r\n          that.setData({\r\n            showPosterPopup: false\r\n          })\r\n        }\r\n      })\r\n    },\r\n    fail: function(err) {\r\n      console.log(err);\r\n      if (err.errMsg === \"saveImageToPhotosAlbum:fail auth deny\") {\r\n        console.log(\"再次发起授权\");\r\n        wx.showModal({\r\n          title: '用户未授权',\r\n          content: '如需保存海报图片到相册，需获取授权.是否在授权管理中选中“保存到相册”?',\r\n          showCancel: true,\r\n          success: function(res) {\r\n            if (res.confirm) {\r\n              console.log('用户点击确定')\r\n              wx.openSetting({\r\n                success: function success(res) {\r\n                  console.log('打开设置', res.authSetting);\r\n                  wx.openSetting({\r\n                    success(settingdata) {\r\n                      console.log(settingdata)\r\n                      if (settingdata.authSetting['scope.writePhotosAlbum']) {\r\n                        console.log('获取保存到相册权限成功');\r\n                      } else {\r\n                        console.log('获取保存到相册权限失败');\r\n                      }\r\n                    }\r\n                  })\r\n\r\n                }\r\n              });\r\n            }\r\n          }\r\n        })\r\n      }\r\n    }\r\n  });\r\n}到这里，小程序的生成海报功能基本上就完成了。总结其实生成海报的功能还有很多小问题，由于最近项目比较紧匆匆上了，后面找时间会优化。通过生成海报的功能，主要还是学习了画布的API，并通过实战也基本可以上手canvas，至于画布上排版，样式就需要自己耐心了，尤其是一些小地方。程序上线后我才发现，海报上的标题，由于有中英文，所占的字符不同，所以换行的处理过于草率了，导致有英文的标题在位置上存在偏差。后期有空的话再持续改善吧～"}
{"title": "各种小程序的组件机制差异 ", "author": "Rolan", "pub_time": "2018-10-18 00:12", "article_content": "在蚂蚁金服的开放平台上看到一些贴子，说提供一个工具，一键转换微信小程序为支付宝小程序。我与百度的人交流时，也听到相似的东西。其实都没有这么简单，它们最多是将一些循环条件分支指令改一下名，将一些文件的后缀名改一下，更多的差异点在API与各式的配置对象上，细节是魔鬼，我在娜娜奇的官网也列举了许多相关的东西，但也不能打票说已经很齐全。。。。各种小程序的差异点-文档补充一句，娜娜奇是我们公司的小程序开发框架，以React方式转译成各种小程序与快应用的框架。类似于京东的taro。最近忙于支付宝小程序的开发，我得到许多有关小程序的一手资料，包括自己测试得到的，及从百度，小米快应用与支付宝内部人士提供的。本文将重点说一下小程序的组件机制，之前娜娜奇的组件机制是基于template标签实现的，但百度的template有点BUG，给他们提了，不知现在修了没有。与template机制在快应用又出入太大，于是转向用自定义组件机制开发娜娜奇的组件机制。下面链接有一些相关的测试与说明转换小程序 · Issue #133 · RubyLouvre/anu经测试，使用了自定义组件机制的确是比template实现的简洁一些。但自定义组件机制是一个比较高级的特性，因此兼容性上比template差多了。只能内部推到各方改进了。微信在Component的配置对象提供了一些对象如methods， lifetimes，pageLifetimes，来减少其直辖的配置项。比如说lifetimes收纳了created、attached、ready、moved、detached这些生命周期钩子，pageLifetimes收纳了onShow, onHide这些与页面切换的钩子，methods收纳剩下的方法，另外还有许多配置项。的确，微信小程序独自发布这么久，肯定是最完善的支付宝的自定义组件机制没有properties，只有props，并且作用也不一样，props只是指定默认值，不是规定参数类型。支付宝也没有lifetimes与pageLifetimes对象，生命周期函数的名字也不一样 didMount 、didUpdate 、didUnmount，数量也少了，但从名称来看，支付宝在内部应该运行一个自己的迷你React。其他方面，支付宝没有 dataset， selectComponent，selectAllComponents，getRelationNodes这些东西，但支持了早被React废弃的mixin机制。支付宝没有created这样的钩子是相当麻烦的事，因此积级推动他们加上这个钩子！百度的自定义组件机制与微信的较为相近，但也没有lifetimes与pageLifetimes对象，只有4种生命周期钩子：created，attached，ready，detached。有selectComponent，selectAllComponents。快应用的页面与组件的配置对象都是一样，但它没有构造函数，只是要求我们export一个对象有props对象，用来定义类型与默认值，也有与state相似的data对象，也有三个做了访问限制的private, protected, public对象。生命周期钩子上有onInit、onReady、onDestroy这三个。从组件的设计来看， 微信 > 百度 > 支付宝 > 快应用因此想兼容这么多种小程序，我们必须自己写一个工厂方法，根据不同的平台生成不同的配置项，并且放弃掉一些微信的强大功能了。var hooksName = {\r\n\twx: ['created', 'attached', 'detached'],\r\n\tbu: ['created', 'attached', 'detached'],\r\n\tali: ['didMount', 'didMount', 'didUnmount'],\r\n\tquick: ['onInit', 'onReady', 'onDestroy'],\r\n};\r\n\r\nexport function registerComponent(type, name) {\r\n\tregisterComponents[name] = type;\r\n\tvar reactInstances = (type.reactInstances = []);\r\n\tvar wxInstances = (type.wxInstances = []);\r\n\tvar hooks = [\r\n\t\tfunction created() {\r\n\t\t\tvar instance = reactInstances.shift();\r\n\t\t\tif (instance) {\r\n\t\t\t\tconsole.log('created时为', name, '添加wx');\r\n\t\t\t\tinstance.wx = this;\r\n\t\t\t\tthis.reactInstance = instance;\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('created时为', name, '没有对应react实例');\r\n\t\t\t\twxInstances.push(this);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunction attached() {\r\n                        if(appType == \"ali\"){\r\n                            created.call(this)\r\n                        }\r\n\t\t\tif (this.reactInstance) {\r\n\t\t\t\tupdateMiniApp(this.reactInstance);\r\n\t\t\t\tconsole.log('attached时更新', name);\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('attached时无法更新', name);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunction detached() {\r\n\t\t\tthis.reactInstance = null;\r\n\t\t},\r\n\t];\r\n\tvar data = {\r\n\t\tprops: {},\r\n\t\tstate: {},\r\n\t\tcontext: {},\r\n\t};\r\n\tvar config = {\r\n\t\tdata: data,\r\n\t\tpublic: data,\r\n\t\tdispatchEvent: eventSystem.dispatchEvent,\r\n\t\tmethods: {\r\n\t\t\tdispatchEvent: eventSystem.dispatchEvent,\r\n\t\t},\r\n\t};\r\n\thooksName[appType].forEach(function(name, index) {\r\n\t\tconfig[name] = hooks[index];\r\n\t});\r\n\r\n\treturn config;\r\n}"}
{"title": "当微信小程序遇上 TensorFlow：接收 base64 编码图像数据 ", "author": "Rolan", "pub_time": "2018-10-18 00:21", "article_content": "这是 当微信小程序遇上TensorFlow 系列文章的第四篇文章，阅读本文，你将了解到：如何查看tensorflow SavedModel的签名如何加载tensorflow SavedModel如何修改现有的TensorFlow模型，增加输入层如果你想要了解更多关于本项目，可以参考这个系列的前三篇文章：当微信小程序遇上TensorFlow：Server端实现当微信小程序遇上TensorFlow：Server端实现补充当微信小程序遇上TensorFlow：小程序实现关于Tensorflow SavedModel格式模型的处理，可以参考前面的文章：Tensorflow SavedModel模型的保存与加载如何查看tensorflow SavedModel格式模型的信息如何合并两个TensorFlow模型问题截至到目前为止，我们实现了一个简单的微信小程序，使用开源的Simple TensorFlow Serving部署了服务端。但这种实现方案还存在一个重大问题：小程序和服务端通信传递的图像数据是(299, 299, 3)二进制数组的JSON化表示，这种二进制数据JSON化的最大缺点是数据量太大，一个简单的299 x 299的图像，这样表示大约有3 ～ 4 M。其实HTTP传输二进制数据常用的方案是对二进制数据进行base64编码，经过base64编码，虽然数据量比二进制也会大一些，但相比JSON化的表示，还是小很多。所以现在的问题是，如何让服务器端接收base64编码的图像数据？查看模型的签名为了解决这一问题，我们还是先看看模型的输入输出，看看其签名是怎样的？这里的签名，并非是为了保证模型不被修改的那种电子签名。我的理解是类似于编程语言中模块的输入输出信息，比如函数名，输入参数类型，输出参数类型等等。借助于Tensorflow提供的saved_model_cli.py工具，我们可以清楚的查看模型的签名：python ./tensorflow/python/tools/saved_model_cli.py show --dir /data/ai/workspace/aiexamples/AIDog/serving/models/inception_v3/ --all\r\n\r\nMetaGraphDef with tag-set: 'serve' contains the following SignatureDefs:\r\n\r\nsignature_def['serving_default']:\r\n  The given SavedModel SignatureDef contains the following input(s):\r\n    inputs['image'] tensor_info:\r\n        dtype: DT_FLOAT\r\n        shape: (-1, 299, 299, 3)\r\n        name: Placeholder:0\r\n  The given SavedModel SignatureDef contains the following output(s):\r\n    outputs['prediction'] tensor_info:\r\n        dtype: DT_FLOAT\r\n        shape: (-1, 120)\r\n        name: final_result:0\r\n  Method name is: tensorflow/serving/predict从中我们可以看出模型的输入参数名为image，其shape为(-1, 299, 299, 3)，这里-1代表可以批量输入，通常我们只输入一张图像，所以这个维度通常是1。输出参数名为prediction，其shape为(-1, 120)，-1和输入是对应的，120代表120组狗类别的概率。现在的问题是，我们能否在模型的输入前面增加一层，进行base64及解码处理呢？也许你认为可以在服务器端编写一段代码，进行base64字符串解码，然后再转交给Simple Tensorflow Serving进行处理，或者修改Simple TensorFlow Serving的处理逻辑，但这种修改方案增加了服务器端的工作量，使得服务器部署方案不再通用，放弃！修改模型，增加输入层其实在上一篇文章《 如何合并两个TensorFlow模型 》中我们已经讲到了如何连接两个模型，这里再稍微重复一下，首先是编写一个base64解码、png解码、图像缩放的模型： base64_str = tf.placeholder(tf.string, name='input_string')\r\n  input_str = tf.decode_base64(base64_str)\r\n  decoded_image = tf.image.decode_png(input_str, channels=input_depth)\r\n  # Convert from full range of uint8 to range [0,1] of float32.\r\n  decoded_image_as_float = tf.image.convert_image_dtype(decoded_image,\r\n                                                        tf.float32)\r\n  decoded_image_4d = tf.expand_dims(decoded_image_as_float, 0)\r\n  resize_shape = tf.stack([input_height, input_width])\r\n  resize_shape_as_int = tf.cast(resize_shape, dtype=tf.int32)\r\n  resized_image = tf.image.resize_bilinear(decoded_image_4d,\r\n                                           resize_shape_as_int)\r\n  tf.identity(resized_image, name=\"DecodePNGOutput\")接下来加载retrain模型： with tf.Graph().as_default() as g2:\r\n    with tf.Session(graph=g2) as sess:\r\n      input_graph_def = saved_model_utils.get_meta_graph_def(\r\n          FLAGS.origin_model_dir, tag_constants.SERVING).graph_def\r\n\r\n      tf.saved_model.loader.load(sess, [tag_constants.SERVING], FLAGS.origin_model_dir)\r\n\r\n      g2def = graph_util.convert_variables_to_constants(\r\n          sess,\r\n          input_graph_def,\r\n          [\"final_result\"],\r\n          variable_names_whitelist=None,\r\n          variable_names_blacklist=None)这里调用了graph_util.convert_variables_to_constants将模型中的变量转化为常量，也就是所谓的冻结图(freeze graph)操作。利用tf.import_graph_def方法，我们可以导入图到现有图中，注意第二个import_graph_def，其input是第一个graph_def的输出，通过这样的操作，就将两个计算图连接起来，最后保存起来。代码如下： with tf.Graph().as_default() as g_combined:\r\n    with tf.Session(graph=g_combined) as sess:\r\n      x = tf.placeholder(tf.string, name=\"base64_string\")\r\n      y, = tf.import_graph_def(g1def, input_map={\"input_string:0\": x}, return_elements=[\"DecodePNGOutput:0\"])\r\n      z, = tf.import_graph_def(g2def, input_map={\"Placeholder:0\": y}, return_elements=[\"final_result:0\"])\r\n\r\n      tf.identity(z, \"myOutput\")\r\n\r\n      tf.saved_model.simple_save(sess,\r\n                                 FLAGS.model_dir,\r\n                                 inputs={\"image\": x},\r\n                                 outputs={\"prediction\": z})如果你不知道retrain出来的模型的input节点是啥（注意不能使用模型部署的signature信息）？可以使用如下代码遍历graph的节点名称：for n in g2def.node:\r\n  print(n.name)模型部署及测试注意，我们可以将连接之后的模型保存在./models/inception_v3/2/目录下，原来的./models/inception_v3/1/也不用删除，这样两个版本的模型可以同时提供服务，方便从V1模型平滑过渡到V2版本模型。我们修改一下原来的test_client.py代码，增加一个model_version参数，这样就可以决定与哪个版本的模型进行通信： with open(file_name, \"rb\") as image_file:\r\n    encoded_string = str(base64.urlsafe_b64encode(image_file.read()), \"utf-8\")\r\n\r\n  if enable_ssl :\r\n    endpoint = \"https://127.0.0.1:8500\"\r\n  else:\r\n    endpoint = \"http://127.0.0.1:8500\"\r\n\r\n  json_data = {\"model_name\": model_name,\r\n               \"model_version\": model_version,\r\n               \"data\": {\"image\": encoded_string}\r\n              }\r\n  result = requests.post(endpoint, json=json_data)小结经过一个多星期的研究和反复尝试，终于解决了图像数据的base64编码通信问题。难点在于虽然模型是编写retrain脚本重新训练的，但这段代码不是那么好懂，想要在retrain时增加输入层也是尝试失败。最后从Tensorflow模型转Tensorflow Lite模型时的freezing graph得到灵感，将图中的变量固化为常量，才解决了合并模型变量加载的问题。虽然网上提供了一些恢复变量的方法，但实际用起来并不管用，可能是Tensorflow发展太快，以前的一些方法已经过时了。本文的完整代码请参阅：https://github.com/mogoweb/aiexamples/tree/master/AIDog/serving点击 阅读原文 可以直达在github上的项目。到目前为止，关键的问题已经都解决，接下来就需要继续完善微信小程序的展现，以及如何提供识别率，敬请关注我的微信公众号：云水木石，获取最新动态。参考How to Show Signatures of Tensorflow Saved ModelServing Image-Based Deep Learning Models with TensorFlow-Serving’s RESTful APITensorflow: How to replace a node in a calculation graph?"}
{"title": "微信小程序图片预加载组件 wxapp-img-loader ", "author": "Rolan", "pub_time": "2018-10-18 00:25", "article_content": "由于微信小程序没有提供类似 Image 这样的 JS 对象，要实现图片的预加载要麻烦一些， wxapp-img-loader自定义组件可以在微信小程序中实现图片预加载功能。使用1、下载 wxapp-img-loader项目源代码（https://github.com/o2team/wxa...），将 img-loader 目录拷贝到你的项目中2、在页面的 WXML 文件中添加以下代码，将组件模板引入<import src=\"../../img-loader/img-loader.wxml\"/>\r\n<template is=\"img-loader\" data=\"{{ imgLoadList }}\"></template>\r\n3、在页面的 JS 文件中引入组件脚本const ImgLoader = require('../../img-loader/img-loader.js')\r\n\r\n4、实例化一个 ImgLoader 对象，将 this(当前 Page 对象) 传入，第二个参数可选，为默认的图片加载完成的回调方法this.imgLoader = new ImgLoader(this)\r\n\r\n5、调用 ImgLoader 实例的 load 方法进行图片加载，第一个参数为图片链接，第二个参数可选，为该张图片加载完成时的回调方法。图片加载完成的回调方法的第一个参数为错误信息（加载成功则为 null），第二个参数为图片信息（Object 类型，包括 src、width 及 height）。this.imgLoader.load(imgUrlOriginal, (err, data) => {    console.log('图片加载完成', err, data.src, data.width, data.height)\r\n})\r\nwxapp-img-loader组件可以加载单张图片、也可以加载多张图片。运行效果：其他wxapp-img-loader项目地址：https://github.com/o2team/wxa..."}
{"title": "小程序版结合promise的axios风格ajax请求函数 ", "author": "Rolan", "pub_time": "2018-10-18 00:42", "article_content": "建议的小程序版本的axios函数，之所以说简易，因为只是用了常用的请求方法外，然后添加了拦截器而已。具体如下：wxhttp命名为wxhttp具体的请求用法如axioswxhttp#request(config)wxhttp#get(url[,config])wxhttp#delete(url[,config])wxhttp#head(url[,config])wxhttp#options(url[,config])wxhttp#post(url[,data[,config]])wxhttp#put(url[,data[,config]])wxhttp#patch(url[,data[,config]])拦截方法：请求拦截wxhttp.interceptors.request.use(handleRequest(config),handleError(err))注意：handleRequest需要返回处理后的config返回拦截wxhttp.interceptors.response.use(handresponse(res))注意：handleResponse需要返回处理后的res例子：import $http from \"../../utils/http\"\r\nexport default {\r\n  name: 'seckillHome',\r\n  data() {\r\n    return {\r\n\r\n    }\r\n  },\r\n  onShow() {\r\n    // 请求拦截\r\n    $http.interceptors.request.use(function (config) {\r\n      console.log(`请求拦截`, config)\r\n      // 此处设置的数据将与请求的数据进行合并，如果自动同名则以拦截的为准。\r\n      config.data = {\r\n        address: \"北京市东城区\"\r\n      }\r\n      return config\r\n    })\r\n\r\n    $http.post('https://www.baidu.com', {\r\n      name: 'cdd',\r\n      age: 23\r\n    }).then(res => {\r\n      console.log(`结果是`, res)\r\n    })\r\n  }\r\n}因为使用了promise风格，所以可以使用Promise.all方法来进行并发请求。查看源码"}
{"title": "微信小程序营销组件wxapp-market ", "author": "Rolan", "pub_time": "2018-10-19 00:08", "article_content": "wxapp-market 是基于微信小程序的营销组件，用于快速开发营销玩法类小程序项目页面，包含大转盘、刮刮乐、老虎机、水果机、九宫格翻纸牌、摇一摇、手势解锁等多种营销组件。使用1.拉取仓库git clone git@github.com:o2team/wxapp-market.git\r\n\r\n2.组件文件大转盘 (Big wheel) : /components/wheel/刮刮乐 (Scratch tickets) : /components/scratch/老虎机 (Slot machine) : /components/slotMachine/水果机 (Fruit machine) : /components/fruitMachine/九宫格翻纸牌 (Grid card) : /components/card/摇一摇 (Shake) : /components/shake/手势解锁 (Gesture lock) : /components/lock/3.调用以大转盘组件为例WXSS中引用样式：@import \"../../components/wheel/wheel.wxss\"\r\nWXML中引用结构：<import src=\"../../components/wheel/wheel.wxml\"/>\r\nJS中引用：import Wheel from \"../../components/wheel/wheel.js\"\r\nJS中实例调用：  new Wheel(this,{\r\n    areaNumber: 8,   //抽奖间隔\r\n    speed: 16,       //转动速度\r\n    awardNumer: 2,   //中奖区域从1开始\r\n    mode: 1,         //1是指针旋转，2为转盘旋转\r\n    callback: (idx, award) => {      //结束回调， 参数对应宫格索引，对应奖项    \r\n    }\r\n  })\r\n运行效果：大转盘其他wxapp-market项目地址：https://github.com/o2team/wxa..."}
{"title": "小程序第三方框架对比 ( wepy / mpvue / taro ) ", "author": "Rolan", "pub_time": "2018-10-19 00:21", "article_content": "众所周知如今市面上端的形态多种多样，手机Web、ReactNative、微信小程序, 支付宝小程序, 快应用等,每一端都是巨大的流量入口，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。但面对目前市面上成熟的小程序第三方框架如何针对自己的需求进行选择也是一个麻烦事,本文针对当前市面上的三大转译框架进行一个综合对比,希望能对大家的技术选择有所帮助,如有哪里不妥的地方希望指正;　小程序开发有哪些痛点?频繁调用 setData及 setData过程中页面跳闪组件化支持能力太弱(几乎没有)不能使用 less、scss 等预编译器request 并发次数限制　为什么使用第三方框架? 只要熟悉vue或react即可快速上手,学习成本低 一套代码可在多端编译运行(微信,支付宝,h5,RN)  支付宝小程序暂不完善组件化开发，完美解决组件隔离，组件嵌套，组件通信等问题 支持使用第三方 npm 资源使小程序可支持 Promise，解决回调烦恼可使用 Generator Fu-nction / Class / Async Function 等特性，提升开发效率 对小程序本身的优化，如生命周期的补充，性能的优化等等支持样式编译器: Scss/Less，模板编译器，代码编译器：Babel/Typescript。    第三方框架对比 wepy mpvue taro　　在这里我通过对目前已开源的三种常用小程序框架做一个综合对比, 还有一个叫nanchi的基于react的小程序转译框架,由于没来的及研究暂不做比较;WEPY https://tencent.github.io/wepy/document.html　　腾讯团队开源的一款类vue语法规范的小程序框架,借鉴了Vue的语法风格和功能特性,支持了Vue的诸多特征，比如父子组件、组件之间的通信、computed属性计算、wathcer监听器、props传值、slot槽分发，还有很多高级的特征支持：Mixin混合、拦截器等;WePY发布的第一个版本是2016年12月份，也就是小程序刚刚推出的时候，到目前为止，WePY已经发布了52个版本, 最新版本为1.7.2; MpVue http://mpvue.com/mpvue/#-html　　美团团队开源的一款使用 Vue.js 开发微信小程序的前端框架。使用此框架，开发者将得到完整的 Vue.js 开发体验，同时为 H5 和小程序提供了代码复用的能力。mpvue在发布后的几天间获得2.7k的star,上升速度飞起,截至目前为止已经有13.7k的star;Taro https://taro.aotu.io/ 　　京东凹凸实验室开源的一款使用 React.js 开发微信小程序的前端框架。它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用 JSX 语法，让代码具有更丰富的表现力，使用 Taro 进行开发可以获得和 React 一致的开发体验。,同时因为使用了react的原因所以除了能编译h5, 小程序外还可以编译为ReactNative;Star  　           生命周期　　同为vue规范的mpvue和wepy的生命周期和各种方法不尽相同　　wepy　　wepy生命周期基本与原生小程序相同,再此基础上糅合了一些vue的特性; 对于WePY中的methods属性，因为与Vue中的使用习惯不一致，非常容易造成误解，这里需要特别强调一下：WePY中的methods属性只能声明页面wxml标签的bind、catch事件，不能声明自定义方法，这与Vue中的用法是不一致的。　　import wepy from 'wepy';\r\n\r\nexport default class MyPage extends wepy.page {\r\n// export default class MyComponent extends wepy.component {\r\n    customData = {}  // 自定义数据\r\n\r\n    customFunction ()　{}  //自定义方法\r\n\r\n    onLoad () {}  // 在Page和Component共用的生命周期函数\r\n\r\n    onShow () {}  // 只在Page中存在的页面生命周期函数\r\n\r\n    config = {};  // 只在Page实例中存在的配置数据，对应于原生的page.json文件\r\n\r\n    data = {};  // 页面所需数据均需在这里声明，可用于模板数据绑定\r\n\r\n    components = {};  // 声明页面中所引用的组件，或声明组件中所引用的子组件\r\n\r\n    mixins = [];  // 声明页面所引用的Mixin实例\r\n\r\n    computed = {};  // 声明计算属性（详见后文介绍）\r\n\r\n    watch = {};  // 声明数据watcher（详见后文介绍）\r\n\r\n    methods = {};  // 声明页面wxml中标签的事件处理函数。注意，此处只用于声明页面wxml中标签的bind、catch事件，自定义方法需以自定义方法的方式声明\r\n\r\n    events = {};  // 声明组件之间的事件处理函数\r\n}　　mpvue　　mpvue 除了 Vue 本身的生命周期外，还兼容了小程序生命周期，这部分生命周期钩子的来源于微信小程序的 Page， 除特殊情况外，不建议使用小程序的生命周期 钩子。 1Vue\r\n 3 beforeCreate\r\n 4 created\r\n 5 beforeMount\r\n 6 mounted\r\n 7 beforeUpdate\r\n 8 updated\r\n 9 activated\r\n10 deactivated\r\n11 beforeDestroy\r\n12 destroyed\r\n13 app 部分\r\n15 onLaunch，初始化\r\n16 onShow，当小程序启动，或从后台进入前台显示\r\n17 onHide，当小程序从前台进入后台\r\n18 page 部分\r\n20 onLoad，监听页面加载\r\n21 onShow，监听页面显示\r\n22 onReady，监听页面初次渲染完成\r\n23 onHide，监听页面隐藏\r\n24 onUnload，监听页面卸载\r\n25 onPullDownRefresh，监听用户下拉动作\r\n26 onReachBottom，页面上拉触底事件的处理函数\r\n27 onShareAppMessage，用户点击右上角分享\r\n28 onPageScroll，页面滚动\r\n29 onTabItemTap, 当前是 tab 页时，点击 tab 时触发 （mpvue 0.0.16 支持）简单示例new Vue({\r\n  data: {\r\n    a: 1\r\n  },\r\n  created () {\r\n    // `this` 指向 vm 实例\r\n    console.log('a is: ' + this.a)\r\n  },\r\n  onShow () {\r\n    // `this` 指向 vm 实例\r\n    console.log('a is: ' + this.a, '小程序触发的 onshow')\r\n  }\r\n})\r\n// => \"a is: 1\" taro与react生命周期完全相同class Clock extends Component {\r\n  constructor (props) {\r\n    super(props)\r\n    this.state = { date: new Date() }\r\n  }\r\n\r\n  componentDidMount() {\r\n\r\n  }\r\n\r\n  componentWillUnmount() {\r\n\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <View>\r\n        <Text>Hello, world!</Text>\r\n        <Text>现在的时间是 {this.state.date.toLocaleTimeString()}.</Text>\r\n      </View>\r\n    )\r\n  }\r\n}列表渲染在列表渲染上三者也分别有不同的应用方法wepy当需要循环渲染WePY组件时(类似于通过wx:for循环渲染原生的wxml标签)，必须使用WePY定义的辅助标签<repeat><template>\r\n    <!-- 注意，使用for属性，而不是使用wx:for属性 -->\r\n    <repeat for=\"{{list}}\" key=\"index\" index=\"index\" item=\"item\">\r\n        <!-- 插入<script>脚本部分所声明的child组件，同时传入item -->\r\n        <child :item=\"item\"></child>\r\n    </repeat>\r\n</template>\r\n\r\n<script>\r\n    import wepy from 'wepy';\r\n    // 引入child组件文件\r\n    import Child from '../components/child';\r\n\r\n    export default class Index extends wepy.component {\r\n        components = {\r\n            // 声明页面中要使用到的Child组件的ID为child\r\n            child: Child\r\n        }\r\n\r\n        data = {\r\n            list: [{id: 1, title: 'title1'}, {id: 2, title: 'title2'}]\r\n        }\r\n    }\r\n</script>mpvue使用v-for与vue一致,只是需要注意一点，嵌套列表渲染，必须指定不同的索引！<!-- 在这种嵌套循环的时候， index 和 itemIndex 这种索引是必须指定，且别名不能相同，正确的写法如下 -->\r\n<template>\r\n    <ul v-for=\"(card, index) in list\">\r\n        <li v-for=\"(item, itemIndex) in card\">\r\n            {{item.value}}\r\n        </li>\r\n    </ul>\r\n</template>taro的列表循环用法基本与react相同,有一点需要注意,在 React 中，JSX 是会编译成普通的 JS 的执行，每一个 JSX 元素，其实会通过 createElement 函数创建成一个 JavaScript 对象（React Element），因此实际上你可以这样写代码 React 也是完全能渲染的：const list = this.state.list.map(l => {\r\n  if (l.selected) {\r\n    return <li>{l.text}</li>\r\n  }\r\n}).filter(React.isValidElement)但是 Taro 中，JSX 会编译成微信小程序模板字符串，因此你不能把 map 函数生成的模板当做一个数组来处理。当你需要这么做时，应该先处理需要循环的数组，再用处理好的数组来调用 map 函数。例如上例应该写成：const list = this.state.list\r\n  .filter(l => l.selected)\r\n  .map(l => {\r\n    return <li>{l.text}</li>\r\n  })事件处理mpvue目前全支持小程序的事件处理器,引入了 Vue.js 的虚拟 DOM ，在前文模版中绑定的事件会被挂在到 vnode 上，同时 compiler 在 wxml 上绑定了小程序的事件，并做了相应的映射，所以你在真实点击的时候通过 runtime 中 handleProxy 通过事件类型分发到 vnode 的事件上，同 Vue 在 WEB 的机制一样，所以可以做到无损支持。同时还顺便支持了自定义事件和 $emit 机制// 事件映射表，左侧为 WEB 事件，右侧为 小程序 对应事件\r\n{\r\n    click: 'tap',\r\n    touchstart: 'touchstart',\r\n    touchmove: 'touchmove',\r\n    touchcancel: 'touchcancel',\r\n    touchend: 'touchend',\r\n    tap: 'tap',\r\n    longtap: 'longtap',\r\n    input: 'input',\r\n    change: 'change',\r\n    submit: 'submit',\r\n    blur: 'blur',\r\n    focus: 'focus',\r\n    reset: 'reset',\r\n    confirm: 'confirm',\r\n    columnchange: 'columnchange',\r\n    linechange: 'linechange',\r\n    error: 'error',\r\n    scrolltoupper: 'scrolltoupper',\r\n    scrolltolower: 'scrolltolower',\r\n    scroll: 'scroll'\r\n}踩坑注意(官方文档)：列表中没有的原生事件也可以使用例如 bindregionchange 事件直接在 dom 上将bind改为@ @regionchange,同时这个事件也非常特殊，它的 event type 有 begin 和 end 两个，导致我们无法在handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 <map @regionchange=\"functionName\" @end=\"functionName\" @begin=\"functionName\"><map>小程序能力所致，bind 和 catch 事件同时绑定时候，只会触发 bind ,catch 不会被触发，要避免踩坑。事件修饰符.stop 的使用会阻止冒泡，但是同时绑定了一个非冒泡事件，会导致该元素上的 catchEventName 失效！.prevent 可以直接干掉，因为小程序里没有什么默认事件，比如submit并不会跳转页面.capture 支持 1.0.9.self 没有可以判断的标识.once 也不能做，因为小程序没有 removeEventListener, 虽然可以直接在 handleProxy 中处理，但非常的不优雅，违背了原意，暂不考虑其他 键值修饰符 等在小程序中压根没键盘，所以。。。wepy事件绑定区别于vue,根据原生小程序事件提供了语法优化绑定事件 bindtap=\"click\" 替换为 @tap=\"click\"，取消冒泡原catchtap=\"click\"替换为@tap.stop=\"click\"。捕获监听事件 capture-bind:tap=\"click\" 替换为 @tap.capture=\"click\"，中断捕获监听capture-catch:tap=“click\"替换为 @tap.capture.stop=\"click\"。Taro 元素的事件处理和 DOM 元素的很相似。但是有一点语法上的不同:Taro 事件绑定属性的命名采用驼峰式写法，而不是小写。 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串 (DOM 元素的写法)。 例如，传统的微信小程序模板：<button onclick=\"activateLasers\">\r\n  Activate Lasers\r\n</button>Taro 中稍稍有点不同：<button onClick={this.activateLasers}>\r\n  Activate Lasers\r\n</button>在 Taro 中另一个不同是你不能使用 catchEvent 的方式阻止事件冒泡。你必须明确的使用 stopPropagation。例如，阻止事件冒泡你可以这样写：class Toggle extends React.Component {\r\n  constructor (props) {\r\n    super(props)\r\n    this.state = {isToggleOn: true}\r\n  }\r\n\r\n  onClick = (e) => {\r\n    e.stopPropagation()\r\n    this.setState(prevState => ({\r\n      isToggleOn: !prevState.isToggleOn\r\n    }))\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <button onClick={this.onClick}>\r\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\r\n      </button>\r\n    )\r\n  }\r\n} request请求wepy对wx.request做了接受参数的修改,值得一提的是它提供了针对全局的intercapter拦截器// 原生代码:\r\n\r\nwx.request({\r\n    url: 'xxx',\r\n    success: function (data) {\r\n        console.log(data);\r\n    }\r\n});\r\n\r\n// WePY 使用方式, 需要开启 Promise 支持，参考开发规范章节\r\nwepy.request('xxxx').then((d) => console.log(d));\r\n\r\n// async/await 的使用方式, 需要开启 Promise 和 async/await 支持，参考 WIKI\r\nasync function request () {\r\n   let d = await wepy.request('xxxxx');\r\n   console.log(d);\r\n}拦截器import wepy from 'wepy';\r\n\r\nexport default class extends wepy.app {\r\n    constructor () {\r\n        // this is not allowed before super()\r\n        super();\r\n        // 拦截request请求\r\n        this.intercept('request', {\r\n            // 发出请求时的回调函数\r\n            config (p) {\r\n                // 对所有request请求中的OBJECT参数对象统一附加时间戳属性\r\n                p.timestamp = +new Date();\r\n                console.log('config request: ', p);\r\n                // 必须返回OBJECT参数对象，否则无法发送请求到服务端\r\n                return p;\r\n            },\r\n\r\n            // 请求成功后的回调函数\r\n            success (p) {\r\n                // 可以在这里对收到的响应数据对象进行加工处理\r\n                console.log('request success: ', p);\r\n                // 必须返回响应数据对象，否则后续无法对响应数据进行处理\r\n                return p;\r\n            },\r\n\r\n            //请求失败后的回调函数\r\n            fail (p) {\r\n                console.log('request fail: ', p);\r\n                // 必须返回响应数据对象，否则后续无法对响应数据进行处理\r\n                return p;\r\n            },\r\n\r\n            // 请求完成时的回调函数(请求成功或失败都会被执行)\r\n            complete (p) {\r\n                console.log('request complete: ', p);\r\n            }\r\n        });\r\n    }\r\n}taro对request进行了二次封装,可以使用Taro.request(OBJECT)发起网络请求，支持 Promise 化使用。 import Taro from '@tarojs/taro'\r\n\r\nTaro.request({\r\n  url: 'http://localhost:8080/test',\r\n  data: {\r\n    foo: 'foo',\r\n    bar: 10\r\n  },\r\n  header: {\r\n    'content-type': 'application/json'\r\n  }\r\n})\r\n  .then(res => console.log(res.data))mpvue没有对request做特殊优化,与原生相同,可以自己根据需要进行封装状态管理wepy 可引用Redux和Mbox,目前wepy的脚手架内已经集成了redux,选择需要即可;mpVue使用vuextaro使用Redux如何选择适合自己的项目如果只需要做一个微信小程序则根据自己的擅长框架选择mpvue或taro如果是当前老项目想像向程序迁移同时老项目又是使用vue开发,建议使用mpvue或wepy如果是老项目使用react开发且需要部分迁移小程序,建议使用taro如果是新项目且新项目需要同时支持微信小程序和支付宝小程序, 建议使用原生开发,因为目前框架的转译支付宝小程序支持并不是很好,且出了问题不好定位修改, 但如果是小demo不涉及太多逻辑的项目都可以使用框架作为尝鲜; 但如果是涉及太多交互逻辑的则不建议使用框架转译,由于支付宝小程序在视图层基本与小程序一致所以建议手动更改替换部分方法和全局替换一些属性或文件名,如wxml替换为axml这种, 手动转换时间比大概是四比一; 当然如果人手足够一端开发一个是最好的..."}
{"title": "微信小程序之：云开发初体验--致我的第一个小程序 ", "author": "Rolan", "pub_time": "2018-10-19 00:36", "article_content": "背景：一直关注微信小程序的发展，看着小程序一步步完善，一步步壮大，心里痒痒，也想做一个自己的微信小程序，但是苦于只会前端，不会服务端，所以想法一直被卡着。现在小程序有了云开发，很轻松实现后端功能，写后端跟写前端没啥区别，真的是前端小伙伴们的福音啊。经过几个晚上的熬夜奋战，我的第一个微信小程序正式上线啦。小程序名字： 杭州地铁通二维码：欢迎小伙伴们体验，欢迎吐槽。现在还只是初版，功能还不完善，后面会继续更新的。 闲话少说，进入正题。小程序云开发是什么？开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。(云端说白了也就是服务端啦，说的那么高大上，对新手朋友可不太友好。)小程序·云开发提供了三个基础能力： 数据库 、 存储 和 云函数 。数据库 ：json数据库，就理解为往里面存的是json，取出来的也是json。存储 ：就是把你的图片、音频和视频之类的资源文件，存储到里面，帮你生成链接，直接拿链接就可以用，就好像一个网盘一样。云函数 ：这个云函数，就是服务端的接口，你调用这个函数，也就是调用接口。云函数可以在客户端写，也可以在云开发控制台写，写完之后同步一下，两端就都有了。在云函数里，你可以进行计算，也可以操作数据库，把想要的结果以同步或者异步的方式返回给客户端。每个用户最多可拥有两套开发环境，两套环境是互相独立的，一般是创建一个test环境用于开发，一个release环境用于发布。这里有小坑，后面说。云开发怎么用？在创建工程时，选择快速创建云开发模板，直接就拥有了云开发能力， 模板里已经配置好了云服务对接模块的路径，如下图：￼在app.js里配置当前的环境ID，配置完毕，就可以进行开发了。1.创建并编写云函数：右键云函数模块文件夹->新建Node.js云函数： ￼比如，我创建了一个获取用户收藏列表的云函数，函数功能就是从数据库从读取用户收藏列表，并把结果返回给小程序。注意：app.js里虽然指定了当前环境，但这里的代码是在云端运行的，还是要重新指定读的是哪个环境的数据库。￼上面是异步查询，并返回，所以用的是 await。用await的好处是，可以把异步代码像同步一样去写，这在阮一峰的ES6入门里有讲。2.云函数上传并部署创建完云函数后，还需要右键点击云函数，进行上传并部署，注意：微信开发工具不支持批量上传，每个云函数都要单独点击上传，这里有点坑。上传部署完后，就可以直接调用了，云函数调用和接口返回处理，其中，参数是放在data对象里的。3.获取用户唯一身份标识：openId以前没有云服务时，开发者用自己的服务器对接小程序，使用微信用户id时，需要自己调用接口进行鉴权，来判断用户身份。而现在这些都已经被云服务给做了，每次调用接口，微信会自动鉴权，而且每个接口都会自带openId，使用起来非常方便。云函数里的微信openId的获取，和参数的获取： ￼到此，这些就是云函数的使用过程，是不是很简单，又很方便。最后：上面说过，云服务有两个环境，两个环境互相独立，目前微信不支持环境间数据同步，那在test里的一些数据，就要手动去同步到release环境，这个有点烦。还有一点是：如果开发完要上线了，那要把环境从test切到release环境。切换环境时，需要把app.js里云服务初始化环境切换到release，云函数里如果有数据库调用，也要指定数据环境。而且切换时，用的是环境ID，不是环境的名字，文档里写的是用名字，坑了我20分钟。"}
{"title": "微信小程序跳H5页面 ", "author": "Rolan", "pub_time": "2018-10-19 00:42", "article_content": "主页面：index.wxml主页面：index.js↑跳转到另一个wxml页面→recharge.wxmlrecharge.wxmlweb-view中设置跳转h5的链接，可以加上需要的参数：tips：1.首先，web-view组件的属性src，正如你说看到的，这个就是设置网页链接的，但是需要特别注意的是web-view的src必须配置https协议的链接；2.其次，就是web-view组件只要配置了链接，它是铺满全屏且自动跳转的，所以这也就是为什么我这边需要先写一个navigator按钮，点击操作之后再让它跳转的原因；3.最后，web-view跳转的接口域名，需要配置在小程序开发设置的业务域名列表中。"}
{"title": "万字解析小程序（2）：如何保证大海上可以看到“小船”？ ", "author": "Rolan", "pub_time": "2018-10-22 00:01", "article_content": "每一个小程序，都需要回答一个问题——你的用户是谁？换句新潮的说法就是：“你是在玩儿微信里的公域流量还是私域流量？”如何判断公域还是私域？根据用户的使用场景。如果用户的使用场景是“吃喝玩乐上班上课”，那就是在玩儿公域流量。如果户的使用场景是“公众号 朋友圈 聊天”，那就是玩儿私域流量。姜太公公观点：本文将讨论小程序下的公域流量和私域流量的核心差别。并且在明天文章中探讨小程序中公域流量和私域流量的玩儿法。大海上看小船淘宝店主想多卖货，过去怎么办？需要买直通车，需要冲击金钻，需要提高淘宝搜索排名。这面向的是“公域流量”。现在怎么办？搞粉丝群，搞社群，把“公域流量”拉出一部分到自己的“私域流量”。为什么要搞私域流量？在选择爆炸的情况下，用户的每次选择都是站在一个茫茫的大海上。海上满满的都是船。用户会看到离他近的船，或者体量大的船。小船的被看到的机会，很少。私域流量的存在带来了什么？天崩地裂，大海被拆分成很多“浅水湖”。我是一艘小小船，用户在“大海”上看不到我，我就开进他身边的“浅水湖”。每日优鲜，玩儿的是公域流量。干死了无数生鲜电商，成为了用户在海上可以看的到的大船。而社区团购生鲜，玩儿的是私域流量，通过一个个宝妈建立的微信群，拼团买生鲜。公域流量是中心化的，这种模式下火的是“规模经济”。赢家因为规模增大带来了经济效益的提高。规模增大后，成本分摊得更低，获客成本更低。所谓赢家通吃。私域流量去中心化的，这一次，“规模效应”失效了。正所谓 场下格斗没套路，乱拳打死老师傅。微信中的“关系”形成了天然的壁垒。导致了去中心化。大海，因为这些关系的存在，变成了“浅水湖”。如何建立私域，需要和用户建立关系。比如建立公众号，成立社群，或者直接和用户的朋友建立关系。建立关系的目的是为了掌握住“私域的入口”。越强的关系，越强的互动，私域流量的质量越好截然不同的玩儿法微信中的公域流量和私域流量，玩儿法完全不同。因为两种流量模式下，用户 形成一个“行为”的方式完全不同。Fogg模型阐述了如何让行为发生。Fogg模型认为一次行为的发生需要具备三个要素，缺一不可。这三个要素是： 动机，成本，触发点。举一个例子，一家饭馆想吸引用户走进来吃饭。这个行为的发生需要如下条件：动机：顾客想吃饭成本：顾客兜里有50块钱，这家饭馆人均消费30元。顾客有“支付的能力”触发点：顾客走到饭馆旁边，看到饭馆“吸引人的招牌”要完成这次行为，三个要素缺一不可。公域流量 和 私域流量的区别在于，这三个要素出现的顺序不同。公域流量是“动机”驱动行为，私域流量是“触发点”驱动行为。公域流量下，用户首先有了一个“动机”，然后打开了一个软件。用户想听歌，于是打开某易云音乐APP。用户记得它的位置在手机第2屏的第3排，然后轻松的找到，然后点开。私域流量下，用户通过“群”“聊天”“公众号”的触发点，获得了一个动机。好友发给我一个“毛衣”拼团链接，看着还挺实惠的。天气真的变冷了，我也需要一件。两者行为的驱动点完全不同。所以，给小程序开发者的建议是：如果你是玩公域流量，你需要降低“主动触发”下的用户摩擦。在用户有一个动机的时候，帮助她迅速完成行为。做到用户所想即所得，让用户快速找到你的软件。用户心理想要的是，don’t make think，don’t make wait。用户找到你的小程序很便捷，就搞好小程序；如果小程序做不到，就将小程序作为引流工具，把用户像APP沉淀，通过APP形成肌肉记忆。如果你是玩私域流量，你需要降低“被动触发”下对用户的打扰。Emmm，这，真的有点复杂哦！具体如何做，看万字解析（3）。总结一下啦微信开放了自己的社交关系，将流量划分为公域流量和私域流量。私域流量是去中心化的，导致“规模效应”失效。私域流量更多是被动触发，公域流量是主动触发。如果你是玩公域流量，你需要降低“主动触发”下的用户摩擦。如果你是玩私域流量，你需要降低“被动触发”下对用户的打扰。相关阅读万字解析小程序（1）：小程序 PK APP = 无解 ？#专栏作家#姜太公公，微信号公众号：grandpa_jiang，人人都是产品经理专栏作家。产品老流氓，终身学习者。致力于研究产品方法论，解决小白PM的疑难杂症。本文原创发布于人人都是产品经理。未经许可，禁止转载题图来自 Pexels，基于 CC0 协议"}
{"title": "node.js 抓取网页内容（针对微信小程序云开发） ", "author": "Rolan", "pub_time": "2018-10-22 00:48", "article_content": "最近在研究微信小程序的云开发功能。云开发最大的好处就是不需要前端搭建服务器，可以使用云端能力，从零开始写出来一个能上线的微信小程序，避免了买服务器的开销，对于个人来尝试练手微信小程序从前端到后台的开发，还是一个不错的选择。可以做到一天就能上线一个微信小程序。云开发的优点云开发为开发者提供完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。云开发目前提供三大基础能力支持：云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码数据库：一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库存储：在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理好了，介绍了这么多关于云开发的知识，感性的同学可以去研究研究。官方文档地址：https://developers.weixin.qq....网页内容抓取小程序是关于答题的，所以题目的来源是一个问题。上网搜，一个题目一个题目粘贴是一种方法，但是这样的重复工作，估计粘个10左右就想放弃了。所以想到了网页抓取。正好把之前学的node捡起来。必备工具：Cheerio。一个类似于服务器端JQuery的包。主要用它来分析和过滤抓取来的内容。node的fs模块。这个是node自带的模块，用来读写文件的。此处用来将解析好的数据写入json文件。Axios（非必须）。用来抓取网站的HTML网页。因为我要的数据是从网页上点击一个button后获取渲染的，所以直接访问这个网址是抓取不到的。无奈只能将想要的内容复制出来，存成字符串，去解析这个字符串。接下来就可以用npm init来初始化一个node项目，一路回车后，即可生成一个package.json文件。然后npm install --save axios cheerio安装cheerio和axios包。关键的是用cheerio来实现一个类似jquery的功能。只需将抓取到的内容cheerio.load(quesitons)一下即可，之后就可以按照jquery的操作取dom，组装你想要的数据了。最后用fs.writeFile将数据保存到json文件中，大功告成。具体代码如下：let axios = require(\"axios\");\r\n\r\nlet cheerio = require(\"cheerio\");\r\n\r\nlet fs = require(\"fs\");\r\n\r\n// 我的html结构大致如下，有很多条数据\r\nconst questions = `<li id=\"q1\" style=\"display: list-item;\">\r\n      <div class=\"questionWrapper\">\r\n        <div class=\"question\">举头望明月，__________。</div>\r\n        <div class=\"answer\" value=\"0\">\r\n          回首白云低\r\n        </div>\r\n        <div class=\"answer\" value=\"1\">\r\n          低头思故乡\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          当春乃发生\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          红掌拨清波\r\n        </div>\r\n      </div>\r\n    </li>\r\n    <li id=\"q2\">\r\n      <div class=\"questionWrapper\">\r\n        <div class=\"question\">__________，却话巴山夜雨时。</div>\r\n        <div class=\"answer\" value=\"1\">\r\n          何当共剪西窗烛\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          在天愿做比翼鸟\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          世味年来薄似纱\r\n        </div>\r\n        <div class=\"answer\" value=\"0\">\r\n          两岸青山相对出\r\n        </div>\r\n      </div>\r\n    </li>\r\n    ..........\r\n    `;\r\n    \r\nconst $ = cheerio.load(quesitons);\r\n\r\nvar arr = [];\r\n\r\nfor (var i = 0; i < 300; i++) {\r\n   var obj = {};\r\n   obj.quesitons = $(\"#q\" + i).find(\".question\").text();\r\n   obj.A = $($(\"#q\" + i).find(\".answer\")[0]).text();\r\n   obj.B = $($(\"#q\" + i).find(\".answer\")[1]).text();\r\n   obj.C = $($(\"#q\" + i).find(\".answer\")[2]).text();\r\n   obj.D = $($(\"#q\" + i).find(\".answer\")[3]).text();\r\n   obj.index = i + 1;\r\n   obj.answer =\r\n     $($(\"#q\" + i).find(\".answer\")[0]).attr(\"value\") == 1\r\n       ? \"A\"\r\n       : $($(\"#q\" + i).find(\".answer\")[1]).attr(\"value\") == 1\r\n         ? \"B\"\r\n         : $($(\"#q\" + i).find(\".answer\")[2]).attr(\"value\") == 1\r\n           ? \"C\"\r\n           : \"D\";\r\n   arr.push(obj);\r\n}\r\n\r\nfs.writeFile(\"poem.json\", JSON.stringify(arr), err => {\r\n   if (err) throw err;\r\n   console.log(\"json文件已成功保存！\");\r\n});保存到json后的文件格式如下，这样就可以通过json文件上传到云端服务器了。注意事项微信小程序云开发的数据库，上传json文件的数据格式需要注意一下，之前一直提示格式错误，后来才发现，JSON 数据不是数组，而是类似 JSON Lines，即各个记录对象之间使用 n 分隔，而非逗号。所以还需要对node写出来的json文件做一个小处理之后才能上传成功。"}
{"title": "万字解析小程序（3）：流量升级触发的“礼物经济” ", "author": "Rolan", "pub_time": "2018-10-29 00:06", "article_content": "本文观点：流量升级的原因：微信社交能力的开放，将渠道集中式的“公域流量”转化成用户为中心的“私域流量”。流量升级的结果：私域流量去中心化，导致了“赢家通吃”模式的失效。礼物经济的启示：礼物具有极强的“外部性”。互惠是一种方式，而不是目的。流量升级的原因2017年6月13日，我写了一篇“唱衰小程序”的文章。在小程序初期，有很多人的看法，是和我相同的。认为“小程序 PK APP”，胜算并不大。1年的时间，我明白了1件事情，擂台搭错了，你在旁边磕一吨焦糖瓜子儿，也等不出输赢。看小程序这个赛道，不该看 “小程序 PK APP”，也不该看“微信 PK Android”，而是看“微信 PK 智能手机”。为什么？移动浪潮的兴起，是因为“智能手机”的发展，带来了流量红利。小程序浪潮的兴起，是因为“微信”社交能力的开放，带来的流量升级。1. 追忆移动浪潮智能手机的出现，大大的提高了用户的终端保有量。它太简单便携，人手一部。可是换一个角度想，如果智能手机没有出现，世界会怎样？2018年，可能会有“9毽键盘”、“大屏”电脑，专供于三四线城市，老年人，小镇青年。没有智能手机，可能人手一部电脑。智能手机最性感的点，不在于让一些不触网的人触网，而在于流量的重新洗牌。这一点，只有它可以做到。流量迁移：流量从一个地方转移到另一个地方；流量洗牌：流量池结构打散，重排。人生海海，我们大部分时间在拼“定位”。一亩三分地，种了玉米就不能种高粱。你需要找到你的差异化优势，才能赢得竞争。可是某些浪潮下，这一亩三分地迅速洗牌，种了的玉米被全部拔了下来。要知道，乱世出英雄，混乱是阶梯。——姜太公公智能手机的洗牌，在于“使用场景”的洗牌，因为LBS，移动性等带来的随时随地的场景。这大大拓宽了整体的使用频次和使用时间。在这波使用场景的浪潮下，产生了各种场景解决方案的公司，比如：吃饭、出行、打发时间……微信的洗牌，在于“用户”结构的洗牌。这导致了用户接触信息、使用信息的方式的完全颠覆。微信社交能力的开放，带来了“用户”结构从渠道集中式的公域流量转化成用户为中心的私域流量。所以小程序的价值不在于小程序是什么？而在于微信开放了自己的终端价值，这个开放带来了什么？2. 为什么当初会错判？我们当初为啥会比较“小程序 PK APP”？为了形成“短平快”的判断，我们经常会贴标签。比如：实习生小姑娘一脸花痴的说“我的idol太帅了，简直是行走的荷尔蒙，我要给idol生孩子”  你说：“小鲜肉就是长得好看，实力都不行”。拜托，人家idol都特么42岁了好么，见了面，你都得叫人家一声大哥。（这个case并不是发生在我身上的哦，不要瞎想）“标签”，帮助我们迅速定义未知事物，却模糊了事物的全貌。如果牛在你心中的标签只有“黑白色”，那我问你是否见过牛尾巴是“666”的？你就不会知道，站在你眼前的这一只就是。标签化思考导致我们无法看到事物的全貌。在看小程序赛道时，很多人同样用了标签化思考，导致使用了错误的擂台。为了快速定义“小程序”，我们给它贴了一个“类似app”的标签。原来安卓、苹果手机上使用“微博APP”，现在微信中使用“微博小程序”。这样的“标签”，遮盖了什么全貌呢？为了更好的说明，我先来拆解下移动浪潮的全貌：应用层：用户使用的东西属于应用层。“APP”属于应用层。系统层：指操作系统。“android系统”，“iOS系统”属于系统层。应用的实现依赖于系统层。同一个应用，可能有“android版本”、“iOS版本”终端：“智能手机”是终端。终端带来了流量，流量和价值直接相关。对应到小程序赛道，这个全貌是什么呢？小程序浪潮下的终端是“微信”，开发者原来抢的是“移动手机”里的用户，现在抢的是“微信”里的用户。终端带来了流量，流量和价值直接相关。小程序能力开放前，“微信”里的用户你是很难碰到的。“微信”和“移动手机”在终端价值上，是一个级别的。万物皆有裂痕，那是风吹过来的地方。不要找风口上的猪，而是要看风里有什么能力。——姜太公公小结移动浪潮的兴起，是因为“智能手机”的发展，带来了流量红利。小程序浪潮的兴起，是因为“微信”社交能力的开放，带来的流量升级。流量升级的结果每一个小程序，都需要回答一个问题：“你是在玩儿微信里的公域流量还是私域流量？”如何判断公域还是私域？这里提供一个判断标准——根据用户的使用场景。如果用户的使用场景是“吃喝玩乐上班上课”，那就是在玩儿公域流量。如果用户的使用场景是“公众号 朋友圈 聊天”，那就是玩儿私域流量。小程序的流量升级，是因为出现了私域流量。私域流量的作用是什么呢？引起的后果是什么呢？NO.1 “赢家通吃”模式失效淘宝店主想多卖货，过去怎么办？需要买直通车，需要冲击金钻，需要提高淘宝搜索排名。这面向的是“公域流量”。现在怎么办？搞粉丝群，搞社群，把“公域流量”拉出一部分到自己的“私域流量”。为什么要搞私域流量？在选择爆炸的情况下，用户的每次选择都是站在一个茫茫的大海上。海上满满的都是船，用户会看到离他近的船，或者体量大的船。小船的被看到的机会，很少。私域流量的存在带来了什么？天崩地裂，大海被拆分成很多“浅水湖”。我是一艘小小船，用户在“大海”上看不到我，我就开进他身边的“浅水湖”。每日优鲜，玩儿的是公域流量。干死了无数生鲜电商，成为了用户在海上可以看的到的大船。而社区团购生鲜，玩儿的是私域流量，通过一个个宝妈建立的微信群，拼团买生鲜。公域流量是中心化的，这种模式下火的是“规模经济”。赢家因为规模增大带来了经济效益的提高，规模增大后，成本分摊得更低，获客成本更低。所谓赢家通吃。私域流量去中心化的，这一次，“规模效应”失效了。正所谓 场下格斗没套路，乱拳打死老师傅。微信中的“关系”形成了天然的壁垒，导致了去中心化。大海，因为这些关系的存在，变成了“浅水湖”。NO.2 用户行为的“驱动力”不再是“需求”Fogg模型阐述了如何让行为发生。Fogg模型认为一次行为的发生需要具备三个要素，缺一不可，这三个要素是： 动机、成本、触发点。举一个例子，一家饭馆想吸引用户走进来吃饭，这个行为的发生需要如下条件：动机：顾客想吃饭成本：顾客兜里有50块钱，这家饭馆人均消费30元。顾客有“支付的能力”触发点：顾客走到饭馆旁边，看到饭馆“吸引人的招牌”要完成这次行为，三个要素缺一不可。公域流量和私域流量的区别在于，这三个要素出现的顺序不同。公域流量是“动机”驱动行为，私域流量是“触发点”驱动行为。公域流量下，用户首先有了一个“动机”，然后打开了一个软件。用户想听歌，于是打开某易云音乐APP。用户记得它的位置在手机第2屏的第3排，然后轻松的找到，然后点开。私域流量下，用户通过“群”“聊天”“公众号”的触发点，获得了一个动机。好友发给我一个“毛衣”拼团链接，看着还挺实惠的。天气真的变冷了，我也需要一件。两者行为的驱动点完全不同。如果你是玩公域流量，你需要降低“主动触发”下的用户摩擦。在用户有一个动机的时候，帮助她迅速完成行为。做到用户所想即所得，让用户快速找到你的软件。用户心理想要的是，don’t make think，don’t make wait。如果你是玩私域流量，你需要降低“被动触发”下对用户的打扰。Emmm，这，真的有点复杂哦！会在第3节中重点讲哦！NO.3 流量池结构变为“沙漏”提到“流量池”，最容易想到什么？没错，用户分层。公域流量，流量池的结构是上图这种“鸡尾酒”型。用户是分层的，稳定的，忠实用户 、老用户、新用户各占有稳定的比例。做好这杯鸡尾酒，需要调好用户分配比例，讲的是“精细化运营”。 私域流量，流量池的结构是“沙漏”型。用户是动态的，流动的。小程序中，留存率20%是一个坎儿，而一个普通app，留存率动辄40%，50%，可见微信中的私域流量留存之低。私域流量做不了鸡尾酒，因为“底是漏的”。APP，强调的是转化率，强调的是一节节，分子小于分母的比例。转化率永远是小于1的，如果做到0.9，已经可以封神了。小程序中，强调的是分享，强调的是一层层，分子大于分母的裂变K值。K值大于1才算及格，1.1的100次方=13780 ，但是0.9的100次方=0.000027。分享带来了流量的复利，解决了留存的问题。分享，是整个私域流量池模型成立的根基。小结私域流量的作用是什么呢？引起的后果是什么呢？NO.1 “赢家通吃”模式失效NO.2 用户行为的“驱动力”不再是“需求”NO.3 公域流量池的结构是“鸡尾酒”型，私域流量池的结构是“沙漏”型。“礼物经济”给小程序的启示上文提到了私欲流量池结构变为“沙漏”。这里就不得不重点讲一下分享，你以为我要讲用户分享的18大驱动力？你以为我要讲裂变的起点是“人民币”和“社交币”？不，我们站的高一点，玩儿的大一点的。私域流量的分享其实在做的是“礼物经济”。礼物经济指的是提供商品或服务者并没有明确的预期回馈对象，也没有预期回馈的内容，有许多分享行为出自于非制式的习惯。同时，礼物的施与受之间已转换成一种未明确规定的义务，形成送礼者与收礼者之间的隐晦关系。礼物经济也被认为是一种债务经济，在这种经济中，交易者的目标是尽可能获得最多的礼物债务人，而不像在商品经济中以获取最大利润为目的。——百度百科从礼物经济的3大特点中，我们可以获得针对于小程序流量的玩法儿启示。1. 礼物经济中“互惠”是媒介，但不是目的互惠是一种语言。小明分享了一个“原价999，团购价9块9”的拼团链接给姜太公公。拼团成功后，小明和公公各自省了900元。请问，小明潜意识里，是希望不久的将来，姜太公公也帮助他省900元钱么？不会，小明对于姜太公公给他的回报没有预期。互惠，是一种媒介，是礼物经济中语言。就好像，见面问一句“你吃了没”。实际上，对方吃了啥，根本不care。对小程序开发者的启示：要让“互惠”成为一种沟通的方式，不要把互惠看的太重，否则会本末倒置。小程序的各种玩儿法“拼 抢 坎 送 比”，都是一种沟通的媒介。2. 交换礼物目的是——增加礼物的往来“礼物和商品交易的一个重要不同之处是，礼物在双方之间形成了情感纽带，商品交易却并不会带来任何必要的联系。我进入一家五金店，付钱给店员购买一根锯条然后离开，我可能再也不会和这名店员见面。疏离感是商品交易模式的基本原则，我们不想被打扰，所以如果这个店员一直不想我谈家里的事儿，我会换一家店，因为我只想买一个金条”—— 摘取自《分享经济的爆发》和商品销售不同，礼物赠予是要在双方建立亲密关系。当礼物在群体里流通，形成了一系列相互交织的关系网络，出现了一种去中心化的内聚力。礼物经济在于关系的维护，通过赠送礼物，强化了双方的关系。如果破坏了双方的关系，就不能称为礼物，比如：什么样的礼物会破坏朋友圈的关系？打卡、广告、利己分享。比如：什么样的礼物会破坏朋友的关系？没完没了集call。对小程序开发者的启示：当小程序的某种裂变玩儿法，用户已经麻木甚至厌恶时，这种玩儿法就已经跳出了礼物经济，它不能对用户的关系起到正向的作用。3. 礼物具有“外部性”礼物的商品价值和消费价值在很大程度上是无关紧要的。礼物的价值，通过“送”而达成。礼物的价值不在于礼物本身。一个没有送出去的礼物，没有价值。礼物这种东西，具有很强的外部性。回到互联网。小程序需要具有“外部性”，用户通过分享，感知到价值。用户没有分享，感知不到价值。只有这样，分享才能成为必备操作。拼多多：用户分享前，感受到这是一个卖低价商品的卖场。用户分享后，哇塞好便宜，感觉自己赚到了人民币。黑咔：用户分享前，感受到这是一个图片处理工具。用户分享后，哇塞好有趣大家一起玩，感觉自己赚到了社交币。对小程序开发者的启示：用户通过分享，“才能”感知到小程序的核心价值。“才能”这两个字儿很重要。小结私域流量的分享其实在做的是“礼物经济”，从礼物经济的特点中，我们可以获得针对于小程序的3大启示。总结这篇文章写的有点难哦，感谢你能看完，本文观点回顾：流量升级的原因：微信社交能力的开放，将渠道集中式的“公域流量”转化成用户为中心的“私域流量”。流量升级的结果：私域流量去中心化，导致了“赢家通吃”模式的失效。礼物经济的启示：礼物具有极强的“外部性”。互惠是一种方式，而不是目的。相关阅读万字解析小程序（1）：小程序 PK APP = 无解 ？万字解析小程序（2）：如何保证大海上可以看到“小船”？#专栏作家#姜太公公，微信号公众号：grandpa_jiang，人人都是产品经理专栏作家。产品老流氓，终身学习者。致力于研究产品方法论，解决小白PM的疑难杂症。本文原创发布于人人都是产品经理。未经许可，禁止转载题图来自 Pexels，基于 CC0 协议"}
{"title": "微信小程序：动画（Animation） ", "author": "Rolan", "pub_time": "2018-10-29 00:30", "article_content": "简单总结一下微信动画的实现及执行步骤。一、实现方式官方文档是这样说的：①创建一个动画实例 animation。②调用实例的方法来描述动画。③最后通过动画实例的 export 方法导出动画数据传递给组件的 animation 属性。因为小程序是数据驱动的，给这句话加上数字标注分为三步：前两步是定义一个动画并设置都要干什么，然后把这个设置好的“规则”扔给界面上的某个元素，让它按照这个规则执行。当然如果有多个元素的animation=\"{{ani}}\"，也都会执行这个动画规则。二、用例子说话新建一个小程序，把没用的删掉修改一下，做个简单例子，上图代码如下：index.wxml，一个helloworld，一个按钮<view class=\"container\">\r\n  <view class=\"usermotto\" animation=\"{{ani}}\">\r\n    <text class=\"user-motto\">{{motto}}</text>\r\n  </view>\r\n  <button bindtap='start'>动画</button>\r\n</view>index.wxss， 为了看着方便加了个边框.usermotto {\r\n  margin-top: 100px;\r\n  border: solid;\r\n}index.jsPage({\r\n  data: {\r\n    motto: 'Hello World',\r\n  },\r\n  start:function(){\r\n    var animation = wx.createAnimation({\r\n      duration: 4000,\r\n      timingFunction: 'ease',\r\n      delay: 1000\r\n    });\r\n    animation.opacity(0.2).translate(100, -100).step()\r\n    this.setData({\r\n      ani:  animation.export()\r\n    })\r\n  }\r\n}) 三、相关参数及方法简单介绍一下例子中的几个参数和方法（其他的详见官方文档）：      duration: 动画持续多少毫秒      timingFunction: “运动”的方式，例子中的 'ease'代表动画以低速开始，然后加快，在结束前变慢        delay: 多久后动画开始运行      opacity(0.2) 慢慢变透明      translate(100, -100) 向X轴移动100的同时向Y轴移动-100      step(): 一组动画完成，例如想让上例中的HelloWorld向右上方移动并变透明后，再次向左移动50可以继续写 animation.translateX( -50).step() , 作用就是向右上方移动和变透明是同时进行， 这两种变化完成之后才会进行向左运行的一步。"}
{"title": "megalo -- 网易考拉小程序解决方案 ", "author": "Rolan", "pub_time": "2018-10-29 00:33", "article_content": "megalo 是基于 Vue 的小程序框架（没错，又是基于 Vue 的小程序框架），但是它不仅仅支持微信小程序，还支持支付宝小程序，同时还支持在开发时使用更多 Vue 的特性。背景对于用户而言，小程序能提供更好的体验，但对于开发者而言，要让一个应用跑在多个平台上，则需要写多套代码。如何提高小程序开发效率让很多开发者都感到头疼。业界也有相关的解决方案，如 taro 和 mpvue，二者都是基于 react 和 vue 的开发模式实现，让开发者能够以他们熟知的 react 或 vue 模式来开发小程序，提高开发效率。mpvue 的发布给了我们很多启发，更早的时候，我们基于 RegularJS（网易自研的前端框架）开发了一个名为 mpregular 的小程序框架。在 mpregular 的开发和实际使用过程中，我们发现如果小程序框架所支持的特性只是原框架的子集（例如不支持 filter、模版复杂表达式等），开发效率会大打折扣。所以，我们在方案上做了很多尝试，目的是支持更多的特性，减少小程序与 H5 开发之前的差异。目前 mpregular 已经在考拉的小程序业务中大量应用，相关业务的开发同学纷纷表示，学习成本变低，跨端业务（H5 和小程序）的开发效率提升近一倍。方案经过一段时间验证后，我们决定把这套方案用 vue 再实现一次，一是为了适应技术栈的变更升级，二是为社区做一点微小的工作，于是就便有了 megalo。特性支持更多模版语法特性相比于其他小程序开发模式，由于支持更多特性，megalo 更贴近 Vue 原生的开发模式。从表格可以看到，megalo 最大的特点之一是，支持更多的 Vue 语法特性。这意味着，如果你有一个需求是要把现有的 Vue 代码迁移到小程序上，不需要太多改动。因为你的代码中可能大量使用 filter、scoped-slot、复杂表达式插值。基本语法支持 vue 的基本模版语法，包括 v-for 、 v-if 。class 和 style 的绑定方式没有限制，官方的用法都支持。<!-- v-if & v-for -->\r\n<div v-for=\"(item, i) in list\">\r\n  <div v-if=\"isEven(i)\">{{ i }} - {{ item }}</div>\r\n</div>\r\n\r\n<!-- style & class -->\r\n<div :class=\"classObject\"></div>\r\n<div :class=\"{ active: true }\"></div>\r\n<div :class=\"[activeClass, errorClass]\"></div>\r\n<div :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\r\n<div :style=\"styleObject\"></div>\r\n<div :style=\"[baseStyles, overridingStyles]\"></div>\r\n复制代码slot & scoped-slot支持 slot 和 scoped-slot。<div>\r\n  <Container>\r\n    <Card>\r\n      <div slot=\"head\"> {{ title }} </div>\r\n      <div> I'm body </div>\r\n      <div slot=\"foot\"> I'm footer </div>\r\n    </Card>\r\n  </Container>\r\n  <List :list=\"list\">\r\n    <span slot-scope=\"scopeProps\">{{ scopeProps.item.label }}</span>\r\n  </List>\r\n<div>\r\n复制代码复杂表达式 & filter可以在模版里面写复杂表达式、调用实例上的方法，当然也可以用更简洁的 filter 语法，跟平时用 Vue 开发一样。<div>\r\n  <div>{{ message.toUpperCase() }}</div>\r\n  <div>{{ toUpperCase( message ) }</div>\r\n  <div>{{ message | toUpperCase }}</div>\r\n</div>\r\n复制代码v-html要使用 v-html 需要添加插件 @megalo/vhtml-plugin ，并引入模版解析库 octoparse ，在页面入口安装一下插件：import Vue from 'vue'\r\nimport VHtmlPlugin from '@megalo/vhtml-plugin'\r\n\r\nVue.use(VHtmlPlugin)\r\n复制代码利用 v-html 指令然后就可以在小程序中渲染 html 了。<div v-html=\"'<h1>megalo</h1>'\"></div>\r\n复制代码更好的数据更新性能小程序的官方明确说明，在调用 setData 更新数据时如果数据量过大或频率更高，会引发性能问题。megalo 在框架底层已经帮开发者对此进行优化，每次数据发生变化时，megalo 只会将视图中要展示的、且发生变化的数据进行更新，将 setData 的数据更新量最小化，同时对更新数据频率进行了限制。像下面这段代码，如果视图只需要展示 user.name 这个字段的话，在进行数据同步时只会将 user.name 这个字符串更新到视图层，其余字段是不会同步到小程序的对象上的。<div>{{ user.name }}</div>\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      user: {\r\n        name: 'kaola',\r\n        age: 3,\r\n        favorite: [\r\n          'encalyptus',\r\n          'sleeping'\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}\r\n</script>\r\n复制代码支持更多平台今年以来，各大流量平台都在小程序领域有所动作，蚂蚁金服成立小程序事业部，百度、今日头条也纷纷推出自己的小程序。megalo 目前已经支持微信和支付宝小程序，百度小程序等平台的支持也在计划当中。微信和支付宝小程序使用使用 megalo 开发非常简单，只需在常见的 Vue 项目 webpack 构建配置上配置 @megalo/target 并引入 @magalo/template-compiler 即可。如果需要编译成支付宝小程序，只需要设置 platform: 'alipay' 。const { createMegaloTarget } = require('@megalo/target');\r\nmodule.exports = {\r\n  target: createMegaloTarget( {\r\n    compiler: require('@megalo/template-compiler'),\r\n    platform: 'wechat'\r\n  } )\r\n  // 其他 webpack 配置，如 vue-loader 等\r\n};\r\n复制代码接着，就可以像开发 Vue 应用一样去开发小程序。示例可以参考 megalo-demo 。如果想用 typescript 进行开发，可以参考 megalo-ts-simple 。实现小程序在结构上主要有 Service(JavascriptCore) 和 View(WebView) 两部分组成（微信和支付宝小程序有着类似的结构，下文均以微信小程序为例，并简称为小程序），分别运行在独立的环境上，之间不具备共享数据通道，二者的通信方式是将数据封装在 js 脚本后传递。Page 实例就在 Service 中，通过 setData 方法将数据传递到 View。View 则通过事件绑定将视图层触发的事件传递给 Service。Service 层中无法操作视图层的 DOM 节点。实际开发中，小程序的逻辑和模版需要写在 .js 和 .wxml 两个文件中，分别在 Service 和 View 中执行。如果要将在浏览器端的 Vue 放到小程序中跑，需要将 .vue 文件中的 template 片段转换成 .wxml 文件，并对 Vue 的 runtime 部分改造，将其中的 DOM 操作移除，通过小程序的 Service 中的页面实例上的 API 与 View 进行通信。最终的运行效果是，当 Vue 的 vm 上数据发生更新时，会重新渲染出 vdom，在的 patch 阶段，框架不在去操作 DOM，而是通过 Page 上的 setData 方法将变化的数据更新到视图层，完成 Vue 和 小程序的视图更新，这就是 megalo 底层所做的工作。megalo 的实现，主要分成以下四个部分，下面本文将对每个部分进行介绍。生命周期小程序中，每一个页面（Page）是一个实例，页面的生命周期钩子有很多，但和实例创建的两个关键生命周期分别是 onLoad 和 onReady ，它们分别在「 页面加载，实例初始化后 」和「 初次页面渲染完成 」时触发。Vue 的实例要和小程序实例建立起联系，则需要在小程序 Page 实例创建好以后，即在 onLoad 的钩子函数里，去初始化对应的 Vue 根实例，将页面实例 page 挂载到 Vue 实例的 $mp 上，此时也会触发 Vue 的生命周期钩子 created 。在页面初次渲染完成后，则会调用 $mount 方法，与在浏览器中挂载 DOM 节点不同，这里会将 Vue 实例上的数据初始化到视图层中。由此，Vue 实例就与小程序的 Page 实建立起了联系。除了这两个生命周期钩子以外，像小程序的 onShow 、 onHide 等生命周期钩子在触发时，也会尝试触发 Vue 实例上的同名钩子函数，实现两种实例间生命周期的绑定。在小程序页面退出销毁时，会触发 onUnload 钩子，此时 Vue 的实例也会跟着销毁。模版转换小程序有它特有的模版语法和文件名后缀，所以在构建阶段，我们会将 .vue 文件中的 template 部分提取出来并转换成对应的 .wxml 文件。标签名、语法都会进行相应的转换，如图所示。这一部分是在构建阶段完成的，这意味着，megalo 不支持 render 函数的写法。在构建阶段除了将模版转换成 .wxml 以外，还需要对模版中的每个节点进行转换，并在生产的 render 函数中加入相关的节点标记信息，数据映射和事件代理需要这些信息。数据映射由于无法直接操作视图层的 DOM，所以我们只能利用 page.setData 这个方法完成数据到视图层的映射。最简单暴力的方法，是将 Vue 实例上的所有数据统统收集起来，通过调用 page.setData 方法更新 Page 实例的数据，这个方法会将数据挂载到 Page 实例上，同时也会把数据传递给视图层。但是，这种粗暴的更新方式有两个弊端：i. 全量更新 vm 上的数据是无法区分哪些数据是视图层需要的，冗余无用的数据会被更新到 page 实例上。像下图这个例子，视图层只需要展现两个字符串，如果 vm 上还存在两个大数组，它们也会被无脑同步到 page 上。ii. 同步到 page 实例上的数据其实就是原始数据，并不是视图层实际要展示的数据，所以展示数据的格式化与转换需要依赖小程序模版的解析能力，导致一些 Vue 支持的模版语法无法支持，例如 filter、复杂表达式、传递 class 对象等。当然以上两个弊端不会对功能开发造成影响，但在实际的业务开发中，会让开发体验不一致，尤其是 h5 代码迁移到小程序时，对效率影响颇大。为了解决这个问题，megalo 采用另一种方式，即将 render 时生成的 vnode 上的数据更新到视图，vnode 的数据就是已经处理好的展示数据，根据 vnode 构造每个节点的数据结构，再同步到视图层。例如以下这段代码，在构建阶段 megalo 会对每个节点进行标记，使 render 时生成的 vnode 和模版中每个插值能够对应上。<!-- 编译前的 Vue 模版 .vue -->\r\n<div :class=“classObj”>\r\n  {{ date | format( 'YYYY' ) }}\r\n</div>\r\n\r\n<!-- 编译后的小程序模版 .wxml -->\r\n<view class=\"{{ node_1.class }}\">\r\n  {{ node_1.text }}\r\n</view>\r\n复制代码以这种方式实现的数据映射，只有视图层需要的两个字符串数据会被同步到小程序的 Page 实例上，其余数据则被认为与视图无关则不会进行同步。export default {\r\n  data() {\r\n    return {\r\n      classObj: {\r\n        'kaola': true\r\n      },\r\n      date: new Date(),\r\n      users: {\r\n        // big object\r\n      }\r\n    }\r\n  }\r\n}\r\n复制代码如下图所示，Vue 渲染出来的 vnode 会被以特定的数据结构映射到 page 上，再同步到小程序视图层。以这种方式实现的数据映射，可以更好地支持 Vue 的模版语法，且更大限度地减少更新视图时传输的数据量，从框架层面规避 setData 的性能问题。事件代理小程序视图触发事件后，会将 event 对象通知到 Page 实例，那么我们只需要将视图层中所有的事件都代理到 page.proxy 这个方法中，然后再靠这个方法从 Vue 的实例树上找到对应的 vm和 handler 做事件处理。为了实现这一目的，在构建阶段对模版进行编译时，除了要将事件监听方法转换为 proxy 以外，还需要通过 data- 在元素上标记对应的组件 compid 和节点 nodeid。<!-- 编译前的 Vue 模版 .vue -->\r\n<div @click=\"onClick\"></div>\r\n\r\n<!-- 编译后的小程序模版 .wxml -->\r\n<view bindtap=\"proxy\" data-compid=\"0\" data-nodeid=\"0\"></view>\r\n复制代码事件触发时，proxy 方法会从 event 对象上获取对应的 id 信息和事件类型，进而从 Vue 的根 vm 开始查找，最终在 vnode 上找到对应的 handler 并执行事件处理，完成小程序事件到 Vue 实例的事件代理。现在与未来目前，megalo 已经逐步在考拉的小程序应用开发中投入使用，但 megalo 的数据映射方案早已通过 mpregular 在考拉的大量小程序应用中得到了验证。现在，megalo 支持 typescript 开发，支持支付宝小程序。百度智能小程序的支持也在计划之内，同时，我们还计划开发一个兼容个平台的 UI 组件库、API 库，尝试将跨 H5 和各小程序平台的应用开发之间的差异最小化，提升开发效率。"}
{"title": "node配置微信小程序解密消息以及推送消息 ", "author": "Rolan", "pub_time": "2019-2-15 00:08", "article_content": "上一篇文章介绍过 微信小程序配置消息推送，没有看过的可以先去查看一下，这里就直接去把那个客服消息接口去解密那个消息了。　　在这里我选择的还是json格式的加密。　　也就是给小程序客服消息发送的消息都会被微信转发到这里配置的地址和接口上面。　　在页面中使用客服消息也就是如下这个效果，是需要用到微信提供的button标签上面的open-type的　　　　点击进入客服消息也就是如下这个效果。　　　　然后你发送的消息就会被转发到上面你配置的那个服务器的端口和那个接口上面，也就是例子中的 　　只不过配置确认的时候的接口是get请求方式，而微信转发消息到这里的接口这里是post请求方式。　　在聊天窗口中发送消息，微信就会把加密后的消息转发到我们的接口  也就是 /checkPushMsg 上面，post请求方式。　　在node中的代码接收，看看微信给我们转发了什么东西呢 1 // 配置前后端的推送消息\r\n 2 router.get('/checkPushMsg', wx_msg.check_push);\r\n 3 \r\n 4 // 那个函数就是如下的处理\r\n 5 exports.handle_customer_sevice = (req, res) => {\r\n 6     console.log('接收到了消息，请求体中');\r\n 7     console.log(req.body);\r\n 8     console.log('接收到了消息，请求url中');\r\n 9     console.log(req.query);\r\n10 }　　我们来查看一下发送过来的什么，我再用文档来比对一下哈。　　现在我在手机上面那个页面里面发送一条消息，任意内容。 　　这里服务器的图片太小了，可以 按住 ctrl + 鼠标滚轮把这里放大看一下，我相信你肯定知道的。　　　　请求url中的内容如下  　　请求体中的内容一个是发送者的 openid，另外一个加密的就是消息内容，它的构成是由  16个字节的随机字符串，4个字节的消息长度，发送的消息，appId由基于AES加解密算法加密而成的。　　这里咱们先不着急解密发送的内容，我们要在解密之前先判断一下是不是微信发送过来的呢，如果不是你在这里解密半天然后发出去那不就难受了。　　上面的图片中也详细的介绍了如何去判断是不是微信发送过来的消息。　　我什么也不想解释了，直接上代码啦。　　 1 exports.handle_customer_sevice = (req, res) => {\r\n 2     console.log('接收到了消息，请求体中');\r\n 3     console.log(req.body);\r\n 4     console.log('接收到了消息，请求url中');\r\n 5     console.log(req.query);\r\n 6     let signature = req.query.signature,\r\n 7         timestamp = req.query.timestamp,\r\n 8         nonce = req.query.nonce,\r\n 9         openid = req.query.openid,\r\n10         encrypt_type = req.query.encrypt_type,\r\n11         msg_signature = req.query.msg_signature,\r\n12         msg_encrypt = req.body.Encrypt; // 密文体\r\n13     \r\n14     // 开发者计算签名\r\n15     let devMsgSignature = sha1(pushToken, timestamp, nonce, msg_encrypt); // 这里的pushToken是 上面那个 配置消息推送 里面设置的Token令牌\r\n16    \r\n17     if(devMsgSignature == msg_signature){\r\n18         console.log('验证成功,是从微信服务器转发过来的消息');\r\n19         \r\n20         res.send('success');\r\n21     }else{\r\n22         console.log('error');\r\n23         res.send('error');\r\n24     }\r\n25 };　　上面的那个sha1函数是这样的 1 /*\r\n 2     @explain sh1加密\r\n 3     @version 1.0.1\r\n 4     \r\n 5     @author : Z\r\n 6     @data : 2019-2-13\r\n 7     \r\n 8     @params : a,b,c……\r\n 9     @return : String 加密完成后的字符串\r\n10  */\r\n11 exports.sha1 = function (...arr) {\r\n12     return crypto.createHash('sha1').update(arr.sort().join('')).digest('hex');\r\n13 };　　上面就可以验证出来如果那个加密的东西确实是那样的就可以验证出来消息确实是由微信发送过来的。  　　然后就要开始解密了，这里我遇到了好多坑，说实话我也不知道下面的代码是谁第一个写出来的，因为官网上面根本就没有Node.js的代码，所以我也是看到了加密消息的构成部分，然后使用下面封装的函数解密。　　 1 /*\r\n 2     @explain: 微信的消息密文解密方法\r\n 3     @version 1.0.1\r\n 4         修复部分消息解析失败的情况\r\n 5     @author: Z\r\n 6     @data :2019-02-14\r\n 7     @params:\r\n 8         obj.AESKey:解密的aesKey值  这里的key就是配置消息推送的那部分\r\n 9         obj.text: 需要解密的密文\r\n10         obj.corpid: 企业的id / 微信小程序的appid\r\n11   \r\n12     @return\r\n13         obj.noncestr  随机数\r\n14         obj.msg_len   微信密文的len\r\n15         obj.msg       解密后的明文\r\n16 */\r\n17 \r\n18 exports.decrypt = function (obj) {\r\n19     let aesKey = Buffer.from(obj.AESKey + '=', 'base64');\r\n20     const cipherEncoding = 'base64';\r\n21     const clearEncoding = 'utf8';\r\n22     const cipher = crypto.createDecipheriv('aes-256-cbc',aesKey,aesKey.slice(0, 16));\r\n23     cipher.setAutoPadding(false); // 是否取消自动填充 不取消\r\n24     let this_text = cipher.update(obj.text, cipherEncoding, clearEncoding) + cipher.final(clearEncoding);\r\n25     /*\r\n26         密文的构成\r\n27             Base64_Encode(AES_Encrypt[random(16B) + msg_len(4B) + msg + $appId])\r\n28         但是由于部分消息是不满足那个 32 位的，所以导致上面那个 cipher.final() 函数报错，所以修改为了自动填充，所以 appId后面还跟着一些字符\r\n29             就无法正常解析了，所以就不返回 corpid 了，然后返回我们想要的东西。\r\n30      */\r\n31     return {\r\n32         noncestr:this_text.substring(0,16),\r\n33         msg_len:this_text.substring(16,20),\r\n34         msg:this_text.substring(20,this_text.lastIndexOf(\"}\")+1)\r\n35     }\r\n36 };　　其中的坑就是我遇到了那个  cipher.setAutoPadding(false) 这里填充的问题，但是有的消息是可以解密出来的，但是有的消息是不可以解密出来的，会报错，所以我就让所有的消息都填充了。　　let this_tex = cipher.update(obj.text, cipherEncoding, clearEncoding) + cipher.final(clearEncoding); 　　解密消息这里的问题是，这是一个加法，前面的那个更新函数会改变 cipher的值，然后导致后面的那个值发生改变，当时找这个错误出现了很多问题。这个问题就是当字体的内容的长度不是32个字节还是什么的倍数的时候，这个函数会报一个500的错误码，然后不知道是哪里的问题，所以我就取消自动填充设置为了false，我就让它一直填充，然后处理那个消息，最后那个明文我再把最后的一个 } 后面截取掉。就可以展示出来了，但是这个里面就无法获取到小程序 appId 了，但是这又有什么必要呢？你后台肯定是知道appId的。　　我把消息处理的完整代码发出来。 1 /*\r\n 2     消息体验证和解密\r\n 3         客服接收到的消息\r\n 4         handle_customer_sevice\r\n 5         \r\n 6 */\r\n 7 \r\n 8 exports.handle_customer_sevice = (req, res) => {\r\n 9     console.log('接收到了消息，请求体中');\r\n10     console.log(req.body);\r\n11     console.log('接收到了消息，请求url中');\r\n12     console.log(req.query);\r\n13     let signature = req.query.signature,\r\n14         timestamp = req.query.timestamp,\r\n15         nonce = req.query.nonce,\r\n16         openid = req.query.openid,\r\n17         encrypt_type = req.query.encrypt_type,\r\n18         msg_signature = req.query.msg_signature,\r\n19         msg_encrypt = req.body.Encrypt; // 密文体\r\n20     \r\n21     // 开发者计算签名\r\n22     let devMsgSignature = sha1(pushToken, timestamp, nonce, msg_encrypt);\r\n23     \r\n24     if(devMsgSignature == msg_signature){\r\n25         console.log('验证成功,是从微信服务器转发过来的消息');\r\n26         \r\n27         let returnObj = decrypt({\r\n28             AESKey: config.server.EncodingAESKey,\r\n29             text: msg_encrypt,\r\n30             corpid: config.app.appId\r\n31         });\r\n32         console.log('解密后的消息');\r\n33         console.log(returnObj);\r\n34         console.log('解密后的消息内容');\r\n35         const decryptMessage = JSON.parse(returnObj.msg);\r\n36         console.log(decryptMessage);\r\n37      \r\n38         /*\r\n39             详细参数请查看官网 消息 https://developers.weixin.qq.com/miniprogram/dev/api/sendCustomerMessage.html\r\n40             @params\r\n41                 access_token  调用接口凭证\r\n42                 touser   用户的openid\r\n43                 msgtype   消息类型\r\n44          */\r\n45         \r\n46         if(JSON.parse(returnObj.msg).Content == '值班'){\r\n47             axios.post(config.url.ip + config.url.P_CustomSend + '?access_token='+config.access_token, {\r\n48                     touser: decryptMessage.FromUserName,\r\n49                     msgtype: \"text\",\r\n50                     text: {\r\n51                         content: \"发送消息\"\r\n52                     }\r\n53                 })\r\n54                 .then(res => {\r\n55                     console.log('消息接口发送成功');\r\n56                     \r\n57                     console.log(res.data);\r\n58                     if(res.data.errcode == 0){\r\n59                         console.log('消息发送成功');\r\n60                     }else if(res.data.errcode == 40001){\r\n61                         console.log('access_token过期');\r\n62                     }else{\r\n63                         console.log('其他错误信息')\r\n64                     }\r\n65                     console.log(res.data);\r\n66                 })\r\n67                 .catch(err => {\r\n68                     console.log('错误消息');\r\n69                     console.log(err);\r\n70                 })\r\n71         }\r\n72         res.send('success');\r\n73     }else{\r\n74         console.log('error');\r\n75         res.send('error');\r\n76     }\r\n77 };　　　　上面用到的两个函数 一个 sha1，另外一个就是 解密函数。　　现在发送一下消息，看一看服务器上面的处理过程。   　　如此是可以解密出来那个消息的内容的，然后我设置了一个发送值班的话会给我发送一个消息。　　   　　如此 就大功告成了。　　看了网上的许多文章大多都是Java，php的代码，很少有Node的代码，而且看了之后也不知道能不能弄出来，如果你遇到这个问题， 仔细看了我的文章之后，还有地方不知道，欢迎打扰我，告诉我哪里不清楚，我也会和你一起把你的问题解决掉。　　如果解决了你的问题我会非常高兴的，其实上面的文章中我也感觉到了有一些地方描述的不是那么清晰，比如说消息加密的那一块，说实话，我也不是那么了解他的加密，只是微信 这里是有讲述的 点击查看　　它的加密我会在最近几天研究一下，把他的加密的细节也给发出来，下一篇文章你可以查看到它的加密。　　如果解决了你的问题我真的会非常高兴，因为我开发了这么久感觉开发出来的东西都没有去影响一些人，甚至我想先给自己做一些程序，并且我已经开始着手去做了，先去方便一下自己再去做一些去对一些人有好处的影响的东西。"}
{"title": "关于小程序的基础库 ", "author": "Rolan", "pub_time": "2019-2-15 00:22", "article_content": "小程序的基础库，它包含了哪些东西，以及载入、更新的机制又是怎样的呢。小程序基础库的组成基础库成分关于基础库的成分，不得不提到我们之前说过的小程序渲染机制，参考 React 的 Virtual DOM。基础库除了处理 VD 的渲染问题，它还包括内置组件和逻辑层API，总的来说负责处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑。小程序的基础库是 JavaScript 编写的，它可以被注入到渲染层和逻辑层运行。在渲染层可以用各类组件组建界面的元素，在逻辑层可以用各类 API 来处理各种逻辑。同时，小程序的一些补充能力：自定义组件和插件，也有相应的基础代码，当然也需要添加到基础库里。所以我们可以看到，小程序的基础库主要是：提供 VD 渲染机制相关基础代码。（Exparser 框架）提供封装后的内置组件。提供逻辑层的 API。提供其他补充能力（自定义组件和插件等）的基础代码。Exparser 框架Exparser 是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由 Exparser 组织管理。Exparser 会维护整个页面的节点树相关信息，包括节点的属性、事件绑定等，相当于一个简化版的 Shadow DOM 实现。Exparser 的主要特点包括以下几点：基于 Shadow DOM 模型：模型上与 WebComponents 的 ShadowDOM 高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他 API 以支持小程序组件编程。可在纯 JS 环境中运行：这意味着逻辑层也具有一定的组件树组织能力。高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。基于这个框架，内置了一套组件，以涵盖小程序的基础功能，便于开发者快速搭建出任何界面。同时也提供了自定义组件的能力，开发者可以自行扩展更多的组件，以实现代码复用。内置组件小程序基于 Exparser 框架，内置了一套组件，提供了视图容器类、表单类、导航类、媒体类、开放类等几十种组件。内置组件在小程序框架里的定义是：在小程序架构里无法实现或者实现不好某类功能，使用组件内置到小程序框架里。常见包括：开放类组件：如 open-data 组件提供展示群名称、用户信息等微信体系下的隐私信息，有 button 组件里 open-type 属性所提供分享、跳转 App 等敏感操作的能力视图容器类组件：如 movable-view 这种因双线程模型导致手势识别不好实现的组件（在双线程模型中，触摸事件从渲染层发出，派发到逻辑层，这中间是有一定的延时而导致视图跟随手指运动这类交互变得有些卡顿）API宿主环境提供了丰富的API，可以很方便调起微信提供的能力。小程序提供的 API 按照功能主要分为几大类：网络、媒体、文件、数据缓存、位置、设备、界面、界面节点信息还有一些特殊的开放接口。需要注意 API 调用大多都是异步的。自定义组件自定义组件是开发者可以自行扩充的组件。开发者可以将常用的节点树结构提取成自定义组件，实现代码复用。在使用自定义组件的小程序页面中，Exparser 将接管所有的自定义组件注册与实例化。以 Component 为例：在小程序启动时，构造器会将开发者设置的 properties、data、methods 等定义段，写入 Exparser 的组件注册表中。这个组件在被其它组件引用时，就可以根据这些注册信息来创建自定义组件的实例。Page 构造器的大体运行流程与之相仿，只是参数形式不一样。这样每个页面就有一个与之对应的组件，称为“页面根组件”。在初始化页面时，Exparser 会创建出页面根组件的一个实例，用到的其他组件也会响应创建组件实例（这是一个递归的过程）。插件插件是对一组 js 接口、自定义组件或页面的封装，用于嵌入到小程序中使用。插件不能独立运行，必须嵌入在其他小程序中才能被用户使用；而第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用。插件开发者可以像开发小程序一样编写一个插件并上传代码，在插件发布之后，其他小程序方可调用。小程序平台会托管插件代码，其他小程序调用时，上传的插件代码会随小程序一起下载运行。小程序基础库机制基础库的载入在开发网页时，经常会引用很多开源的 JS 库，在使用到这些库所提供的 API 前，我们需要先在业务代码前边引入这些库。同样道理，我们需要在启动 APP 之前载入基础库，接着再载入业务代码。由于小程序的渲染层和逻辑层是两个线程管理，而我们 一般说起基础库，也通常包括 WebView 基础库（渲染层），和 AppService 基础库（逻辑层）。显然，所有小程序在微信客户端打开的时候，都需要注入相同的基础库。所以，小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。将基础库内置在微信客户端，有两个好处：降低业务小程序的代码包大小。可以单独修复基础库中的Bug，无需修改到业务小程序的代码包。小程序的启动在小程序启动前，微信会提前准备好一个页面层级用于展示小程序的首页。这里就包括了逻辑层和渲染层分别的初始化以及公共库的注入。在小程序启动时，微信会为小程序展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。基础库的更新小程序的很多能力需要微信客户端来支撑，例如蓝牙、直播能力、微信运动等，可以说，小程序基础库的迭代离不开微信客户端的发布。为了避免新版本的基础库给线上小程序带来未知的影响，微信客户端都是携带上一个稳定版的基础库发布的。等到微信客户端正式发布后，小程序会开始灰度推送新版本的基础库到微信客户端里，在这个过程需要仔细监控各类异常现象以及开发者和用户的反馈，一般灰度时长为12小时，灰度结束后，用户设备上就会有新版本的基础库。如果存在重大Bug，那此次推送会被回退。参考《小程序开发指南——小程序基础库的更新迭代》《小程序开发指南——6.2 组件系统》结束语本节大致结合了小程序的启动来讲了下小程序的基础库。其实很多都能在小程序开发指南里找到，只是文字太多又有些乱，看一遍未必能记住，但是第二遍又找不到了。哈哈哈吐槽下小程序的文档，很详细就是有点容易找不到。"}
{"title": "小程序的底层框架 ", "author": "Rolan", "pub_time": "2019-2-15 00:25", "article_content": "前端的框架太多让人眼花缭乱，很多相似的地方，优秀的地方大家都会借鉴，同时又会有各自的一些特点。小程序也好，其他框架也好，理解他们的设计缘由、实现原理，还是能学到很多很多东西的。一切始于双线程技术选型上一节《小程序的诞生》中，我们也提到了小程序的双线程设计。目前来说，页面渲染的方式主要有三种：Web 渲染。Native 原生渲染。Web 与 Native 两者掺杂，也即我们常说的 Hybrid 渲染。前面也说过，小程序最终的呈现形式，是 WebView + 原生组件，Hybrid 方式。我们结合之前对小程序的期望来看：开发门槛：Web 门槛低，不过 Native 也有像 RN 这样的框架支持体验：Native 体验比 Web 不要好太多，Hybrid 在一定程度上比 Web 接近原生体验版本更新：Web 支持在线更新，Native 则需要打包到微信一起审核发布管控和安全：Web 可跳转或是改变页面内容，存在一些不可控因素和安全风险由于小程序的宿主是微信，如果用纯客户端原生技术来编写小程序 ，那小程序代码需要与微信代码一起编包，跟随微信发版本，这种方式跟开发节奏必然都是不对的。所以方向应该是需要像 Web 技术那样，有一份随时可更新的资源包放在云端，通过下载到本地，动态执行后即可渲染出界面。如果用纯 Web 技术来渲染小程序，在一些有复杂交互的页面上可能会面临一些性能问题。这是因为在 Web 技术中，UI渲染跟 JavaScript 的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源。总地看来，小程序选择了 Hybrid 的渲染方式，可以用一种近似 Web 的方式来开发，并且还可以实现在线更新代码。同时，引入原生组件有以下好处：扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力体验更好，同时也减轻 WebView 的渲染工作绕过 setData、数据通信和重渲染流程，使渲染性能更好现在，我们还剩下一个很重要的问题：管控性和安全性。于是，双线程的设计被提出来了。双线程的小程序也不知道是哪位大佬，能想出双线程这样的模型，反正我是佩服得666的。双线程是什么？我们先来看个官方的图：小程序的渲染层和逻辑层分别由 2 个线程管理：渲染层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS 脚本。为什么要这么设计呢？前面提到的管控和安全，为了解决这些问题，我们需要阻止开发者使用一些浏览器提供的，诸如跳转页面、操作 DOM、动态执行脚本的开放性接口。我们可以使用客户端系统的 JavaScript 引擎，iOS下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境。通过提供一个沙箱环境来运行开发者的 JavaScript 代码来解决。这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口。这就是小程序双线程模型的由来：逻辑层：创建一个单独的线程去执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码渲染层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程双线程通信把开发者的 JS 逻辑代码放到单独的线程去运行，但在 Webview 线程里，开发者就没法直接操作 DOM。那要怎么去实现动态更改界面呢？前面我们知道，逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。这是不是意味着，我们可以把 DOM 的更新通过简单的数据通信来实现呢？Virtual DOM 相信大家都已有了解，大概是这么个过程：用JS对象模拟DOM树 -> 比较两棵虚拟DOM树的差异 -> 把差异应用到真正的DOM树上。在这里我们可以用上，如图：在渲染层把 WXML 转化成对应的 JS 对象。在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。我们通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。而这样完整的一套框架，基本上都是通过小程序的基础库来完成的。小程序的基础库小程序的基础库是 JavaScript 编写的，它可以被注入到渲染层和逻辑层运行。主要用于：在渲染层，提供各类组件来组建界面的元素在逻辑层，提供各类 API 来处理各种逻辑处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑由于小程序的渲染层和逻辑层是两个线程管理，两个线程各自注入了基础库。小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。这样可以：降低业务小程序的代码包大小可以单独修复基础库中的 Bug，无需修改到业务小程序的代码包Exparser 框架Exparser 是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由 Exparser 组织管理。Exparser 特点包括：基于 Shadow DOM 模型：模型上与 WebComponents 的 ShadowDOM 高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。关于基础库和 Exparser 框架，更多的也可以参考：《小程序开发指南》结束语这节里大概讲了小程序设计中比较重要的一个模型——双线程，关于双线程的出现、设计、数据通信，到基础库、Exparser 框架，都是一个个相关而又相互影响的选择。关于小程序的底层框架设计，其实还涉及更多更多我们未能一时半会掌握完的内容，自定义组件、原生组件，还有他们做了很多的性能优化工作，都不是只言片语能讲完的。我们能做的，就是多去思考。"}
{"title": "小程序页面管理与跳转 ", "author": "Rolan", "pub_time": "2019-2-15 00:31", "article_content": "一个小程序有很多页面，每个页面又有各自的线程、生命周期和功能逻辑。关于小程序的生命周期、页面之间的跳转有哪些特殊的地方呢？小程序的启动小程序启动过程初次进入小程序的时候，微信客户端初始化好宿主环境，同时从网络下载或者从本地缓存中拿到小程序的代码包，把它注入到宿主环境。大概是这么个过程：创建线程（渲染层和逻辑层），启动小程序。载入基础库（WebView 基础库和 AppService 基础库）。载入小程序业务代码（下载或者从本地缓存中拿到）。使用App()注册程序实例。为了让小程序业务代码能够调用 API 以及组件，就需要在启动小程序后先载入基础库，接着再载入业务代码。由于所有小程序都需要注入相同的基础库，所以小程序的基础库会被提前内置在微信客户端。而基础库是热更新的，故一般等微信客户端携带上一个稳定版的基础库正式发布后，再进行新版本基础库的灰度和推送。注册 App 实例宿主环境提供了App()构造器用来注册一个程序 App。App 实例是单例对象，在其他 JS 脚本中可以使用宿主环境提供的getApp()来获取程序实例。App() 必须在 app.js 中调用，必须调用且只能调用一次。不然会出现无法预期的后果。App()函数用来注册一个小程序。接受一个Object参数，其指定小程序的生命周期回调等。onLaunch小程序初始化完成时（全局只触发一次）触发onLaunch回调。在微信客户端中打开小程序有很多途径，对不同途径的打开方式，小程序有时需要做不同的业务处理。所以微信客户端会把打开方式带给onLaunch和onShow的调用参数options，我们可以根据参数来判断一些进入方式，以及做对应的逻辑处理。例如，我需要拿到从另外一个小程序跳转过来携带的信息，此时场景值应该是1037（参考场景值）：123456789App({  // ...  onShow: function(e) {    if(e.scene === 1037){      const data = e.referrerInfo && e.referrerInfo.extraData; // 拿到对应的数据      const refAppid = e.referrerInfo && e.referrerInfo.appId; // 拿到对应的小程序appid    }  }})onShow小程序启动，或从后台进入前台显示时触发onShow回调。通常我们用来处理数据和状态的更新。小程序进入后台状态：当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁。onHide小程序从前台进入后台时触发onHide回调。小程序进入前台状态：当再次进入微信或再次打开小程序，又会从后台进入前台。获取 App 实例我们可以使用全局的getApp()函数来获取到小程序 App 实例（在App()内的函数中使用this就可以拿到app实例。）。前面我们可以看到，App 的生命周期是由微信客户端根据用户操作主动触发的。故我们通过getApp()获取实例之后，不应该私自调用生命周期函数。具体的原理是什么呢？小程序的 JS 脚本是运行在 JsCore 的线程里，小程序的每个页面各自有一个 WebView 线程进行渲染，所以小程序切换页面时，小程序逻辑层的 JS 脚本运行上下文依旧在同一个 JsCore 线程中。因此，App 构造器可以传递其他参数作为全局属性以达到全局共享数据的目的。由于所有页面的脚本逻辑都跑在同一个 JsCore 线程，页面使用setTimeout或者setInterval的定时器，即使切换了页面，也需要自行清理定时器。可以选择：在页面离开onUnload、onHide等的时候自行清理做全局的定时器管理（当然也还是需要关闭时清理）说到页面之间的数据共享，我们也该来讲讲小程序里页面的启动。小程序页面页面生命周期宿主环境提供了Page(Object)构造器用来注册一个小程序页面，接受一个Object类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。注意：Object 内容在页面加载时会进行一次深拷贝，需考虑数据大小对页面加载的开销。这里我们先来看看官方的生命周期图：左侧是渲染层，右侧是逻辑层。几件事：渲染层和逻辑层之间通信，是通过 Native 转发实现的。逻辑层通过 Page 实例的setData方法传递数据到渲染层。由于需要两个线程的一些通信消耗，为了提高性能，每次只设置需要改变的最小单位数据。生命周期顺序：onLoad -> onShow -> onReady。页面生命周期函数：onLoad(Object query)页面加载时触发。一个页面只会调用一次，可以在onLoad的参数中获取打开当前页面路径中的参数。onShow()页面显示/切入前台时触发。onReady()页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。onHide()页面隐藏/切入后台时触发。onUnload()页面卸载时触发。和小程序实例的生命周期对比，其实页面也是有些相似。这里需要注意几点：当前页面路径的参数获取，只能在onLoad(query)的query参数中获取，无法在onShow()中获取onLoad、onReady和onUnload，一个页面都只会调用一次页面是卸载还是切换到后台，这些除了与小程序的后台切换有关系，还会与页面的跳转、切换逻辑有关系下面我们就来看下页面的逻辑。页面导航我们知道，一个小程序会拥有多个页面。在小程序里会有页面的层级关系，例如通过wx.navigateTo推入一个新的页面，在首页使用2次wx.navigateTo后，页面层级会有三层：获取页面栈getCurrentPages()函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。需要注意的是：修改页面栈会导致路由以及页面状态错误App.onLaunch的时候 page 还没有生成，不能在这调用getCurrentPages()但是其实不是每一次切换页面，都会被记录到页面栈里，我们看看页面导航的一些方法和行为：关于导航 API 的几个补充点：wx.navigateTo和wx.redirectTo只能打开非 TabBar 页面，wx.switchTab只能打开 Tabbar 页面，wx.reLaunch可以打开任意页面TabBar 页面指在 app.json 的 TabBar 字段定义的页面（客户端窗口的底部或顶部有 tab 栏可以切换页面）跳转到 TabBar 页面，路径后不能带参数（注意，Tabbar 页面初始化之后不会被销毁）调用页面路由带的参数可以在目标页面的onLoad中获取页面层级准备我们知道页面栈的表现，以及一些常见的导航方法，而小程序基础库也在页面层级做了些体验优化。对于每一个新的页面层级，视图层都需要进行一些额外的准备工作：在小程序启动前，微信会提前准备好一个页面层级用于展示小程序的首页每当一个页面层级被用于渲染页面，微信都会提前开始准备一个新的页面层级，减少每次新开页面的耗时每个页面的准备都有三个阶段：启动一个 WebView。WebView 中初始化基础库（此时还会进行一些基础库内部优化，以提升页面渲染性能）。注入小程序 WXML 结构和 WXSS 样式（小程序能在接收到页面初始数据之后马上开始渲染页面）。PS：wx.redirectTo不会打开一个新的页面层级，而是将当前页面层级重新初始化。参考导航.小程序路由.小程序3.2 程序与页面7.2 页面层级准备结束语页面的路由和跳转、切入方式，其实和用户的使用和交互紧紧相关，设计合理也是能大大提升用户体验的。其实这一节的内容，大部分都是小程序文档里面有的。只不过好些相关的内容被分散在各个地方，理解和使用起来还是需要查找，这一节就当作整理笔记吧。"}
{"title": "小程序button引导用户授权 ", "author": "Rolan", "pub_time": "2019-2-18 00:23", "article_content": "wx.getUserInfo(OBJECT) 注意：此接口有调整，使用该接口将不再出现授权弹窗，请使用<button open-type=\"getUserInfo\"></button>引导用户主动进行授权操作所以我们要使用上述button来请求用户授权1.index.wxml<button \r\n    wx:if=\"{{canIUse}}\" \r\n    open-type=\"getUserInfo\" \r\n    bindgetuserinfo=\"bindGetUserInfo\"\r\n>授权登录</button>\r\n<view wx:else>请升级微信版本</view>2.index.jsPage({\r\n  data: {\r\n    //判断小程序的API，回调，参数，组件等是否在当前版本可用。\r\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\r\n  },\r\n  onLoad: function () {\r\n    // 查看是否授权\r\n    wx.getSetting({\r\n      success: function (res) {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          wx.getUserInfo({\r\n            success: function (res) {\r\n              console.log(res.userInfo)\r\n              //用户已经授权过\r\n            }\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n  bindGetUserInfo: function (e) {\r\n    console.log(e.detail.userInfo)\r\n    if (e.detail.userInfo) {\r\n      //用户按了允许授权按钮\r\n    } else {\r\n      //用户按了拒绝按钮\r\n    }\r\n  }\r\n})注：如果未出现微信授权的弹窗，则可能是因为之前授权的缓存导致的，因为只有未授权才会出现弹窗，清除缓存即可参考： https://blog.csdn.net/weixin_...https://blog.csdn.net/weidong...https://www.cnblogs.com/legen..."}
{"title": "小程序端实现文本展示以及标题定位 ", "author": "Rolan", "pub_time": "2019-2-18 00:34", "article_content": "探讨一个针对文本内容设置标题定位的业务场景。\r\n业务场景\r\n管理后台录入/编辑一段md或富文本协议，小程序端进行展示协议，且在小程序实现标题侧边栏，能快速定位至对应的内容。如图所示\r\n\r\n\r\n管理后台：录入内容实现方式\r\n1. 产出 长文本\r\n管理后台录入时，录入以markdown格式或富文本格式。\r\n由于项目在早期已进入开发，当时对markdown的转化工具兼容性较低，所以选择采取以富文本的方式进行保存。\r\n2. 产出 标题列表\r\n录入后，检索出对应的标题，将标题赋予对应标识，产出 标题列表。\r\n客户端：小程序实现方式\r\n小程序的实现方式有多种，先讲比较常用的两种方式：\r\n方式一：wxParse + <scrollView>\r\n采用微信小程序创建 wxParse —— 微信小程序富文本解析组件，支持Html及markdown转wxml可视化。\r\n\r\n\r\n优点\r\n\r\n对富文本支持程度很高，样式上可以按需调整\r\n易定制化，对于图片、链接等，可根据不同需要来控制其点击效果\r\n\r\n\r\n\r\n缺点\r\n\r\n解析时间随着元素的数量而不同。对html元素都进行解析，如果遇到一些表格类型，就会有特别多<tr> 、<td> 标签，解析速度非常缓慢，导致等待时间很长，用户体验不好。但如果采用方式二，就可以避开对内容的解析，不需要再控制解析时间。\r\n\r\n\r\n\r\n方式二：web-view + 网页展示\r\n文本的内容就全部放到一个h5网页来实现，在小程序端就通过 web-view 组件来展示这个网页内容。\r\n但对于标题的定位跳转，也可以有不同实现方式：\r\n<a> 标签做标题跳转的锚点\r\n\r\n\r\n优点\r\n\r\n富文本展示，内容不需要很多调整\r\n设定锚点非常简单，跳转容易\r\n\r\n\r\n\r\n缺点\r\n\r\n\r\n通过触发点击带锚点的链接，浏览器前进后退可能导致hash的变化。点击返回的时候，返回的不是上一页面，而是上一个定位的位置。详情可查看《理解浏览器历史记录》\r\n\r\n\r\n\r\n\r\n\r\n由于用<a> 标签做标题跳转的锚点的方式，对\"返回\"按钮不友好，所以采用另一种方式，用 js 模仿 <a> 标签跳转。\r\njs 控制滚动，仿 <a> 标签跳转\r\n\r\n\r\n优点\r\n\r\n富文本展示，内容不需要很多调整\r\n设定锚点非常简单，跳转容易\r\n能返回上一页面\r\n\r\n\r\n\r\n缺点\r\n\r\n需要处理那些非业务域名下的链接跳转，否则会弹出非法域名的提示，对用户不友好。\r\n微信其他组件的使用受到限制，例如点击图片预览等，需要加jssdk配置\r\n\r\n不过上述的两个缺点都可以通过网页进行解决，剩下的是开发便捷性的问题。\r\n\r\n\r\n总结\r\n上面的实现方式仅仅是富文本的方式，如今对 markdown 格式的应用和转化的支持性都有所提高，所以针对 markdown 格式的文本，也可以做类似的探讨。如果你有想法可以和我们一起交流，并且我们也在招聘 web前端开发工程师 ，如果有兴趣也可以加入我们哟O(∩_∩)O ，了解更多或者投递简历到邮箱 web@talkmoney.cn。\r\n\r\n\r\n作者简介：土拨鼠，芦苇科技web前端开发工程师，代表作品：飞花亭小程序、续航基因、YY表情红包、YY叠方块直播竞赛小游戏。擅长网站建设、公众号开发、微信小程序开发、小游戏、公众号开发，专注于前端框架、服务端渲染、SEO技术、交互设计、图像绘制、数据分析等研究，有兴趣的小伙伴来撩撩我们~ web@talkmoney.cn"}
{"title": "关于微信 setData 回调函数中的坑 ", "author": "Rolan", "pub_time": "2019-2-18 00:43", "article_content": "最近在做录音功能，需求大体是这样的：点击开始录音按钮，页面状态变为录音中，然后开始录音。不过伟大的测试同学发现了一个问题：当快速的连续点击开始录音按钮时，会触发多次开始录音的事件，这样在结束录音时就仍然会有一个正在录音中的标识，像这样:下面开始曲折的修复之路:最开始的代码是这样的:Page({\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function(options) {\r\n    // 初始化录音管理器\r\n    this.recorderManager = wx.getRecorderManager()\r\n\r\n    // 录音开始事件\r\n    this.recorderManager.onStart(() => {\r\n      \r\n    })\r\n  },\r\n\r\n  /**\r\n   * 录音按钮点击事件\r\n   */\r\n  tapRecordBtn: function() {\r\n    this.setData({\r\n      // 切换页面显示\r\n    }, () => {\r\n      // 开始录音\r\n      this.recorderManager.start({})\r\n    })\r\n  },\r\n})这时我的猜测是：页面重新渲染之前，按钮还是显示状态，所以还能被点击。那既然这样，就加个标识，在一次点击之后，到页面重新渲染之前，都不能再次点击就好了，代码如下：Page({\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function(options) {\r\n    // 初始化录音管理器\r\n    this.recorderManager = wx.getRecorderManager()\r\n    // 录音开始按钮点击标识\r\n    this.isRecordBtnClicked = false\r\n\r\n    // 录音开始事件\r\n    this.recorderManager.onStart(() => {\r\n\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 录音按钮点击事件\r\n   */\r\n  tapRecordBtn: function() {\r\n    // 如果录音按钮已被点击(录音即将开始)，则不会再次触发开始录音事件\r\n    if (this.isRecordBtnClicked) {\r\n      return\r\n    }\r\n    this.isRecordBtnClicked = true\r\n\r\n    this.setData({\r\n      // 切换页面显示\r\n    }, () => {\r\n      this.isRecordBtnClicked = false\r\n      // 开始录音\r\n      this.recorderManager.start({})\r\n    })\r\n  },\r\n})想法是好的，不过并没有实现想要的效果。还是可以被多次点击。于是在多次实验之后，改为如下的方式（可行）：Page({\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function(options) {\r\n    // 初始化录音管理器\r\n    this.recorderManager = wx.getRecorderManager()\r\n    // 录音开始按钮点击标识\r\n    this.isRecordBtnClicked = false\r\n\r\n    // 录音开始事件\r\n    this.recorderManager.onStart(() => {\r\n      // 将录音按钮的点击状态在录音开始时修改\r\n      this.isRecordBtnClicked = false\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 录音按钮点击事件\r\n   */\r\n  tapRecordBtn: function() {\r\n    // 如果录音按钮已被点击(录音即将开始)，则不会再次触发开始录音事件\r\n    if (this.isRecordBtnClicked) {\r\n      return\r\n    }\r\n    this.isRecordBtnClicked = true\r\n\r\n    this.setData({\r\n      // 切换页面显示\r\n    }, () => {\r\n      // 开始录音\r\n      this.recorderManager.start({})\r\n    })\r\n  },\r\n\r\n})将按钮的点击状态在录音开始事件中进行重置，就可以解决这个问题了。说一下最后验证的结果：setData() 方法的回调函数并不是在页面重新渲染完之后才执行的，所以并不能以回调函数作为一个明确的时间点来处理一些逻辑。而由于recorderManager.onStart() 方法触发时会有一定的延时，所以间接的解决了这个问题。"}
{"title": "微信小程序的登录体系 ", "author": "Rolan", "pub_time": "2019-2-19 00:21", "article_content": "我们知道，WEB服务器通过浏览器携带的cookie获取session来判断是否是同一用户（或浏览器）。cookie 和 session 的区别cookie 和 session 并不是同一个层面的东西。cookie 是实际真实存在的一个东西，是http协议规定的，如同一种载体，我们可以在响应头里面设置 cookie，只要你愿意，你可以在cookie里面设置任何东西，不管是用户信息用户昵称, 但是这样有安全性风险，cookie里面不适合有敏感性的信息，比如说，只放 session_idsession 是一个抽象概念，是客户端和服务端保持会话的一种方法，一种通用的机制。 session 的意思是 会话 ，实现是：服务端把一个 唯一标识 和用户身份的对应的关系存储下来，存在 redis , 文件 ， 数据库 中都可以。客户端出的请求带上 唯一标识 ，服务端从 redis或者 文件 或者 数据库 中找出这个 唯一标识 对应的身份，这种机制就被称为 sessionsession 机制大部分使用 cookie 作为载体运送这个 唯一标识 ，也可以采用url 连接、 自定义请求头来实现。小程序登录态对于小程序来说，也需要一个唯一的标识符来区分用户，也就是session来保持会话，但是小程序没有cookie, 因此我们的唯一标识符会被存储在 localstorage 里面，每次发请求时，都会从 localStorage 里面拿到这个唯一标识符，带在请求中。微信的 openid 和 code在日常开发中，我们也经常听到 openid 和 code 的概念。openid 用来标识这个唯一的微信用户，也就是说，一个微信用户相对于一个公众号（主体）的 openid 是唯一的，是不会变的。那么我们如何才能知道 某一个用户的 openid 呢？就是通过 code , 对于同一个用户，每次获取到的 code 都会改变，有有效期。我们把 code 作为参数，调用指定的微信服务器的接口，就可以拿到用户的 openid 。那么我们如何才能拿到 code 呢？微信内h5页面的方法是：跳到指定的微信的承接页面，再跳回到本页面，url链接上就会被拼上 code 。小程序的方法是： 通过调用 wx.login() 方法，就可以拿到用户的 code知道了上面的前提条件，就可以去实现一个微信小程序的登录体系。微信小程序登录体系通过 wx.login() 获取到用户的 code通过 wx.request() 方法请求我们自己的后端，我们自己的服务端把 appid , appsecret 和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到微信服务器返回了 openid我们在自己的数据库中，查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走我们生成一个第三方session, 也就是session_id, 也就是用户唯一标识符。在redis中，把session_id 和用户的身份存进去。返回 3rd_session小程序把 3rd_session 存到 storage 里面下次请求时，先从 storage 里面读取，然后带给服务端服务端从redis 里面找到 3rd_session 对应的记录，然后校验有效期问题一：为什么我们要自己维护一个用户数据库，实现一个注册体系？用微信的不好吗？因为我们业务不光是在微信里面玩，比如说，在app的场景下，我们肯定没有办法通过微信这一套来登录。问题二：为什么仍需设置前端的登录态，而不是每次用小程序的code换open_id？因为用code换open_id的方式，需要等待wx.login() 获取code, 需要等待node端请求微信服务器用code换取open_id。 相比于直接直接带上登录态，用户等待时间更长。获取用户信息最新版小程序中，只需要一个按钮就可以获取到用户的信息获取头像昵称 \r\n复制代码微信规定需要指定该btn的 open-type 为 getUserInfo , 用户信息会放在 getUserInfo 的回调函数里面。如果用户之前没有授权过，则会弹出弹窗授权。如果用户已经授权过，则不需要弹出弹窗授权。通过 wx.getSetting 方法可以获取到用户的授权信息wx.getSetting({\r\n            success(res) {\r\n                if (!res || !res.authSetting) {\r\n                    wx.showToast({\r\n                        title: '查询授权失败',\r\n                    })\r\n                    return;\r\n                }\r\n                this.setData({\r\n                    authInfo: res.authSetting\r\n                })\r\n            }\r\n        })\r\n复制代码"}
{"title": "小程序多业务线融合【完整分包业务接入】 ", "author": "Rolan", "pub_time": "2018-9-10 00:19", "article_content": "应用场景同一个主体（公司、部门）下有多个小程序这些小程序，由一个主小程序和后来新建的多条业务线构成（每条业务线拥有独立的小程序）各业务线的小程序需要挂载到主程序下面，因为需要主程序导流同时各业务线自己的小程序也照常发布更新==一套代码，通过打包命令，来生成独立包和分包==（分包生成完需要拷贝到主程序的subPages目录下）项目概述我的这条业务线叫欢乐送（项目名为enjoy_given），是转转旗下一个免费的以物换物平台因为我们这条业务线小程序是用mpvue构建的（整个项目也是通过mpvue的cli生成的），所以后面相关配置都是以mpvue为例，如果是wepy项目基本也大同小异。下面就是我们的目录结构src目录下的几个js文件需要专门介绍下：src/App.vue 是小程序的入口文件，里面定义的是小程序的生命周期src/main.js 里面初始化通用业务、定义小程序页面路径和全局变量src/vars.js 存放整个项目的全局变量src/baseInstall.js 基础方法装配逻辑（如：给vue对象挂载登录、统计逻辑、识别渠道号等）分包配置概述首先要配置source和appid作为分包时，这两个参数都要统一采用主包参数（建议通过webpack配置来实现）source：是每条业务线登录、注册、和接口访问时用的标识，用来区分该用户来自于哪条业务线appid：微信分配的小程序appid为什么要配置这两参数：因为不配置没法登录页面路径问题作为分包时，所有页面的跳转路径都要加主包的跳转前缀（建议通过包装跳转方法navigateTo、redirectTo、reLaunch、navigateBack实现，建议配合webpack统一处理）当新业务线作为分包接入主程序时，页面跳转路径前需要统一加一个前缀如：独立小程序首页路径为 /pages/content/index/main作为分包时，主程序分配的包为/subPages/enjoy_given那么分包业务线首页路径为: /subPages/enjoy_given/pages/content/index/mainwxss引用路径问题不要用使根目录引入方式（建议采用webpack或者shell脚本来完成）因为在分包状态下，用根目录访问方式会直接访问主程序的根目录，文件是不存在的图片路径问题所有图片路径统一采用cdn资源访问方式，不要引用本地图片对于分包的main.js和App.vue入口文件不执行的问题可以通过抽离基础业务装配方法，对于每一个从主包跳到分包页面的入口分别引入，后面会细说对于小程序内的h5页面拉起小程序页面在打开webview时候，要加入一个标志位，或者prefix，告诉h5页面，当前处于分包当中，打开的小程序path要加前缀分享路径问题，在路径前面也要加入路径前缀可以通过一个通用的分享方法，进行统一处理，后面会细说小程序的所有页面都需要在主包入口文件（app.vue）注册，每新增页面都要注册这个是坑，尤其新增页面时，会很容易忽略这个问题，这里要特别强调下分包接入需要注意的地方storage命名问题，为了避免和主程序或者其他业务线小程序发生冲突（建议采用 zz_业务名_xxx, 我们业务名是enjoy_given，简称eg，如： zz_eg_address， zz指的就是转转）登录问题，推荐和主程序使用同样的cookie名称，这样可以通用一套用户信息，免得双方各维护一套，还能避免重复授权。支付问题，保证下单时和支付时，cookie中的参数保持一致调试，可以找主程序那边要个主程序的测试包，把生成的代码(dist目录下的内容)拷贝到主程序包的 subPages/业务名/ 下面例如我们的目录是 subPages/enjoy_given/（目录结构同上）一套代码，通过不同打包命令生成对应的程序包（独立包和分包）package.json中scripts\"scripts\": {\r\n    \"dev\": \"node build/dev-server.js\",\r\n    \"start\": \"node build/dev-server.js\",\r\n    \"build\": \"rimraf dist && node build/build.js\",\r\n    \"lint\": \"eslint --ext .js,.vue src\",\r\n    \"build_subPkg\": \"node build/build-subpkg.js && sh ./scripts/path-replace.sh\"\r\n}\r\n独立小程序(调试) npm run dev\r\n独立小程序(构建) npm run build\r\n主程序分包(构建) npm run build_subPkg\r\n为什么没有主程序分包（测试）因为我们无论是构建测试分包还是构建正式分包，都要把生成dist下的代码拷贝到主程序的subPages/enjoy_given/目录下，成本基本是一样的，所以，就没有写构件分包的命令分包webpack配置因为需要兼容独立小程序和分包业务，webpack我们建议分开配置我们对测试环境和正式环境分别配置了webpack，通过对webpack配置替换全局变量，直接修改项目的全局参数。通过npm命令动态执行替换。为了分开配置，我们拷贝了一份build.js更名为build-subpkg.js\"scripts\": {\r\n    ...,\r\n    \"build_subPkg\": \"node build/build-subpkg.js && sh ./scripts/path-replace.sh\"\r\n}\r\nbuild_subPkg命令就是读取的build-subpkg.js文件build.js和build-subpkg.js中99%的内容都一样，只有一行不一样var webpackConfig = require('./webpack.prod.conf')\r\n变更为\r\nvar webpackConfig = require('./webpack.subpkg.prod.conf')\r\n所以下一步就是创建webpack.subpkg.prod.conf文件webpack.subpkg.prod.conf由webpack.prod.conf拷贝而来，里面依旧99%的内容一致// webpack.prod.conf...\r\nvar config = require('../config')\r\nvar env = config.build.env\r\n...\r\nvar webpackConfig = merge(baseWebpackConfig, {\r\n    ...\r\n    plugins: [\r\n        new webpack.DefinePlugin({\r\n            'process.env': env,\r\n            'app.source': env.APP_SOURCE,\r\n            'app.udeskDebug': env.UDESK_DEBUG,\r\n            'app.id': env.APP_ID,\r\n            'app.pathPrefix': env.APP_PATH_RREFIX,\r\n            'app.isUseCrazyFormId': env.IS_USE_CRAZY_FORMD_ID\r\n        }),\r\n        ...\r\n    ]\r\n})\r\n// webpack.subpkg.prod.conf...\r\nvar config = require('../config')\r\nvar env = config.build.env\r\n...\r\nvar webpackConfig = merge(baseWebpackConfig, {\r\n    ...\r\n    plugins: [\r\n        new webpack.DefinePlugin({\r\n            'process.env': env,\r\n            'app.source': env.APP_SUB_PKG_SOURCE,\r\n            'app.udeskDebug': env.UDESK_DEBUG,\r\n            'app.id': env.APP_SUB_PKG_ID,\r\n            'app.pathPrefix': env.APP_SUB_PKG_PATH_RREFIX,\r\n            'app.isUseCrazyFormId': env.IS_USE_CRAZY_FORMD_ID\r\n        }),\r\n        ...\r\n    ]\r\n})\r\nDefinePlugin插件是用来进行全局替换的如：’process.env’: ‘“hahaha”‘, 指的就是全局process.env替换为”hahaha”里面通过定义多个全局变量，实现打包时，通过不同的命令替换对应环境下的全局变量我们看一下../config/index.js中的文件var path = require('path')\r\n\r\nmodule.exports = {\r\n  build: {\r\n    env: require('./prod.env'),\r\n    ...\r\n  },\r\n  dev: {\r\n    env: require('./dev.env'),\r\n    ...\r\n  }\r\n}\r\n引入了dev.env.js和prod.env.js以prod.env.js为例module.exports = {\r\n  // 环境\r\n  NODE_ENV: '\"production\"',\r\n  // 欢乐送独立小程序source\r\n  APP_SOURCE: '114',\r\n  // 欢乐送分包小程序source\r\n  APP_SUB_PKG_SOURCE: '103',\r\n  // 欢乐送独立程序appid\r\n  APP_ID: '\"wxaaaaaaaaaaaaaaa\"',\r\n  // 欢乐送分包程序appid\r\n  APP_SUB_PKG_ID: '\"wxbbbbbbbbbbbbbbbb\"',\r\n  // udesk测试标志位\r\n  UDESK_DEBUG: false,\r\n  // 欢乐送独立小程序页面路径前缀\r\n  APP_PATH_RREFIX: '\"\"',\r\n  // 欢乐送分包小程序页面路径前缀\r\n  APP_SUB_PKG_PATH_RREFIX: '\"/subPages/enjoy_given\"',\r\n  // 是否启用crazyFormId\r\n  IS_USE_CRAZY_FORMD_ID: true\r\n}\r\n然后我们再来看一下存放全局变量的文件src/vars.js（上面项目截图中有）// 小程序常量\r\nexport default {\r\n  ...\r\n  // 小程序版本号\r\n  version: '1.3.5',\r\n  // 小程序appid\r\n  appId: app.id,\r\n  // 小程序source（由webpack根据不同环境统一替换）\r\n  source: app.source,\r\n  // 路径前缀\r\n  pathPrefix: app.pathPrefix,\r\n  // 是否启用CrazyFormId\r\n  isUseCrazyFormId: app.isUseCrazyFormId\r\n}\r\nvar webpackConfig = merge(baseWebpackConfig, {\r\n    ...\r\n    plugins: [\r\n        new webpack.DefinePlugin({\r\n            'process.env': env,\r\n            'app.source': env.APP_SUB_PKG_SOURCE,\r\n            'app.udeskDebug': env.UDESK_DEBUG,\r\n            'app.id': env.APP_SUB_PKG_ID,\r\n            'app.pathPrefix': env.APP_SUB_PKG_PATH_RREFIX,\r\n            'app.isUseCrazyFormId': env.IS_USE_CRAZY_FORMD_ID\r\n        }),\r\n        ...\r\n    ]\r\n})\r\n在打包完成后，全局变量文件中的”app.xxx”会被webpack中的同名变量替换掉如vars.js中 appId: app.id的app.id会被替换，独立小程序时该值为”wxaaaaaaaaaaaaaaa”，作为分包业务时，该值为”wxbbbbbbbbbbbbbb”这样整个替换全局变量的流程就跑完了==作为分包，接入主程序中，自己的main.js和App.vue都不会执行==这个是大坑，因为很多通用业务的初始化如登录、cookie、统计都是在这里完成的。解决方案把基础功能的装配业务（如在录、统计、识别渠道号等逻辑）从main.js中抽离到另一个文件，我这里叫baseInstall.js。里面我还加入了对query的处理，比如渠道号channel和微信入口scene。那这样的话，src/main.js就会变得非常简单,import Vue from 'vue'\r\nimport App from './App'\r\nimport baseInstall from './baseInstall'\r\nApp.mpType = 'app'\r\nbaseInstall.init()  // ！！！最关键就是这行代码！！！\r\nconst app = new Vue(App)\r\napp.$mount()\r\n\r\nexport default {\r\n  config: {\r\n    pages: [\r\n      '^pages/content/index/main',            // 首页\r\n      ...\r\n    ],\r\n    window: {\r\n      ...\r\n    }\r\n  }\r\n}\r\n里面最关键的是baseInstall.init()这行代码下面我们来看看baseInstall.js// 通用业务装配初始化\r\n...\r\nasync function init (opts) {\r\n  let options = opts\r\n  ...\r\n  // 获取指定渠道号\r\n  const channel = options.channel || options.c || ''\r\n  // 设置渠道号\r\n  if (channel) {\r\n    VARS.channel = channel.indexOf('waeg_') === 0 ? channel : ('waeg_' + channel)\r\n  }\r\n  ...\r\n  if (!VARS.baseInstallFlag) {\r\n    // 为了避免重复装备，通过标志位进行区分\r\n    VARS.baseInstallFlag = true\r\n    ...\r\n    // 登录配置\r\n    ZZLogin.config({\r\n      source: VARS.source\r\n    })\r\n    ZZLogin.install()\r\n    Navigator.install()\r\n    // 统计\r\n    LeStatic.config({\r\n      appid: VARS.source,\r\n      pageTypePrefix (currentRoute) {\r\n        return 'waeg_'\r\n      }\r\n    }).install()\r\n    ...\r\n  }\r\n  // 写入cookie\r\n  cookie.set({\r\n    channelid: VARS.channel,\r\n    fromShareUid: VARS.shareUid\r\n  })\r\n\r\n  return options\r\n}\r\n\r\nexport default {\r\n  init\r\n}\r\n为什么要用VARS.baseInstallFlag标志位因为，在分包时候是不执行main.js的，实际场景，会从主包的业务直接跳转到分包的一些页面。由于没有固定入口，所以在这些页面中都要加入baseInstall.js的引入，为了避免重复装配，才会设置这个标志位。为什么要把这些业务抽离baseInstall.init里面涵盖了所有启动小程序时需要初始化的业务前面也提到了在作为分包时，自己的App.vue和main.js是不会执行的。那怎么办，这样，就在所有的页面中，在onLoad的生命周期中加入baseInstall.init方法。,所以我们抽离肯定是为了更方便的复用了。以首页为例（pages/content/index/index.vue）import baseInstall from '@/baseInstall'\r\n\r\nexport default {\r\n    ...\r\n    async onLoad (options) {\r\n        options = await baseInstall.init(options)\r\n        ...\r\n    }\r\n}\r\n用async/await是因为baseInstall.init中部分逻辑用到了异步请求因为主程序不会读取main.js，所以，所有的分包页面路径，都要统一在主程序中注册注：每新增一个页面，都要在主程序中注册。也就是新增一个页面，就要通知主程序那边，在他们的文件里统一注册页面路径在分包中，所有页面路径访问要加入前缀如：原来访问/pages/content/index/main就可以了但是分包的访问路径为：/subPages/enjoy_given/pages/content/index/main解决方案：以包装的navigateTo为例async navigateTo (route) {\r\n    route.url = VARS.pathPrefix + (route.url.indexOf('/') === 0 ? '' : '/') + route.url // 这里做前缀处理\r\n    console.log('[Navigator] navigateTo:', route)\r\n    ...\r\n    wx.navigateTo(route)\r\n}\r\n这里面需不需要加前缀，都是由全局变量VARS中的pathPrefix来决定而pathPrefix是在打包过程中由webpack根据打包命令动态替换的图片访问路径问题图片访问路径统一采用cdn的资源访问路径，不要用本地访问路径，要不然在分包路径中是有问题的，同时也会增加程序包的体积wxss路径问题用mpvue生成的wxss文件,里面会把通用的vendor.wxss引入，但是引入路径是根路径，作为分包，直接引入根路径，会去访问主包的路径，导致文件无法找到。@import \"/static/css/vendor.wxss\"; //在分包中用根路径是无法找到文件的\r\n._button,._input[type=button],._input[type=reset],._input[type=submit],._textarea{-webkit-appearance:none}._button:after{border:none}page{background-color:#fff}...\r\n解决方案通过shell脚本对文件进行批量替换scripts/path-replace.sh#!/bin/sh\r\nsed -i \"_bak\" \"s/\\/static\\/css\\/vendor\\.wxss/\\/subPages\\/enjoy_given\\/static\\/css\\/vendor\\.wxss/g\" `grep \"\\/static\\/css\\/vendor\\.wxss\" -rl ./dist/static/css/pages/**/*.wxss ./dist/static/css/pages/*/*/*.wxss`\r\n这段shell脚本的目的就是把./dist/static/css/pages/下所有的wxss文件中的/static/css/vendor.wxss替换成/subPages/huanlesong/static/css\\vendor.wxss替换完成后，路径变更ok生成正式包的时候，用npm run build_subPkg就ok了分享路径问题主程序和独立小程序分享出来的路径也是一样的，处理方式和跳转类似。解决方案建议通过通用方法统一处理，我们的做法是，在页面的onShareAppMessage中加入通用方法Share.getFinalShareInfo以首页分享为例import Share from '@/lib/share'\r\nexport default {\r\n    ...\r\n    onShareAppMessage () {\r\n        ...\r\n        return Share.getFinalShareInfo({\r\n            title: 'xxx',\r\n            path: `/pages/content/index/main`,\r\n            imageUrl: 'xxxx'\r\n        })\r\n    }\r\n}\r\n分享时统一调用Share.getFinalShareInfo方法我们再来看下share.jsexport default class Share {\r\n    static getFinalShareInfo (shareInfo) {\r\n        ...\r\n        // 路径前缀处理\r\n        shareInfo.path = VARS.pathPrefix + (shareInfo.path.indexOf('/') === 0 ? '' : '/') + shareInfo.path\r\n        ...\r\n        return shareInfo\r\n    }\r\n}\r\n这样整个分包业务就配置完成了。是不是很麻烦~当初和主程序融合时候确实踩了很多坑，这里我把解决方案和大家分享下如果有更好的解决方案，也希望一起交流：）"}
{"title": "微信小程序之callout自定义气泡 ", "author": "Rolan", "pub_time": "2018-9-14 10:46", "article_content": "最近闲着踩踩地图的坑一脚下去差点没从坑里爬起来，然后由于某个原因，去研究了 微信小程序里面地图 callout 这个属性callout呢，是在标记的点上面显示 一个 气泡，作为提示用最后展示下 效果  可以展示 顶部气泡以及监听被点击 废话不多说，直接上代码wxml[AppleScript] 纯文本查看 复制代码?1234<map id=\"map\"  scale=\"{{scale}}\" bindcontroltap=\"controltap\" markers=\"{{markers}}\" bindmarkertap=\"markertap\"latitude=\"{{latitude}}\" bindcallouttap = \"bindcallouttap\"longitude =\"{{longitude}}\"controls=\"{{controls}}\" show-location bindregionchange=\"regionchange\" style=\"width: 100%; height: {{view.Height}}px;\"></map>js[AppleScript] 纯文本查看 复制代码?001002003004005006007008009010011012013014015016017018019020021022023024025026027028029030031032033034035036037038039040041042043044045046047048049050051052053054055056057058059060061062063064065066067068069070071072073074075076077078079080081082083084085086087088089090091092093094095096097098099100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147var app = getApp(); Page({  data: {    url: '',[color=#0800][backcolor=rgb(255, 255, 254)][font=Consolas]//测试的时候把下面listData换成身边的点就行[/font][/backcolor][/color]    listData: [{      \"id\": 1,      \"placeName\": \"测试地址1\",      \"placeImageUrl\": \"\",      \"placeOpenTime\": 1506200400,      \"placeCloseTime\": 1506265200,      \"placeAddress\": \"测试地址1啊\",      \"placeLongitude\": \"114.08190678985596\",      \"placeLatitude\": \"22.544808209639864\"    }, {      \"id\": 2,      \"placeName\": \"测试地址2\",      \"placeImageUrl\": \"\",      \"placeOpenTime\": 1506200400,      \"placeCloseTime\": 1506265200,      \"placeAddress\": \"测试地址2啊\",      \"placeLongitude\": \"114.0938372555542\",      \"placeLatitude\": \"22.53953655390022\"    }, {      \"id\": 3,      \"placeName\": \"测试地址3\",      \"placeImageUrl\": \"\",      \"placeOpenTime\": 1506243600,      \"placeCloseTime\": 1506265200,      \"placeAddress\": \"测试地址3啊\",      \"placeLongitude\": \"114.05454\",      \"placeLatitude\": \"22.52291\"    }],    scale: '15',    Height: '0',    controls: '40',    latitude: '',    longitude: '',    markers: [],  },  onReady: function(e) {    // 使用 wx.createMapContext 获取 map 上下文     this.mapCtx = wx.createMapContext('myMap')  },  onLoad: function() {    var that = this;    that.setData({      url: app.globalData.url    })     // var data = JSON.stringify({    //   page: 1,    //   pageSize: 10,    //   request: {    //     placeLongitude: app.globalData.longitude,    //     placeLatitude: app.globalData.latitude,    //     userId: app.globalData.userId    //   }    // })     wx.getLocation({      type: 'gcj02', //返回可以用于wx.openLocation的经纬度      success: (res) => {        console.log(res);        that.setData({          markers: that.getSchoolMarkers(),          scale: 12,          longitude: res.longitude,          latitude: res.latitude        })      }    });     wx.getSystemInfo({      success: function(res) {        //设置map高度，根据当前设备宽高满屏显示        that.setData({          view: {            Height: res.windowHeight          }        })      }    })  },  bindcallouttap: function(e) {    console.log(\"头上文字被点击\", e)  },  markertap: function(e) {    console.log(\"定位的点被点击\", e)  },  controltap: function(e) {    console.log(\"111\")    this.moveToLocation()  },  getSchoolMarkers() {     var market = [];     for (let item of this.data.listData) {       let marker1 = this.createMarker(item);       market.push(marker1)    }    console.log(\"market===========\", market)    return market;  },  moveToLocation: function() {    this.mapCtx.moveToLocation()  },  strSub: function(a) {    var str = a.split(\".\")[1];    str = str.substring(0, str.length - 1)    return a.split(\".\")[0] + '.' + str;  },  createMarker(point) {     let latitude = this.strSub(point.placeLatitude);    let longitude = point.placeLongitude;    let marker = {      iconPath: \"../images/here.png\",      id: point.id || 0,      name: point.placeName || '',      title: point.placeName || '',      latitude: latitude,      longitude: longitude,      label: {        x: -24,        y: -26,        content: point.placeName      },      width: 50,      height: 50,      callout: {        content: point.placeName || '',        fontSize: 14,        bgColor: \"#FFF\",        borderWidth: 1,        borderColor: \"#CCC\",        padding: 4,        display: \"ALWAYS\",        textAlign: \"center\"      }    };    return marker;  }})wxss[AppleScript] 纯文本查看 复制代码?123456789.map_container{    height: 300px;     width: 100%; }  .map {    height: 100%;     width: 100%; }\r\ntip：\r\n1、如有遇到新问题，可以在下方留言（回的比较慢）或者加QQ群437729329 进行咨询\r\n\r\n\r\nmap.rar"}
{"title": "小程序即时通讯demo ", "author": "Rolan", "pub_time": "2018-10-10 00:21", "article_content": "前段时间写了一个小程序即时聊天demo,仿微信，效果如下:项目地址是： github.com/lirongrong/… ,大家可以自行下载，按照提示运行，就能看到效果；现在只是做了要给基本版的，要做复杂功能，可以继续添加。功能发送文字发送图片（图片可点击放大）发送拍摄照片 （图片可点击放大）发送位置 （map组件默认在最顶层，样式控制不了，bug还在修复中...）发送语音 （包括语音时长，可点击播放）websorket长连接是基于nodejs-websocket的服务，代码如下：(最基础版)var ws = require(\"nodejs-websocket\")\r\n\r\n// Scream server example: \"hi\" -> \"HI!!!\"\r\n//创建一个server\r\nvar server = ws.createServer(function (conn) {\r\n\tconsole.log(\"New connection\")\r\n\tconn.on(\"text\", function (str) { \r\n\t\t// console.log(\"Received \"+str)\r\n\t\t// conn.sendText(str.toUpperCase()+\"!!!\")\r\n\t\t//链接成功之后，发送欢迎语\r\n\t\tconsole.log(\"连接成功\")\r\n\t\t//欢迎语\r\n\t\tif(str == 'null'){\r\n\t\t\tconn.sendText(\"有什么能帮到您？\");\r\n\t\t}\r\n\t\t//输入文字\r\n\t\telse if(str != 'null' && str){\r\n\t\t\tconn.sendText(\"文字\")\r\n\t\t}\r\n\t\t//输入多媒体\r\n\t\telse{\r\n\t\t\tconn.sendText(\"多媒体文本\")\r\n\t\t}\r\n\t\tconsole.log(str);\r\n\t})\r\n\tconn.on(\"close\", function (code, reason) {\r\n\t\tconsole.log(\"Connection closed\")\r\n\t})\r\n}).listen(8001)\r\n复制代码在项目根目录下运行 npm run dev 服务就能启动了， 启动之后websorket地址为： ws://localhost:8001chat.js直接看代码，注释都写清楚了// pages/user/chat.js\r\nvar util = require('../utils/util.js');\r\nvar app = getApp();\r\n//websocket心跳重连对象\r\nlet heartCheck = {\r\n  timeout: 1000,//1s\r\n  timeoutObj: null,\r\n  serverTimeoutObj: null,\r\n  //重置\r\n  reset: function () {\r\n    clearTimeout(this.timeoutObj);\r\n    clearTimeout(this.serverTimeoutObj);\r\n    return this;\r\n  },\r\n  //开始\r\n  start: function () {\r\n    wx.sendSocketMessage({\r\n      data: \"null\",\r\n    });\r\n  }, \r\n}; \r\n//微信小程序新录音接口，录出来的是aac或者mp3，这里要录成mp3\r\nconst recorderManager = wx.getRecorderManager();\r\nconst options = {\r\n  duration: 600000,//录音时长，这里设置的是最大值10分钟\r\n  sampleRate: 44100,\r\n  numberOfChannels: 1,\r\n  encodeBitRate: 192000,\r\n  format: 'mp3',\r\n  //frameSize: 50 \r\n};\r\n\r\n//音频播放\r\nconst innerAudioContext = wx.createInnerAudioContext()\r\n\r\nPage({ \r\n  data: {  \r\n    taskId:'',\r\n    userId:'',\r\n    chatList:[],//聊天内容\r\n    isShowModelUp:false,//底部弹框显示true,隐藏为false \r\n    isLuYin:false,//没有录音false,开始录音true\r\n    luYinText:'按住说话',\r\n    audioUrl:'',//录音文件地址\r\n    isShowLuYin:false,//true为开始播放，false为取消播放\r\n    inputValue:'',//输入框内容\r\n    lockReconnect:false,//默认进来是断开链接的\r\n    limit:0,//重连次数\r\n  }, \r\n  onLoad: function (options) { \r\n    this.linkSocket(); \r\n  }, \r\n  //连接socket\r\n  linkSocket:function(){\r\n    let that = this;\r\n    wx.connectSocket({\r\n      //url: app.globalData.wsUrl + 'websocket?' + this.data.taskId + '&' + this.data.userId,\r\n      url:app.globalData.wsUrl,\r\n      success() {\r\n        console.log('连接成功')\r\n        wx.onSocketMessage((res) => {\r\n          console.log(res.data);\r\n          //收到消息\r\n          that.pushChatList(0, {\r\n            text: res.data\r\n          });\r\n        })\r\n        wx.onSocketOpen(() => {\r\n          console.log('WebSocket连接打开')\r\n          heartCheck.reset().start()\r\n        })\r\n        wx.onSocketError(function (res) {\r\n          console.log('WebSocket连接打开失败')\r\n          that.reconnect()\r\n        })\r\n        wx.onSocketClose(function (res) {\r\n          console.log('WebSocket已关闭！')\r\n          that.reconnect()\r\n        })\r\n      }\r\n    }) \r\n  }, \r\n  //断线重连\r\n  reconnect() { \r\n    var that = this;\r\n    if (that.lockReconnect) return;\r\n    that.lockReconnect = true;\r\n    clearTimeout(that.timer)\r\n    if (that.data.limit < 12) {\r\n      that.timer = setTimeout(() => {\r\n        that.linkSocket();\r\n        that.lockReconnect = false;\r\n      }, 5000);\r\n      that.setData({\r\n        limit: that.data.limit + 1\r\n      })\r\n    } \r\n  }, \r\n  //打开底部弹框\r\n  showModelUp:function(){ \r\n    var that=this; \r\n    if (that.data.isShowModelUp==false){\r\n      that.setData({\r\n        isShowModelUp: true, \r\n      })\r\n    }else{\r\n      that.setData({\r\n        isShowModelUp: false, \r\n      })\r\n    } \r\n  },\r\n  //关闭底部弹框\r\n  closeModelUp:function(){\r\n    var that=this;\r\n    that.setData({\r\n      isShowModelUp:false, \r\n    })\r\n  },\r\n  //选择照片\r\n  chooseImage:function(){\r\n    var that=this;\r\n    wx.chooseImage({ \r\n      count: 1, // 默认9\r\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success: function (res) { \r\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n        var tempFilePaths = res.tempFilePaths;\r\n        console.log(res);\r\n        that.pushChatList(1,{\r\n          imgUrl: tempFilePaths,\r\n        }) \r\n        //关闭弹窗\r\n        that.closeModelUp();\r\n        that.pageScrollToBottom();\r\n      }\r\n    })\r\n  },\r\n  //界面滚到最底端\r\n  pageScrollToBottom: function () {\r\n    wx.createSelectorQuery().select('#bottom').boundingClientRect(function (rect) {\r\n      console.log(rect.top);\r\n      console.log(rect.bottom);\r\n      // 使页面滚动到底部\r\n      wx.pageScrollTo({\r\n        scrollTop: rect.bottom + 200\r\n      })\r\n    }).exec()\r\n  },\r\n  //预览图片\r\n  previewImage:function(e){\r\n    console.log(e);\r\n    var url=e.currentTarget.dataset.src;\r\n    var that=this;\r\n    wx.previewImage({\r\n      current: url[0], // 当前显示图片的http链接\r\n      urls: url // 需要预览的图片http链接列表\r\n    })\r\n  },\r\n  //拍摄\r\n  paishe:function(){\r\n    var that = this;\r\n    wx.chooseImage({\r\n      count: 1, // 默认9\r\n      sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success: function (res) {\r\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n        var tempFilePaths = res.tempFilePaths;\r\n        console.log(res);\r\n        that.pushChatList(1,{\r\n          imgUrl: tempFilePaths,\r\n        })\r\n        //关闭弹窗\r\n        that.closeModelUp();\r\n        that.pageScrollToBottom();\r\n      }\r\n    })\r\n  },\r\n  //发送位置\r\n  getlocat: function () {\r\n    var that = this\r\n    wx.getLocation({\r\n      type: 'gcj02', //返回可以用于wx.openLocation的经纬度\r\n      success: function (res) {\r\n        that.setData({\r\n          latitude: res.latitude,\r\n          longitude: res.longitude,\r\n          markers: [{\r\n            latitude: res.latitude,\r\n            longitude: res.longitude,\r\n            name: '时代一号',\r\n            desc: '现在的位置'\r\n          }], \r\n        })\r\n        that.pushChatList(1,{\r\n          map: true\r\n        })\r\n      }\r\n    })\r\n    that.closeModelUp();\r\n    that.pageScrollToBottom();\r\n  },\r\n  //切换是否录音按钮\r\n  btnRecord:function(){ \r\n    var that=this;\r\n    if (that.data.isLuYin==false){\r\n      that.setData({\r\n        isLuYin: true\r\n      });\r\n    }else{\r\n      that.setData({\r\n        isLuYin: false,\r\n        luYinText: '按住说话'\r\n      });\r\n    }  \r\n  },\r\n  //开始录音\r\n  startRecord:function(e){ \r\n    var that=this;\r\n    that.setData({\r\n      luYinText:'录音中...', \r\n    }); \r\n    recorderManager.start(options); \r\n    recorderManager.onStart(() => {\r\n      console.log('recorder start')\r\n    })\r\n  },\r\n  //结束录音\r\n  stopRecord:function(){ \r\n    var that = this;\r\n    that.setData({\r\n      luYinText: '按住说话'\r\n    });\r\n    recorderManager.stop();  \r\n    recorderManager.onStop((res) => {\r\n      console.log('recorder stop', res)\r\n      const { tempFilePath } = res;\r\n      that.pushChatList(1,{\r\n        audioUrl: res.tempFilePath,\r\n        audioDuration: (res.duration / 60000).toFixed(2),//录音时长,转为分,向后取两位,\r\n      })\r\n      that.setData({\r\n        audioUrl: res.tempFilePath,\r\n        audioDuration: (res.duration / 60000).toFixed(2),//录音时长,转为分,向后取两位,\r\n      })\r\n    })\r\n    //关闭弹窗\r\n    that.closeModelUp();\r\n    that.pageScrollToBottom();\r\n  },\r\n  //录音、停止播放\r\n  playRecord:function(e){  \r\n    console.log(e);\r\n    var that=this;  \r\n    innerAudioContext.autoplay = true;\r\n    innerAudioContext.src = that.data.audioUrl\r\n    //innerAudioContext.src = 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E061FF02C31F716658E5C81F5594D561F2E88B854E81CAAB7806D5E4F103E55D33C16F3FAC506D1AB172DE8600B37E43FAD&fromtag=46';//测试音频文件\r\n    if (!e.currentTarget.dataset.isshowluyin){//开始播放 \r\n      //innerAudioContext.play();//兼容起见用它\r\n      innerAudioContext.onPlay(() => {\r\n        console.log('开始播放');\r\n        that.setData({ \r\n          isShowLuYin: true\r\n        }); \r\n        return;\r\n      }); \r\n    }else{//暂停播放 \r\n      innerAudioContext.pause();\r\n      console.log(\"暂停\");\r\n      that.setData({\r\n        isShowLuYin: false\r\n      });\r\n      return; \r\n    } \r\n  },\r\n  //输入框点击完成按钮时触发\r\n  btnConfirm:function(e){\r\n    var that = this;\r\n    if (typeof (e) == 'undefined' || e.detail.value == ''){\r\n      return false;\r\n    }else {  \r\n      var value = e.detail.value;\r\n      that.pushChatList(1,{\r\n        text: value\r\n      });\r\n      that.setData({\r\n        inputValue:''//清空输入框\r\n      })\r\n      //发送数据\r\n      wx.sendSocketMessage({\r\n        data: value\r\n      })\r\n      //关闭弹窗\r\n      that.closeModelUp();\r\n      that.pageScrollToBottom();\r\n    }\r\n  },\r\n  //页面隐藏/切入后台时触发\r\n  onHide:function(){\r\n    wx.onSocketClose(function (res) {\r\n      console.log('WebSocket已关闭！') \r\n    })\r\n  },\r\n  //页面卸载时触发\r\n  onUnload:function(){\r\n    wx.onSocketClose(function (res) {\r\n      console.log('WebSocket已关闭！')\r\n    })\r\n  },\r\n  //pushchatList\r\n  //enu:0 是客服发送的消息\r\n  //enu:1 是我发送的消息\r\n  pushChatList:function(enu,options){\r\n    var that = this;\r\n    var defaults = {\r\n      userImage: '',\r\n      text: '',\r\n      isAdmin: false,\r\n    }\r\n    options = util.extendObj(defaults,options);\r\n    options.time = util.formatDateTime(util.getNowFormatDate());\r\n    console.log(options); \r\n    if(enu == 0){\r\n      options.userImage = '../images/admin.png';\r\n      options.isAdmin = false;  \r\n    }else if(enu==1){\r\n      options.userImage = app.globalData.wxUserInfo.avatarUrl;\r\n      options.isAdmin = true;\r\n    }\r\n    var t = that.data.chatList;\r\n    t.push(options)\r\n    that.setData({\r\n      chatList: t\r\n    });\r\n  }\r\n})\r\n复制代码需要优化的地方上传图片应该要支持多图上传并压缩一下，我做h5的聊天功能的时候压缩了，这个简版的小程序没做，大家可以自行加上这个demo只是实现了UI和文字的通讯，图片、视频、地图等的通讯还没完善发送消息之后滚到底部的方法需要改进，因为发送图片、地图、语音没有滚到底部需要改进的请大神指点"}
{"title": "秀杰实战教程系列《一》：记账应用开发 ", "author": "天下雪", "pub_time": "2016-10-18 11:08", "article_content": "通过阅读本课程你可以学到以下知识：1.使用表单组件、表单验证、Alert警告框2.实现列表页并重写单元格3.保存与读取数据到本地4.页面跳转先看一上效果图图0-1图0-2输入图片说明一、创建项目并勾上quickStart如图1-1二、首页首页包含一个添加收支按钮与所有条目的列表1. 首页布局1.1 增加一个添加按钮    <!--index.wxml--><view class=\"container\">    <navigator url=\"../item/item\" hover-class=\"navigator-hover\">添加收支</navigator></view>1.2 设置按钮按下高亮样式hover-class/**index.wxss**//** 修改默认的navigator点击态 **/.navigator-hover {    color:#2297f1;}2. 添加页面布局依次新建一个item文件夹，item.wxml item.wxss item.js item.json如图2-2-1修改app.json{  \"pages\":[    \"pages/index/index\",    \"pages/item/item\"  ],  \"window\":{    \"backgroundTextStyle\":\"light\",    \"navigationBarBackgroundColor\": \"#2297f1\",    \"navigationBarTitleText\": \"灵犀账本\",    \"navigationBarTextStyle\":\"white\"  }}item.wxml<!--item.wxml--><view class=\"page\">    <view class=\"section\">        <view class=\"section__title\">标题</view>        <input bindinput=\"bindTitleInput\" placeholder=\"内容\" value=\"{{title}}\" />    </view>    <view class=\"section\">        <view class=\"section__title\">类型</view>        <radio-group class=\"radio-group\" bindchange=\"radioChange\">            <label class=\"radio\">                <radio class=\"radio\" value=\"income\" checked=\"true\"/>收入            </label>            <label class=\"radio\">                <radio class=\"radio\" value=\"cost\"/>支出            </label>        </radio-group>    </view>    <view class=\"section\">        <view class=\"section__title\">金额</view>        <input bindinput=\"bindAccountInput\" type=\"number\" placeholder=\"请输入数字，不加正负号\"/>    </view>    <button class=\"button\" type=\"primary\">添加</button></view>item.wxss.page {    min-height: 100%;    flex: 1;    background-color: #FBF9FE;    font-size: 32rpx;    font-family: -apple-system-font,Helvetica Neue,Helvetica,sans-serif;    overflow: hidden;}.page input{    padding: 20rpx 30rpx;    background-color: #fff;}.section{    margin:40rpx 0;}.section_gap{    padding: 0 30rpx;}"}
{"title": "完整微信小程序开发教程实例详解：微天气《上》 ", "author": "天下雪", "pub_time": "2016-10-19 10:04", "article_content": "这次带大家一起开发一个功能完整的微信小程序，希望能对大家有一些参考价值。这次咱们一起开发一个天气预报小程序，之所以选这个类型，有两个原因。 一是天气类的小程序整体复杂度比较低，适合我们说明问题。 另外，这种类型的应用也更加适合微信小程序生态的场景，我的理解这个生态不适宜开发过于复杂的应用。 所以选了则个类型。咱们首先来看看最终效果，有个感官的认识：这个是在我的调试器上面的最终运行效果，根据你当前的位置显示当前以及未来一周的天气情况。 对于小程序的使用场景，个人觉得比较适合。准备工作先给大家看了运行效果，建立一个感官认识。那么接下来，我们就可以开始了。首先在微信开发者工具里建立一个项目:接下来，项目创建窗口有一点说明下， 在 AppID 条目中， 如果你已经有了内测账号，就填写你的 AppID， 如果你还没有内测账号，点击旁边的无AppID就可以了(相信大多数同学是没有内测账号的，所以可以使用这个方法继续在本地调试)。关于小程序的基本流程，以及项目结构等，可以参看咱们之前的文章 不需内测账号，带你体验微信小程序完整开发过程。 基础部分咱们这里就不多赘述。项目结构整个项目的文件结构如下：大家可以看到，有一个 index 目录里面是主页。 app.js 是程序主入口， utils.js 是咱们的工具脚本，用于读取天气数据。 还有一个 bg.jpg 的图片文件，是小程序的背景图。这个项目的所有文件都在这里了，是不是挺简单的？ 项目的完整代大家可以在咱们的 Github 主页上查看https://github.com/swiftcafex/wechat-weather基本结构介绍完了， 接下来咱们可以开始 Coding 了。 对于这个天气程序来说， 首先要处理的一个事情就是天气数据的获取了。 那咱们就一步一步的来做。首先，我们需要获取当前的地理位置， 微信给我们提供了相应的接口， 我们在 util.js 中可以定义这样一个方法：function getLocation(callback) {    wx.getLocation({           success: function(res) {        \tcallback(true, res.latitude, res.longitude);        },        fail: function() {        \tcallback(false);        }    })}wx.getLocation 方法给我们返回一个我们当前位置的经纬度信息。 如果成功，我们将信息传回给 callback， 如果失败我们给 callback 传回 false。 注意，失败的情况在实际开发中是需要注意处理的。比如，如果一些用户没有开启定位权限，不处理失败的话，就有可能产生预期之外的情况了。获取到当前位置之后，我们还要获取什么呢？ 天气数据。 相关的 API 很多， 我们这个小程序用的是 darksky.net提供的天气 API。 它提供了一个很简单的 API 接口:function getWeatherByLocation(latitude, longitude, callback) {    var apiKey = \"你自己的Key\";    var apiURL = \"https://api.darksky.net/forecast/\" + apiKey + \"/\" + latitude + \",\" + longitude + \"?lang=zh&units=ca\";    wx.request({        url: apiURL,        success: function(res){            var weatherData = parseWeatherData(res.data);            getCityName(latitude, longitude, function(city){                weatherData.city = city;                callback(weatherData);            });                    }    });}getWeatherByLocation 这个方法依然写在 util.js 里面，它的逻辑也很简单，拼接出 darksky 的 API 的 URL，然后调用 wx.request 请求网络数据。 因为我们不需要用到 API 返回的所有数据， 只需要获得当天的天气，以及未来 7 天的预报即可。 所以这里还使用 parseWeatherData 方法取得我们需要的数据并重组成新的结果。 这个方法的定义如下：function parseWeatherData(data) {    var weather = {};    weather[\"current\"] = data.currently;    weather[\"daily\"] = data.daily;    return weather;}从上面的代码不难看出，我们只取得了原始结果集的 currently 和 daily 数据，然后重新返回。 为什么我们要这样取得部分数据呢，主要是因为这个接口的其他数据我们并不需要，所以就没必要再传给应用层了。 原始数据的格式给大家贴一下：优化数据格式大家可能注意到了，这个 API 给我们返回的数据中，有些数据的格式我们还需要继续处理一下。 比如 time 是用时间戳的形式给我们返回的，但我们需要将时间显示在 UI 上， 所以我们就需要进行一下格式转换。 另外 temperature 字段的格式也不是我们需要的。温度数据我们不需要显示到小数点之后，取整数就可以。定义几个格式化数据的方法：//将时间戳格式化为日期function formatDate(timestamp) {    var date = new Date(timestamp * 1000);    return date.getMonth()+1 + \"月\" + date.getDate() + \"日 \" + formatWeekday(timestamp);}//将时间戳格式化为时间function formatTime(timestamp) {    var date = new Date(timestamp * 1000);    return date.getHours() + \":\" + date.getMinutes();}//中文形式的每周日期function formatWeekday(timestamp) {    var date = new Date(timestamp * 1000);    var weekday = [\"周日\", \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\"];    var index = date.getDay();    return weekday[index];}这三个方法都是对日期进行格式化输出。具体功能代码里的注释已经说明了，不多赘述。 最后，我们把前面所有的方法整合起来，组成给应用层的接口：//加载天气数据function requestWeatherData(cb) {    getLocation(function(success, latitude, longitude){      //如果 GPS 信息获取不成功， 设置一个默认坐标      if(success == false) {          latitude = 39.90403;          longitude = 116.407526;      }                  //请求天气数据 API      getWeatherByLocation(latitude, longitude, function(weatherData){                         cb(weatherData);          });    });}请求原始数据，这里调用了 getLocation 请求当前位置， 在回调里面判断返回结果是否获取位置成功，如果不成功，设置一个默认位置。 这个判断在实际的产品中还是比较有用的。 位置获取不成功的情况还是比较多的。比如用户没有开启定位权限。紧接着，在里面又调用了 getWeatherByLocation 方法获取天气数据，然后将原始的天气数据返回。原始数据读取成功后， 我们再封装一层，将原始数据进行加工：function loadWeatherData(callback) {    requestWeatherData(function(data){      //对原始数据做一些修整， 然后输出给前端      var weatherData = {};      weatherData = data;            weatherData.current.formattedDate = formatDate(data.current.time);      weatherData.current.formattedTime = formatTime(data.current.time);      weatherData.current.temperature = parseInt(weatherData.current.temperature);      var wantedDaily = [];      for(var i = 1;i < weatherData.daily.data.length;i++) {        var wantedDailyItem = weatherData.daily.data[i];        var time = weatherData.daily.data[i].time;        wantedDailyItem[\"weekday\"] = formatWeekday(time);        wantedDailyItem[\"temperatureMin\"] = parseInt(weatherData.daily.data[i][\"temperatureMin\"])        wantedDailyItem[\"temperatureMax\"] = parseInt(weatherData.daily.data[i][\"temperatureMax\"])        wantedDaily.push(wantedDailyItem);      }            weatherData.daily.data = wantedDaily;      callback(weatherData);    });}这是最终输出给应用层的方法，它里面用了咱们刚才定义的几个数据格式化方法将返回的原始天气数据加工了一下。 最终传递给回调方法。最后我们将这个方法暴露给应用层：module.exports = {    loadWeatherData: loadWeatherData}这个语法和 nodejs 比较相似。 到此为止，咱们这个小程序的数据处理逻辑部分就开发完成了。 大家可以稍微消化一下， 下一篇会和大家一起处理应用层的逻辑。 如果你想查看完整的代码， 也可以进入 Github 主页下载：https://github.com/swiftcafex/wechat-weather。"}
{"title": "小程序 lazy-load 不生效的问题 ", "author": "Rolan", "pub_time": "2018-9-21 00:17", "article_content": "最近在开发家里喵喵的小程序（娱乐），本想抽一小部分时间做个懒加载。看了小程序官网 API，给 image 标签加上 lazy-load 就能实现懒加载。但从微信开发者工具看，似乎并没有生效。搜了一下，很多小伙伴似乎都遇到了问题，并没有解决。但经过我的验证， 懒加载确实是生效了 。只不过， 小程序会提前加载当前屏幕和下一屏的图片，导致感知不到懒加载的存在。个人认为，这样的懒加载比传统懒加载的体验更加好。我的验证过程：验证过程wxml部分（用 scroll-view 并且加上 bindload）：<scroll-view class=\"container\" scroll-y>  \r\n  <view wx:for=\"{{list}}\" class=\"list-item\"> \r\n    <image class=\"list-img\" lazy-load src=\"{{item.img}}\" bindload='onLazyLoad'></image>\r\n    <view>{{item.desc}}</view>\r\n  </view>\r\n</scroll-view>js部分：const app = getApp()  \r\nPage({  \r\n  data: {\r\n    list: []\r\n  },\r\n  onLazyLoad(info) {\r\n    console.log(info)\r\n  }\r\n})最终效果首屏输出日志：清空首屏输出日志后，滑动过程中输出的日志：整张页面一共有 13 张图。因此，确实是进行了懒加载。魁拔喵喵喵最后，介绍下我的小程序：魁拔喵喵喵（已经能搜到啦）。功能目前比较简陋，欢迎交流和意见。"}
{"title": "微信小程序简易全攻略《三》创建轮播图与数据请求，表单的创建、提交、与接收 ... ", "author": "天下雪", "pub_time": "2016-10-20 15:04", "article_content": "一：创建轮播图应用中最常见的就是轮播图了，今儿个就讲讲微信小程序中轮播图的使用轮播图，不外乎俩个要素，跳转链接 和 图片地址1. 设置数据我在 pages/test/test.js中添加如下数据//test.js//获取应用实例var app = getApp()Page({  data: {      imgUrls: [       {          link:'/pages/index/index',          url:'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg'        },{          link:'/pages/logs/logs',          url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg'        },{          link:'/pages/test/test',          url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg'        }     ],    indicatorDots: true,    autoplay: true,    interval: 5000,    duration: 1000,    userInfo: {}  },  onLoad: function () {    console.log('onLoad test');  }})其中 imgUrls 是我们轮播图中将要用到的 图片地址和 跳转链接indicatgorRots 是否出现焦点autoplay  是否自动播放interval  自动播放间隔时间duration 滑动动画时间更多样式编辑请参看文档  https://mp.weixin.qq.com/debug/wxadoc/dev/component/swiper.html?t=14750520542282. 部署到页面找到 文件 pages/test/test.wxml<swiper indicator-dots=\"{{indicatorDots}}\"        autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">      <block wx:for=\"{{imgUrls}}\">        <swiper-item>           <navigator url=\"{{item.link}}\" hover-class=\"navigator-hover\">            <image src=\"{{item.url}}\" class=\"slide-image\" width=\"355\" height=\"150\"/>           </navigator>         </swiper-item>      </block></swiper>注意： swiper 千万不要在外面  加上任何标签 例如 <view> 之类的 ，如果加了可能会导致轮播图出不来3. 添加页面样式创建文件 pages/test/test.wxss.slide-image{      width: 100%;  }  加上上面的样式可以使 轮播图的宽度达到100% 然后更漂亮点，当然可以根据自己的喜好罗！看效果二：数据请求 表单的创建 提交 与接收开始正题了，本节小小研究了下 微信小程序的表单创建与提交先看看效果1. 表单页面<view id=\"adduser\">    <form bindsubmit=\"formSubmit\" bindreset=\"formReset\">         <view class=\"section\">            <view class=\"section__title\">姓名:</view>            <view class='form-group'>                <input type=\"text\" class=\"input-text\" name=\"username\" placeholder=\"请输入姓名\" />            </view>            </view>        <view class=\"section section_gap\">            <view class=\"section__title\">年龄:</view>            <view class='form-group'>                <slider name=\"age\" show-value ></slider>            </view>            </view>        <view class=\"section section_gap\">            <view class=\"section__title\">性别:</view>            <view class='form-group'>                <radio-group name=\"gender\">                  <label><radio value=\"1\"/>男</label>                  <label><radio value=\"0\"/>女</label>                </radio-group>            </view>            </view>        <view class=\"section\">            <view class=\"section__title\">地区选择:</view>            <view class='form-group'>                <picker bindchange=\"bindPickerChange\" value=\"{{index}}\" range=\"{{array}}\">                    <view class=\"picker\">                        <input type=\"hidden\" disabled=\"true\" name=\"addr\" value=\"{{array[index]}}\"/>                    </view>                </picker>            </view>        </view>        <view class=\"section section_gap\">            <view class=\"section__title\">爱好:</view>            <view class='form-group'>                <checkbox-group name=\"hobby\">                    <label><checkbox value=\"羽毛球\"/>羽毛球</label>                    <label><checkbox value=\"游泳\"/>游泳</label>                </checkbox-group>            </view>        </view>                <view class=\"section section_gap\">            <view class=\"section__title\">是否显示:</view>            <view class='form-group'>                 <switch name=\"isshow\"/>            </view>        </view>        <view class=\"section btn-area\">            <button formType=\"submit\">提交</button>            <button formType=\"reset\">清空</button>        </view>    </form>     <!-- 黑框提示并消失 -->    <toast hidden=\"{{toast1Hidden}}\" bindchange=\"toast1Change\">        {{notice_str}}    </toast>    <!-- 确认框 及 提示框 -->    <view class=\"page__bd\">        <modal title=\"确认\" confirm-text=\"确定\" cancel-text=\"取消\" hidden=\"{{modalHidden}}\" mask bindconfirm=\"confirm_one\" bindcancel=\"cancel_one\">            确认提交么？        </modal>        <modal class=\"modal\" hidden=\"{{modalHidden2}}\" no-cancel bindconfirm=\"modalChange2\" bindcancel=\"modalChange2\">            <view> 提示 </view>            <view> 清空成功 </view>        </modal>    </view></view>    2. js 代码var app = getApp();Page({  data:{    // text:\"这是一个页面\"    array:[\"中国\",\"美国\",\"巴西\",\"日本\"],    toast1Hidden:true,    modalHidden: true,    modalHidden2: true,    notice_str: '',    index:0  },  toast1Change:function(e){    this.setData({toast1Hidden:true});  },  //弹出确认框  modalTap: function(e) {    this.setData({      modalHidden: false    })  },  confirm_one: function(e) {    console.log(e);    this.setData({      modalHidden: true,      toast1Hidden:false,      notice_str: '提交成功'    });  },  cancel_one: function(e) {    console.log(e);    this.setData({      modalHidden: true,      toast1Hidden:false,      notice_str: '取消成功'    });  },  //弹出提示框  modalTap2: function(e) {    this.setData({      modalHidden2: false    })  },  modalChange2: function(e) {    this.setData({      modalHidden2: true    })  },  bindPickerChange: function(e) {    console.log('picker发送选择改变，携带值为', e.detail.value)    this.setData({      index: e.detail.value    })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  },  formSubmit: function(e) {    var that = this;    var formData = e.detail.value;     wx.request({      url: 'http://test.com:8080/test/socket.php?msg=2',      data: formData,      header: {          'Content-Type': 'application/json'      },      success: function(res) {        console.log(res.data)        that.modalTap();      }    })  },  formReset: function() {    console.log('form发生了reset事件');    this.modalTap2();  }})3. 部分样式#adduser{    background: #f5f5f5;}.section__title{    float: left;    width:30%;}.form-group{    float: right;    width: 70%;}.section{    clear: both;    width:90%;    margin: 2rem auto;}.input-text{    border: 1px solid #ddd;}.button{    border: 1px solid #1aad19;    border-radius: 2px;}.picker{    padding: 13px;    background-color: #FFFFFF;}4. 服务器端<?phpvar_dump($_REQUEST);本节 集合了 表单  https://mp.weixin.qq.com/debug/wxadoc/dev/component/form.html?t=1476197486816数据请求 https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html?t=1476197484427提示框  https://mp.weixin.qq.com/debug/wxadoc/dev/component/toast.html?t=1476197486420确认和非确认框  https://mp.weixin.qq.com/debug/wxadoc/dev/component/modal.html?t=1476197489278以及相关表单 的信息 ， 之后将分解讲解 对应的小功能。"}
{"title": "微信小程序简易全攻略《四》模板条件列表渲染完成模拟公众号自动回复 ... ", "author": "天下雪", "pub_time": "2016-10-20 15:10", "article_content": "最近突发奇想，如果微信小程序不在微信公众号里了该如何使用 自动回复呢？先看下效果话不多说 直接上代码1.页面代码：<swiper indicator-dots=\"{{indicatorDots}}\"        autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">      <block wx:for=\"{{imgUrls}}\">        <swiper-item>           <navigator url=\"{{item.link}}\" hover-class=\"navigator-hover\">            <image src=\"{{item.url}}\" class=\"slide-image\" width=\"355\" height=\"150\"/>           </navigator>         </swiper-item>      </block></swiper> <block>    <input type=\"text\" class=\"input-text\" bindchange=\"setInputValue\"  placeholder=\"请输入你要咨询的内容\"/>    <button bindtap=\"getgetinputSEnd\" class=\"input-button\">发送</button></block><view class=\"chat-area\">        <view wx:for=\"{{msgs}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">        <view class=\"say-title\">            <block wx:if=\"{{idx%2 != 0}}\"><text class=\"red-font\">客服：</text></block>            <block wx:if=\"{{idx%2 == 0}}\"><text class=\"green-font\">你：</text></block>        </view>        <view class=\"say-content\">            <block wx:if=\"{{itemName.type == 'video'}}\">                <video src=\"{{itemName.msg}}\"></video>            </block>            <block wx:if=\"{{itemName.type == 'voice'}}\">                <audio src=\"{{itemName.msg}}\" controls loop></audio>            </block>            <block wx:if=\"{{itemName.type == 'image'}}\">                <image src=\"{{itemName.msg}}\"></image>            </block>            <block wx:if=\"{{itemName.type == 'text'}}\">                <text>{{itemName.msg}}</text>            </block>        </view>    </view></view>页面中 使用了 模板的 条件渲染 ：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html?t=1476197490824 列表渲染：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/conditional.html?t=14761974929812. 样式代码.slide-image{    width: 100%;}.input-text{border:1px solid #abcdef;width:88%;background:#ddd;line-height:100%;text-indent: 0.5rem;margin:1rem auto;height:40px;}.input-button{    background:#48C23D;margin:0.5rem 5%;color:#fff;}.chat-area{    width: 90%;    margin:0.5rem 5%;    border:1px solid #ddd;    background:#eee;    font-size: 1rem;}.red-font{    color:#DC143C;}.green-font{    color:#48C23D;}.say-content{font-size:80%;width:80%;margin:0.5rem 5%;}3. js代码//test.js//获取应用实例var app = getApp();Page({  data: {      imgUrls: [       {          link:'/pages/index/index',          url:'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg'        },{          link:'/pages/logs/logs',          url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg'        },{          link:'/pages/test/test',          url:'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg'        }     ],    indicatorDots: true,    autoplay: true,    interval: 5000,    duration: 1000,    msgs:[],    inputdata:'',    userInfo: {}  },  onLoad: function () {    console.log('onLoad test');    console.log(this.data.msgs);  },  getgetinputSEnd:function(){      var input = this.data.inputdata;      var that = this;      var msgs = that.data.msgs;       msgs.push({msg:input,'type':'text'});      //--------------------------------- 微信数据请求           wx.request({        url: 'http://test.com:8080/test/socket.php',        data: {          msg:input        },        header: {            'Content-Type': 'application/json'        },        success: function(res) {          msgs.push({msg:res.data.content,'type':res.data.msgType});          that.setData({msgs:msgs});          console.log(res.data)        }      })       },  setInputValue:function(e){      console.log(e.detail);      this.data.inputdata = e.detail.value;  }})4. 服务器端代码<?php$params = $_REQUEST;$msg = $params['msg'];$content = array();switch ($msg) {    case '1': \tcase '美女': \t\t$content['msgType'] = 'image'; \t\t$content['content'] = 'https://ss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/image/h%3D200/sign=ae4df4ec878ba61ec0eecf2f713497cc/43a7d933c895d143b233160576f082025aaf074a.jpg'; \t\tbreak; \tcase '2': \tcase '音乐': \t\t$content['msgType'] = 'voice'; \t\t$content['content'] = 'http://www.w3school.com.cn/i/song.mp3'; \t\tbreak; \tcase '3': \tcase '视频': \t\t$content['msgType'] = 'video'; \t\t$content['content'] = 'http://www.w3school.com.cn//i/movie.ogg'; \t\tbreak;\t \tcase '4': \tcase '笑话': \t\t$content['msgType'] = 'text'; \t\t$content['content'] = '一男子在闹市骑摩托撞昏了一个陌生的老汉! 男子惊吓的不知所措!围观群众越来越多!突然,该男抱住老汉,声泪俱下的喊道:“爹,你等着我,我这就去给...'; \t\tbreak;\t\t \tdefault: \t\t$content['msgType'] = 'text'; \t\t$content['content'] = '您发送的指令不在识别范围内： \t\t                       你可以选择  \t\t                         1 美女  \t\t                         2 音乐 \t\t                         3 视频 \t\t                         4 笑话 '; \t\tbreak; }  echo json_encode($content);"}
{"title": "微信小程序开发框架MINA分析 ", "author": "天下雪", "pub_time": "2016-10-23 11:58", "article_content": "MINA是微信开发小程序的框架：MINA的目标是通过尽可能简单，高效的方式让开发者可以在微信中开发具有原生APP体验的服务。运行MINA的项目必须要有微信web开发者工具MINA框架中有四种类型的文件:.js文件 基于JavaScript的逻辑层框架.wxml 视图层文件，是MINA设计的一套标签语言.wxss 样式文件，用于描述WXML的组件样式.json 文件，配置文件，用于单个页面的配置和整个项目的配置目录结构为了减少配置项，小程序中一个页面中的四个文件必须要有相同的路径和文件名,使用微信web开发者工具新建一个项目,可以看到他的目录结构是这样的：其中app.js是程序的入口，app.json是项目的配置文件,app.wxss是全局配置的样式文件,logs和index文件夹是是单个页面的文件，utils用来存放常用的工具类文件夹。app.jsapp.js使用App()函数注册一个小程序，可以指定小程序的生命周期小程序的App()生命周期中三个事件可以监听:onLaunch，onShow，onHide。onLaunch：小程序加载完成之后调用,全局只触发一次onShow： 小程序启动，或者从后台到前台会触发一次onHide：小程序从前台到后台会触发一次例如:App({ \r\n onLaunch: function () { \r\n    console.log('App Launch')\r\n  }, \r\n onShow: function () {\r\n    console.log('App Show')  \r\n},  \r\nonHide: function () {\r\n    console.log('App Hide')  \r\n}, \r\n globalData: {\r\n    hasLogin: false  \r\n}\r\n})其中app.js的globalData可以设置全局的变量,在一个页面中可以通过getApp()函数获取小程序的实例，使用App的getCurrentPage()可以获取到当前页面的实例。app.jsonapp.json是小程序的全局配置包括:页面的路径，窗口表现，设置网络超时,开发模式等...页面配置pages:设置页面的路径  \"pages\":[\r\n    \"pages/index/index\",\r\n    \"pages/logs/logs\"\r\n  ]配置的index和logs两个页面的路径,在这里使用相对路径配置页面路径。窗口配置windows：用来配置状态栏的颜色，导航条的样式和颜色，标题，已经窗口的背景色:\"window\":{\r\n    \"backgroundTextStyle\":\"light\",\r\n    \"navigationBarBackgroundColor\": \"#ffffff\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\":\"black\"\r\n  }使用的Color为十六进制的颜色值,比如\"#ffffff\"注意:其中navigationBarTextStyle，导航栏的颜色仅支持black/white。而backgroundTextStyle，下拉背景的样式仅支持dark/light。tabBar: 设置tab应用，tabBar是一个数组，最少需要配置2个，最多能配置5个tab，tab按照数据的顺序排序：\"tabBar\":{\r\n    \"color\":\"#dddddd\",\r\n    \"selectdColor\":\"#3cc51f\",\r\n    \"borderStyle\":\"black\",\r\n    \"backgroundColor\":\"#ffffff\"\r\n  ,\"list\":[\r\n    {\r\n      \"pagePath\":\"pages/index/index\",\r\n      \"iconPath\":\"image/wechat.png\",\r\n      \"selectedIconPath\":\"image/wechatHL.png\",\r\n      \"text\":\"主页\"\r\n      },{\r\n    \"pagePath\":\"pages/logs/logs\",\r\n    \"iconPath\":\"image/wechat.png\",\r\n    \"selectedIconPath\":\"image/wechatHL.png\",\r\n    \"text\":\"日志\"\r\n  }]\r\n}这里设置了两个tab页:index和log，效果如下:networkTimeout设置网络请求的超时时间,小程序有四种类型的网络请求wx.request普通的http请求，配置为requestwx.connect stock链接,配置为connectSocketwx.uploadFile上传文件,配置为uploadFilewx.downloadFile下载文件,配置为downloadFile配置单位为毫秒,例如：\"networkTimeout\": {\r\n    \"request\": 10000,\r\n    \"connectSocket\": 10000,\r\n    \"uploadFile\": 10000,\r\n    \"downloadFile\": 10000\r\n  }debug:开发工具中开启debug模式，在控制台面板上可以看到调试信息,我们也可以使用console.log('onLoad')输入log帮助我们调试程序。\"debug\": trueapp.wxssapp.wxss中定义的的样式为全局样式，作用在每一个页面，在page中定义的.wxss文件为局部样式，只作用在局部，局部样式中的定义会覆盖app.wxss中定义的样式。样式的定义:.container {\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  padding: 200rpx 0;\r\n  box-sizing: border-box;\r\n}其中200rpx中的rpx是reponslve pixel，可以根据屏幕的宽度进行自适应，在iPhone6上1rpx=0.5px=1物理像素。微信小程序建议设计以iPhone6为准样式的使用：class=\"container\">\r\n\r\npage使用Page()函数来注册一个页面，为其指定页面的初始数据，生命周期函数，事件处理等。data 页面的初始数据，可以使用setData更新定义的数据onLoad 页面加载事件onReady 页面渲染完成onShow 页面显示onHide 页面隐藏onUnload 页面卸载例如:Page({\r\n  data: {\r\n    logs: []\r\n  },\r\n  onLoad: function () {\r\n    this.setData({\r\n      logs: (wx.getStorageSync('logs') || []).map(function (log) {\r\n        return util.formatTime(new Date(log))\r\n      })\r\n    })\r\n  }\r\n})page另外使用的文件.wxml是页面文件，使用定义好一套标签语言，.wxss是局部样式文件，.json局部配置文件比如需要在一个单独的页面中设置他的navigationBarTitleText,可以在.json文件中设置:{\r\n    \"navigationBarTitleText\": \"日志文件\"\r\n}源代码地址:https://github.com/jjz/weixin-mina"}
{"title": "有渔微信小程序系统概述《一》认识微信小程序与HelloWorld ", "author": "天下雪", "pub_time": "2016-10-23 12:11", "article_content": "认识微信小程序一、当前APP的痛点1. 用户的痛自从买了智能手机后，手机上装了一堆APP，每次装一个新应用就必须下载安装一个APP。这手机屏幕成了百货展厅，每次找个APP还得滑动屏幕找白天；而且每次安装一个APP，就占用大量空间，这手机容量也越来越不够用了。一次跟一位做运营的朋友聊天，他说现在只在微信上做推广，因为微信上客户群体多。他说知名度小的APP很难推，一是推广费用高，二是客户一般也不愿下载。 2. 开发者的痛现在做互联网的，开发了PC端的WEB后，再开发Android和Apple版，几乎是标配。我也曾经赶过这趟浑水，当时团队开发完了PC端的WEB，然后自然就想到要开发Android和Apple版。但问题来了：我们团队人少，而且大家都没APP开发经验；哪就找外包呗？于是我们就去找外包公司。后来在聊天中外包公司的老大就向我吐苦水，他说现在1个Android，1个Apple团队，1个项目必须得养2帮人马，开发成本太高了。后来，为了省财力、时间，我就让外包公司开发一个APP的外壳，然后里面打开浏览器访问我们的WAP网站，也就是Hybrid APP解决方案。Hybrid APP解决方案虽然开发便捷，但在用户体验上就比原生的APP差很多。 二、微信小程序方便了用户，更方便了开发者什么是小程序？小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不关心是否安装太多应用的问题。应用将无处不在，随时随地可用，但又无需安装卸载。微信小程序解决了当前APP的痛点，方便了用户，更方便了开发者。从本质上看，微信小程序有点类似Hybrid APP解决方案。以后微信就成为移动端入口，用户不用再无休止地安装APP了；开发者只需要用javaScript一种语言就可以了，开发成本几乎可省下2/3以上；而且微信提供了非常丰富的API，微信小程序的用户体验肯定不会比原生的APP差。微信作为国内最大的交友平台，已经成了一个独立的互联网王国，上面有大量的用户资源，微信小程序推广的性价比就非常高。   可以想象，再过一段时间，大量的APP开发者会转投微信小程序的大营，而且几乎所有的APP都会重新再开发一个微信小程序版本，微信小程序开发人员的需求也会非常大。所以，作为一名互联网从业人员，学习掌握微信小程序开发是非常有必要的。HelloWorld微信小程序看千遍不如做一遍。先让我们来一起做一个最简单的HelloWorld吧。    1.下载安装微信小程序开发者工具，下载路径：https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html根据你的操作系统类型，选择windows 64、windows 32或mac。     2.创建项目    ⑴ 添加项目    点击“添加项目”按钮，创建一个项目。⑵ 项目的几个参数说明    没有 AppID 就选无AppID（如果乱写会报错，到时可能无法进入项目）。如果你选择的“项目目录”为空，请如图所示勾选在“当前目录中创建quick start项目”。项目名称就随便写一个吧，比如“测试项目”。点击“添加项目”按钮，一个最简单的微信小程序就完成了。3.项目代码结构说明    点击开发者工具左侧导航的“编辑”，我们可以看到这个项目已经初始化并包含了一些简单的代码。其中包括：app.js，app.json，app.wxss和2个目录：pages，utils。     其中，最重要的是 app.js、app.json、app.wxss 这三个文件。    app.js：这个文件是整个小程序的入口文件。    app.json：这个文件是小程序的全局配置文件，决定页面文件的路径，窗口表现，设置网络超时时间等。app.wxss：是小程序的样式文件，你可以把它想象成html中的CSS。"}
{"title": "有渔微信小程序系统概述《二》了解.js文件及.json文件 ", "author": "天下雪", "pub_time": "2016-10-23 12:17", "article_content": "了解.js文件1、app.jsapp.js是整个小程序的入口文件，也是控制整个小程序生命周期的文件。App.js用App()来实现对整个程序的注册，同时App()里面还实现了对小程序生命周期的监控函数(onLaunch, onShow, onHide)。APP()内部参数说明：属性类型描述触发时机onLaunchFunction生命周期函数--监听小程序初始化当小程序初始化完成时，会触发onLaunch（全局只触发一次）onShowFunction生命周期函数--监听小程序显示当小程序启动，或从后台进入前台显示，会触发 onShowonHideFunction生命周期函数--监听小程序隐藏当小程序从前台进入后台，会触发 onHide其他Any开发者可以添加任意的函数或数据到Object 参数中，用 this 可以访问     我们来看一个app.js的代码：//app.jsApp({  onLaunch: function () {    ... ...  },  getUserInfo:function(cb){    ... ...  },  globalData:{    userInfo:null  },  onShow: function(){    ... ...  },  onHide: function(){    ... ...  }}) 小程序前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。简单地说，前台就是你在操作小程序时；后台就是你离开了小程序，去玩手机的其他东西去了，这时小程序就隐藏到后面去了。 2、index.js小程序中每一个页面可以放在一个文件夹中，这个文件夹中一般包括4个文件：.js, .json, .wxml, .wxss。官方建议这四个文件的名字最好和文件夹的名字一致，这样便于框架自动查找。每个页面都需要注册，index.js用Page()这个函数来注册一个页面，它接受一个object参数，用这个参数来指定页面的初始数据，生命周期函数，事件处理函数。 Page()内部参数说明：属性类型描述dataObject页面的初始数据onLoadFunction生命周期函数--监听页面加载onReadyFunction赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\nhgf\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              有渔微信小程序系统概述《一》认识微信小程序与HelloWorld \n              有渔微信小程序系统概述《三》view层及小程序框架概述 \n            \n             \n            \n                  原作者: 有渔 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 有渔微信小程序系统概述《一》认识微信小程序与HelloWorld\n                                    \n                  • 有渔微信小程序系统概述《三》view层及小程序框架概述\n                                    \n                  • 有渔微信小程序系统进阶《四》小程序组件\n                                    \n                  • 有渔微信小程序技术分析《五》Mustache语法要点总结\n                                    \n                  • 有渔微信小程序系统概述《八》：小程序开发中应注意的几个问题 ...\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSTj33fr', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163861|99b3d7268b7490e150f1ba4ea0c2a75a|2';"}
{"title": "有渔微信小程序系统概述《三》view层及小程序框架概述 ", "author": "天下雪", "pub_time": "2016-10-23 12:25", "article_content": "小程序的view层MVC模式这里就不讲了，不懂MVC模式的就自己去查阅相关资料。小程序的的view层由WXML与WXSS编写，由组件来进行展示。view层将逻辑层的数据反应成界面显示，同时将界面发生的事件发送给逻辑层。WXML(WeiXin Markup language)用于描述页面的结构，可以想象成Html文件。WXSS(WeiXin Style Sheet)用于描述页面的样式，可以想象成Css文件。组件(Component)是视图的基本组成单元，可以想象成Html中的组件。下面我们用简单的例子来看看 WXML 具有什么能力： 1、测试环境准备⑴ pages目录里建立viewtest目录，专门用来做view层测试。⑵ index里添加触发viewtest的相关代码① index.wxml修改成：② index.js添加下面的代码：  bindUserTap: function() {    wx.navigateTo({      url: '../viewtest/viewtest'    })  },③ app.json把viewtest路径加入pages参数里：  \"pages\":[    \"pages/index/index\",    \"pages/logs/logs\",    \"pages/viewtest/viewtest\"  ], 2、例子⑴ 数据绑定<!--viewtest.wxml--><view> {{message}} </view>// viewtest.jsPage({  data: {    message: 'Hello MINA!'  }}) ⑵ 列表渲染<!--viewtest.wxml--><view wx:for=\"{{array}}\"> {{item}} </view>// viewtest.jsPage({赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              有渔微信小程序系统概述《二》了解.js文件及.json文件 \n              有渔微信小程序系统概述《六》小程序的API \n            \n             \n            \n                  原作者: 有渔 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 有渔微信小程序系统概述《一》认识微信小程序与HelloWorld\n                                    \n                  • 有渔微信小程序系统概述《二》了解.js文件及.json文件\n                                    \n                  • 有渔微信小程序系统进阶《四》小程序组件\n                                    \n                  • 有渔微信小程序技术分析《五》Mustache语法要点总结\n                                    \n                  • 有渔微信小程序系统概述《八》：小程序开发中应注意的几个问题 ...\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSocyl1F', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163862|65a5b163e5d4d1aea70e7c1dcdde7c82|2';"}
{"title": "有渔微信小程序系统进阶《四》小程序组件 ", "author": "天下雪", "pub_time": "2016-10-23 12:34", "article_content": "组件(Component)是小程序视图的基本组成单元，可以把它想象成Html中的组件，你可以通过组合这些基础组件快速开发小程序的界面。小程序的组件包括以下内容：大类具体组件说明视图容器view视图scroll-view可滚动视图区域swiper滑块视图区域赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              精品教程《二》：微信小程序实战之小豆瓣图书 \n              微信小程序实战教程：火车票查询，直取12306数据 \n            \n             \n            \n                  原作者: 有渔 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 有渔微信小程序系统概述《一》认识微信小程序与HelloWorld\n                                    \n                  • 有渔微信小程序系统概述《二》了解.js文件及.json文件\n                                    \n                  • 有渔微信小程序系统概述《三》view层及小程序框架概述\n                                    \n                  • 有渔微信小程序技术分析《五》Mustache语法要点总结\n                                    \n                  • 有渔微信小程序系统概述《八》：小程序开发中应注意的几个问题 ...\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSIByN2z', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序第三方框架对比 ( wepy / mpvue / ta2019-01-28微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30分享一款拥有历史搜索记录的微信小程序搜索2019-01-28小程序点睛之三：才不是你想的那种组件2019-01-28微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n微信小程序Demo:Canvas图片拖拽生成实现2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo：精美的画板小程序2019-02-21微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：仿 [one] 微信小程序2019-02-18微信小程序Demo：3D旋转效果2019-02-18微信小程序Demo: flappy-bird小游戏2019-02-15微信小程序Demo：群应用（群通知、群接龙、2019-02-15微信小程序Demo：咩咩单词2019-02-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163863|28b6af8102a8d56ef64064548bc0b1a2|2';"}
{"title": "有渔微信小程序技术分析《五》Mustache语法要点总结 ", "author": "天下雪", "pub_time": "2016-10-23 12:36", "article_content": "小程序开发的wxml里，用到了Mustache语法。所以，非常有必要把Mustache研究下。什么是Mustache?Mustache是一个logic-less（轻逻辑）模板解析引擎，它是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，通常是标准的HTML文档。比如小程序的wxml中的代码：{{userInfo.nickName}}，这里的{{ }}就是Mustache的语法。1、Mustache的模板语法很简单，就那么几个：{{keyName}}{{{keyName}}}{{#keyName}} {{/keyName}}{{^keyName}} {{/keyName}}{{.}}{{!comments}}{{>partials}} 1、{{keyName}}⑴ 简单的变量替换：{{name}}var data = { \"name\": \"weChat\" };Mustache.render（\"{{name}} is excellent.\"，data）;返回 weChat is excellent.⑵ 变量含有html的代码，如：、等而不想转义，可以在用{{&name}}var data = {    \"name\" : \"<br>weChat<br>\"};var output = Mustache.render(\"{{&name}} is excellent.\", data);console.log(output);返回：<br>weChat<br> is excellent. 去掉\"&\"的返回是转义为：<br>weChat<br> is excellent.另外，你也可以用{{{ }}}代替{{&}}。 ⑶ 若是对象，还能声明其属性var data = {              \"name\" : {              \"first\" : \"Chen\"，              \"last\" : \"Jackson\"              }，              \"age\" : 18         };var output = Mustache.render(           \"name:{{name.first}} {{name.last}}，age:{{age}}\", data);console.log(output);返回：name:Chen Jackson，age:18 2、{{#keyName}} {{/keyName}}以#开始、以/结束表示区块，它会根据当前上下文中的键值来对区块进行一次或多次渲染。它的功能很强大，有类似if、foreach的功能。var data = {    \"stooges\" : [ {        \"name\" : \"Moe\"    }， {        \"name\" : \"Larry\"    }， {        \"name\" : \"Curly\"    } ]};var output = Mustache.render(\"{{＃stooges}}<b>{{name}}</b>{{/stooges}}\"，                 data);console.log(output);返回：<b>Moe</b><b>Larry</b><b>Curly</b>3、{{^keyName}} {{/keyName}}该语法与{{#keyName}} {{/keyName}}类似，不同在于它是当keyName值为null, undefined, false时才渲染输出该区块内容。比如：var data = {             \"name\" : \"<br>weChat<br>\"         };    var tpl = ‘{{^nothing}}没找到 nothing 键名就会渲染这段{{/nothing}}’;    var output = Mustache.render(tpl, data);返回：没找到 nothing 键名就会渲染这段 4、{{.}}    {{.}}表示枚举，可以循环输出整个数组，例如：var data = {    \"product\": [\"Macbook \",\"iPhone \",\"iPod \",\"iPad \"]}var tpl = '{{#product}} <p>{{.}}</p> {{/product}}';var html = Mustache.render(tpl, data);返回：<p>Macbook </p> <p>iPhone </p> <p>iPod </p> <p>iPad </p> 5、{{!  }}表示注释6、{{>partials}}以>开始表示子模块，当结构比较复杂时，我们可以使用该语法将复杂的结构拆分成几个小的子模块。"}
{"title": "有渔微信小程序系统概述《六》小程序的API ", "author": "天下雪", "pub_time": "2016-10-23 12:42", "article_content": "小程序开发框架提供丰富的API，可以方便地调用微信提供的功能，比如获取用户信息，本地存储，微信支付等功能。目前，小程序的API分成下面几个大类：网络、媒体、数据、位置、设备、界面、开放接口。小程序API的具体参考文档：    https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=1476197491659 看千遍，不如自己做一遍。做一遍后，就能更加深刻地认识小程序的某个API，然后举一反三，通过查询腾讯的API文档，就能掌握其他API了。好了，下面开始干活。    1、wx.requestwx.request发起的是https请求。一个微信小程序，同时只能有5个网络请求连接。wx.request的参数如下：参数类型是否必填说明urlString是开发者服务器接口地址dataObject、String否请求的参数headerObject否设置请求的 header , header 中不能设置ReferermethodString否默认为 GET，有效值：OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECTsuccessFunction否收到开发者服务成功返回的回调函数，res = {data: '开发者服务器返回的内容'}failFunction否接口调用失败的回调函数completeFunction否接口调用结束的回调函数（调用成功、失败都会执行） 我们请求这个restful API：http://news-at.zhihu.com/api/4/news/latest，然后把数据显示出来。⑴ 我先用postMan测试下这个restful API，看下显示的数据是什么？⑵ 在app.js中添加一个getHttpRequest()函数。getHttpData: function(){    return “测试wx.request”},⑶ index.js的onLoad()函数修改成：onLoad: function () {    var that = this    var httpData = app.getHttpData()    that.setData({username:httpData})}     ⑷ 编译后，能看到如下界面：     ⑸ 我们把getHttpData的代码进行升级，如下所示：getHttpData: function(callback){    wx.request({    url: 'http://www.yangfuhai.com/api',    data: {      x: '' ,      y: ''    },    header: {      'Content-Type': 'application/json'    },    success: function(res) {      callback(res.data)    }    })}⑹ index.js的onLoad()函数修改成：onLoad: function () {    var that = this    app.getHttpData(function(data){        console.log(data.date)        that.setData({username:data.date})    })}     ⑺ 编译后，能看到如下界面：     ⑻ 把that.setData({username:data.date})修改成：that.setData({username:data.stories[0].title})     编译后，看到如下界面：     在前面的例子中，data.stories返回的是个数组列表，我们通过data.stories[0].title得到了数组的第1个对象的title。现在让我们回顾下小程序的渲染功能，用wx:for把data.stories循环地列出来。⑴ index.wxml里添加如下代码：  <view wx:for=\"{{items}}\">    {{index}}: {{item.title}}  </view>⑵ index.js的onLoad()函数修改成：  onLoad: function () {    var that = this    app.getHttpData(function(data){        that.setData({items:data.stories})    })  }     编译后，看到如下界面："}
{"title": "微信小程序实战教程：火车票查询，直取12306数据 ", "author": "天下雪", "pub_time": "2016-10-24 11:15", "article_content": "最终效果图： 样式丑哭了，我毕竟不是前端，宗旨就是练练手，体验微信小程序的开发，以最直接的方式获取12306数据查询火车票。 目录结构：search1是出发站列表，search2是目的站列表，命名没有太好好想。 车站信息12306查询页面，打开浏览器开发者工具分析请求，发现各个车站的信息都在这个JS文件中：当然车站的信息会发生变动，所以最好的方式就是抓取数据，我现在为了方便，直接把数据拷贝过来，就是一大堆字符串：通过正则截取出目前项目需要的两个东西，如：北京北 VAP 在search1.js和search2.js中各自放了这个字符串，本想按照data:{}的方式放在app.js中，可是取不到，这个该如何实现？ 请求信息12306查询页面，点击查询按钮的时候，它会发送两个请求：第一个是日志请求，这里不需要，它有什么作用12306知道第二个才是我们需要的，拷贝它的请求地址，构建我们程序的请求url中最后的queryC，之前是query的，可能过段时间变为queryD、query0... 又一个变化的地方，也可以说处处皆会变化，毕竟12306不是自己做的，无法掌控，所以最好还是抓取数据的方式来做，我现在方便直接写死了。leftTicketDTO.train_date  日期，格式：2016-10-13leftTicketDTO.from_station  出发站编码，上面那堆车站信息中的，北京北为VAPleftTicketDTO.to_station  目的站编码，同上purpose_codes  普通（ADULT）或学生（0X00） 响应信息参数错误或没给全返回的JSON：{\"status\":false,\"c_url\":\"leftTicket/queryC\",\"c_name\":\"CLeftTicketUrl\"}一般正常的格式为：要是提交的是昨天的日期，则messages中会有消息，但status和httpstatus仍然为true和200。于是乎对返回结果有了如下判断：  展示信息 先看看data中的有什么东东：用到的参数，能够确认其作用的：车次 station_train_code始发站 start_station_name终点站 end_station_name出发站 from_station_name目的站 to_station_name出发时间 start_time目的时间 arrive_time历时时间 lishi商务座 swz_num一等座 zy_num二等座 ze_num软卧 rw_num硬卧 yw_num软座 rz_num硬座 yz_num无座 wz_num特等座 tz_numgr_num和qt_num，猜测为高级软卧和其他，gg_num和yb_num就实在想不到了。需要注意的是，座位的票数超过某个数的返回值是“有”，而低于则返回的是数字，所以在显示数据列表之前还得处理下。  在写程序的时候我发现我有挺多想法想写出来的，可到真正要写博客的时候却想不出要写什么了，悲哀！日后想到在补充吧。附上源码：http://pan.baidu.com/s/1hrKWRac或者直接下载：TrainTicket.rar"}
{"title": "微信小程序 原生实现下拉刷新 ", "author": "天下雪", "pub_time": "2016-10-24 11:20", "article_content": "在微信小程序中想要实现下拉刷新，是很方便的。但是如何使用，在文档上找起来却不是很方便。话不多说，直接上文档截图\r\n很明显，enablePullDownRefresh 这个属性设置为true。就默认开启了下拉刷新。enablePullDownRefresh可以 写在app.json 中 和页面的***.jsonapp.json \r\n***.json\r\n两者的区别是，app.json 是全局型的下拉刷新，而***.json 是单个页面的下拉刷新，只能设置window相关的配置项，以决定本页面的窗口表现，所以无需写window这个键。  剩下的就是监听下拉刷新了，直接上代码。\r\n   wx.stopPullDownRefresh() 是隐藏下拉刷新动画icon。剩下的就是下拉刷新后你要写的逻辑了"}
{"title": "微信小程序选项卡(窗口顶部TabBar)及(窗口底部TabBar)页面切换 ", "author": "天下雪", "pub_time": "2016-10-24 11:40", "article_content": "一：窗口顶部TabBar页面切换微信小程序开发中选项卡.在Android中选项卡一般用fragment,到了小程序这里瞬间懵逼了.总算做出来了.分享出来看看。先看效果：再上代码:1.index.wxml<!--index.wxml-->  <view class=\"swiper-tab\">      <view class=\"swiper-tab-list {{currentTab==0 ? 'on' : ''}}\" data-current=\"0\" bindtap=\"swichNav\">哈哈</view>      <view class=\"swiper-tab-list {{currentTab==1 ? 'on' : ''}}\" data-current=\"1\" bindtap=\"swichNav\">呵呵</view>      <view class=\"swiper-tab-list {{currentTab==2 ? 'on' : ''}}\" data-current=\"2\" bindtap=\"swichNav\">嘿嘿</view>  </view>  <swiper current=\"{{currentTab}}\" class=\"swiper-box\" duration=\"300\" style=\"height:{{winHeight - 31}}px\" bindchange=\"bindChange\">      <!-- 我是哈哈 -->      <swiper-item>        <view>我是哈哈</view>      </swiper-item>      <!-- 我是呵呵 -->      <swiper-item>        <view>我是呵呵</view>      </swiper-item>      <!-- 我是嘿嘿 -->      <swiper-item>        <view>我是嘿嘿</view>      </swiper-item>  </swiper>  2.index.wxss/**index.wxss**/  .swiper-tab{      width: 100%;      border-bottom: 2rpx solid #777777;  赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序 原生实现下拉刷新 \n              微信小程序把玩《八》：toast组件，loading组件，navigator组件 \n            \n             \n            \n                  原作者: dzp_coder \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • tabbar相关知识系列《二》跳转时无法带参数解决方法，ios下不显示文字 ...\n                                    \n                  • 微信小程序 选项卡demo\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSBzSk2T', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163869|5d98883524b004bd70fa989f1bc469d1|2';"}
{"title": "微信小程序把玩《八》：toast组件，loading组件，navigator组件 ", "author": "天下雪", "pub_time": "2016-10-24 12:35", "article_content": "一：toast组件toast消息提示框，可用在提示一些信息，比如清楚缓存给用户一个友好的提示！或操作一些请求不想让用户有什么操作，toast也可以做到因为toast显示时其他操作是无效的主要属性：wxml<!----><button type=\"primary\" bindtap=\"listenerButton\">显示loading</button><!--默认隐藏--><loading hidden=\"{{hiddenLoading}}\">正在加载</loading>jsPage({  data:{    // text:\"这是一个页面\"    hiddenToast: true  },/** * 监听button点击事件 */  listenerButton: function() {      this.setData({          hiddenToast: !this.data.hiddenToast      })  },  /**   *    toast显示时间到时处理业务    */  toastHidden:function(){      this.setData({          hiddenToast: true      })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})二：loading组件loading通常使用在请求网络数据时的一种方式，通过hidden属性设置显示与否主要属性：wxml<!----><button type=\"primary\" bindtap=\"listenerButton\">显示loading</button><!--默认隐藏--><loading hidden=\"{{hiddenLoading}}\">正在加载</loading>jsPage({  data:{    // text:\"这是一个页面\"    hiddenLoading: true  },  /**   * 监听button点击事件   */  listenerButton:function(){      this.setData({          hiddenLoading: !this.data.hiddenLoading      })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})三：navigator组件navigator跳转分为两个状态一种是关闭当前页面一种是不关闭当前页面。用redirect属性指定。主要属性：wxml<navigator url=\"../index/index\">点击跳转不关闭当前页面</navigator><navigator url=\"../logs/logs\" redirect=\"true\" >点击跳转关闭当前页面</navigator>"}
{"title": "微信小程序把玩《九》：audio组件，image组件，video组件 ", "author": "天下雪", "pub_time": "2016-10-24 15:35", "article_content": "一：audio组件音频播放已经封装的很好！只需配合属性设置即可！ （method和data配合使用）主要属性：wxml<!--监听button点击事件--><button bindtap=\"listenerButton\">点击显示视频组件</button><!--视频组件src资源地址，binderror为监听错误信息--><video     src=\"http://mvvideo1.meitudata.com/575c2b652d7375255.mp4\"    style=\"width: 100%; height: 100%\"    hidden=\"{{hiddenVideo}}\"    binderror=\"listenerVideo\" />jsPage({  data:{    // text:\"这是一个页面\"    hiddenVideo: true  },  /**   * 监听视频加载错误状态   */  listenerVideo:function(e) {      console.log(e.detail.errMsg);  },  /**   * 监听button点击事件   */  listenerButton:function() {      this.setData({          hiddenVideo: !this.data.hiddenVideo      })  }})二：image组件image组件也是一个程序不可缺少的，可以这样说一个app中image组件随处可以看到，一般 image有两种加载方式第一种是网络图片第二种是本地图片资源，都用src属性去指定。重点属性：三种缩放模式九种剪切方式wxml<!--3中是缩放模式    scaleToFill 不保持纵横比缩放图片，使图片的宽高完全拉伸至填满image元素    aspectFit   保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。    aspectFill  保持纵横比缩放图片，只保证图片的短边能完全显示出来--><view>aspectFit 保持纵横比缩放图片，只保证图片的短边能完全显示出来</view><image style=\"width: 100%; height:100%\" mode=\"aspectFit\" src=\"../../image/image.jpg\"/><!--9种是裁剪模式    top 不缩放图片，只显示图片的顶部区域    bottom,同上    left    right    top right    top left    bottom right    bottom left--><view>bottom 不缩放图片，只显示图片的底部区域</view><image style=\"width: 100%; height: 100%\" mode=\"bottom\" src=\"../../image/image.jpg\"/><view>left 不缩放图片，只显示图片的左边区域</view><image style=\"width: 100%; height: 100%\" mode=\"left\" src=\"../../image/image.jpg\"/><view>top right 不缩放图片，只显示图片的右上边区域</view><image style=\"width: 100%; height: 100%\" mode=\"top right\" src=\"../../image/image.jpg\"/>三：video组件视频播放组件与图片加载组件也没啥差别，使用起来也没啥注意的重要属性：wxml<!--监听button点击事件--><button bindtap=\"listenerButton\">点击显示视频组件</button><!--视频组件src资源地址，binderror为监听错误信息--><video     src=\"http://mvvideo1.meitudata.com/575c2b652d7375255.mp4\"    style=\"width: 100%; height: 100%\"    hidden=\"{{hiddenVideo}}\"    binderror=\"listenerVideo\" />jsPage({  data:{    // text:\"这是一个页面\"    hiddenVideo: true  },  /**   * 监听视频加载错误状态   */  listenerVideo:function(e) {      console.log(e.detail.errMsg);  },  /**   * 监听button点击事件   */  listenerButton:function() {      this.setData({          hiddenVideo: !this.data.hiddenVideo      })  }})"}
{"title": "微信小程序把玩《十》：wx.request(object) API，wx.uploadFile(object) ", "author": "天下雪", "pub_time": "2016-10-24 15:48", "article_content": "一：wx.request(object) API这里通过干活集中营的API接口真实请求下数据。如果提示URL 域名不合法，请在 mp 后台配置后重试修改asdebug.js两行代码即可可看下面图定位到asdebug.js文件打开搜索关键字URL 域名不合法关键字就是提示错误信息注释两行代码主要方法：wxml<button type=\"primary\" bindtap=\"listenerButtonDownLoadFile\">下载图片</button><image src=\"{{resource}}\" style=\"width:100%; height: 80%\"/>jsPage({  data:{    // text:\"这是一个页面\"    resource: ''  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  /**   * 下载文件   */  listenerButtonDownLoadFile: function() {      var that = this;      wx.downloadFile({          url: 'https://t2.27270.com/uploads/tu/201609/240/1mb2dybkw2x.jpg',          type: 'image',          success:function(res){              console.log(res.tempFilePath);              that.setData({                  resource: res.tempFilePath,              })          },          fail:function(err){              console.log(err)          },          complete:function(e) {              console.log(e)          }      })  }})二：wx.uploadFile(object), wx.downloadFile(object) API反正我是没有测通这两个API！！！！不知道用的方式不对还是其他的！！！先记录下回头再说。。。主要方法：wx.uploadFile(OBJECT)上传wx.downloadFile(OBJECT)下载wxml<button type=\"primary\" bindtap=\"listenerButtonDownLoadFile\">下载图片button>\r\n\r\n<image src=\"{{resource}}\" style=\"width:100%; height: 80%\"/>123123jsPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n    resource: ''\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  /**\r\n   * 下载文件\r\n   */\r\n  listenerButtonDownLoadFile: function() {\r\n      var that = this;\r\n      wx.downloadFile({\r\n          url: 'https://t2.27270.com/uploads/tu/201609/240/1mb2dybkw2x.jpg',\r\n          type: 'image',\r\n          success:function(res){\r\n              console.log(res.tempFilePath);\r\n              that.setData({\r\n                  resource: res.tempFilePath,\r\n              })\r\n          },\r\n          fail:function(err){\r\n              console.log(err)\r\n          },\r\n          complete:function(e) {\r\n              console.log(e)\r\n          }\r\n      })\r\n  }\r\n})"}
{"title": "有渔微信小程序技术分析《七》实例开发教程 ", "author": "天下雪", "pub_time": "2016-10-24 17:50", "article_content": "作者名字：有渔原文地址：http://itsart.blog.51cto.com/1005243/1865085，请大家多多支持作者原创不易；作者的博客：http://itsart.blog.51cto.com/前面花了8篇文章，简单地介绍了一下小程序。相信完整看下来的读者，对微信小程序应该有了一定的认识。学习，需要边学边练，这样掌握起来快，反正我喜欢这么去学习一样新的技术。学而不思则罔，思而不学则殆嘛。下面，我们一起从0开始，来做一个简单的实例。这个实例我分成2篇文章来讲解：1，完成界面、API交互 2，问题总结及注意事项。有渔系列文章：有渔微信小程序系统概述《六》小程序的API有渔微信小程序技术分析《五》Mustache语法要点总结      有渔微信小程序系统进阶《四》小程序组件      有渔微信小程序系统概述《三》view层及小程序框架概述      有渔微信小程序系统概述《二》了解.js文件及.json文件      有渔微信小程序系统概述《一》认识微信小程序与HelloWorld例子描述：我们一起来做一个叫做“知乎新闻”的小程序，小程序通过zhihu的API查询新闻，把最新的新闻标题列出来，点击标题后显示新闻的详细内容。1、首页设计思路：⑴ 头部“知乎新闻”，通过设置app.json里的window属性就可以了。⑵ 底部的“首页”、“主题新闻”，通过设置app.json里的tabBar属性就可以了。⑶ 图片滚动新闻，用swiper滑块滚动视图组件。⑷ 新闻列表，用view组件；其中，有一个点击新闻标题后，显示新闻详细内容的功能。这个功能，用navigator组件。 代码编写：⑴ app.json  \"window\":{    \"backgroundTextStyle\":\"dark\",    \"navigationBarBackgroundColor\": \"#00a2ea\",    \"navigationBarTitleText\": \"知乎新闻\",    \"navigationBarTextStyle\": \"white\"  },  \"tabBar\": {    \"color\": \"#353535\",    \"selectedColor\": \"#3cc51f\",    \"borderStyle\": \"white\",    \"backgroundColor\": \"#ffffff\",    \"list\": [{      \"pagePath\": \"pages/index/index\",      \"iconPath\": \"images/icon_API.png\",      \"selectedIconPath\": \"images/icon_API_HL.png\",      \"text\": \"主页\"    }, {      \"pagePath\": \"pages/theme/theme\",      \"iconPath\": \"images/icon_component.png\",      \"selectedIconPath\": \"images/icon_component_HL.png\",      \"text\": \"主题新闻\"    }]  }, 跟pages同级创建一个images目录，把png图片文件拷贝到这个目录。然后点击开发者工具左侧的“编译”，显示如下界面：⑵ 添加“图片滚动新闻”① index.wxml里，添加如下代码：<view>  <swiper indicator-dots=\"true\"  autoplay=\"true\" interval=\"3000\" duration=\"2000\">      <swiper-item >          <image src=\"\"  data-id=\"\" />          <text>title</text>      </swiper-item>  </swiper></view>现在，界面有了，但swiper组件里没有图片来源，下面需要通过调用zhihu的API，把图片来源动态地获取出来。 ② index.js里，添加如下代码：  data: {    banner: [],    duration: 2000, // 滑动动画时长    indicatorDots: true, // 是否显示面板指示点    autoplay: true, // 是否自动切换    interval: 3000 // 自动切换时间间隔  },   onLoad () {    var that = this    wx.request({ //调用API，获取新闻数据      url: 'http://news-at.zhihu.com/api/4/news/latest',      headers: {        'Content-Type': 'application/json'      },      success (res) {         that.setData({           banner: res.data.top_stories         })      }    })  }, ③ 这里需要说明下，调用任何API前，需要先了解API返回的数据格式。http://news-at.zhihu.com/api/4/news/latest返回的数据格式如下：为了在swiper中动态显示图片，标题。index.wxml的代码需要修改成：<view>  <swiper indicator-dots=\"{{indicatorDots}}\"  autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">    <block wx:for=\"{{banner}}\">      <swiper-item >          <image src=\"{{item.image}}\"  data-id=\"{{item.id}}\" />          <text>{{item.title}}</text>      </swiper-item>    </block>  </swiper></view> 编译后，显示的界面如下：④ 点击滚动图片，显示新闻具体内容。<image>组件里添加bindtap属性，修改后的代码如下：<image src=\"{{item.image}}\"  data-id=\"{{item.id}}\"                bindtap=\"bindViewTap\" class=\"banner-image\"/>⑤ index.js需要添加相应的bindViewTap方法，如下：  bindViewTap(e) {    wx.navigateTo({      url: '../detail/detail?id=' + e.target.dataset.id    })  }, 2、detail页面前面的首页，点击滚动图片，需要显示新闻具体内容。这时，就需要创建1个detail页面，页面设计如下：⑴ 跟index目录并级，创建detail目录，并创建detail.wxml, detail.js 2个文件。① detail.js的代码如下： onLoad (options) {    var that = this    wx.request({      url: 'http://news-at.zhihu.com/api/4/news/' + options.id,      headers: {        'Content-Type': 'application/json'      },      success (res) {         that.setData({           art: res.data         })      }    })  } ② wxml的代码如下：<view>    <view>        <image src=\"{{art.image}}\"/>        <view>{{art.title}}</view>        <view>{{art.image_source}}</view>    </view>    <view>      {{art.body}}    </view></view> 编译后，显示的界面如下：③ 发现小程序对含html格式的数据，显示有问题。目前，只能人工把html代码过滤掉。后期，我希望腾讯能推出html组件，这样用户在<html> </html>里显示就没问题了。当然，现在你可以自己写js代码，把html格式的数据处理掉。 3、完善首页的“新闻列表”⑴ 用wx:for循环列出新闻，用navigator页面链接组件显示每一条新闻。⑵ 添加“更多”按钮具体代码，我这里就不列了。因为再列代码，这文章也忒长了吧。我喜欢简单，简单。写到这里，我觉得用写文章的方式来讲实例，效果不是很好。下面我会录个视频教程，手把手教你写完这个实例。"}
{"title": "微信小程序开发实战：使用Underscore.js ", "author": "天下雪", "pub_time": "2016-10-25 10:25", "article_content": "Underscore.js 是一个 JavaScript 工具库，它提供了一整套函数式编程的实用功能，但是没有扩展任何 JavaScript 内置对象。Underscore 提供了100多个函数，包括常用的：map、filter、invoke — 当然还有更多专业的辅助函数，如：函数绑定、JavaScript 模板功能、创建快速索引、强类型相等测试等等。 微信小程序无法直接使用require( 'underscore.js' )进行调用。微信小程序模块化机制微信小程序运行环境支持CommoJS模块化，通过module.exports暴露对象，通过require来获取对象。微信小程序Quick Start utils/util.jsfunction formatTime(date) {\r\n  var year = date.getFullYear()\r\n  var month = date.getMonth() + 1\r\n  var day = date.getDate()\r\n\r\n  var hour = date.getHours()\r\n  var minute = date.getMinutes()\r\n  var second = date.getSeconds();\r\n\r\n\r\n  return [year, month, day].map(formatNumber).join('/') + ' ' + [hour, minute, second].map(formatNumber).join(':')\r\n}\r\n\r\nfunction formatNumber(n) {\r\n  n = n.toString()\r\n  return n[1] ? n : '0' + n\r\n}\r\n\r\nmodule.exports = {\r\n  formatTime: formatTime\r\n}\r\npages/log/log.jsvar util = require('../../utils/util.js')\r\nPage({\r\n  data: {\r\n    logs: []\r\n  },\r\n  onLoad: function () {\r\n    this.setData({\r\n      logs: (wx.getStorageSync('logs') || []).map(function (log) {\r\n        return util.formatTime(new Date(log))\r\n      })\r\n    })\r\n  }\r\n})\r\n原因分析Underscore CommonJs模块导出代码如下：// Export the Underscore object for **Node.js**, with\r\n// backwards-compatibility for the old `require()` API. If we're in\r\n// the browser, add `_` as a global object.\r\nif (typeof exports !== 'undefined') {\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n     exports = module.exports = _;\r\n  }\r\n  exports._ = _;\r\n} else {\r\n  root._ = _;\r\n}exports、module必须都有定义，才能导出。通过测试，微信小程序运行环境exports、module并没有定义//index.js\r\n\r\n//获取应用实例\r\nvar app = getApp();\r\n\r\nPage({ \r\n\r\n  onLoad: function () {\r\n    console.log('onLoad');\r\n    var that = this;\r\n\r\n    console.log('typeof exports: ' + typeof exports);    \r\n    console.log('typeof module: ' + typeof exports); \r\n\r\n    var MyClass = function() {\r\n\r\n    }\r\n\r\n    module.exports = MyClass;\r\n\r\n    console.log('typeof module.exports: ' + typeof module.exports);   \r\n  }\r\n})\r\n解决方法修改Underscore代码，注释原有模块导出语句，使用module.exports = _ 强制导出    /*\r\n    // Export the Underscore object for **Node.js**, with\r\n    // backwards-compatibility for the old `require()` API. If we're in\r\n    // the browser, add `_` as a global object.\r\n    if (typeof exports !== 'undefined') {\r\n      if (typeof module !== 'undefined' && module.exports) {\r\n        exports = module.exports = _;\r\n      }\r\n      exports._ = _;\r\n    } else {\r\n      root._ = _;\r\n    }\r\n    */\r\n\r\n    module.exports = _;\r\n    /*\r\n    // AMD registration happens at the end for compatibility with AMD loaders\r\n    // that may not enforce next-turn semantics on modules. Even though general\r\n    // practice for AMD registration is to be anonymous, underscore registers\r\n    // as a named module because, like jQuery, it is a base library that is\r\n    // popular enough to be bundled in a third party lib, but not be part of\r\n    // an AMD load request. Those cases could generate an error when an\r\n    // anonymous define() is called outside of a loader request.\r\n    if (typeof define === 'function' && define.amd) {\r\n      define('underscore', [], function() {\r\n        return _;\r\n      });\r\n    }\r\n    */使用Underscore.js//index.js\r\n\r\nvar _ = require( '../../libs/underscore/underscore.modified.js' );\r\n\r\n//获取应用实例\r\nvar app = getApp();\r\n\r\n\r\nPage( {\r\n\r\n    onLoad: function() {\r\n        //console.log('onLoad');\r\n        var that = this;\r\n\r\n        var lines = [];\r\n\r\n        lines.push( \"_.map([1, 2, 3], function(num){ return num * 3; });\" );\r\n        lines.push( _.map( [ 1, 2, 3 ], function( num ) { return num * 3; }) );\r\n\r\n        lines.push( \"var sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num; }, 0);\" );\r\n        lines.push( _.reduce( [ 1, 2, 3 ], function( memo, num ) { return memo + num; }, 0 ) );\r\n\r\n        lines.push( \"var even = _.find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });\" );\r\n        lines.push( _.find( [ 1, 2, 3, 4, 5, 6 ], function( num ) { return num % 2 == 0; }) );\r\n\r\n        lines.push( \"_.sortBy([1, 2, 3, 4, 5, 6], function(num){ return Math.sin(num); });\" );\r\n        lines.push( _.sortBy( [ 1, 2, 3, 4, 5, 6 ], function( num ) { return Math.sin( num ); }) );\r\n\r\n        lines.push( \"_.indexOf([1, 2, 3], 2);\" );\r\n        lines.push( _.indexOf([1, 2, 3], 2) );\r\n\r\n        this.setData( {\r\n            text: lines.join( '\\n' )\r\n        })\r\n    }\r\n})其他完整代码 https://github.com/guyoung/GyWxappCases/tree/master/Modularity"}
{"title": "微信小程序用户信息解密 C# ", "author": "qq515373375", "pub_time": "2016-10-13 18:24", "article_content": "背景有幸参加微信小程序的内测，由于公司之前已经有自己的服务大号，积累转化了大量的会员所以在做小程序时，要实现会员的互通，想到的是 unionid 开发文档wx.login(OBJECT)调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-login.html?t=1474887500719wx.getUserInfo(OBJECT)获取用户信息，需要先调用 wx.login 接口其中需要的unionid在调用成功返回的参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/open.html?t=1474887500618是个加密数据，解密算法参见：https://mp.weixin.qq.com/debug/wxadoc/dev/api/signature.html 实现code 换取 session_key前端先调 wx.login 得到code后端换取session_key和openid， openid返回前端，session_key保存（缓存）解密用注意：一个code只能换取一次；再次调用 wx.login， 会导致上一次的 session_key 失效，解密出来的都是乱码　　2. 解密前端先调 wx.getUserInfo 得到encryptData用login返回的openid，encryptData 调后端解密刚开始按开发文档，用C# 系统自带AES解密失败报“填充无效，无法被移除”异常在网上扒拉了一圈，也没找到有用的信息，最终在github上，找带了参考代码，自己再改改，才解密成功结语代码本身没啥牛逼的，希望贴出来能对后面的开发伙伴有所帮助 :)"}
{"title": "anjular2和微信小程序的对比 ", "author": "qq515373375", "pub_time": "2016-10-13 18:30", "article_content": "1条件渲染：小程序：用 wx:if=\"{{condition}}\" 来判断是否需要渲染该代码块。<view wx:if=\"{{condition}}\">　　　　True</view>ng2:  用 *ngIf=\"condition\"来判断是否需要渲染该代码块。<p  *ngIf=\"condition\">　　　　condition is true and ngIf is true.</p>对于ng2, 当=号里面的值为真时才渲染标签内的元素，为假时将元素移除。注意：这里是将元素从DOM树里面完全移除，而不是隐藏。 对于需要频繁切换可见性的元素来说，改变元素的display无疑要比频繁的移除和重新渲染高效的多。 不过，angulra2开发者认为，在大多数 UI中，当我们“关闭”一个组件时，在相当长时间内都不大可能想再见到它——可能永远也不见。 而且，当我们隐藏掉一个元素时，组件的行为还在继续——它仍然附加在它所属的 DOM 元素上， 它也仍在监听事件。 Angular 会继续检查哪些能影响数据绑定的变更。 组件原本要做的那些事情仍在继续。 虽然不可见，组件及其各级子组件仍然占用着资源。  虽然每种方法都有各自的优点和缺点，但使用 ngIf 来移除不需要的组件通常都会比隐藏它们更好一些。微信小程序文档较少，不过根据文档中这段话：一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好可以推测wx:if和*ngIf实质是一样的，虽然在写法上有些区别，wx是将条件包裹在{{ condition }}里面。 2 循环列表渲染小程序：列表渲染：默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item<view wx:for=\"{{items}}\">　　{{index}}: {{item}}</view>如某个数组为[a,b,c,d]，则对应的下标index为0,1,2,3，对应的变量名item为a,b,c,d使用wx:for-item可以指定数组当前元素的变量名；使用wx:for-index可以指定数组当前下标的变量名；如： <view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">　　　　  {{idx}}: {{itemName.message}}      </view>则此时下标idx为0,1,2,3, 变量名itemName为a,b,c,dng2:<div *ngFor=\"let hero of heroes; let i=index\">　　　　{{i + 1}} - {{hero.fullName}}</div>ng2里指定变量名用的是let hero of heroes，即设置变量名为hero，对应微信的 wx:for-item=\"itemName；指定下标let  i=index，对应微信的wx:for-index=\"idx\";上面这种写法实际上已经经过语法糖包装后的写法，原来的写法太啰嗦，形似类似： <template ngFor let-item [ngForOf]=\"items\" let-i=\"index\" [ngForTrackBy]=\"trackByFn\">　　　　<li>...</li></template> 3数据绑定微信：数据绑定使用 Mustache 语法（双大括号）将变量包起来　　　　<view> {{ message }} </view>并在js文件里面设置对应的变量值Page({　　data: {　　　　message: 'Hello MINA!'　　}})微信小程序没有双向数据绑定，要改变变量值时，需要通过setdata改变，监听事件如eventname: function(e) {　　this.setData({　　　　data: \"im_new\"　　})}注意不能这样this.data=\"im_new\"，否则会出错 ng2:ng2:主要看一下双向数据绑定：<input [(ngModel)]=\"currentHero.firstName\">（123）表示绑定事件，[12345]表示绑定数据通过[( )]即可实现双向数据绑定这是种简写的形式，背后是这样写的<input　　　　[ngModel]=\"currentHero.firstName\"　　　　(ngModelChange)=\"currentHero.firstName=$event\">"}
{"title": "微信小程序的数据访问 ", "author": "qq515373375", "pub_time": "2016-10-13 18:34", "article_content": "先简单说一下，小程序的结构如图所示1、每个视图(.wxml)只需要添加对应名字的脚本（.js）和样式（.wxss）就可以了，不需要引用，page下面的脚本以及样式都是继承至最外面的app.js , app.wxcss2、脚本也就是.js文件，他有固定格式：page，是用于获取数据的3、utils是用来放置数据接口的 数据访问，如果懂点ajax，都不是问题，没啥好讲的微信小程序，因为IDE太烂了，如果代码再写得难以阅读，整个项目就很难维护了。因为没有写过app，不知道在app中数据访问是怎么封装的作为一个有3天工作经验的小程序码农，觉得如果每个页面的数据都是自己去访问数据接口，那就太不OOP了然后想到了linq to sql，只取了其中的两个方法，原本打算用singelordefault，firstordefault的，想想也麻烦，就用了getbyparams,getbyid，根据条件查找出所有数据，或者根据id获取一条数据直接看方法吧，有点啰嗦了const API_URL = 'http://localhost:4424/api/'function getApi(url,params){  return new Promise((res,rej)=>{    wx.request({      url:API_URL+'/'+url,      data:Object.assign({},params),      header:{'Content-Type': 'application/json'},      success:res,      fail:rej    })  })}module.exports = {  GetByParams(url,page=1,pageSize=20,search = ''){    const params = { start: (page - 1) * pageSize, pageSize: pageSize }    return getApi(url, search ? Object.assign(params, { q: search }) : params)      .then(res => res.data)  },  GetById(url,id){    return getApi(url, id)      .then(res => res.data)  }}module.exports = {}是固定写法，里面写一个一个的方法，每个方法用,隔开。我设置了一个url参数，因为不可能把所有的接口都放在一个conntroller里面，所以url的格式是“conntroller/action”看一个调用的栗子吧，就明白怎么用了const req = require('../../utils/util.js')Page({  data: {    imgUrls: [],    indicatorDots: true,    autoplay: true,    interval: 2000,    duration: 2000  },  onLoad(){    req.GetByParams('home/homebanner')//看这里   看这里   看这里    .then(d=>this.setData({imgUrls:d,loading:false}))    .catch(e=>{      this.setData({imgUrls:[],loading:false})    })  }})这是index的获取banner图的方法，req.GetByParams('home/homebanner')，这里也可以带参数，也可以空着最终的页面是这样的在右边的红色框里面，我们可以看到请求返回的数据，也可以在右边修改数据，界面会跟随着变化，这是关于调试的事情了"}
{"title": "微信小程序之预览图片 ", "author": "qq515373375", "pub_time": "2016-10-13 18:36", "article_content": "选择图片时可设置图片是否是原图，图片来源。这用的也挺常见的，比如个人中心中设置头像，可以与wx.upLoadFile()API使用主要方法：wx.chooseImage(object)wxml<button type=\"primary\" bindtap=\"listenerButtonChooseImage\">点击我选择相册button><image src=\"{{source}}\" mode=\"aspecFill\" style=\"width: 640rpx; height: 640rpx\"/>jsPage({  data:{    // text:\"这是一个页面\"    source: ''  },  /**   * 选择相册或者相机 配合上传图片接口用   */  listenerButtonChooseImage: function() {      var that = this;      wx.chooseImage({          count: 1,          //original原图，compressed压缩图          sizeType: ['original'],          //album来源相册 camera相机           sourceType: ['album', 'camera'],          //成功时会回调          success: function(res) {              //重绘视图              that.setData({                  source: res.tempFilePaths              })          }      })  },wx.previewImage(object)这又是一个奇葩API真实搞不懂怎么用这个。先模仿下官方咋使用但是没有效果，搞懂了在补充下自己的使用wxml<button type=\"primary\" bindtap=\"listenerButtonPreviewImage\">展示图片button>jsvar app = getApp()　　Page({　　　　data: {　　　　　　banner:['../images/big.png', '../images/big.png', '../images/big.png'],　　　　　　modalHidden: true　　　　},　　　　tapMove:function(e){　　　　　　this.setData({ 　　　　　　　　num: e.detail.current+1　　　　　　})　　　　},/**  * 预览图片   */ 　　listenerButtonPreviewImage: function() {   　　　　wx.previewImage({     　　　　　　current: '../images/big.png',        　　　　//这根本就不走       　　　　 success: function(res) {          　　　　console.log(res);       　　　　 },        　　　　//也根本不走       　　　　 fail: function() {          　　　　console.log('fail')       　　　　 },　　　　　　complete:function(){　　　　　　　　console.log('complete')　　　　　　}  　　　　　　 }) 　　　　　　},onLoad: function () { var that = this;that.setData({num:1,count:that.data.banner.length})}})"}
{"title": "微信小程序的快速搭建 ", "author": "qq515373375", "pub_time": "2016-10-13 18:37", "article_content": "「小程序」这个划时代的产品发布快一周了，互联网技术人都在摩拳擦掌，跃跃欲试。可是小程序目前还在内测，首批只发放了\r\n 200 个内测资格（泪流满面）。本以为没有 AppID \r\n这个月就与小程序无缘了，庆幸的是微信这两天发布了正式版开发者工具，无需内测邀请也可以尝鲜了。\r\n因此也就有了我与「小程序」的初体验，而我的感受只有一个字——爽！\r\n选择哪个「小程序」Demo？\r\n在知名同性交友网站 Github 上，「小程序」的 Demo 不少，但是大多只是简单的 API 演示，有的甚至直接把页面数据写在了 \r\njson 文件里（分明有网络请求 API）。我想体验的是能够将服务端和小程序端无缝连接起来（体验够爽）的项目。最终，我选择了腾讯云官方推出的「小相册」项目。\r\n「小相册」主要实现了以下功能：\r\n\r\n列出对象存储 COS 中的图片列表。\r\n\r\n点击左上角上传图片图标，可以调用相机拍照或从手机相册选择图片，并将选中的图片上传到 对象存储 COS 中。\r\n\r\n轻按任意图片，可进入全屏图片预览模式，并可左右滑动切换预览图片。\r\n\r\n长按任意图片，可将其保存到本地，或从 对象存储 COS 中删除。\r\n\r\n效果演示图（受开发工具的限制，部分功能尚未实现）\r\n\r\n对象存储服务（Cloud Object Service）是腾讯云推出的面向企业和个人开发者提供的高可用，高稳定，强安全的云端存储服务。可以将任意数量和形式的非结构化数据放入COS，并在其中实现数据的管理和处理。\r\n\r\n之所以选择腾讯云的 Demo，一是因为它是腾讯自家推出的，项目的质量有保障；二是因为它是少有的既讲小程序开发，又介绍云端部署的项目。\r\n稍微有点经验的程序员都知道，架构要动静分离，静态文件最好不要放在自己的服务器上，要放在专门用来存储的对象存储服务器COS上，并且用CDN 加速。「小相册」后端采用的是 Node.js，Nginx作为反向代理。\r\n第一步：搭开发环境\r\n首先，我们需要在本地搭建好微信「小程序」的开发环境。即下载开发者工具。微信官方已经推出了正式版 IDE，大家没有必要再去下载破解版了。打开官网下载页面，根据自己的操作系统选择。我使用的是 Mac 版。\r\n安装好之后打开运行，会要求微信扫码登陆。之后，就可以看到创建项目的页面了。\r\n\r\n选择添加项目，没有 AppID 就选无（如果乱写会报错，到时可能无法进入项目）。如果你选择的项目目录为空，请如图所示勾选在“当前目录中创建quick start项目”。\r\n\r\n点击“添加项目”之后，我们会进入开发工具的调试页面。\r\n第二步：下载「小相册」源码\r\n接下来，我们下载「小相册」的源码。可以选择直接从腾讯云官网提供的链接下载，也可以从腾讯云团队的 Github 仓库拉取。我推荐从 Github 仓库拉取，这样可以及时获取最新的代码。\r\ngit clone https://github.com/CFETeam/weapp-demo-album.git\r\n最终，我们会得到类似这样的文件目录。\r\n\r\n简单解释下目录结构：\r\n\r\napplet（或app）: 「小相册」应用包代码，可直接在微信开发者工具中作为项目打开。\r\n\r\nserver: 搭建的Node服务端代码，作为服务器和app通信，提供 CGI 接口示例，用于拉取图片资源、上传图片、删除图片。\r\n\r\nassets：「小相册」的演示截图。\r\n\r\n源码下载完成之后，我们打开微信 web 开发者工具，新建项目「小相册」，选择目录applet（或app）。\r\n\r\n「小相册」源码分析\r\n在进行部署之前，我们来简单分析一下「小相册」的具体代码。毕竟只看效果不是我们的目的，我们的目的是以「小相册」为例，了解如何开发小程序并与服务端进行交互。「小相册」包含一个描述整体程序的 app 和多个描述各自页面的 page。主程序 app 主要由三个文件组成，分别是 app.js（小程序逻辑）、app.json（小程序公共设置）和 app.wxss（小程序公共样式表），其中前两个为必备文件。config.js 文件中包含了一些部署域名的设置，现在不用管。在 pages 目录下，有两个 page 页面，分别是 index 和 album。页面结构算是比较简单的，其中 index \r\n是小程序启动时默认进入的页面。每个页面下，至少要有 .js（页面逻辑）和 .wxml（页面结构）两个文件，.wxss（页面样式表）和 \r\n.json（页面配置）文件为选填。你可能注意到了，这些文件的文件名与父目录的名称相同。这是微信官方的规定，目的是减少配置项，方便开发者。接下来我们以 index 页面为例做简单的解释。index.wxml 是这个页面的表现层文件，其中的代码非常简单，可以分为上下两大部分。<view>\r\n    <view class=\"page-top\">\r\n        <text class=\"username\">恭喜你</text>\r\n        <text class=\"text-info\">成功地搭建了一个微信小程序</text>\r\n        <view class=\"page-btn-wrap\">\r\n            <button class=\"page-btn\" bindtap=\"gotoAlbum\">进入相册</button>\r\n        </view>\r\n    </view>\r\n    <view class=\"page-bottom\">\r\n        <text class=\"qr-txt\">分享二维码邀请好友结伴一起写小程序！</text>\r\n        <image src=\"../../images/qr.png\" class=\"qr-img\"></image>\r\n        <image src=\"../../images/logo.png\" class=\"page-logo\"></image>\r\n    </view>\r\n</view>\r\n\r\n\r\n\r\n\r\n\r\n页面的演示效果如下：\r\n\r\n我们看到，页面上有一个“进入相册”的按钮。正常理解，点击后该按钮后我们就可以进入相册了（这不废话嘛）。那小程序背后是怎样实现该操作的呢？\r\n在 index.wxml 中，我们发现对应的 button 标签上定义了一个 bindtap 属性，绑定了一个叫做 gotoAlbum 的方法。而这个方法可以在 index.js 文件中找到。事实上，文件中也只定义了这一个方法，执行的具体动作就是跳转到 album 页面。\r\nPage({\r\n    // 前往相册页\r\n    gotoAlbum() {\r\n        wx.navigateTo({ url: '../album/album' });\r\n    },\r\n});\r\nalbum.js 页面中编写了程序的主要逻辑，包括选择或拍摄图片、图片预览、图片下载和图片删除；album.wxml 中三种视图容器 view、scroll-view、swiper均有使用，还提供了消息提示框 toast。具体方法和视图的实现请查看项目源码。所有的这些功能都写在 Page 类中。\r\nlib 目录下提供了小程序会用的一些辅助函数，包括异步访问和对象存储 COS 的 API。\r\n总的来说，和微信官方宣传的一样，在开发者工具下进行小程序的开发，效率确实提高了很多，而且有很多微信提高的组件和 API。所以，在开发速度这点上的体验还是非常爽的。\r\n另外，由于「小相册」需要使用诸多云端能力，如图片的上传和下载，我们还需要进行服务器端的部署和设置。具体请看接下来的步骤。\r\n第三步：云端部署 server 代码\r\n虽然服务端的开发不是本文的重点，但是为了全面地体验「小相册」的整个开发部署流程，我们还是有必要了解服务端的部署，这里我们使用的是腾讯云。\r\n如果你想更爽一点，那么可以选择腾讯云官方提供的小程序云端镜像。「小相册」的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，可以直接使用。可谓是一键部署好云端。\r\n如果你以前没有使用过腾讯云，可以选择免费试用（我已经领取了 8 天的个人版服务器），或者领取礼包以优惠的价格购买所需的服务。\r\n\r\n你也可以选择将「小相册」源码中的server文件夹上传到自己的服务器。\r\n第四步：准备域名和配置证书\r\n如果你已经有腾讯云的服务器和域名，并配置好了 https，那么可以跳过第 4-6 步。\r\n在微信小程序中，所有的网络请求受到严格限制，不满足条件的域名和协议无法请求。简单来说，就是你的域名必须走 https 协议。所以你还需要为你的域名申请一个证书。如果没有域名，请先注册一个。由于我们没有收到内测，也就暂时不用登录微信公众平台配置通信域名了。\r\n第五步：Nginx 配置 https\r\n微信小程序云端示例镜像中，已经部署好了 Nginx，但是还需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。\r\n\r\n请将红框部分换成自己的域名和证书，并且将 proxy_pass 设置为 Node.js 监听的端口，我的是 9993。\r\n配置完成后，重新加载配置文件并且重启 Nginx。\r\nsudo service nginx reload\r\nsudo service nginx restart\r\n第六步：域名解析\r\n我们还需要添加域名记录，将域名解析到我们的云服务器上，这样才可以使用域名进行 https 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们的域名就支持 https 访问了。\r\n\r\n\r\n第七步：开通和配置 COS\r\n由于我们希望实现动静分离的架构，所以选择把「小相册」的图片资源是存储在 COS 上的。要使用 COS 服务，需要登录 COS 管理控制台，然后在其中完成以下操作。\r\n\r\n点击创建 Bucket。会要求选择所属项目，填写相应名称。这里，我们只需要填上自己喜欢的 Bucket 名称即可。\r\n然后在 Bucket 列表中，点击刚刚创建的 Bucket。然后在新页面点击“获取API密钥”。\r\n弹出的页面中包括了我们所需要的三个信息：唯一的 APP ID，一对SecretID和SecretKey（用于调用 COS API）。保管好这些信息，我们在稍后会用到。最后，在新的 Bucket 容器中创建文件夹，命名为photos。这点后面我们也会提到。\r\n第八步：启动「小相册」的服务端\r\n在官方提供的镜像中，小相册示例的 Node 服务代码已部署在目录 /data/release/qcloud-applet-album 下。进入该目录，如果是你自己的服务器，请进入相应的文件夹。\r\ncd /data/release/qcloud-applet-album\r\n在该目录下，有一个名为 config.js 的配置文件（如下所示），按注释修改对应的 COS 配置：\r\nmodule.exports = {\r\n    // Node 监听的端口号\r\n    port: '9993',\r\n    ROUTE_BASE_PATH: '/applet',\r\n\r\n    cosAppId: '填写开通 COS 时分配的 APP ID',\r\n    cosSecretId: '填写密钥 SecretID',\r\n    cosSecretKey: '填写密钥 SecretKey',\r\n    cosFileBucket: '填写创建的公有读私有写的bucket名称',\r\n};\r\n另外，cd ./routes/album/handlers，修改 list.js，将 const listPath 的值修改为你的Bucket 下的图片存储路径。如果是根目录，则修改为 '/'。当前服务端的代码中将该值设置为了 '/photos' ，如果你在第七步中没有创建该目录，则无法调试成功。\r\n小相册示例使用 pm2 管理 Node 进程，执行以下命令启动 node 服务：\r\npm2 start process.json\r\n第九步：配置「小相册」通信域名\r\n接下来，在微信 web 开发者工具打开「小相册」项目，并把源文件config.js中的通讯域名 host 修改成你自己申请的域名。\r\n\r\n将蓝色框内的内容修改为自己的域名\r\n然后点击调试，即可打开小相册Demo开始体验。\r\n\r\n\r\n最后提示一点，截止目前为止，微信小程序提供的上传和下载 API 无法在调试工具中正常工作，需要用手机微信扫码预览体验。但是由于没有内测资格，我们暂时是没办法体验了。\r\n嗯，就这点不够爽，没有内测邀请。"}
{"title": "微信小程序demo视频：博卡君开发实操指南 ", "author": "天下雪", "pub_time": "2016-10-14 10:16", "article_content": "经过国庆节的七天假期，相信很多朋友都已经研究出自己的小程序 demo 了吧？我最近也利用休息时间关注了一下网上关于小程序开发的讨论，今天就利用这个番外篇谈谈自己对小程序的一些想法吧，顺便把目前做好的成品 demo 给大家看一看。\r\n　　很多学编程的朋友最关心的问题就是小程序的开发难度。我个人觉得，微信小程序的开发难度不算高，最主要的是要时时刻刻遵守微信给我们划定的一些框架和规范。如果你有前端开发基础，那上手会非常快，相比之下，原生APP开发难度就大了很多。　　在用户体验方面，其实微信小程序开发和原生APP在体验方面在日常应用中可以做到非常接近了。不同点就是，微信小程序开发学习周期比较快，开发周期较短，维护起来也快，而原生APP的开发需要全部重新学习它的语言，学习周期很长，开发周期也很长，同时发布需要很长时间的审核期，在迭代方面速度比较慢。　　对于做前端的朋友，适应小程序最需要完成一个开发理念上的大转变，从操作 DOM 转变为操作数据，项目组件化、模板化，需要使用的组件直接调用。换言之，小程序绝对不是「Html 5 + javascrpt 封装一下」那么简单，为了让用户体验更加接近原生 APP，腾讯专门开放了大量接口和组件，这些都是 Html 本身所不具备的。我在一开始接触到这些东西的时候，也琢磨了很久才渐渐适应小程序的节奏。　　有朋友也问过，博卡君连夜吐血赶工了近两周才基本完成一个小程序，是不是微信小程序的开发工作量比较大，我觉得这要具体看你的项目重不重，轻量型的项目团队开发只需要一两周，但也可能在开发中碰到很多需要攻克的技术难点。此外，如果你的需求一直在变化，或者与不熟练的队友在开发，都是有可能影响进度。博卡君吐血熬夜毕竟是为了第一时间同时完成开发和教程的进度，如果团队协作，应该不需要这么辛苦?。　　最后谈一点，博卡君在这个项目中一直是以个人开发者的角色来做的，对于想跟博卡君一样独立开发的朋友，我个人觉得，如果你有数据支持，而且懂后台开发和Mysql，那完全不妨一试。　　好了，博卡君的全球首个微信小程序教程到这里就完全结束了，谢谢大家一直以来的支持和关注。最近大家都在期待微信官方的动态，毕竟目前既不能提交已经做好的小程序，也不确定微信会不会有小程序商店之类的入口来体验成品，博卡君也利用国庆长假顺带关注了一下 iMessage 插件的开发，看看其它平台有没有适合自己发挥的空间。　　其实关注 iMessage 最主要的原因还是它跟微信小程序有许多相似之处，譬如两者都是聊天工具的内部程序、都切合轻量化的使用场景、对 Html 5 都有很好的支持等。我这两天也尝试做了一款 iMessage APP，等功能完善之后会把成品放出来给大家看看。大家也可以对比一下两者的异同，选择适合自己的开发方向。"}
{"title": "iOS程序员上手微信小程序指南：含demo及工具下载 ", "author": "天下雪", "pub_time": "2016-10-14 11:25", "article_content": "什么是微信小程序工具破解开始教程DEMO展示iOS开发如何应对微信小程序热潮本文主要摘录微信小程序工具破解和第一个Hello World DMEO，其他内容可以从 “阅读原文” 中获取什么是微信小程序及其学习价值微信小程序是一种全新的连接用户与服务的方式，可以在微信内被便捷地获取和传播，同时具有出色的使用体验。在微信的发现Tab中增加一个“小程序”入口，点开之后，会出现自己开启的小程序。来看下小程序提供哪些开发能力？视图容器：视图(View)、滚动视图、Swiper，图标、文本、进度条，按钮、表单等等操作反馈，导航媒体组件：音频、图片、视频，地图位置服务画布，文件操作能力网络：上传下载能力、WebSocket数据：数据缓存能力位置：获取位置、查看位置设备：网络状态、系统信息、重力感应、罗盘界面：设置导航条、导航、动画、绘图等等开放接口：登录，包括签名加密，用户信息、微信支付、模板消息一句话，App能做的事，它都能做，微信是通过weixin jssdk兑现这个承诺的。。小程序的体验和原生 app 几乎没有差异。。。（惊）工具破解开发工具 v0.7百度: https://pan.baidu.com/s/1pLxqFzH （密码: bwt9）360: https://yunpan.cn/ckvTYFHWzYYFV （提取码：e09b）开发工具 v0.9百度: https://pan.baidu.com/s/1pLTKIqJ （密码: iswg）360: https://yunpan.cn/ckvXjEbnFYMSC （提取码：f9ca）Demo源代码百度: https://pan.baidu.com/s/1o8hJFuU （密码: bsky）360: https://yunpan.cn/ckvXAacJjvsgR （提取码：3327）微信小程序开发文档：http://notedown.cn/weixin/api/ Mac测试可用，Windows测试可用下载开发工具，并安装（注意：一定要安装0.9版本）打开『微信Web开发者工具』的程序目录Windows：使用资源管理器查看Mac：右键点击图标，选择『显示包内容』进入程序目录后，替换以下文件（只需要替换0.9版本里的，0.7版本用来登陆）：替换文件下载请戳原文链接enjoy开始运行『微信Web开发者工具』通过微信扫描二维码创建项目AppID：随便填项目名称：随便填本地开发目录：选择一个目录点击「添加项目」此时如果出错，先退出再重进此时，能够看到项目列表了打开项目开始开发enjoyDEMO创建项目打开项目所在目录下载「Demo源代码」并解压覆盖打开项目Good luck"}
{"title": "于连林：从程序员的角度分析微信小程序 ", "author": "天下雪", "pub_time": "2016-10-14 11:42", "article_content": "先来了解下什么是微信小程序。 转自知乎微信也许重申了”我们是一款约炮软件”微信还提供了一大堆接口和组件（不好意思，说了句废话）。下面是禅叔的观点：小程序原理就是用JS调用底层native组件，和React Native非常类似。恰恰又证明了，凡是能用JS开发的最终都会用JS开发。证明：凡是能用JS开发的最终都会用JS开发解： 据我多年经验，这句话是一个真命题。 语言的设计者是有两个派系的，有些人认为程序员语言应该防止程序员干蠢事，另一些认为程序员应该可以用编程语言干一切他们想干的事。 C/Java语言是前一个阵营的代表， JS是后一个阵营的代表。往往第一个阵营的语言强调性能， int就是int，double就是double 还第二个阵营就是强调便利性 ，int是var ， double还是var。选择语言的时候，其实就是在做选择题。是选择便利还是选择性能。往往新出的语言便利性都很强，是因为硬件性能提高了，从而可以为了便利性放弃性能要求。编程语言的主要矛盾就是程序开发的便利性和硬件水平的矛盾。如果能够穿越回到70年代（首先在中南海西面买块地）， 那时候你坐在庞大的计算机面前写代码的时候，无意间小手一抖，多敲俩空格，然后程序oom。不要感觉上面的事情不可思议，那时候内存低的可怜，每一个字符都是严格定义的，不允许任何浪费。能运行java虚拟机都是天方夜谭，怎么可能会有java语言。节俭是一种美德，浪费不一定是坏事情随着硬件性能的提高，出现了越来越多的编程语言，新出的语言往往性能上浪费，便利性上提高。要是按照几十年前的标准衡量，有一些使用新语言开发的热门应用程序对硬件资源浪费非常惊人。不仅编程语言有这种现象,这实际是一种普遍的历史趋势, 随着技术的发展，每一代人都在做上一代人觉得浪费的事情。你可以想象下30年前打个长途电话，而现在，别说长途电话了， 有的人都就坐飞机去约炮了，这个在以前很难想象。浪费可以分成好的浪费和坏的浪费。用更多的浪费换来简单的设计，并不是什么坏事。如何才能充分利用新硬件更强大的性能最有利地“浪费”他们？这时候问题就回到了开始， 证明：凡是能用JS开发的最终都会用JS开发JS这种语言扩展性极强， 性能比起其它语言只能呵呵了。 但是硬件速度会提高很快。 Paul Graham算过，如果摩尔定律一直成立。一百年后计算机的运行速度是现在的74乘以10的18次方倍。（准确地说是73 786 976 294 838 206 464倍） 终有一天，你会在选择的时候忽略性能，选择便利性。以前上学的时候，经常去网吧玩大话西游和传奇。而现在随便一个页游就能做出这种游戏效果。10年前你很难想象在网页上能玩这种游戏。你现在就可以尝试想象一下若干年后，打开网页能玩魔兽世界。这并不是不可能实现的。强调性能的语言还能否生存我们都知道C/C++ 就是强调性能的语言， 我们做游戏或者视频播放的都是要求性能的。他们会不会被新的语言取代呢我可以郑重证明，不会的。虽然上面我说的Java语言属于强调性能的第一阵营的语言。但是相对于C/C++ 它显然是增强了便利性。 语言是发展的，是迭代的， 随着硬件性能提高，基本上每个节点下都会产生新的语言，相对于之前的语言浪费性能，增强便利性。但是很难取代之前的语言，对性能要求高的程序依然会出现的， 即使以后可以在网页上玩魔兽世界，但是还会出现 超级魔兽世界，泰坦世界, 宇宙世界 等等一大堆新的对性能要求较高的游戏。微信小程序会取代其它APP吗？问题回到我们的主题微信小程序上，微信小程序会取代其它APP吗？我的观点很明确， 现在不会取代，以后会，但是以后会出现以后的微信取代不了的；以后的以后会取代以后的，但是以后的以后会出现以后的以后的微信取代不了的 …..其实也不难解释，10年前我们不能在网页上玩传奇， 但是现在可以。但是现在又有了魔兽世界，也许10年后网页上就能玩了，但那时候肯定还会出现 超级魔兽世界之类的游戏不能在网页上玩。 作为一个程序员，我们需要学什么？有的人会担心，微信小程序出来了， 做Android、iOS开发的会不会失业啊。其实你大可放心，只要你会学习，永远不会失业，你不学习，就算微信小程序没有推出你也会失业。就目前而言，小程序始终是小，场景有限。还不能完全取代APP , 还可以通过小程序引导用户下载APP。就像简书一样，网页端能浏览不代表不开发APP软件。但是要认清大的趋势， 这段时间就是用来给你学习的。具体怎么学啊？看文档学习呗， 首先了解JS语法基础， 了解React Native原理，学习JS , RN，H5,CSS，运营，测试，产品设计规范，图形设计，神经网络，OpenGL………总之，根据具体文档，用到什么学什么。作为一个程序员，你可以忘了学习的高数，可以忘了学习的英语，可以忘了学习的线性代数…. 但是千万别忘了学习。"}
{"title": "微信小程序内测体验教程：列表的上拉加载和下拉刷新的实现 ... ", "author": "天下雪", "pub_time": "2016-10-14 15:49", "article_content": "1.介绍几个组件1.1 scroll-view 组件注意：使用竖向滚动时，需要给一个固定高度，通过 WXSS 设置 height。1.2 image组件注意：mode有12种模式，其中3种是缩放模式，9种是裁剪模式。1.3 Icon组件iconType: [ ‘success’, ‘info’, ‘warn’, ‘waiting’, ‘safe_success’, ‘safe_warn’, ‘success_circle’, ‘success_no_circle’, ‘waiting_circle’, ‘circle’, ‘download’, ‘info_circle’, ‘cancel’, ‘search’, ‘clear’ ]2.列表的上拉加载和下拉刷新的实现2.2.1 detail.wxml 布局文件<loading hidden=\"{{hidden}}\" bindchange=\"loadingChange\">\r\n    加载中...\r\n  </loading>  \r\n <scroll-view scroll-y=\"true\" style=\"height: 100%;\" bindscrolltolower=\"loadMore\" bindscrolltoupper=\"refesh\">\r\n      <view wx:if=\"{{hasRefesh}}\" style=\"display: flex;flex-direction: row;align-items: center;align-self: center;justify-content: center;\">\r\n      <icon type=\"waiting\" size=\"45\"/><text>刷新中...</text></view>\r\n      <view wx:else  style=\"display:none\" ><text></text></view>\r\n  <view class=\"lll\"  wx:for=\"{{list}}\" wx:for-item=\"item\" bindtap=\"bindViewTap\" \r\n         data-title=\"{{item.title}}\" >\r\n      <image style=\" width: 50px;height: 50px;margin: 20rpx;\" src=\"{{item.firstImg}}\"   ></image>\r\n      <view  class=\"eee\" > \r\n       <view style=\"margin:5px;font-size:8px\"> 标题:{{item.title}}</view>\r\n       <view style=\"margin:5px;color:red;font-size:6px\"> 来源:{{item.source}}</view>\r\n       </view>\r\n</view>\r\n<view class=\"tips1\">\r\n      <view wx:if=\"{{hasMore}}\" style=\"display: flex;flex-direction: row;align-items: center;align-self: center;justify-content: center;\">\r\n      <icon type=\"waiting\" size=\"45\"/><text>玩命的加载中...</text></view>\r\n      <view wx:else><text>没有更多内容了</text></view>\r\n    </view>\r\n </scroll-view>\r\n12345678910111213141516171819202122123456789101112131415161718192021222.2.1 detail.js逻辑代码文件\r\nvar network_util = require('../../utils/network_util.js');\r\nvar json_util = require('../../utils/json_util.js');\r\nPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n    list:[],\r\n     dd:'',\r\n     hidden:false,\r\n     page: 1,\r\n     size: 20,\r\n     hasMore:true,\r\n     hasRefesh:false\r\n  },\r\n  onLoad:function(options){\r\n    var that = this;\r\n    var url = 'http://v.juhe.cn/weixin/query?key=f16af393a63364b729fd81ed9fdd4b7d&pno=1&ps=10';\r\n    network_util._get(url,\r\n    function(res){\r\n    that.setData({\r\n       list:res.data.result.list,\r\n       hidden: true,\r\n    });\r\n    },function(res){\r\n     console.log(res);\r\n });\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  },\r\n   //点击事件处理\r\n  bindViewTap: function(e) {\r\n    console.log(e.currentTarget.dataset.title);\r\n  },\r\n  //加载更多\r\n  loadMore: function(e) {\r\n     var that = this;\r\n    that.setData({\r\n    hasRefesh:true,});\r\n    if (!this.data.hasMore) return\r\n    var url = 'http://v.juhe.cn/weixin/query?key=f16af393a63364b729fd81ed9fdd4b7d&pno='+(++that.data.page)+'&ps=10';\r\n    network_util._get(url,\r\n    function(res){\r\n    that.setData({\r\n       list: that.data.list.concat(res.data.result.list),\r\n       hidden: true,\r\n       hasRefesh:false,\r\n    });\r\n    },function(res){\r\n     console.log(res);\r\n  })\r\n},\r\n//刷新处理\r\nrefesh: function(e) {\r\n var that = this;\r\n that.setData({\r\n    hasRefesh:true,\r\n });\r\n    var url = 'http://v.juhe.cn/weixin/query?key=f16af393a63364b729fd81ed9fdd4b7d&pno=1&ps=10';\r\n    network_util._get(url,\r\n    function(res){\r\n    that.setData({\r\n      list:res.data.result.list,\r\n       hidden: true,\r\n       page:1,\r\n       hasRefesh:false,\r\n    });\r\n    },function(res){\r\n     console.log(res);\r\n })\r\n},\r\n})123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081最后的效果： 代码地址：https://github.com/lidong1665/WeiXinProject"}
{"title": "微信小程序几个令人兴奋的细节 ", "author": "天下雪", "pub_time": "2016-10-15 01:46", "article_content": "1应用号的真实名称叫「微信小程序」，而不是应用号。这个名字还是很可爱的。2小程序的开发文档是微信提供的所有开发文档里最详细最丰富的。3和我在《别开发 app 了》猜测的类似，微信不仅提供丰富的 API，还提供了足够多的框架和组建。你可以去回顾我的老文章。4接口和框架异常丰富，包括：视图、内容、按钮、导航、多媒体、网络能力、罗盘、重力感应、画板等。5有了这个框架和丰富的组件，小程序的启动和运行速度将可以和原生 app 媲美。能实现的功能也将被纯网页的服务号要多得多。6微信不仅提供了详细的文档，还提供了多平台的开发工具，包括 Mac、Linux、Windows。7小程序开发后，不能直接发布，需要经过审核，类似 App Store。这是好事。8微信除了提供开发文档，还提供了比服务号更详尽的设计规范，还有布局时会用到的控件。9不像完全基于网页的服务号，小程序将拥有缓存能力。想象一下这是多么美好的事。10会 Javascript 的工程师，将会越来越吃香。"}
{"title": "一张图，详解微信小程序逻辑层、视图层及逻辑管理 ", "author": "天下雪", "pub_time": "2016-10-15 01:51", "article_content": "最近，微信小程序在业内产生了很大影响，业内从很多角度进行了分析。对于我个人，很幸运地拿到了一个开发者账号，利用周末研究了小程序的框架、开发过程，期间遇到了一些问题，然后用一张图总结下这两天的学习内容及心得体会。图片无法看清楚，请新窗口下打开再行放大"}
{"title": "chemzqm：文件保存后自动刷新微信小程序 ", "author": "天下雪", "pub_time": "2016-10-15 16:14", "article_content": "作者的话：我发现这个方法有副作用，就是别的应用也可能有注册这个全局快捷键，所以我开发了 https://github.com/chemzqm/wept正文部分：微信开发者工具支持刷新和重建的快捷键，所以我们可以发送一段 apple script 脚本来达到刷新/重建项目的效果，从而免去手工切换再使用快捷键的麻烦。例如：tell application \"wechatwebdevtools\"  activate  delay 0.2  tell application \"System Events\"    key code {55, 15}  end tellend tell这段代码可以使用命令 osascript 执行，效果就是聚焦微信开发者工具，然后发送 Command + R 刷新界面。这里的问题是我们还是需要每次刷新都要切换到微信开发者工具界面，这对于开发的流畅度还是有影响的。一个简单的解决办法就是修改开发者工具源码，让它支持全局快捷键，经过一番查找，找到了文件：/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/app/dist/common/menu/menu.js,添加代码：function registShortcut(key, onactive) {  var option = {    key : key,    active : onactive,    failed : function(msg) {      // :(, fail to register the |key| or couldn't parse the |key|.      console.log(msg);    }  };  // Create a shortcut with |option|.  var shortcut = new nw.Shortcut(option);  // Register global desktop shortcut, which can work without focus.  nw.App.registerGlobalHotKey(shortcut);}以及registShortcut(\"Command+Shift+R\", function () {  e.reload()})registShortcut(\"Command+Shift+B\", function () {  e.reBuild()})到 init 函数下面就可以让开发者工具支持全局刷新的热键了（Command+Shift+R 和 Command+Shift+B）,完整文件下载然后只需要让 vim 保存 wxss 和 wxml 文件后发送快捷键就可以了。使用一键安装命令：curl https://raw.githubusercontent.com/chemzqm/vim-macos/master/autoload/macos.vim > ~/.vim/autoload/macos.vim安装 vim-macos 插件, 然后在 ~/.vimrc 中配置：autocmd BufWritePost *.wxml call macos#keycodes('command', 'shift', 'r')autocmd BufWritePost *.wxss call macos#keycodes('command', 'shift', 'r')大功告成。"}
{"title": "微信小程序云端解决方案教程一：文件上传下载应用场景 ", "author": "天下雪", "pub_time": "2016-10-15 16:55", "article_content": "内容架构：部署和运行整体架构1. 准备域名和证书2. 云主机和镜像部署3. 配置 HTTPS4. 域名解析5. 开通和配置 COS6. 启动小相册示例 Node 服务7. 微信小程序服务器配置8. 启动小相册 Demo主要功能实现上传图片获取图片列表下载和保存图片删除图片微信小程序提供了一套在微信上运行小程序的解决方案，有比较完整的框架、组件以及 API，在这个平台上面的想象空间很大。小相册是结合腾讯云对象存储服务（Cloud Object Service，简称COS）制作的一个微信小程序示例。在代码结构上包含如下两部分：applet: 小相册应用包代码，可直接在微信开发者工具中作为项目打开server: 搭建的 Node 服务端代码，作为服务器和applet通信，提供 CGI 接口示例用于拉取 COS 图片资源、上传图片到 COS、删除 COS 图片等。小相册主要功能如下：列出 COS 服务器中的图片列表点击左上角上传图片图标，可以调用相机拍照或从手机相册选择图片，并将选中的图片上传到 COS 服务器中轻按任意图片，可进入全屏图片预览模式，并可左右滑动切换预览图片长按任意图片，可将其保存到本地，或从 COS 中删除部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构1. 准备域名和证书在微信小程序中，所有的网络请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP 中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个证书。域名注册好之后，可以登录微信公众平台配置通信域名了。2. 云主机和镜像部署小相册的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，大家可以直接使用。镜像已包含所有小程序的服务器环境与代码，需要体验其它小程序的朋友无需重复部署3. 配置 HTTPS镜像中已经部署了 nginx，需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 开通和配置 COS小相册示例的图片资源是存储在 COS 上的，要使用 COS 服务，需要登录 COS 管理控制台，然后在其中完成以下操作：开通 COS 服务分配得到唯一的APP ID使用密钥管理生成一对SecretID和SecretKey（用于调用 COS API）在 Bucket 列表中创建公有读私有写访问权限、CDN加速的 bucket（存储图片的目标容器）6. 启动小相册示例 Node 服务在镜像中，小相册示例的 Node 服务代码已部署在目录/data/release/qcloud-applet-album下：进入该目录：cd /data/release/qcloud-applet-album在该目录下有个名为config.js的配置文件（如下所示），按注释修改对应的 COS 配置：module.exports = {    // Node 监听的端口号    port: '9993',    ROUTE_BASE_PATH: '/applet',    cosAppId: '填写开通 COS 时分配的 APP ID',    cosSecretId: '填写密钥 SecretID',    cosSecretKey: '填写密钥 SecretKey',    cosFileBucket: '填写创建的公有读私有写的bucket名称',};小相册示例使用pm2管理 Node 进程，执行以下命令启动 node 服务：pm2 start process.json7. 微信小程序服务器配置进入微信公众平台管理后台设置服务器配置，配置类似如下设置：注意：需要将 www.qcloud.la 设置为上面申请的域名，将 downloadFile 合法域名设置为在 COS 管理控制台中自己创建的 bucket 的相应 CDN 加速访问地址，如下图所示：8. 启动小相册 Demo在微信开发者工具将小相册应用包源码添加为项目，并把源文件config.js中的通讯域名修改成上面申请的域名。然后点击调试即可打开小相册Demo开始体验。这里有个问题。截止目前为止，微信小程序提供的上传和下载 API 无法在调试工具中正常工作，需要用手机微信扫码预览体验。主要功能实现上传图片上传图片使用了微信小程序提供的wx.chooseImage(OBJECT)获取需要上传的文件路径，然后调用上传文件接口wx.request(OBJECT)发送 HTTPS POST 请求到自己指定的后台服务器。和传统表单文件上传一样，请求头Content-Type也是multipart/form-data。后台服务器收到请求后，使用 npm 模块 multiparty 解析 multipart/form-data 请求，将解析后的数据保存为指定目录下的临时文件。拿到临时文件的路径后，就可直接调用 COS SDK 提供的文件上传 API 进行图片存储，最后得到图片的存储路径及访问地址（存储的图片路径也可以直接在 COS 管理控制台看到）。获取图片列表调用列举目录下文件&目录 API可以获取到在 COS 服务端指定 bucket 和该 bucket 指定路径下存储的图片。下载和保存图片指定图片的访问地址，然后调用微信小程序提供的wx.downloadFile(OBJECT)和wx.saveFile(OBJECT)接口可以直接将图片下载和保存本地。这里要注意图片访问地址的域名需要和服务器配置的 dowmloadFile 合法域名一致，否则无法下载。删除图片删除图片也十分简单，直接调用文件删除 API 就可以将存储在 COS 服务端的图片删除。"}
{"title": "微信小程序云端解决方案教程二：WebSocket长连接应用场景 ", "author": "天下雪", "pub_time": "2016-10-15 16:58", "article_content": "部署和运行整体架构1. 准备域名和证书2. 云主机和镜像部署3. 配置 HTTPS4. 域名解析5. 启动 WebSocket 服务6. 启动微信小程序为什么要用 WebSocket通信协议设计服务器逻辑微信端实现没事打开小程序，和附近的人剪刀石头布，想来就来，想走就走。谁能成为武林高手？！微信小程序提供了一套在微信上运行小程序的解决方案，有比较完整的框架、组件以及 API，在这个平台上面的想象空间很大。腾讯云拿到了小程序内测资格，研究了一番之后，发现微信支持 WebSocket 还是很值得玩味的。这个特性意味着我们可以做一些实时同步或者协作的小程序。这篇文章分享一个简单的剪刀石头布的小游戏的制作，希望能对想要在小程序中使用 WebSocket 的开发者有帮助。整个游戏非常简单，连接到服务器后自动匹配在线玩家（没有则分配一个机器人），然后两人进行剪刀石头布的对抗游戏。当对方进行拳头选择的时候，头像会旋转，这个过程使用 WebSocket 会变得简单快速。部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构小程序的架构非常简单，这里有两条网络同步，一条是 HTTPS 通路，用于常规请求。对于 WebSocket 请求，会先走 HTTPS 后再切换协议到 WebSocket 的 TCP 连接，从而实现全双工通信。1. 准备域名和证书在微信小程序中，所有的网路请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP 中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个证书。域名注册好之后，可以登录微信公众平台配置通信域名了。2. 云主机和镜像部署剪刀石头布的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，大家可以直接使用。腾讯云用户可以免费领取礼包，体验腾讯云小程序解决方案。镜像部署完成之后，云主机上就有运行 WebSocket 服务的基本环境、代码和配置了。镜像已包含所有小程序的服务器环境与代码，需要体验其它小程序的朋友无需重复部署3. 配置 HTTPS镜像中已经部署了 nginx，需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 启动 WebSocket 服务在镜像的 nginx 配置中（/etc/nginx/conf.d），已经把 /applet/websocket 的请求转发到 http://127.0.0.1:9595 处理。我们需要把 Node 实现的 WebSocket 服务在这个端口里运行起来。进入镜像中源码位置：cd /data/release/qcloud-applet-websocket使用 pm2 启动服务：pm2 start process.json6. 启动微信小程序在微信开发者工具中修改小程序源码中的 config.js 配置，把通讯域名修改成上面申请的域名。完成后点击调试即可连接到 WebSocket 服务进行游戏。配置完成后，运行小程序就可以看到成功搭建的提示！为什么要用 WebSocket使用传统的 HTTP 轮询或者长连接的方式也可以实现类似服务器推送的效果，但是这类方式都存在资源消耗过大或推送延迟等问题。而 WebSocket 直接使用 TCP 连接保持全双工的传输，可以有效地减少连接的建立，实现真正的服务器通信，对于有低延迟有要求的应用是一个很好的选择。目前浏览器对 WebSocket 的支持程度已经很好，加上微信小程序的平台支持，这种可以极大提高客户端体验的通信方式将会变得更加主流。Server 端需要实现 WebSocket 协议，才能支持微信小程序的 WebSocket 请求。鉴于 SocketIO 被广泛使用，剪刀石头布的小程序，我们选用了比较著名的 SocketIO 作为服务端的实现。Socket IO 的使用比较简单，仅需几行代码就可启动服务。export class Server {    init(path: string) {        /** Port that server listen on */        this.port = process.env.PORT;        /** HTTP Server instance for both express and socket io */        this.http = http.createServer();        /** Socket io instance */        this.io = SocketIO(this.http, { path });        /** Handle incomming connection */        this.io.on(\"connection\", socket => {            // handle connection        });    }    start() {        this.http.listen(this.port);        console.log(`---- server started. listen : ${this.port} ----`);    }}const server = new Server();server.init(\"/applet/ws/socket.io\");server.start();但是，SocketIO 和一些其它的服务器端实现，都有其配套的客户端来完成上层协议的编码解码。但是由于微信的限制（不能使用 window 等对象）， SocketIO 的客户端代码在微信小程序平台上是无法运行的。经过对 SocketIO 通信进行抓包以及研究其客户端源码，笔者封装了一个大约 100 行适用于微信小程序平台的 WxSocketIO 类，可以帮助开发者快速使用 SocketIO 来进行 WebSocket 通信。const socket = new WxSocketIO();socket.on('hi', packet => console.log('server say hi: ' + packet.message));socket.emit('hello', { from: 'techird' });如果想要使用微信原生的 API，那么在服务器端也可以直接使用 ws 来实现 W3C 标准的接口。不过 SocketIO 支持多进程的特性，对于后续做横向扩张是很有帮助的。腾讯云在后面也会有计划推出支持大规模业务需求的 WebSocket 连接服务，减小业务的部署成本。通信协议设计实现一个多客户端交互的服务，是需要把中间涉及到所有的消息类型都设计清楚的，就像是类似剪刀石头布这样一个小程序，都有下面这些消息类型。消息方向说明helloc => s客户端连上后发送 hello 信息，告知服务器自己身份以及位置。his => c服务器响应客户端打招呼，并且反馈附近有多少人joinc => s客户端请求加入一个房间进行游戏leavec => s客户端请求退出房间starts => c房间里面全部人都 ready 后，会发送游戏开始的信号，并且告知客户端游戏时间。choicec => s客户端选择出剪刀、石头还是布facec => s客户端更新自己的表情movements => c有用户更新选择或者更新表情会通知其它用户results => c超过选择时间后，游戏结束，广播游戏结果具体每个消息的参数可以参考源码里的 server/protocol.brief.md服务器逻辑服务器的逻辑很简单：收到用户请求加入房间（join），就寻找还没满的房间找到房间，则加入没找到房间，创建新房间有用户加入的房间检查是否已满，如果已满，则：给房间里每个用户发送开始游戏的信号（start）启动计时器，计时器结束后进行游戏结算游戏结算两两之间 PK，赢方分数加一，输方减一，最终得每个玩家基本得分 x对于每个玩家，如果分数 x 大于 0，则视为胜利，连胜次数加一，否则连胜次数归零本局得分为分数 x 乘以连胜次数发送本局游戏结果给房间里的每位玩家微信端实现微信小程序直接使用上面的协议，针对不同的场景进行渲染。整体的状态机如下。状态机整理清楚后，就是根据状态机来控制什么时候发送消息，接到消息后如何处理的问题了。具体实现请参照 app/pages/game/game.js 里的源码。"}
{"title": "微信小程序云端解决方案教程三：会话管理场景 ", "author": "天下雪", "pub_time": "2016-10-15 17:07", "article_content": "部署和运行整体架构1. 准备域名和证书2. 云主机和镜像部署3. 配置 HTTPS4. 域名解析5. 配置云存储 Redis6. 配置云数据库 MongoDB7. 启动一笔到底示例 Node 服务实现会话层实现源代码微信小程序示例 - 一笔到底微信小程序提供了一套在微信上运行小程序的解决方案，有比较完整的框架、组件以及 API，在这个平台上面的想象空间很大。微信的定位并不是 HTML5，这里很多人都有误解。在一些实现上，并不能想当然地用 HTML5 的思路来思考。比如，微信的请求接口 wx.request并不支持 cookie 传递，所以会话层不能使用传统的 Session 方式。这篇文章分享一个简单的画图应用，使用自己新鲜出炉的小程序会话管理能力来判断并当前用户的身份。小程序非常简单，使用 Canvas 绘图后，把序列化的 actions 提交给服务器保存。下次加载的时候，再列出用户曾经绘制过的图。部署和运行拿到了本小程序源码的朋友可以尝试自己运行起来。整体架构1. 准备域名和证书在微信小程序中，所有的网路请求受到严格限制，不满足条件的域名和协议无法请求，具体包括：只允许和在 MP 中配置好的域名进行通信，如果还没有域名，需要注册一个。网络请求必须走 HTTPS 协议，所以你还需要为你的域名申请一个证书。域名注册好之后，可以登录微信公众平台配置通信域名了。2. 云主机和镜像部署一笔到底的服务器运行代码和配置已经打包成腾讯云 CVM 镜像，大家可以直接使用。腾讯云用户可以免费领取礼包，体验腾讯云小程序解决方案。镜像已包含所有小程序的服务器环境与代码，需要体验其它小程序的朋友无需重复部署3. 配置 HTTPS镜像中已经部署了 nginx，需要在 /etc/nginx/conf.d 下修改配置中的域名、证书、私钥。配置完成后，即可启动 nginx。nginx4. 域名解析我们还需要添加域名记录解析到我们的云服务器上，这样才可以使用域名进行 HTTPS 服务。在腾讯云注册的域名，可以直接使用云解析控制台来添加主机记录，直接选择上面购买的 CVM。解析生效后，我们在浏览器使用域名就可以进行 HTTPS 访问。5. 配置云存储 Redis会话管理依赖 Redis 进行作为缓存管理，开发者可以选择自行搭建 Redis 服务或者直接购买云存储 Redis 服务。6. 配置云数据库 MongoDB一笔到底小程序使用 MongoDB 来存储用户绘制的图像路径，要运行小程序开发者需要自行搭建 MongoDB 服务或者直接购买云数据库 MongoDB。7. 启动一笔到底示例 Node 服务在镜像的 nginx 配置中（/etc/nginx/conf.d），已经把/applet/session的请求转发到 http://127.0.0.1:5757处理。我们需要把 Node 服务运行起来。Node 代码部署在目录/data/release/qcloud-applet-session下。进入该目录：cd /data/release/qcloud-applet-session在该目录下有个名为config.js的配置文件（如下所示），根据注释将appId、appSecret、redisConfig、mongoConfig修改成自己的配置。module.exports = {    port: '5757',    ROUTE_BASE_PATH: '/applet',    // 微信小程序 App ID    appId: '',    // 微信小程序 App Secret    appSecret: '',    // Redis 配置    // @see https://www.npmjs.com/package/redis#options-object-properties    redisConfig: {        host: '',        port: '',        password: '',    },    // MongoDB 配置    // @see https://www.qcloud.com/doc/product/240/3979    mongoConfig: {        username: '',        password: '',        host: '',        port: '',        query: '?authMechanism=MONGODB-CR&authSource=admin',        database: 'qcloud-applet-session',    },};一笔到底示例使用 pm2 管理 Node 进程，执行以下命令启动 node 服务：pm2 start process.json实现会话层实现会话层实现包含两个部分：服务器端：https://github.com/CFETeam/weapp-session客户端：https://github.com/CFETeam/weapp-session-client我们的 Demo 直接使用这两个仓库，可以快速地拥有会话层的能力。会话层的实现和传统 Cookie 的实现方式类似，都是在 Header 上使用特殊的字段跟踪。一个请求的完整流程如下：客户端（微信小程序）发起请求 requestweapp-session-client 包装 request首次请求调用 wx.login() 和 wx.getUserInfo() 接口获得 code、rawData 和 signaturerequset 的头部带上 code、rawData 和 signature保存 code 供下次调用非首次请求request 的头部带上保存的 code服务器收到请求 request，中间件从头部提取 code、rawData 和 signature 字段如果 code 为空，跳到第 4 步如果 code 不为空，且 rawData 不为空，需要进行签名校验使用 code，appid、app_secret 请求微信接口获得 session_key 和 openid如果接口失败，响应 ERR_SESSION_KEY_EXCHANGE_FAILED使用签名算法通过 rawData 和 session_key 计算签名 signature2对比 signature 和 signature2签名一致，解析 rawData 为 wxUserInfo把 openid 写入到 wxUserInfo把 (code, wxUserInfo) 缓存到 Redis把 wxUserInfo 存放在 request.$wxUserInfo 里跳到第 4 步签名不一致，响应 ERR_UNTRUSTED_RAW_DATA如果 code 不为空，但 rawData 为空，从 Redis 根据 code 查询缓存的用户信息找到用户信息，存放在 request.$wxUserInfo 字段里，跳到第 4 步没找到用户信息（可能是过期），响应 ERR_SESSION_EXPIREDrequest 被业务处理，可以使用 request.$wxUserInfo 来获取用户信息（request.$wxUserInfo 可能为空，业务需要自行处理）源代码可从 Github 获取 https://github.com/CFETeam/weapp-session"}
{"title": "微信小程序开发新手实战教程 ", "author": "天下雪", "pub_time": "2016-10-20 17:47", "article_content": "创建快捷项目app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。 app.json是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。 app.wxss是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。App({  onLaunch: function () {    //调用API从本地缓存中获取数据    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)  },  getUserInfo:function(cb){    var that = this    if(this.globalData.userInfo){      typeof cb == \"function\" && cb(this.globalData.userInfo)    }else{      //调用登录接口      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {              that.globalData.userInfo = res.userInfo              typeof cb == \"function\" && cb(that.globalData.userInfo)            }          })        }      })    }  },  globalData:{    userInfo:null  },  onShow:function() {    console.log(\"show\");  },  onHide:function() {    console.log(\"hide\");  }})注意必须在 app.js 中注册App() ，不能注册多个。 onLaunch：程序初始化执行，且只执行一次。 onShow:程序启动，或从程序后台进入前台时执行。 onHide:程序从前台进入后台时执行。 可以添加任意函数到OBJECT中，使用this访问。底部导航 添加images目录，放入图片资源并添加主程序页面 添加底部导航tabBar{  \"pages\":[    \"pages/index/index\",    \"pages/logs/logs\",    \"pages/main/main\"  ],  \"window\":{    \"backgroundTextStyle\":\"light\",    \"navigationBarBackgroundColor\": \"#dddddd\",    \"navigationBarTitleText\": \"WeChat\",    \"navigationBarTextStyle\":\"black\"  },  \"tabBar\":{    \"color\":\"#000\",    \"selectedColor\":\"#48c33c\",    \"borderStyle\":\"block\",    \"backgroundColor\":\"#ffffff\",    \"list\":[{      \"pagePath\":\"pages/index/index\",      \"iconPath\":\"images/footer/index.png\",      \"selectedIconPath\":\"images/footer/indexS.png\",      \"text\":\"首页\"    },    {      \"pagePath\":\"pages/logs/logs\",      \"iconPath\":\"images/footer/logs.png\",      \"selectedIconPath\":\"images/footer/logsS.png\",      \"text\":\"日志\"    },    {      \"pagePath\":\"pages/main/main\",      \"iconPath\":\"images/footer/main.png\",      \"selectedIconPath\":\"images/footer/mainS.png\",      \"text\":\"主程序\"    }    ]  }}color：文字默认颜色 selectedColor：文字选中颜色 borderStyle：上边框颜色（只支持black/white） backgroundColor：背景色 list：菜单列表list属性 pagePath：页面路径（需要在pages中初始化） iconPath：图片路径，大小限制40kb selectedIconPath：选中样式图片路径，大小限制40kb text：按钮文字数据绑定main.jsPage({\r\n  data:{\r\n    text:\"这是一个页面\"\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})12345678910111213141516171819201234567891011121314151617181920main.wxml<view>\r\n    <text>{{text}}</text>\r\n</view>123123view组件 flex-direction： row：横向排列；column：纵向排列 justify-content：flex-start：左对齐； flex-end：右对齐；center：居中；space-between：两端分散对齐；space-around：居中分散对齐 align-items：flex-start：垂直顶部；flex-end：垂直底部；center：垂直居中轮播    <swiper indicator-dots=\"true\" autoplay=\"true\" duration=\"1000\" bindchange=\"listenSwiper\" >\r\n        <swiper-item>\r\n            <view style=\"background: red; height: 150px\"></view>\r\n        </swiper-item>\r\n        <swiper-item>\r\n            <view style=\"background: green; height: 150px\"></view>\r\n        </swiper-item>\r\n            <swiper-item>\r\n            <view style=\"background: blue; height: 150px\"></view>\r\n        </swiper-item>    \r\n    </swiper>12345678910111234567891011属性名 类型 默认值 说明 indicator-dots Boolean false 是否显示面板指示点 autoplay Boolean false 是否自动切换 current Number 0 当前所在页面的 index interval Number 5000 自动切换时间间隔 duration Number 1000 滑动动画时长 bindchange EventHandle current 改变时会触发 change 事件，event.detail = {current: current} 注意：其中只可放置组件，其他节点会被自动删除。 仅可放置在组件中，宽高自动设置为100%。获取轮播改变事件listenSwiper:function(e) {\r\n    console.log(e)\r\n},123123值Object {target: Object, currentTarget: Object, type: \"change\", timeStamp: 35345, detail: Object}\r\ncurrentTarget\r\n:\r\nObject\r\ndetail\r\n:\r\nObject\r\ntarget\r\n:\r\nObject\r\ntimeStamp\r\n:\r\n35345\r\ntype\r\n:\r\n\"change\"\r\n__proto__\r\n:\r\nObject1234567891011121314151617181912345678910111213141516171819图标 icon type 有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear size 默认23px color 同css的color<!--成功图标-->    <icon type=\"success\" size=\"40\"/>    <!--安全成功标志图标-->    <icon type=\"safe_success\" size=\"40\"/>    <!--提示信息图标-->    <icon type=\"info\" size=\"40\"/>    <!--带圆的信息提示图标-->    <icon type=\"info_circle\" size=\"40\"/>    <!--不带圆的成功图标-->    <icon type=\"success_no_circle\" size=\"40\"/>    <!--带圆的成功图标-->    <icon type=\"success_circle\" size=\"40\"/>    <!--警告图标-->    <icon type=\"warn\" size=\"40\"/>    <!--带圆的等待图标-->    <icon type=\"waiting_circle\" size=\"40\"/>    <!--等待图标-->    <icon type=\"waiting\" size=\"40\"/>    <!--下载图标-->    <icon type=\"download\" size=\"40\"/>    <!--取消图标-->    <icon type=\"cancel\" size=\"40\"/>    <!--清除图标-->    <icon type=\"clear\" size=\"40\"/>    <!--改变颜色的success-->    <icon type=\"success\" size=\"40\" color=\"red\"/>进度条 percent Float 无 百分比0~100 show-info Boolean false 在进度条右侧显示百分比 stroke-width Number 6 进度条线的宽度，单位px color Color #09BB07 进度条颜色 active Boolean false 进度条从左往右的动画<progress percent=\"80\" show-info=\"true\" stroke-width=\"5\" color=\"red\" active=\"true\"/>按钮 button    <button type=\"defaule\" bindtap=\"clickButton\">Defalut</button>    <!--原始颜色，不可点击状态， 正在加载状态-->    <button type=\"primary\" disabled=\"true\" loading=\"true\">Primary</button>    <button type=\"warn\">warn</button>注：button-hover 默认为{background-color: rgba(0, 0, 0, 0.1); opacity: 0.7;}按钮点击事件  clickButton: function(e) {    console.log(e);  },CHECKBOX    <!--checkbox-group是checkbox的组，使用bindchange，监听数据选中和取消-->    <checkbox-group bindchange=\"listenCheckboxChange\">        <label style=\"display: flex;\"  wx:for-items=\"{{items}}\">            <checkbox value=\"{{item.name}}\" checked=\"{{item.checked}}\"/>{{item.value}}        </label>    </checkbox-group>绑定事件 绑定数据items: [        {          name: 'S',           value: 'S',           checked: 'true'        },        {          name: 'O',           value: 'O'        },        {          name: 'N',           value: 'N'        },        {          name: 'G',           value: 'G'        },        {          name: 'SONG',           value: 'SONG'        }    ]绑定监听事件  listenCheckboxChange:function(e) {      console.log(e);  },至此页面源代码（Git）：https://github.com/yz-mengxiangsong/wechatDemo.git"}
{"title": "一斤代码深入理解系列《二》：微信小程序样式机制 ", "author": "天下雪", "pub_time": "2016-10-31 10:50", "article_content": "之前，我已经介绍过在小程序开发中使用WXML来做界面布局，但是WXML只是一个界面的骨架。要让我们的小程序变得精致漂亮高大上起来，就需要一种为其添加样式的机制。小程序的开发框架采用了与Web开发中所使用的CSS（层叠样式表）几乎相同的一种机制，称作WXSS。WXSS用于描述WXML的组件样式，用于决定WXML的组件应该如何显示。为了适应广大的前端开发者，它被设计为支持CSS中大部分的特性（但是注意是大部分，还是有一些特性是不支持的），并且有一些自己的扩展和修改。比如引入了一种新的尺寸单位rpx，还有@import这种外联样式的导入机制（话说这个功能不是CSS里也有的么...）关于CSS，我就不在这里介绍它的用法了，这个内容实在有点多，还没学习过CSS的朋友可以自己找一下资料学习，我在这里主要想讲解一下WXSS和CSS之间的不同之处。样式的设置在WXML文件中，我们可以通过style和class属性为组件设置样式。不过由于WXML的数据绑定功能的存在，我们就可以动态的设置style和class的属性值了。比如：<view style=\"color:{{color}};padding:{{padding}};\">Hello</view><view class=\"message-{{type}}\">{{message}}</view>不过，我们要尽量避免使用style来设置组件的样式，最好将样式定义成样式规则放到样式文件中(.wxss)，然后通过class属性来设置。因为组件通过style接收动态样式，在运行时会进行解析，影响渲染性能。有限的选择器和CSS不一样，小程序的WXSS支持的选择器的类型有限，官方文档中明确列出说支持的，目前只有以下几种选择器：\r\n.class：类选择器，例如.error-msg，它会选择所有class=\"error-msg\"的组件\r\n#id：ID选择器，例如#my-container，它会选择id=\"my-container\"的组件\r\nelement：元素选择器，例如view，它会选择所有view组件\r\nelement, element：多选择器，例如view, button，它会选择所有view和button组件\r\n::after：例如view::after，它会在view组件后面插入内容\r\n::before：例如view::after，它会在view组件前面插入内容\r\n其实自己试了一些在CSS中可用，小程序官方没有声明在WXSS里支持的选择器，也是可以生效的。但是有些用了就会把微信web开发者工具给整崩溃掉，所以，还是不要在实际开发中使用这类没说支持的选择器了，虽然在有的场景下麻烦了点，但是以上支持了的选择器还是基本够用了。全局样式与局部样式WXSS中有全局样式与局部样式之分。定义在app.wxss文件中的样式为全局样式，将会对每一个页面起作用。而定义为page同名的wxss文件，则称为局部样式，只会针对对应的页面起作用，而且样式优先级比全局样式要高，可以覆盖全局样式。新的尺寸单位最后来说一下WXSS中新增和扩展的尺寸单位，对于做屏幕的自适应是非常有帮助的。\r\nrpx (responsive pixel，响应式px)，简单来说，就是不管什么尺寸的设备，总是认为屏幕宽度是750rpx\r\nrem (root em，根em)，也很简单，就是不管什么尺寸的设备，总是认为屏幕的宽度是20rem。\r\n所以rpx和rem之间的换算，就是：1rem = (750/20)rpx = 37.5rpx设计师的设计稿一般都是按照px来做单位的，那么在开发阶段，开发人员就需要在px和rpx之间进行换算，具体可以如下来计算：rpx = (屏幕实际宽度/750)px\r\npx = (750/屏幕实际宽度)rpx因此，如果设计师的设计是以iphone6屏幕尺寸为参照(iphone6的屏幕宽度为375px)，则：1rpx = (375/750)px = 0.5px\r\n1px = (750/375)rpx = 2rpx是不是很容易理解？好了，关于微信小程序样式WXSS的关键点内容，就讲解到这里，不对的地方欢迎指正。谢谢啦。"}
{"title": "梦断难寻新手入门篇《三》：下拉刷新，上拉加载更多 ", "author": "天下雪", "pub_time": "2016-10-31 11:50", "article_content": "本文记载了如何在微信小程序里面实现下拉刷新，上拉加载更多先开看一下界面  大致如此的界面吧。 这个Demo使用了微信的几个Api和事件，我先列出来。1.wx.request （获取远程服务器的数据，可以理解成$.ajax）2. scroll-view的两个事件   2.1 bindscrolltolower（滑到页面底部时）   2.2 bindscroll (页面滑动时)   2.3 bindscrolltoupper (滑倒页面顶部时)然后我们看代码，详细描述。index.jsvar url = \"http://www.imooc.com/course/ajaxlist\";\r\nvar page =0;\r\nvar page_size = 20;\r\nvar sort = \"last\";\r\nvar is_easy = 0;\r\nvar lange_id = 0;\r\nvar pos_id = 0;\r\nvar unlearn = 0;\r\n\r\n\r\n// 获取数据的方法，具体怎么获取列表数据大家自行发挥\r\nvar GetList = function(that){\r\n    that.setData({\r\n        hidden:false\r\n    });\r\n    wx.request({\r\n        url:url,\r\n        data:{\r\n            page : page,\r\n            page_size : page_size,\r\n            sort : sort,\r\n            is_easy : is_easy,\r\n            lange_id : lange_id,\r\n            pos_id : pos_id,\r\n            unlearn : unlearn\r\n        },\r\n        success:function(res){\r\n            //console.info(that.data.list);\r\n            var list = that.data.list;\r\n            for(var i = 0; i < res.data.list.length; i++){\r\n                list.push(res.data.list[i]);\r\n            }\r\n            that.setData({\r\n                list : list\r\n            });\r\n            page ++;\r\n            that.setData({\r\n                hidden:true\r\n            });\r\n        }\r\n    });\r\n}\r\nPage({\r\n  data:{\r\n    hidden:true,\r\n    list:[],\r\n    scrollTop : 0,\r\n    scrollHeight:0\r\n  },\r\n  onLoad:function(){\r\n    //   这里要非常注意，微信的scroll-view必须要设置高度才能监听滚动事件，所以，需要在页面的onLoad事件中给scroll-view的高度赋值\r\n      var that = this;\r\n      wx.getSystemInfo({\r\n          success:function(res){\r\n              console.info(res.windowHeight);\r\n              that.setData({\r\n                  scrollHeight:res.windowHeight\r\n              });\r\n          }\r\n      });\r\n  },\r\n  onShow:function(){\r\n    //   在页面展示之后先获取一次数据\r\n    var that = this;\r\n    GetList(that);\r\n  },\r\n  bindDownLoad:function(){\r\n    //   该方法绑定了页面滑动到底部的事件\r\n      var that = this;\r\n      GetList(that);\r\n  },\r\n  scroll:function(event){\r\n    //   该方法绑定了页面滚动时的事件，我这里记录了当前的position.y的值,为了请求数据之后把页面定位到这里来。\r\n     this.setData({\r\n         scrollTop : event.detail.scrollTop\r\n     });\r\n  },\r\n  refresh:function(event){\r\n    //   该方法绑定了页面滑动到顶部的事件，然后做上拉刷新\r\n      page = 0;\r\n      this.setData({\r\n          list : [],\r\n          scrollTop : 0\r\n      });\r\n      GetList(this)\r\n  }\r\n})index.wxml <view class=\"container\">\r\n    <scroll-view scroll-top=\"{{scrollTop}}\" scroll-y=\"true\" style=\"height:{{scrollHeight}}px;\" \r\n        class=\"list\" bindscrolltolower=\"bindDownLoad\" bindscroll=\"scroll\" bindscrolltoupper=\"refresh\">\r\n        <view class=\"item\" wx:for=\"{{list}}\">\r\n            <image class=\"img\" src=\"{{item.pic_url}}\"></image>\r\n            <view class=\"text\">\r\n                <text class=\"title\">{{item.name}}</text>\r\n                <text class=\"description\">{{item.short_description}}</text>\r\n            </view>\r\n        </view>\r\n    </scroll-view>\r\n    <view class=\"body-view\">\r\n        <loading hidden=\"{{hidden}}\" bindchange=\"loadingChange\">\r\n            加载中...\r\n        </loading>\r\n    </view>\r\n</view> 源码奉上 下拉刷新，上拉加载更多.zip"}
{"title": "微信小程序准备工作：微信开发实战《二》微信公众平台接口调试工具 ... ", "author": "天下雪", "pub_time": "2016-10-31 12:03", "article_content": "微信公众平台为公众号开发者提供了网页版的接口调试工具，开发者可以直接在网页中调用对应的接口，比如获取access_token接口，创建菜单接口，发送消息接口 等等。先看一下界面，访问：http://mp.weixin.qq.com/debug/可以看到如下界面：一、接口类型：因为微信公众号接口比较多，所以这里进行了分类，包括：基础支持、向用户发送消息、用户管理、自定义菜单、硬件接入api接口调试 等等；二、接口列表：指的是具体的接口；三、参数列表：调用接口需要的参数；一、获取access_token接口 的调用1.1，根据类型选择接口比如，此界面中调试的接口是 “获取access_token接口”，此接口主要用于调用其他接口前的验证，类似于钥匙。一般平台的接口都不会让开发者直接调用，那样既不安全也增加了平台接口的访问压力。所以平台都会在调用接口之前要求先获取“钥匙”，然后才让“进门”（调用接口）。1.2，填写参数下一步就是填写参数： appId 和 secret（appSecret）。上篇文章介绍了测试号的注册和登录，在测试号登录成功之后，就会发现appId和appSecret，如下图：1.3，调用调试接口将此appId和appSecret填写到参数对应的位置，然后点击 检查问题 按钮，就会获取返回的结果，如下图：这样就获取了 access_token 和 expires_in。access_token：访问其他接口之前的“钥匙”。我们先保存下来，一会演示调试“创建菜单接口”的时候再使用。expires_in：过期时间。开发者不可能每调用一次接口就要去获取一次access_token，这样既增加了微信接口服务器压力，也增加了开发者的工作量。所以为access_token设置了过期时间，单位是秒。开发者一般会将它先缓存在开发者服务器7200s，如果过期了再去获取，具体开发细节后面篇章再详细介绍。二、创建菜单接口刚刚介绍了 获取access_token接口 ，它就是“钥匙”，主要是为了调用其他接口做准备。下面介绍一下创建菜单接口。2.1，菜单json创建微信公众号菜单主要是通过json格式的字符串参数进行创建。菜单级别包括：一级菜单、二级菜单；类型包括：链接，消息，事件，调用摄像头，等等。具体可参考接口文档。简单起见，我们只创建一个链接菜单“我的菜单”，点击它可以打开百度网页，json如下：{     \"button\": [              {                    \"type\": \"view\",                     \"name\": \"我的菜单\",                     \"url\": \"http://www.baidu.com\",                     \"sub_button\": [ ]                }        ]}sub_button：是二级菜单，你也可以尝试将json写的复杂一些，不过要保证格式是正确的。如果有二级菜单，一级菜单就只有展现作用，打不开百度链接。2.2，填写参数，调用接口填写刚获取的 access_token 和 菜单json字符串参数；点击 检查问题 按钮，提示创建菜单成功。2.3，手机微信中查看测试号菜单效果效果如下图，点击 我的菜单 按钮，即可以打开百度网页。提示：如果你创建菜单后，提示创建成功，但是这里的菜单没有变化，可能是由于微信公众号菜单缓存引起的，可以先取消关注，然后再关注即可。结束语如果你已经成功的创建了菜单，也可以尝试调试其他类型的接口。下篇文章主要介绍 开发者公众号的基本原理"}
{"title": "微信小程序准备工作：微信开发实战《三》开发者公众号的交互原理 ... ", "author": "天下雪", "pub_time": "2016-10-31 12:08", "article_content": "通过前2篇文章，相信你已经对公众号有了基本的了解。从本篇文章开始，详细介绍如何进行公众号开发。本篇文章主要介绍公众号常用的消息交互，并配以流程图。主要目的是希望开发者们从宏观角度对开发者公众号有个清晰的认识，在后续各接口开发中有事半功倍的效果。题外话：在我们开发过程中，一般先有明确的目标，再形成清晰的流程逻辑，最后根据设计模式等理论落实代码细节。所以，最后无论使用哪种编程语言，都是一样的了。所以，高层等都是不写代码的...，如果有一天你也不写代码了，恭喜你高升了；或者还有一种可能：恭喜您，不再做码农了~一，微信服务器与开发者服务器交互显然的，如果公众号想成为开发者号，必须有自己的服务器，也就是说必须部署自己的独立应用。以Java开发为例，需要有对应web应用，且是80端口。服务器获取的方式很多，可以租（比如阿里、腾讯：收费），也可以使用新浪SAE（可免费，后面详细介绍）。前提是你要：有想法，有公众号，有码农！1.1，交互图我们以消息交互场景，讲解交互过程。就是粉丝给公众号发送了一条消息，公众号自动回复一条或多条消息。比如，你关注了公众号 程序员实战（coder10），想撩一下它，就发送了一条文本消息：hello，于是下面的事情就会发生了....1动作请求：就是你给coder10发送了 hello ；这时候微信平台服务器会接受到这条消息，并确定是公众号coder10的粉丝发送来的；2是否开发者公众号：在微信公众平台中可以开启开发者配置，如果没有配置，说明不是开发号，进入：3业务处理 ；如果配置为开发者号，那么进入：4包装转换；3业务处理：微信平台会根据coder10的 “自动回复”（微信平台菜单）中的设置，获取对应的回复素材，然后进行：8回复处理；4包装转换：微信平台会重新包装粉丝请求的动作，并转换为公众号开放接口报文的形式（XML格式），并转发给开发者服务器;5请求：微信平台会带着转换后的参数，发送http请求开发者服务器应用，也就是上文提到的web应用。所以web应用必须是公网的、开放的、80端口的应用。请求的URL就是公众号成为开发者号配置的时候，填写的URL、Token认证时候的URL（后面详细介绍）。6开发者根据自己的业务进行处理：现在就进入了码农们比较熟悉的领域了，无论你用什么技术或编程语言，只要提供对外的web应用就可以了。此web应用可以接受http请求，并获取参数，根据自己的业务逻辑处理后，包装转换回复数据，并返回数据给微信服务器：7回复；7回复：回复的数据格式依然是公众号开放接口规定的XML格式的报文。微信服务器接收到数据之后，进入：8回复处理；8回复处理：就是将要回复的内容转换处理，比如是菜单调用摄像头事件，还是地理位置事件，还是仅仅回复消息等等；coder10是回复消息。处理完成之后进行动作回复；9动作回复：这时，粉丝的微信中就会收到公众号的反馈！流程结束！"}
{"title": "微信小程序开发系列分析《三》websocket ", "author": "天下雪", "pub_time": "2016-10-31 12:21", "article_content": "作者：jsong原文地址（已获授权）作者微信公众号：半圆生活，欢迎关注为什么需要websocket？传统的实时交互的游戏，或服务器主动发送消息的行为（如推送服务），如果想做在微信上，可能你会使用轮询的方式进行，不过这太消耗资源，大量的请求也加重了服务器的负担，而且延迟问题比较严重。如果是自己开发的app，为了解决这些问题，很多团队会自建socket，使用tcp长链接、自定协议的方式与服务器进行相对实时的数据交互。有能力的团队，采用这种方式自然没什么大问题。不过小团队可能就要花费很多时间去调试，要解决很多难题，这个在成本上就划不来。H5引入了webSocket来解决网页端的长链接问题，而微信小程序也支持websocket。这是一个非常重要的特性，所以本系列的文章会专门拿出一篇来讨论websocket。webSocket本质上也是TCP连接，它提供全双工的数据传输。一方面可以避免轮询带来的连接频繁建立与断开的性能损耗，另一方面数据可以是比较实时的进行双向传输（因为是长链接），而且WebSocket允许跨域通信（这里有个潜在的跨域安全的问题，得靠服务端来解决）。目前除IE外的浏览器已经对webSocket支持得很好了，微信小程序再推一把之后，它会变得更加流行。我们来设计一个新的demo，一个比较有趣的小游戏，多人版扫雷，准确地讲，多人版挖黄金。后台代码：https://github.com/jsongo/mime-server前端代码：https://github.com/jsongo/wx-mime 游戏规则是这样的：把雷换成金子，挖到金子加一分，每人轮流一次（A挖完轮到B，B挖完A才能再点击），点中金子就算你的，也不会炸，游戏继续，直到把场上所有的金子都挖完游戏才结束。跟扫雷一样，数字也是表示周边有几个金子，然后用户根据场上已经翻出来的数字来猜哪一格可能有金子。这种交互的游戏难点在于，用户的点击操作都要传到服务器上，而且服务器要实时的推送到其它玩家的应用上。另外用户自己也要接收对方操作时实时传过来的数据，这样才不至于重复点中同一个格子。简单讲，就是你要上报操作给服务器，而服务器也要实时给你推消息。为了简化整个模型，我们规定玩家必须轮流来点击，玩家A点完后，才能轮到玩家B，玩家B操作完，玩家A才能点。我们分几步来实现这个功能。一、实现思路1、第一步，我们要先生成扫雷的地图场景这个算法比较简单，简述一下。随机取某行某列就可以定位一个格子，标记成金子（-1表示金子）。mimeCnt表示要生成的金子的数量，用同样的方式循环标记mimeCnt个随机格子。生成完后，再用一个循环去扫描这些-1的格子，把它周边的格子都加1，当然必须是非金子的格子才加1。代码放在这里。其中increaseArround用来把这格金子周边的格子都加1，实现也比较简单：执行genMimeArr()，随机生成结果如下：-1表示金子。看了下貌似没什么问题。接下去，我们就要接入webSocket了。（这个是js版本的，其实生成地图场景的工作是在后台生成，这个js版本只是一个演示，不过算法是一样的。）2、我们需要一个支持webSocket的服务端本例子中，我们使用python的tornado框架来实现（tornado提供了tornado.websocket模块）。当然读者也可以使用socket.io，专为webSocket设计的js语言的服务端，用起来非常简单，它也对不支持webSocket的浏览器提供了兼容（flash或comet实现）。笔者本人比较喜欢使用tornado，做了几年后台开发，使用最多的框架之一的就是它，NIO模型，而且非常轻量级，同样的rps，java可能需要700-800M的内存，tornado只要30-40M，所以在一台4G内存的机子上可以跑上百个tornado服务，而java，对不起，只能跑3个虚拟机。微服务的时代，这一点对小公司很重要。当然如果读者本人对java比较熟悉的话，也可以选择netty框架尝试一下。webSocket用tornado的另一个好处是，它可以在同一个服务（端口）上同时支持webSocket及http两种协议。tornado的官方demo代码中展示了怎么实现同时使用两种协议。在本游戏中，可以这么用：用户进入首页，用http协议去拉取当前的房间号及数据。因为首页是打开最多的，进了首页的用户不一定会玩游戏。所以首页还没必要建立webSocket链接，webSocket链接主要用来解决频繁请求及推送的操作。首页只有一个请求操作。选了房间号后，进去下一个游戏页面再开始建立webSocket链接。3、客户端使用微信小程序开发工具，直接连接是会报域名安全错误的，因为工具内部做了限制，对安全域名才会允许连接。所以同样的，这里我们也继续改下工具的源码，把相关的行改掉就行修改方式如下：找到asdebug.js的这一行，把它改成: if(false)即可。if (!i(r, \"webscoket\"))\r\n懒得修改的读者可以直接使用我破解过的IDE。 发起一个websocket链接的代码也比较简单：wx.connectSocket({\r\n    url: webSocketUrl,\r\n});\r\n在调用这个请求代码之前，先添加下事件监听，这样才知道有没有连接成功：wx.onSocketOpen(function(res){\r\n    console.log('websocket opened.');\r\n});\r\n连接失败的事件：wx.onSocketError(function(res){\r\n  console.log('websocket fail');\r\n})\r\n收到服务器的消息时触发的事件：wx.onSocketMessage(function(res){\r\n    console.log('received msg: ' + res.data);\r\n})\r\n当链接建立之后，发送消息的方法如下：wx.sendSocketMessage({\r\n    data:msg\r\n})\r\n消息发送由于建立链接是需要几次握手，需要一定的时间，所以在wx.connectSocket成功之前，如果直接wx.sendSocketMessage发送消息会报错，这里做一个兼容，如果连接还没建立成功，则用一个数组来保存要发送的信息；而链接第一次建立时，把数据遍历一遍，把消息拿出来一个个补发。这个逻辑我们封装成一个send方法，如下：function sendSocketMessage(msg) {\r\n    if (typeof(msg) === 'object') { // 只能发送string\r\n        msg = JSON.stringify(msg);\r\n    }\r\n    if (socketOpened) { // socketOpened变量在wx.onSocketOpen时设置为true\r\n        wx.sendSocketMessage({\r\n            data:msg\r\n        });\r\n    } else { // 发送的时候，链接还没建立\r\n        socketMsgQueue.push(msg);\r\n    }\r\n}\r\n二、demo功能解析1、首页entry为了简化模型，把重点放在webSocket上，我们把首页做成自己填写房间号的形式。读者如果自己有时间和能力的话，可以把首页做成一个房间列表，并显示每个房间有多少人在玩，只有一人的可以进去跟他玩。甚至后面还可以加上观"}
{"title": "白球手札：微信小程序学习摘要 ", "author": "天下雪", "pub_time": "2016-10-31 12:24", "article_content": "框架微信小程序是一个框架，小程序开发框架。目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。框架结构自己的视图层描述语言（View） WXML 和 WXSS基于 JavaScript 的逻辑层（App Service）框架视图层与逻辑层间提供了数据传输和事件系统特点响应的数据绑定整个系统分为两块视图层（View）和逻辑层（App Service）只需要在逻辑层修改数据，视图层就会做相应的更新。省心的页面管理框架 管理了整个小程序的页面路由。可以做到页面间的无缝切换，并给以页面完整的生命周期。只要将页面的数据，方法，生命周期函数注册进 框架 中，其他的一切复杂的操作都交由 框架 处理。更加微信“原生”与在微信上浏览webAPP相比，会减少脱节感。文件结构小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。关键文件三个最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。.js后缀的是脚本文件监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API.json后缀的文件是配置文件app.json 是对整个小程序的全局配置。配置小程序是由哪些页面组成配置小程序的窗口背景色，配置导航条样式，配置默认标题注意该文件不可添加任何注释。.wxss后缀的是样式表文件就是css关键文件夹pages每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中且 pages 中的第一个页面是小程序的首页。小程序页面组成描述页面的这四个文件必须具有相同的路径与文件名.js后缀的文件是脚本文件，监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件.json后缀的文件是配置文件，.wxss后缀的是样式表文件，.wxml后缀的文件是页面结构文件。.json非必要将会在app.json的基础上，覆盖相同的配置项。.wxml<!--index.wxml-->\r\n<view class=\"container\">\r\n  <view  bindtap=\"bindViewTap\" class=\"userinfo\">\r\n    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\r\n    <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\r\n  </view>\r\n  <view class=\"usermotto\">\r\n    <text class=\"user-motto\">{{motto}}</text>\r\n  </view>\r\n</view>具有新的标签支持自刷新的数据传递方式MVVC.wxss当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。"}
{"title": "微信小程序1028版本新增：文件管理 API说明 ", "author": "天下雪", "pub_time": "2016-10-31 17:57", "article_content": "wx.saveFile(OBJECT)保存文件到本地。OBJECT参数说明：赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              官方指导文档：微信小程序平台运营规范 \n              微信小程序1028版本新增：新增数据管理 API \n            \n             \n            \n                   \n                   \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSTm8820', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序第三方框架对比 ( wepy / mpvue / ta2019-01-28微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30分享一款拥有历史搜索记录的微信小程序搜索2019-01-28小程序点睛之三：才不是你想的那种组件2019-01-28微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11\r\n\r\n\n     \n      \r\n热门主题\r\n\r\n\r\n微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：精美的画板小程序2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo:Canvas图片拖拽生成实现2019-02-21需要一个查询物流的小程序2019-02-22角色扮演，语言cosplay-戏次元2019-02-19小程序转让2019-02-19发表评论后，页面顶部导航跑到页面中间了，2019-02-22request fail length=8192;index=8192，电2019-02-20\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163904|2c8e71bc219be2fc27a2c3c983cd4857|2';"}
{"title": "微信小程序1028版本新增：交互反馈 API 说明 ", "author": "天下雪", "pub_time": "2016-10-31 18:07", "article_content": "wx.showToast(OBJECT)显示消息提示框OBJECT参数说明：参数类型必填说明titleString是提示的内容iconString否图标，只支持\"success\"、\"loading\"durationNumber否提示的延迟时间，单位毫秒，默认：1500, 最大为10000successFunction否接口调用成功的回调函数failFunction否接口调用失败的回调函数completeFunction否接口调用结束的回调函数（调用成功、失败都会执行）示例代码：wx.showToast({\r\n  title: '成功'\r\n  icon: 'success',\r\n  duration: 2000\r\n})wx.hideToast()隐藏消息提示框wx.showToast({\r\n  title: '加载中',\r\n  icon: 'loading',\r\n  duration: 10000\r\n})\r\n\r\nsetTimeout(function(){\r\n  wx.hideToast()\r\n},2000)wx.showModal(OBJECT)​显示模态弹窗OBJECT参数说明：参数类型必填说明titleString是提示的标题contentString是提示的内容showCancelBoolean否是否显示取消按钮，默认为 truecancelTextString否取消按钮的文字，默认为\"取消\"cancelColorHexColor否取消按钮的文字颜色，默认为\"#000000\"confirmTextString否确定按钮的文字，默认为\"确定\"confirmColorHexColor否确定按钮的文字颜色，默认为\"#3CC51F\"successFunction否接口调用成功的回调函数，返回res.confirm==1时，表示用户点击确定按钮failFunction否接口调用失败的回调函数completeFunction否接口调用结束的回调函数（调用成功、失败都会执行）示例代码：wx.showModal({\r\n  title: '提示',\r\n  content: '这是一个模态弹窗',\r\n  success: function(res) {\r\n    if (res.confirm) {\r\n      console.log('用户点击确定')\r\n    }\r\n  }\r\n})wx.showActionSheet(OBJECT)​显示操作菜单OBJECT参数说明：参数类型必填说明itemListString Array是按钮的文字数组，数组长度最大为6个itemColorHexColor否按钮的文字颜色，默认为\"#000000\"successFunction否接口调用成功的回调函数，详见返回参数说明failFunction否接口调用失败的回调函数completeFunction否接口调用结束的回调函数（调用成功、失败都会执行）success返回参数说明：参数类型说明cancelBoolean用户是否取消选择tapIndexNumber用户点击的按钮，从上到下的顺序，从0开始示例代码：wx.showActionSheet({\r\n  itemList: ['A', 'B', 'C'],\r\n  success: function(res) {\r\n    if (!res.cancel) {\r\n      console.log(res.tapIndex)\r\n    }\r\n  }\r\n})"}
{"title": "微信小程序1028版本新增：地理位置 API，图片信息 API，音频组件控制 API，视频组件控 ... ", "author": "天下雪", "pub_time": "2016-10-31 18:20", "article_content": "wx.chooseLocation(OBJECT)打开地图选择位置OBJECT参数说明：参数类型必填说明successFunction是接口调用成功的回调函数，返回内容详见返回参数说明。cancelFunction否用户取消时调用failFunction否接口调用失败的回调函数completeFunction否接口调用结束的回调函数（调用成功、失败都会执行）success返回参数说明：参数说明name位置名称address详细地址latitude纬度，浮点数，范围为-90~90，负数表示南纬longitude经度，浮点数，范围为-180~180，负数表示西经wx.getImageInfo(OBJECT)获取图片信息OBJECT参数说明：参数类型必填说明srcString是图片的路径，可以是相对路径，临时文件路径，存储文件路径successFunction否接口调用成功的回调函数failFunction否接口调用失败的回调函数completeFunction否接口调用结束的回调函数（调用成功、失败都会执行）success返回参数说明：参数类型说明widthNumber图片宽度，单位pxheightNumber图片高度 单位px示例代码：wx.getImageInfo({\r\n  src: 'images/a.jpg',\r\n  success: function (res) {\r\n    console.log(res.width)\r\n    console.log(res.height)\r\n  }\r\n})\r\n\r\nwx.chooseImage({\r\n  success: function (res) {\r\n    wx.getImageInfo({\r\n      src: res.tempFilePaths[0],\r\n      success: function (res) {\r\n        console.log(res.width)\r\n        console.log(res.height)\r\n      }\r\n    })\r\n  }\r\n})wx.createAudioContext(audioId)创建并返回 audio 上下文 audioContext 对象audioContextaudioContext 通过 audioId 跟一个 audio 组件绑定，通过它可以操作一个 audio 组件。audioContext对象的方法列表：方法参数说明play无播放pause无暂停seekposition跳转到指定位置，单位 s示例代码：<!-- audio.wxml -->\r\n<audio  src=\"{{src}}\" id=\"myAudio\" ></audio>\r\n\r\n<button type=\"primary\" bindtap=\"audioPlay\">播放</button>\r\n<button type=\"primary\" bindtap=\"audioPause\">暂停</button>\r\n<button type=\"primary\" bindtap=\"audio14\">设置当前播放时间为14秒</button>\r\n<button type=\"primary\" bindtap=\"audioStart\">回到开头</button>// audio.js\r\nPage({\r\n  onReady: function (e) {\r\n    // 使用 wx.createAudioContext 获取 audio 上下文 context\r\n    this.audioCtx = wx.createAudioContext('myAudio')\r\n  },\r\n  data: {\r\n    src: 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E06DCBDC9AB7C49FD713D632D313AC4858BACB8DDD29067D3C601481D36E62053BF8DFEAF74C0A5CCFADD6471160CAF3E6A&fromtag=46',\r\n  },\r\n  audioPlay: function () {\r\n    this.audioCtx.play()\r\n  },\r\n  audioPause: function () {\r\n    this.audioCtx.pause()\r\n  },\r\n  audio14: function () {\r\n    this.audioCtx.seek(14)\r\n  },\r\n  audioStart: function () {\r\n    this.audioCtx.seek(0)\r\n  }\r\n})wx.createVideoContext(videoId)创建并返回 video 上下文 videoContext 对象videoContextvideoContext 通过 videoId 跟一个 video 组件绑定，通过它可以操作一个 video 组件。videoContext对象的方法列表：方法参数说明play无播放pause无暂停seekposition跳转到指定位置，单位 ssendDanmudanmu发送弹幕，danmu 包含两个属性 text, color。示例代码：<view class=\"section tc\">\r\n  <赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序1028版本新增：交互反馈 API 说明 \n              微信小程序公测接入指南 \n            \n             \n            \n                   \n                   \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序位置API\n                                    \n                  • 小程序开发之视频开发 适配、禁止拖动进度\n                                    \n                  • 微信小程序播放音频\n                                    \n                  • 【微信小程序】再次授权地理位置getLocation+openSetting使用\n                                    \n                  • 微信小程序音频功能开发实(cai)践(keng)\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSe30767', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序第三方框架对比 ( wepy / mpvue / ta2019-01-28微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30分享一款拥有历史搜索记录的微信小程序搜索2019-01-28小程序点睛之三：才不是你想的那种组件2019-01-28微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11\r\n\r\n\n     \n      \r\n热门主题\r\n\r\n\r\n微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：精美的画板小程序2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo:Canvas图片拖拽生成实现2019-02-21需要一个查询物流的小程序2019-02-22角色扮演，语言cosplay-戏次元2019-02-19小程序转让2019-02-19发表评论后，页面顶部导航跑到页面中间了，2019-02-22request fail length=8192;index=8192，电2019-02-20\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163908|1c4d760ac7739f4fd4eb7bbe95f5cb10|2';"}
{"title": "一斤代码深入理解系列《三》：微信小程序和服务器通信 ", "author": "天下雪", "pub_time": "2016-11-1 10:19", "article_content": "如果你的小程序需要和远程的服务进行交互，比如访问你自己的或别人提供的远程API来操作数据（增删改查），那么你就需要一种和远程服务器进行通信的机制来完成这样的功能。\r\n基于浏览器的Web开发中，目前主要有2种主流的服务器通信方式：\r\n\r\n通过Ajax发起HTTP请求访问REST API\r\n通过WebSocket进行实时通信\r\n\r\n小程序框架提供了一套自己的API，实现了跟以上2种方式基本等同的服务器访问方法。由于无论是调用REST API，还是WebSocket通信，都是基于http协议的，为了保证安全性，小程序框架规定在生产环境下，只能使用安全的http协议，即HTTPS，这个也是一个大趋势。而在开发环境下，为了方便起见，我们还是可以用普通的http协议来做开发调试的。\r\nHTTP请求\r\n小程序框架提供了一个名为wx.request()的方法，用于发起HTTP请求，不过值得注意，小程序对并发请求数量限制在了5个。\r\n这个wx.request()方法的用法跟我们用jQuery里面的ajax方法十分的相似：wx.request({ \r\n  url: 'https://your-domain/test',\r\n  method: 'GET',\r\n  data: { \r\n    param1: 'foo' , \r\n    param2: 'bar' \r\n  }, \r\n  header: { \r\n    'Content-Type': 'application/json' \r\n  }, \r\n  success: function(res) { \r\n    console.log(res.data) \r\n  }\r\n})\r\n借这个机会，我们用node.js来写一个正真的提供REST API服务的服务器端程序，并用小程序的API来连接测试一下。在这里我选用Sails框架来实现这个REST API Server。\r\n首先我们安装sails的命令行工具，在你的命令行工具输入:npm install -g sails\r\n安装完成后，建立一个新的项目目录，比如叫rest-server，然后进入该目录，执行以下命令：sails new --no-linker --no-frontend\r\n它会在当前的rest-server目录下，生成一堆代码。这样，一个提供REST服务的node.js服务器程序的架子就基本有了。\r\n代码结构\r\n\r\n但是它里面还没有包含任何可用的REST API，我们需要自行添加。让我们在api/controllers目录下新建一个UsersController.js的文件，然后添加如下内容：\r\nUsersController.js\r\n\r\n这个文件会被自动映射成REST API，访问路径为/users/list，如果不做任何额外配置，那么这个API可以用任何HTTP Method去访问，如果我们想要限定它只能以GET方式访问，那么我们可以去config/routes.js中进行如下配置：\r\nroutes.js\r\n\r\n好，一个非常简单的，可以用GET方式访问的REST API就完成了，我们来把这个服务器运行起来，在rest-server目录下，运行命令：\r\nsails lift\r\n成功启动后，就可以在1337端口进行访问了。我们可以直接在浏览器中输入网址测试一下我们写的API：\r\n在网页中测试API\r\n\r\n看上去我们的REST API已经在工作了。那好，我们就在小程序中，试着去调用这个REST API:\r\n小程序调用逻辑\r\n\r\n如果我们成功获取到这个API返回的数组数据，我们就在小程序界面里将它们显示出来：\r\n小程序模板\r\n\r\n这个是实际的运行效果：\r\n运行结果\r\n\r\n好了，这就是关于小程序调用REST API的一个非常简单的例子，实际的项目中，可能要复杂一些，但是万变不离其宗。\r\nWebSocket\r\n有些应用场景下，我们会对页面的实时性有要求，在浏览器的Web页面开发中，使用WebSocket API去连接一个提供WebSocket服务的服务器端，是目前的主流方案。\r\n在浏览器中，我们直接使用WebSocket对象，然后调用这个对象上的一些方法和监听该对象发出的一些事件。而微信小程序框架提供的是一系列的函数，不过，两者在概念上基本是一样的，所以熟悉WebSocket的朋友不会对其陌生。\r\n小程序的WebSocket API\r\n\r\n在下一篇的文章里，我将继续讲解如何建立一个基于node.js的WebSocket服务器，并在小程序中使用它。"}
{"title": "一斤代码深入理解系列《四》：微信小程序和服务器通信-WebSocket ... ... ", "author": "天下雪", "pub_time": "2016-11-1 10:24", "article_content": "接上一篇文章的话题，我们这次来讲一下如何建立一个基于node.js的WebSocket服务器，并在小程序中使用这个提供实时服务的服务器。\r\nnode.js中已经有很多现成的第三方库，用于构建WebSocket服务。我们今天选用一个叫做websocket的库，来构建一个可以提供标准WebSocket接口的node.js服务端程序。\r\n先建一个空文件夹，名叫ws-server，然后进入该文件夹，在命令行执行:\r\nnpm install websocket\r\n然后在ws-server文件夹下，再新建一个名为app.js的文件，内容如下：\r\napp.js\r\n\r\n因为WebSocket服务是建立在HTTP之上的，所以我们看到，代码中建立了一个http server, 然后建立了一个使用了该http server的WebSocket server，并让http server监听8080端口对外提供服务。\r\n这个服务端的功能也很简单，就是收到客户端发送的消息并打印出来，然后再接收到的消息前面加上一个[from server]的前缀后，返回给客户端。\r\n好，我们来实现调用该服务的微信小程序代码：\r\nindex.js\r\n\r\n首先我们需要用wx.connectSocket()方法去连接目标服务器，因为我们开发环境用的是非安全的http，所以这边的url参数是ws://打头的，在以后微信的实际运行环境中，你的服务端必须使用SSL，所以连接url就会是wss://的了。\r\n然后需要调用wx.onSocketOpen()方法来设置WebSocket连接打开时的回调函数。当连接打开后，就可以开始向服务端发送数据了，我们在这里使用wx.sendSocketMessage()方法，向服务端发送了一个后面跟随一个随机数的Hello,World字符串。我们运行一下程序，可以看到，服务端的控制台上会打印出这样的结果：\r\n服务端\r\n\r\n说明服务端已经成功接收到了客户端发送的字符串消息。\r\n之后服务端会向客户端再反馈这个消息，那客户端这边如何接收这个从服务端过来的消息呢？我们可以在小程序中，使用wx.onSocketMessage()方法，监听服务端发送到客户端的消息，正如我们上面的示例代码写的那样：\r\nwx.onSocketMessage(function (msg) {\r\n      console.log(msg)\r\n})\r\n这里在，我们在小程序的Console上，简单的打印了从服务端过来的消息，如下所示：\r\n小程序Console\r\n\r\n这样，一个简单但完整的客户端和服务器端的WebSocket交互就完成了。如果你想关闭这个WebSocket连接，那么你可以调用wx.closeSocket()来进行关闭。\r\n好了，关于微信小程序和WebSocket服务器通信的例子，就讲到这里吧。不对之处，欢迎指正。"}
{"title": "白球手札：微信小程序学习摘要《二》.json，逻辑层 ", "author": "天下雪", "pub_time": "2016-11-1 10:34", "article_content": "一：.json-配置进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab...app.json 配置项列表属性类型必填描述pagesString Array是设置页面路径windowObject否设置默认页面的窗口表现tabBarObject否设置底部 tab 的表现networkTimeoutObject否设置网络超时时间debugBoolean否设置是否开启 debug 模式pages小程序中新增/减少页面，都需要对 pages 数组进行修改。文件名不需要写文件后缀，因为框架会自动去寻找路径.js,.json,.wxml,.wxss的四个文件进行整合window设置小程序的状态栏、导航条、标题、窗口背景色。tabBar如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。内容与显示分离{[几个包含数据的对象]，统一的样式设置1，统一的样式设置2，统一的样式设置3}networkTimeout可以设置各种网络请求的超时时间。debug可以在开发者工具中开启 debug 模式page.json每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。只只是只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。决定本页面的窗口表现无需!!!写 window 这个键，如：{\r\n  \"navigationBarBackgroundColor\": \"#ffffff\",\r\n  \"navigationBarTextStyle\": \"black\",\r\n  \"navigationBarTitleText\": \"微信接口功能演示\",\r\n  \"backgroundColor\": \"#eeeeee\",\r\n  \"backgroundTextStyle\": \"light\"\r\n}二：逻辑层(App Service)小程序开发框架的逻辑层是由JavaScript编写。逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。在 JavaScript 的基础上，我们做了一些修改，以方便地开发小程序:增加 App 和 Page 方法，进行程序和页面的注册。增加 getApp 和 getCurrentPages 方法，分别用来获取 App 实例和当前页面栈。提供丰富的 API，如微信用户数据，扫一扫，支付等微信特有能力。每个页面有独立的作用域，并提供模块化能力。由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等。开发者写的所有代码最终将会打包成一份 JavaScript，并在小程序启动的时候运行，直到小程序销毁。类似 ServiceWorker，所以逻辑层也称之为 App Service。(RDD:类似于JSX)APPApp()App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。object参数说明：属性类型描述触发时机onLaunchFunction生命周期函数--监听小程序初始化当小程序初始化完成时，会触发 onLaunch（全局只触发一次）onShowFunction生命周期函数--监听小程序显示当小程序启动，或从后台进入前台显示，会触发onShowonHideFunction生命周期函数--监听小程序隐藏当小程序从前台进入后台，会触发 onHide其他Any开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问RDD注解：小程序的数据库。小程序的宏观状态变化时的表现。打开后台 -> 前台前台 -> 后台getApp()我们提供了全局的 getApp() 函数，可以获取到小程序实例。// other.js\r\nvar appInstance = getApp()\r\nconsole.log(appInstance.globalData) // I am global data注意唯一：App() 必须在 app.js 中注册，且不能注册多个。一次：不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。生命周期：不要在 onLaunch 的时候调用 getCurrentPage()，此时 page 还没有生成。不干涉：通过 getApp() 获取实例之后，不要私自调用生命周期函数。三：微信小程序的一些特点小压缩之后不得大于1M内容限制不允许做游戏（APPLE微信的框架比较封闭受限的环境限制大部分对DOM的操作。限制对外链接的数据。限制多数的API(但对‘亲儿子’开放比较粗糙的模块化。阉割版的 require.js比较粗糙的MVVC实现。直接修改数据时并不会自动刷新，而要通过使用data.set({})来触发刷新"}
{"title": "【摘要】微信小程序初步探究简单整理 ", "author": "天下雪", "pub_time": "2016-11-1 11:13", "article_content": "下面是我初步探究所做的简单整理。开发工具下载目录结构我们在微信提供的开发工具中新建一个项目，开发工具会给我们建立一个最基本的目录结构和示例Demo代码，结构如下：结构很简单，程序主体部分由app.js,app.json,app.wxss三个文件组成，而且必须放在项目的根目录。页面由四个文件组成，分别是：文件类型作用必填js页面逻辑yeswxml页面结构yeswxss页面样式nojson页面配置no配置使用app.json文件来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。逻辑层1.注册程序App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。示例：App({\r\n  onLaunch: function() {\r\n    // Do something initial when launch.\r\n  },\r\n  onShow: function() {\r\n      // Do something when show.\r\n  },\r\n  onHide: function() {\r\n      // Do something when hide.\r\n  },\r\n  globalData: 'I am global data'\r\n})2.注册页面Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。Page({\r\n  data: {\r\n    text: \"This is page data.\"\r\n  },\r\n  onLoad: function(options) {\r\n    // Do some initialize when page load.\r\n  },\r\n  onReady: function() {\r\n    // Do something when page ready.\r\n  },\r\n  onShow: function() {\r\n    // Do something when page show.\r\n  },\r\n  onHide: function() {\r\n    // Do something when page hide.\r\n  },\r\n  onUnload: function() {\r\n    // Do something when page close.\r\n  },\r\n  onPullDownRefresh: function() {\r\n    // Do something when pull down\r\n  },\r\n  // Event handler.\r\n  viewTap: function() {\r\n    this.setData({\r\n      text: 'Set some data for updating view.'\r\n    })\r\n  }\r\n});3.模块化可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。需要注意的是：exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以我们更推荐开发者采用 module.exports 来暴露模块接口，除非你已经清晰知道这两者的关系。小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候建议拷贝出相关的代码到小程序的目录中。4.API小程序开发框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。5.ES6 转 ES5微信小程序运行在三端：iOS、Android 和用于调试的开发者工具在 iOS 上，小程序的 javascript 代码是运行在 JavaScriptCore 中在 Android 上，小程序的 javascript 代码是运行在 X5 内核中在 开发工具上， 小程序的 javascript 代码是运行在 nwjs（chrome） 中虽然三个运行环境在大部分情况下是相似的，但是还有一些细微的区别，为了帮助开发者解决这种区别带来的困扰，开发工具会自动帮助开发者将 ES6 的代码转为 ES5 的代码。对于使用其他构建工具的开发者，可以在项目也开中关掉这个功能，使用自己的构建和转码工具。视图层和我之前对微信小程序的直觉不同，微信小程序不支持也不兼容HTML，而是微信全新定义的规范，它的视图文件的后缀名为.wxml，是基于xml进行的扩展，其样式表文件也并非CSS，而是.wxss,兼容受限的部分CSS写法。视图渲染时，采用了类似单向数据绑定的方式进行数据绑定，WXML 中的动态数据均来自对应Page的data。使用Mustache语法（双大括号）将变量包起来:<view> {{ message }} </view>框架可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。支持条件渲染、列表渲染、模板、事件WXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。WXSS 用来决定 WXML 的组件应该怎么显示。WXSS 具有 CSS 大部分特性。 同时为了更适合开发微信小程序，我们对 CSS 进行了扩充以及修改。与 CSS 相比我们扩展的特性有：尺寸单位样式导入框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。组件文档微信小程序官方文档传送门"}
{"title": "秀杰实战教程系列《五》：实战课程之记账应用开发（续） ", "author": "天下雪", "pub_time": "2016-10-21 10:26", "article_content": "缘起：昨天官方开发有了更新v0.10.101100，Picker的mode属性已经支持date以及time（background-image的bug也修复），于是来更新此实例。目标：实现集成日期组件如图官方文档出处：https://mp.weixin.qq.com/debug/wxadoc/dev/component/picker.html步骤，在item.wxml文件中增加一个picker组件，如下：如图从图中可以看出：1.日期后面是空白的，应该默认显示今天日期； 2.点击确定也没有显示到组件上，需要实现bindDateChange方法。于是我们需要在item.js文件中，声明一个data值date与wxml中的{{date}}绑定关联然后在onLoad中初始化字符串格式的日期值，详细说明见注释：经过如上处理，日期组件已经显示为当前日期如图处理到此，我们还需要修复一个逻辑错误，即组件的结束日期应该不超过当日，做法也很简单，只需要在wxml文件中对picker的日期属性end由2017-09-01改为{{date}}即可<picker mode=\"date\" value=\"{{date}}\" start=\"{{date}}\" end=\"2017-09-01\" bindchange=\"bindDateChange\">\r\n吐槽一下，官方的picker的还是有bug的，完全不听start与end使唤，仍可以选任意日期，暂时不去理会，代码就这么写着，什么时候开发工具修复了自然可以了，毕竟是现在还只是内测，就将就用着。接下来处理日期组件点击确认事件bindDateChange回到item.js文件声明一个bindDateChange方法，添加如下代码以写回data中的date值至此，已经实现集成日期picker组件。剩下的就是将它同之前的标题、类型、金额字段那样存在json再本地setStorage存储即可，这里不作赘述"}
{"title": "新手跳坑指南：小程序开发过程中遇到的各种坑 ", "author": "天下雪", "pub_time": "2016-10-21 11:06", "article_content": "1：wx.request 中 method:\"POST” 模式下，后台收到请求，但是data:{}数据全部消失，也就是发了一个空请求！！2：wx.uploadFile和wx.downloadFile 这两个基佬传说在真机有效，在IDE环境中无效~~反正我是没试通，后台没收到任何请求3：【问题】wx.request 中 method:\"POST” 模式下，后台收到请求，但是data:{}数据全部消失，也就是发了一个空请求！！     【解决】可以看下是不是设置了Content-Type='application/json'，我是设置了这个后发现微信也会自动加上'application/json'导致Content-Type变成了application/jsonapplication/json，注释掉自己设置的Content-Type='application/json'就正常了4：【问题】wx.uploadFile和wx.downloadFile 这两个基佬传说在真机有效，在IDE环境中无效~~反正我是没试通，后台没收到任何请求     【解决】开发工具更新前pc无效，手机可以；开发工具更新后pc可以，手机可以。5：【问题】canvas的图片绘制实例无效！！（就是下边这些）var context = wx.createContext()wx.chooseImage({success: function(res) {context.drawImage(res.tempFilePaths[0], 0, 0)wx.drawCanvas({canvasId: 1,actions: context.getActions()})}})6：【问题】分割线用1rpx的时候有时候有些分辨率不显示     【解决】将单位改成px就可以了7：小程序中无法使用图文混合的富文本，以前在网站后台编辑的文章详情和商品详情都无法直接在小程序中正常显示"}
{"title": "微信小程序登录态验证流程 ", "author": "天下雪", "pub_time": "2016-10-21 11:42", "article_content": "点击进入原地址小程序调用wx.login得到code.调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）。用户数据的加解密通讯需要依赖会话密钥完成。小程序调用wx.getUserInfo得到rawData, signatrue, encryptData.小程序调用server获取token接口, 传入code, rawData, signature, encryptData.server调用微信提供的jsoncode2session接口获取openid, session_key, 调用失败应给予客户端反馈, 微信侧返回错误则可判断为恶意请求, 可以不返回. 微信文档链接这是一个 HTTP 接口，开发者服务器使用登录凭证 code 获取 session_key 和 openid。其中 session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输。接口地址：\"https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code\"server计算signature, 并与小程序传入的signature比较, 校验signature的合法性, 不匹配则返回signature不匹配的错误. 不匹配的场景可判断为恶意请求, 可以不返回. 微信文档链接通过调用接口（如 wx.getUserInfo）获取敏感数据时，接口会同时返回 rawData、signature，其中 signature = sha1( rawData + session_key )将 signature、rawData、以及用户登录态发送给开发者服务器，开发者在数据库中找到该用户对应的 session-key，使用相同的算法计算出签名 signature2 ，比对 signature 与 signature2 即可校验数据的可信度。使用第4步返回的session_key解密encryptData, 将解得的信息与rawData中信息进行比较, 需要完全匹配, 解得的信息中也包括openid, 也需要与第4步返回的openid匹配. 解密失败或不匹配应该返回客户相应错误. 微信文档链接接口如果涉及敏感数据（如wx.getUserInfo当中的 openid ），接口的明文内容将不包含敏感数据。开发者如需要获取敏感数据，需要对接口返回的加密数据( encryptData )进行对称解密。 解密算法如下：对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。对称解密的目标密文为 Base64_Decode(encryptData),对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节对称解密算法初始向量 iv = aeskey, 同样是16字节rawData格式:{\r\n    \"nickName\": \"Band\",\r\n    \"gender\": 1,\r\n    \"language\": \"zh_CN\",\r\n    \"city\": \"Guangzhou\",\r\n    \"province\": \"Guangdong\",\r\n    \"country\": \"CN\",\r\n    \"avatarUrl\": \"http://wx.qlogo.cn/mmopen/vi_32/1vZvI39NWFQ9XM4LtQpFrQJ1xlgZxx3w7bQxKARol6503Iuswjjn6nIGBiaycAjAtpujxyzYsrztuuICqIM5ibXQ/0\"\r\n}\r\nencryptData解密之后格式:{\r\n    \"openId\": \"OPENID\",\r\n    \"nickName\": \"NICKNAME\",\r\n    \"gender\": 1,\r\n    \"city\": \"CITY\",\r\n    \"province\": \"PROVINCE\",\r\n    \"country\": \"COUNTRY\",\r\n    \"avatarUrl\": \"AVATARURL\",\r\n    \"unionId\": \"UNIONID\"\r\n}\r\n使用session_key作为密钥, 加密至少包括openid, timestamp, random(随机值), version(版本)的内容, 得到token. 加密算法可以参考微信对encryptData的加密算法. server应该缓存session_key, 缓存的过期时间不应该小于token的过期时间. 将openid, token返回给客户端.小程序每次业务请求都必须带上openid和token, server验证token的合法性: token能否被正常解密; 解密后的openid和传入的openid是否一致; 解密后可得到token的生成时间, token是否过期. 全部校验通过即可正常处理业务请求."}
{"title": "秀杰实战教程系列《六》：服务端之用户注册与登录基于ThinkPHP5描述 ... ", "author": "天下雪", "pub_time": "2016-10-21 14:46", "article_content": "1.下载ThinkPHP 5.0.1：http://www.thinkphp.cn/down/855.html2.安装 解压到站点根目录http://localhost/thinkphp_5.0.1_core/public/访问，可以看到:) ThinkPHP V5 十年磨一剑 - 为API开发设计的高性能框架 [ V5.0 版本由 七牛云 独家赞助发布 ] 新手快速入门完全开发手册说明安装成功。以上url等同于http://localhost/thinkphp_5.0.1_core/public/index.php/index/index/index第一个index是模块名，第二个index是控制器名，第三个index是方法名出处参见config.php Line 60-673.用户登录控制器目标是我们需要一个如下的接口，供我们提交用户信息http://localhost/thinkphp_5.0.1_core/public/index.php/index/user/login参数：openid创建Controller稍加改造输出json格式header(\"Content-type: application/json\");无效！查看文档，需要改配置修改第36行4.用户登录模型5. 配置数据库信息进入database.php6. 建表7. 获取用户输入使用PostMan 测试输出\"灵犀网络\"字样8. 查询是否用户是否已经存在通过openid查询数据库，判断用户是否已经注册如有，返回用户的id,accessToken,username9. 插入新用户创建并返回用户信息10. json输入用户信息，供小程序本地缓存，主要是accessToken配置文件config.php指定了返回类型是json的话，不必通过$user->toArray()，即为纯净的array。而不是如下的对象格式。"}
{"title": "微信小程序开发之吐司toast(消息提示框) ", "author": "天下雪", "pub_time": "2016-10-21 14:50", "article_content": "做Android的时候对toast是很熟悉的.微信小程序开发中吐司也是重要的消息提示方式.上代码:1.index.wxmltoast是微信提供的组件,duration是延迟时间,单位毫秒.这里设置是1000ms.bindchange是事件.在index.js中触发事件即可。<!--index.wxml-->  <toast hidden=\"{{toastHidden}}\" duration=\"1000\" bindchange=\"onToastChanged\">            {{toastText}}    </toast>  2.index.js先在data中定义参数,toastHidden(吐司是否显示),toastText(吐司文本),函数onToastChanged(),当toastHidden变化为时执行,也就是为false时置为true;不加函数吐司不会消失。//index.js  //获取应用实例  var app = getApp()  Page( {    data: {      toastHidden: true, //吐司      toastText: '',//吐司文本    },    onToastChanged: function() {      this.setData( { toastHidden: !this.data.toastHidden });    },    onLoad: function() {      this.setData( {        toastHidden: false, //吐司        toastText: '我是吐司',//吐司文本      })    }  })  我是直接在页面初始化(onLoad:function)时执行,可根据自己需求赋值给toastHidden和toastText。"}
{"title": "微信小程序把玩《六》：picker组件，radio组件，slider组件 ", "author": "天下雪", "pub_time": "2016-10-21 15:03", "article_content": "一：picker组件picker选择器分为三种，普通选择器，时间选择器， 日期选择器 用mode属性区分，默认是普通选择器。测试时时间和日期点击无反应不知道是BUG还是啥！没法手机测试现在也不知道咋回事！！主要属性：普通选择器时间选择器日期选择器wxml<view>普通选择器</view><!--mode默认selector range数据源value选择的index bindchange事件监听--><picker mode=\"selector\" range=\"{{array}}\" value=\"{{index}}\" bindchange=\"listenerPickerSelected\">    <text>{{array[index]}}</text></picker><view>时间选择器</view><picker mode=\"time\" value=\"{{time}}\" start=\"06:00\" end=\"24:00\" bindchange=\"listenerTimePickerSelected\">    <text>{{time}}</text></picker><view>日期选择器</view><picker mode=\"date\" value=\"{{date}}\" start=\"2016-09-26\" end=\"2017-10-10\" bindchange=\"listenerDatePickerSelected\">    <text>{{date}}</text></picker>jsPage({  data:{    // text:\"这是一个页面\"    array: ['Android', 'IOS', 'ReactNativ', 'WeChat', 'Web'],    index: 0,    time: '08:30',    date: '2016-09-26'  },  /**   * 监听普通picker选择器   */  listenerPickerSelected: function(e) {      //改变index值，通过setData()方法重绘界面      this.setData({        index: e.detail.value      });  },   /**   * 监听时间picker选择器   */  listenerTimePickerSelected: function(e) {      //调用setData()重新绘制      this.setData({          time: e.detail.value,      });  },  /**   * 监听日期picker选择器   */  listenerDatePickerSelected:function(e) {    this.setDate({      date: e.detail.value    })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})二：radio组件赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                (1)\r\n\r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\ngyx2813\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              新手跳坑指南：小程序开发过程中遇到的各种坑 \n              微信小程序把玩《七》：switch组件，action-sheet组件，modal组件 \n            \n             \n            \n                  原作者: 顺子_RTFSC \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序把玩《一》：window配置，tabBar底部导航，应用生命周期 ...\n                                    \n                  • 微信小程序把玩《二》：页面生命周期，模块化，数据绑定，view组件 ... ...\n                                    \n                  • 微信小程序把玩《三》：scroll-view组件，swiper组件，icon组件\n                                    \n                  • 微信小程序把玩《四》：text组件，progress组件，button组件\n                                    \n                  • 微信小程序把玩《五》：checkbox组件，form组件，input组件\n                                    \n                  • 微信小程序把玩《八》：toast组件，loading组件，navigator组件\n                                    \n                  • 微信小程序把玩《十》：wx.request(object) API，wx.uploadFile(object)\n                                    \n                  • 微信小程序把玩《十一》：Image API，Record API，Audio API\n                                    \n                  • 微信小程序把玩《十二》：Video API，Storage API，location API\n                                    \n                  • 微信小程序把玩《十三》：获取设备信息 API，navigation API，animation API ...\n                                    \n                  • 微信小程序把玩《十四》：canvas API\n                                    \n                  • 小程序 自定义slider组件音频播放实例\n                                    \n                  • 微信小程序radio点选框，再次点击取消\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSl5ox46', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163924|d9bd551e27c183c68a8c167d5c99578e|2';"}
{"title": "微信小程序把玩《七》：switch组件，action-sheet组件，modal组件 ", "author": "天下雪", "pub_time": "2016-10-21 15:11", "article_content": "一：switch组件switch开关组件使用主要属性：wxml<!--switch类型开关--><view>switch类型开关</view><switch type=\"switch\" checked=\"true\" bindchange=\"listenerSwitch\"/><!--checkbox类型开关--><view>checkbox类型开关</view><switch type=\"checkbox\" bindchange=\"listenerCheckboxSwitch\" />jsPage({  data:{    // text:\"这是一个页面\"  },  /**   * switch开关监听   */  listenerSwitch: function(e) {    console.log('switch类型开关当前状态-----', e.detail.value);  },  /**   * checkbox类型开关监听   */  listenerCheckboxSwitch: function(e) {    console.log('checkbox类型开关当前状态-----', e.detail.value)  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})二：action-sheet组件action-sheet组件是从底部弹出可选菜单项，估计也是借鉴iOS的设计添加的，action-sheet有两个子组件， action-sheet-item为每个选项，action-sheet-cancel取消选项，与action-sheet-item中间会有间隔，并且点击会触发action-sheet监听事件主要属性：wxml<!--触发action-sheet事件--><button type=\"primary\" bindtap=\"listenerButton\">弹出ActionSheet</button><!--默认action-sheet为隐藏，由button触发--><action-sheet hidden=\"{{actionSheetHidden}}\" bindchange=\"listenerActionSheet\" >    <block wx:for-items=\"{{actionSheetItems}}\" >         <action-sheet-item >{{item}}</action-sheet-item>    </block>    <!--自动隐藏action-sheet-->    <action-sheet-cancel>取消</action-sheet-cancel></action-sheet>jsPage({  data:{    // text:\"这是一个页面\"    actionSheetHidden: true,    actionSheetItems: ['item1', 'item2', 'item3']  },  listenerButton: function() {      this.setData({        //取反          actionSheetHidden: !this.data.actionSheetHidden      });  },  listenerActionSheet:function() {    this.setData({      actionSheetHidden: !this.data.actionSheetHidden    })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})三：modal组件modal弹出框常用在提示一些信息比如：退出应用，清楚缓存，修改资料提交时一些提示等等。常用属性：wxml<!--监听button点击事件--><button bindtap=\"listenerButton\" type=\"primary\">弹出modal</button><!--弹出框--><modal     title=\"退出应用\"     hidden=\"{{hiddenModal}}\"     confirm-text=\"再看看\"     cancel-text=\"退出\"     bindconfirm=\"listenerConfirm\"     bindcancel=\"listenerCancel\" >     您是否真的要退出应用     </modal>jsPage({  data:{    // text:\"这是一个页面\"    hiddenModal: true  },  listenerButton:function() {      this.setData({          hiddenModal: !this.data.hiddenModal      })  },  listenerConfirm:function() {      this.setData({          hiddenModal: true      })  },  listenerCancel:function() {      this.setData({          hiddenModal: true      })  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }})"}
{"title": "精品教程：微信小程序实战之知乎日报 ", "author": "天下雪", "pub_time": "2016-10-21 16:27", "article_content": "上一次的《微信小程序之小豆瓣图书》制作了一个图书的查询功能，只是简单地应用到了网络请求，其他大多数小程序应有的知识。而本次的示例是知乎日报，功能点比较多，页面也比上次复杂了许多。在我编写这个DEMO之前，网上已经有很多网友弄出了相同的DEMO，也是非常不错的，毕竟这个案例很经典，有比较完整的API，很值得模仿学习。本次个人的DEMO也算是一次小小的练习吧。由于知乎日报是一个资讯类的App，UI的布局主要是以资讯列表页、资讯详情页和评论页为主，当然本次也附带了应用设置页，不过现阶段功能尚未编写，过段时间会更新补充，继续完善。API分析本次应用使用了知乎日报的API，相比上次豆瓣图书的数量比较多了，但是部分仍然有限制，而且自己没有找到评论接口的分页参数，所以评论这块没有做数据的分页。以下是使用到的具体API，更加详细参数和返回结构可参照网上网友分享的 知乎日报-API-分析 ，在此就不做再次分析了。启动界面图片http://news-at.zhihu.com/api/4/start-image/{size}参数说明size图片尺寸，格式：宽*高。例如: 768*1024获取刚进入应用时的显示封面，可以根据传递的尺寸参数来获取适配用户屏幕的封面。获取最新日报http://news-at.zhihu.com/api/4/news/latest返回的数据用于日报的首页列表，首页的结构有上下部分，上部分是图片滑动模块，用于展示热门日报，下部分是首页日报列表，以上接口返回的数据有热门日报和首页日报获取日报详细http://news-at.zhihu.com/api/4/news/{id}参数说明id日报id在点击日报列表也的日报项时，需要跳转到日报详情页展示日报的具体信息，这个接口用来获取日报的展示封面和具体内容。历史日报http://news.at.zhihu.com/api/4/news/before/{date}参数说明date年月日格式时间yyyyMMdd,例如：20150903、20161202这个接口也是用与首页列表的日报展示，但是不同的是此接口需要传一个日期参数，如20150804格式。获取最新日报接口只能获取当天的日报列表，如果需要获取前天或者更久之前的日报，则需要这个接口单独获取。日报额外信息http://news-at.zhihu.com/api/4/story-extra/{id}参数说明id日报id在日报详情页面中，不仅要展示日报的内容，好需要额外获取此日报的评论数目和推荐人数等额外信息。日报长评http://news-at.zhihu.com/api/4/story/{id}/long-comments参数说明id日报id日报的评论页面展示长评用到的接口（没有找到分页参数，分页没有做）日报短评http://news-at.zhihu.com/api/4/story/{id}/short-comments参数说明id日报id日报的评论页面展示段评用到的接口（没有找到分页参数，分页没有做）主题日报栏目列表http://news-at.zhihu.com/api/4/themes主页的侧边栏显示有主题日报的列表，需要通过这个接口获取主题日报栏目列表主题日报具体内容列表http://news-at.zhihu.com/api/4/theme/{themeId}参数说明themeId主题日报栏目id在主页侧栏点击主题日报进入主题日报的内容页，需要展示此主题日报下的日报列表。代码编写启动页作为一个仿制知乎日报的伪APP，高大上的启动封面是必须的，哈哈。启动页面很简单，请求一个应用启动封面接口，获取封面路径和版权信息。当进入页面，在onLoad事件中获取屏幕的宽和高来请求适合尺寸的图片，在onReady中请求加载图片，在请求成果之后，延迟2s进入首页，防止页面一闪而过。onLoad: function( options ) {\r\n    var _this = this;\r\n    wx.getSystemInfo( {\r\n      success: function( res ) {\r\n        _this.setData( {\r\n          screenHeight: res.windowHeight,\r\n          screenWidth: res.windowWidth,\r\n        });\r\n      }\r\n    });\r\n},\r\n\r\nonReady: function() {\r\n    var _this = this;\r\n    var size = this.data.screenWidth + '*' + this.data.screenHeight;\r\n    requests.getSplashCover( size, ( data ) => {\r\n      _this.setData( { splash: data });\r\n    }, null, () => {\r\n      toIndexPage.call(_this);\r\n    });\r\n}\r\n  \r\n/**\r\n * 跳转到首页\r\n */\r\nfunction toIndexPage() {\r\n  setTimeout( function() {\r\n    wx.redirectTo( {\r\n      url: 赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序开发之吐司toast(消息提示框) \n              精品教程《二》：微信小程序实战之小豆瓣图书 \n            \n             \n            \n                  原作者: oopsguy \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 精品教程《二》：微信小程序实战之小豆瓣图书\n                                    \n                  • Rebecca Han：微信小程序仿知乎Demo实战教程（适用1028版本）\n                                    \n                  • oopsguy精品教程《三》微信小程序之ES6与事项助手\n                                    \n                  • 推荐！微信小程序开发心得：首页制作，animation使用，动画详解 ... ... ...\n                                    \n                  • 从零开始一个微信小程序版知乎\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSJA4RV7', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序第三方框架对比 ( wepy / mpvue / ta2019-01-28微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30分享一款拥有历史搜索记录的微信小程序搜索2019-01-28小程序点睛之三：才不是你想的那种组件2019-01-28微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n微信小程序Demo:Canvas图片拖拽生成实现2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo：精美的画板小程序2019-02-21微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：仿 [one] 微信小程序2019-02-18微信小程序Demo：3D旋转效果2019-02-18微信小程序Demo: flappy-bird小游戏2019-02-15微信小程序Demo：群应用（群通知、群接龙、2019-02-15微信小程序Demo：咩咩单词2019-02-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163927|ade195ba736ba23fcd43a5c76d978040|2';"}
{"title": "精品教程《二》：微信小程序实战之小豆瓣图书 ", "author": "天下雪", "pub_time": "2016-10-21 16:35", "article_content": "最近微信小程序被炒得很火热，本人也抱着试一试的态度下载了微信web开发者工具，开发工具比较简洁，功能相对比较少，个性化设置也没有。了解完开发工具之后，顺便看了一下小程序的官方开发文档，大概了解了小程序的开发流程和一些常用的API。了解了小程序之后，自己就有了想要做一个小demo的冲动，虽然自己对小程序还没有做过很多实践，只是在官方例子上徘徊，但是还是想做出点小东西。既然要做一个demo，自然需要到数据，自己有又不想独自搭建服务端，所以在网上搜索可以用来提供测试数据的免费api，最后我选择了豆瓣图书。豆瓣图书提供的api功能比较少，加上不开放appkey申请，所以无法操作用户数据。只能做点简单的图书查询和图书详细信息展示，这个demo只有两个页面，非常之简单。豆瓣图书APIdemo中用到的豆瓣图书api只有两个，一个是图书搜索，另一个是获取图书详情。搜索图书赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              精品教程：微信小程序实战之知乎日报 \n              有渔微信小程序系统进阶《四》小程序组件 \n            \n             \n            \n                  原作者: oopsguy \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 精品教程：微信小程序实战之知乎日报\n                                    \n                  • oopsguy精品教程《三》微信小程序之ES6与事项助手\n                                    \n                  • 推荐！微信小程序开发心得：首页制作，animation使用，动画详解 ... ... ...\n                                    \n                  • 小程序之豆瓣电影源码解读\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSTYwoon', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序第三方框架对比 ( wepy / mpvue / ta2019-01-28微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30分享一款拥有历史搜索记录的微信小程序搜索2019-01-28小程序点睛之三：才不是你想的那种组件2019-01-28微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n微信小程序Demo:Canvas图片拖拽生成实现2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo：精美的画板小程序2019-02-21微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：仿 [one] 微信小程序2019-02-18微信小程序Demo：3D旋转效果2019-02-18微信小程序Demo: flappy-bird小游戏2019-02-15微信小程序Demo：群应用（群通知、群接龙、2019-02-15微信小程序Demo：咩咩单词2019-02-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163927|ade195ba736ba23fcd43a5c76d978040|2';"}
{"title": "微信小程序入门系列《四》：触控事件 ", "author": "天下雪", "pub_time": "2016-10-22 13:54", "article_content": "作者：疯狂的猫原文地址：http://www.cnblogs.com/nosqlcoco/p/5954453.html》》》什么是事件事件是视图层到逻辑层的通讯方式。事件可以将用户的行为反馈到逻辑层进行处理。事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。事件对象可以携带额外信息，如id, dataset, touches。》》》事件分类touchstart 手指触摸touchmove 手指触摸后移动touchcancel 手指触摸动作被打断，如弹窗和来电提醒touchend 手指触摸动作结束tap 手指触摸后离开longtap 手指触摸后后，超过350ms离开》》》事件绑定事件绑定的写法同组件的属性，以 key、value 的形式。key 以bind或catch开头，然后跟上事件的类型，如bindtap, catchtouchstartvalue 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。 bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。上面简单介绍了小程序事件基础，是时候彰显\"事件\"的威力：单击(tap)双击(dbtap)长按(longtap)滑动多点触控1.单击单击事件由touchstart、touchend组成,touchend后触发tap事件。<view>  <button type=\"primary\" bindtouchstart=\"mytouchstart\" bindtouchend=\"mytouchend\" bindtap=\"mytap\">点我吧</button></view>mytouchstart: function(e){    console.log(e.timeStamp + '- touch start')},mytouchend: function(e){        console.log(e.timeStamp + '- touch end')},mytap: function(e){        console.log(e.timeStamp + '- tap')}2.双击双击事件由两个单击事件组成，两次间隔时间小于300ms认为是双击；微信官方文档没有双击事件，需要开发者自己定义处理。<view>  <button type=\"primary\" bindtap=\"mytap\">点我吧</button></view> 3.长按长按事件手指触摸后，超过350ms再离开。<view>  <button type=\"primary\" bindtouchstart=\"mytouchstart\" bindlongtap=\"mylongtap\"     bindtouchend=\"mytouchend\" bindtap=\"mytap\">点我吧</button></view>mytouchstart: function(e){        console.log(e.timeStamp + '- touch start')},//长按事件mylongtap: function(e){        console.log(e.timeStamp + '- long tap')},mytouchend: function(e){        console.log(e.timeStamp + '- touch end')},mytap: function(e){        console.log(e.timeStamp + '- tap')}单击、双击、长按属于点触事件，会触发touchstart、touchend、tap事件，touchcancel事件只能在真机模拟，不多说了。事件触发顺序单击touchstart → touchend → tap双击touchstart → touchend → tap → touchstart → touchend → tap长按touchstart → longtap → touchend → tap4.滑动手指触摸屏幕并移动，为了简化起见，下面以水平滑动和垂直滑动为例。 滑动事件由touchstart、touchmove、touchend组成坐标图： 以屏幕左上角为原点建立直角坐标系。第四象限为手机屏幕，Y轴越往下坐标值越大（注意跟数学象限的区别）。假设A点为touchstart事件触摸点，坐标为A(ax,ay)，然后手指向上滑动到点B(bx,by)，就满足条件by < ay;同理，向右滑动到C(cx,cy),满足cx > ax；向下滑动到D(dx,dy),满足dy > ay；向左移动到E(ex，ey)满足ex < ax.计算线段AB在Y轴上投影长度为m,在X轴上的投影长度为n计算r = m/n,如果r > 1,视为向上滑动。同理计算线段AC,AD,AE在Y轴投影长度与X轴的投影长度之比，得出向右向下向左的滑动。以上没考虑r为1的情况。<view>  <button type=\"primary\"  bindtouchstart=\"mytouchstart\" bindtouchmove=\"mytouchmove\">点我吧</button></view>5.多点触控由于模拟器尚不支持多点触控，内测开放后，继续补充。"}
{"title": "微信小程序官方设计指南 ", "author": "天下雪", "pub_time": "2016-10-22 16:24", "article_content": "概要基于微信小程序轻快的特点，我们拟定了小程序界面设计指南和建议。 设计指南建立在充分尊重用户知情权与操作权的基础之上。旨在微信生态体系内，建立友好、高效、一致的用户体验，同时最大程度适应和支持不同需求，实现用户与小程序服务方的共赢。友好礼貌为了避免用户在微信中使用小程序服务时，注意力被周围复杂环境干扰，小程序在设计时应该注意减少无关的设计元素对用户目标的干扰，礼貌地向用户展示程序提供的服务，友好地引导用户进行操作。重点突出每个页面都应有明确的重点，以便于用户每进入一个新页面的时候都能快速地理解页面内容，在确定了重点的前提下，应尽量避免页面上出现其他干扰项影响用户的决策和操作。反例示意此页面的主题是查询，却添加了诸多与查询不相关的业务入口，与用户的预期不符，易造成用户的迷失。纠正示意去掉任何与用户目标不相关的内容，明确页面主题，在技术和页面控件允许的前提下提供有助于用户目标的帮助内容，比如最近搜索词，常用搜索词等。反例示意操作没有主次，让用户无从选择纠正示意首先要避免并列过多操作让用户选择，在不得不并列多个操作时，需区分操作主次，减轻用户的选择难度。流程明确为了让用户顺畅地使用页面，在用户进行某一个操作流程时，应避免出现用户目标流程之外的内容而打断用户。反例示意用户本打算进行搜索，在进入页面时却被突如其来的抽奖弹窗所打断；对于抽奖没有兴趣的用户是非常不友好的干扰； 而即便有部分用户确实被“诱人”的抽奖活动所吸引，离开主流程去抽奖之后可能就遗忘了原本的目标，进而失去了对产品真正价值的利用和认识。清晰明确一旦用户进入我们的小程序页面，我们就有责任和义务清晰明确地告知用户身在何处、又可以往何处去，确保用户在页面中游刃有余地穿梭而不迷路，这样才能为用户提供安全的愉悦的使用体验。导航明确，来去自如导航是确保用户在网页中浏览跳转时不迷路的最关键因素。导航需要告诉用户，我在哪，我可以去哪，如何回去等问题。首先在微信系统内的所有小程序的全部页面，均会自带微信提供的导航栏，统一解决我在哪，如何回去的问题。在微信层级导航保持体验一致，有助于用户在微信内形成统一的体验和交互认知，无需在各小程序和微信切换中新增学习成本或改变使用习惯。微信导航栏微信导航栏，直接继承于客户端，除导航栏颜色之外，开发者无需亦不可对其中的内容进行自定义。但开发者需要规定小程序各个页面的跳转关系，让导航系统能够以合理的方式工作。微信导航栏分为导航区域、标题区域以及操作区域。其中导航区控制程序页面进程。目前导航栏分深浅两种基本配色。导航区（iOS）导航区通常只有一个操作，即返回上一级界面。导航区（Android）同iOS一样，导航区也只有一个返回上一级页面的操作，而点击安卓手机自带的硬件返回键也起到相同作用。微信导航栏自定义颜色规则（iOS和Android）小程序导航栏支持基本的背景颜色自定义功能，选择的颜色需要在满足可用性前提下，和谐搭配微信提供的两套主导航栏图标。建议参考以下选色效果：选色方案示例页面内导航开发者可根据自身功能设计需要在页面内添加自有导航。并保持不同页面间导航一致。但是受限于手机屏幕尺寸的限制，小程序页面的导航应尽量简单，若仅为一般线性浏览的页面建议仅使用微信导航栏即可。开发者可选择小程序页面添加标签分页（Tab）导航。标签分页栏可固定在页面顶部或者底部，便于用户在不同的分页间做切换。标签数量不得少于2个，最多不得超过5个，为确保点击区域，建议标签数量不超过4项。一个页面也不应出现一组以上的标签分页栏。其中小程序首页可选择微信提供的原生底部标签分页样式，该样式仅供小程序首页使用。开发时可自定义图标样式、标签文案以及文案颜色等，具体设置项可参考开发文档。 顶部标签分页栏颜色可自定义。在自定义颜色选择中，务必注意保持分页栏标签的可用性、可视性和可操作性。 减少等待，反馈及时页面的过长时间的等待会引起用户的不良情绪，使用微信小程序项目提供的技术已能很大程度缩短等待时间。即便如此，当不可避免的出现了加载和等待的时候，需要予以及时的反馈以舒缓用户等待的不良情绪。启动页加载小程序启动页是小程序在微信内容一定程度上展现品牌特征的页面之一。本页面将突出展示小程序品牌特征和加载状态。启动页除品牌标志（Logo）展示外，页面上的其他所有元素如加载进度指示，均由微信统一提供且不能更改，无需开发者开发。页面下拉刷新加载在微信小程序内，微信提供标准的页面下拉刷新加载能力和样式。开发者可自定义需要通过下拉交互完成刷新的页面，此类交互微信将提供标准能力和样式。在样式上，刷新图标与下拉标示配色已捆绑，分为深浅两套方案，开发者在使用时，应注意头部文字、下拉标识与刷新图标的和谐统一。当用户在该类页面做出下拉交互时，出现微信小程序页面标准加载动画。开发者无需自行开发样式深浅两套下拉样式微信下拉提示用于给用户明确的小程序归属者，防止造假与作弊。此处标示提供深浅两套方案，文字颜色不可自定义，开发者在自定义背景色时，应注意保证下拉标示的辨识度。iOS和Android配色方案相同如下展示。微信下拉标示错误使用案例请避免以下错误使用情况，确保信息的可见性和页面的可用性页面内加载反馈开发者可在小程序里自定义页面内容的加载样式。建议不管是使用在局部还是全体，自定义加载样式都应该尽可能简洁，并使用简单动画告知用户加载过程。 开发者也可以使用微信提供的，统一的页面加载样式，如图中例所示。模态加载模态的加载样式将覆盖整个页面的，由于无法明确告知具体加载的位置或内容将可能引起用户的焦虑感，因此应谨慎使用。除了在某些全局性操作下不要使用模态的菊花。局部加载反馈即只在触发加载的页面局部进行反馈，这样的反馈机制更加有针对性，页面改动小，是微信推荐的反馈方式。例如：加载反馈注意事项若载入时间较长,应提供取消操作,并使用进度条显示载入的进度。载入过程中,应保持动画效果 ; 无动画效果的加载很容易让人产生该界面已经卡死的错觉。不要在同一个页面同时使用超过1个加载动画。结果反馈除了在用户等待的过程中需予以及时反馈外，对操作的结果也需要予以明确反馈。根据实际情况，可选择不同的结果反馈样式。对于页面局部的操作，可在操作区域予以直接反馈，对于页面级操作结果，可使用弹出式提示（Toast）、模态对话框或结果页面展示。页面局部操作结果反馈对于页面局部的操作，可在操作区域予以直接反馈，例如点击多选控件前后如下图。对于常用控件，微信设计中心将提供控件库，其中的控件将提供完整操作反馈。页面全局操作结果——弹出式提示（Toast）弹出式提示（Toast）适用于轻量级的成功提示，1.5秒后自动消失，并不打断流程，对用户影响较小，适用于不需要强调成功状态的操作提醒。特别注意该形式不适用于错误提醒。页面全局操作结果——模态对话框对于需要用户明确知晓的操作结果状态可通过模态对话框来提示，并可附带下一步操作指引。页面全局操作结果—结果页对于操作结果已经是当前流程的终结的情况，可使用操作结果页来反馈。这种方式最为强烈和明确的告知用户操作已经完成，并可根据实际情况给出下一步操作的指引。异常可控，有路可退在设计任何的任务和流程时，异常状态和流程往往容易被忽略，而这些异常场景往往是用户最为沮丧和需要帮助的时候，因此需要格外注意异常状态的设计，在出现异常时予以用户必要的状态提示，并告知解决方案，使其有路可退。要杜绝异常状态下，用户莫名其妙又无处可去，卡在某一个页面的情况。2.2中所提到的弹窗和结果页面都可作为异常状态的提醒方式。除此之外，在表单页面中尤其是表单项较多的页面中，还应明确指出出错项目，以便用户修改。异常状态——表单出错表单报错，在表单顶部告知错误原因，并标识出错误字段提示用户修改便捷优雅从PC时代的物理键盘鼠标到移动端时代手指，虽然输入设备极大精简，但是手指操作的准确性却大大不如键盘鼠标精确。为了适应这个变化，需要开发者在设计过程中充分利用手机特性，让用户便捷优雅的操控界面。减少输入由于手机键盘区域小且密集，输入困难的同时还易引起输入错误，因此在设计小程序页面时因尽量减少用户输入，利用现有接口或其他一些易于操作的选择控件来改善用户输入的体验。减少输入，巧用接口例如下图中，在添加银行卡时，采用摄像头识别接口来帮助用户输入。除此之外微信团队还对外开放例如地理位置接口等多种微信小程序接口 ，充分利用这些接口将大大提高用户输入的效率和准确性，进而优化体验。除了利用接口外，在不得不让用户进行手动输入时，应尽量让用户做选择而不是键盘输入。一方面，回忆易于记忆，让用户在有限的选项中做选择通常来说是容易于完全靠记忆输入；另一方面，仍然是考虑到手机键盘密集的单键输入极易造成输入错误。 例如图中，在用户搜索时提供搜索历史快捷选项将帮助用户快速进行搜索，而减少或避免不必要是键盘输入。避免误操作因为在手机上我们通过手指触摸屏幕来操控界面，手指的点击精确度远不如鼠标，因此在设计页面上需点击的控件时，需要充分考虑到其热区面积，避免由于可点击区域过小或过于密集而造成误操作。当简单的将原本在电脑屏幕上使用的界面不做任何适配直接移植到手机上时，往往就容易出现这样的问题。由于手机屏幕分辨率各不相同，因此最适宜点击像素尺寸也不完全一致，但换算成物理尺寸后大致是在7mm-9mm之间。在微信提供的标准组件库中，各种控件元素均已考虑到了页面点击效果以及不同屏幕的适配，因此再次推荐使用或模仿标准控件尺寸进行设计。利用接口提升性能微信设计中心已推出了一套网页标准控件库，包括sketch设计控件库和Photoshop设计控件库，后续还将完善小程序组件，这些控件都已充分考虑了移动端页面的特点，能够保证其在移动端页面上的可用性和操作性能；同时微信开发团队也在不断完善和扩充微信小程序接口，并提供微信公共库，利用这些资源不但能够为用户提供更加快捷的服务，而且对页面性能的提高有极大作用，无形之中提升了用户体验。统一稳定除了以上所提到的种种原则，建议接入微信的小程序还应该时刻注意不同页面间的统一性和延续性，在不同的页面尽量使用一致的控件和交互方式。统一的页面体验和有延续性的界面元素都将帮助用最少的学习成本达成使用目标，减轻页面跳动所造成的不适感。正因如此，小程序可根据需要使用微信提供的标准控件，以达到统一稳定的目的。视觉规范为方便设计师进行设计，微信提供一套可供Web设计和小程序使用的基础控件库；同时提供方便开发者调用的资源。字体规范微信内字体的使用与所运行的系统字体保持一致，常用字号为20, 18, 17, 16,14 13, 11(pt)，使用场景具体如下：字体颜色主内容 Black 黑色，次要内容 Grey 灰色；时间戳与表单缺省值 Light 灰色；大段的说明内容而且属于主要内容用 Semi 黑；蓝色为链接用色，绿色为完成字样色，红色为出错用色 Press与 Disable状态分别降低透明度为20%与10%；列表视觉规范表单输入视觉规范按钮使用原则列表外按钮上文字标准按钮高度为44px下使用: 颜色 ＃000000 / ＃353535 字号 18pt可点状态下文字调整透明度为60%不可点状态下文字调整透明度为30%列表外按钮上文字标准按钮高度为25px下使用: 颜色 ＃000000 / ＃353535 字号 14pt页面线性按钮上文字标准按钮高度为35px下使用: 颜色 ＃09BB07 / ＃353535 字号 16pt图标使用原则"}
{"title": "微信小程序的原型设计尝鲜 ", "author": "天下雪", "pub_time": "2016-10-23 11:47", "article_content": "\"小程序”来了，大世界要变了？微信小程序可能是近期业绩最火的话题之一了。这个根植于微信流量巨无霸的应用，将对应用市场、对微商、电商、对企业的开发成本、获客成本将产生深远影响？将制造出绕开Google Play和AppStore的另一大App体系？将实现“知人性”的PM张小龙先生的“用后即走”的轻量App之梦？将秒杀传统的App？虽有海量追捧者趋之若鹜，但也有冷静人士淡定的白眼。但无论如何，腾讯这步棋子既然落在了棋盘上，绝不能悔棋，更不可能半途而废，你我这样神经敏感的PM、UX，不尝鲜是不可能的。说动就动，查找到微信小程序的设计规范后，让我们开始吧。造大梦的事儿还是让大佬们去干吧，咱们干点实在的。干活儿首先得挑个工具，我这里使用了Mockplus，近期国内的一款比较流行的原型设计。比较顺手，线框、交互都能胜任。首先尝试做WeUI的界面元素吧。经过一会儿的折腾，搞成了一套（好在WeUI的界面元素比不是太多）。有了这个，之后就方便了。在提示和上传页面中，我使用了交互，点击“成功提示”按钮，弹出提示。点击“上传”按钮，完成进度条的走动。操作很简单：在Mockplus中选中按钮，直接拖拽到准备弹出的提示框上，设置“显示/隐藏”，并在消失时做了延迟处理。提示框的默认显示状态，设为“不可见”。至于进度条的走动，是设置每个进度轨道的“调整尺寸”的交互（设置宽度变化），多拖拽几次鼠标，设置链接就好了，如图：好了，让我们来看看效果。点这里看我的成果：http://run.mockplus.cn/Tnr9w9TyUKjXeDeR/index.html这个尝试到此暂时结束，页面不多，算是个半成品。但在制作时，我边做边琢磨微信在设计中的一些理念：简约、准确、易用。这个伟大的产品之所以在国内能够深入人心，还是有些道理的。"}
{"title": "微信小程序开发系列分析《四》模块化 ", "author": "天下雪", "pub_time": "2016-11-2 17:12", "article_content": "作者：jsong原文地址（已获授权）作者微信公众号：半圆生活，欢迎关注1、模块化标准玩前端的同学大部分都知道模块化的几个标准，CommonJs / AMD / CMD。这里花费一些篇幅简单的介绍一下，比较熟悉的同学可以跳过这一部分的介绍。（1）CommonJs CommonJs主要用于服务器端的一些简单的模块引用，如nodejs：fs=require('fs');对它来说，一个单独的文件就是一个模块，一个文件定义一个作用域，变量在文件内部都是私有的。CommonJs采用了同步加载的方式，把文件加载下来才会执行后面的代码，由于在服务端，文件一般在某个目录下，加载不需要网络，所以这种方式不用考虑网络的成本。下面讲到的AMD和CMD，主要用在浏览器端。（2）AMDAsynchronous Module Definition，异步模块定义，requireJs是最典型的例子。这也是国外目前比较流行的模块化标准。AMD把一个文件（模块）里需要用到的其它模块，定义在头部刚开始的地方，以告诉浏览器，加载这个模块所需要的其它的依赖，这就把依赖前置并执行。（3）CMDCommon Module Definition，通用模块加载规范，seaJs是典型的代码，一开始是由淘宝的玉伯开发。与AMD相反的是，它不会前置去执行当前模块所有的依赖，而是在需要的地方才去引入。关于AMD与CMD之争由来已久，本文不讨论他们的优劣。还有一个最新的标准，UMD，它想统一几种模块化规范，有兴趣的读者可以去网上了解。2、微信小程序的模块化wxml、wxss、js，这三类都可以做模块化。（1）js的模块化首先先要了解一点，每个js里定义的变量、函数，只在当前的文件里有效，也就是说每个js文件的作用域只在文件内部。MINA框架其实也做了挺多模块化的封装和合并等工作，开发的时候，我们可以不用在意自己在用的是什么样的标准，最后怎么被合并，也不用去考虑网络问题，因为MINA也帮我们打好包了，按照微信小程序官方文档给出的例子来使用就行，其它的工作它都帮我们做好了。js的模块引用语法如下：//  a.jsvar xxx = require('xxx.js')导出的语法，在每个文件里定义// b.jsfunction yyy() {    // ...}module.exports = {  yyy: yyy}这样，在a.js文件里，就可以用xxx.yyy来调用到b.js里定义的方法。这个看起来很简单，不过我们要关注的是怎么去做模块化，而不是这个语法本身。（2）wxml的模块化wxml代码里也可以根据界面上不同的部分去分块。从主wxml文件里分出来的文件，可以写成一个模板template。如何定义一个模板？语法很简单<template name=\"myTpl\">...</template>使用：<template is=\"myTpl\" data=\"\"/>讲到模块化，这里我们就需要把template的定义分开，放到另外的wxml文件里，作为另一个wxml文件。在使用的时候，用import来引入。假设我们的模板写在一个单独的文件item.wxml里，要在主页面中引入：<import src=\"item.wxml\"/><template is=\"myTpl\" data=\"\"/>这样就可以把独立的UI模块给拆分出来。上面传入data的时候，注意要用…三个点把data这个object平铺开，这个是微信文档中给的规定，读者可以测试下，后面在使用的时候多注意。另外，微信还提供了一个include操作。跟import的区别是，import是把相应的一个文件里定义的模板引入进来，让主wxml文件可以用这个模板。而include是直接把相关文件的源码、内容，原封不动的导入进来。微信的官方说明在这里。使用上，读者可以这样简单地来区分：用模板时，用import引入模板的定义；不用模板时，用include直接把文件内容导入进来。前者(import)可以理解为c语法里的引入头文件；后者可以理解为nginx里的ssi，帮你把一个大文件切分成多个内容块，放到几个小文件里。给了一个非常简单的import和include的演示代码在这里。（3）wxss的模块化wxss也支持模块化，用@import来导入其它wxss文件到主wxss文件中。这个用法跟sass或less一样，后面记得加分号：@import base.wxss3、模块化的几个小建议对于微信小程序的开发，如果项目大了，代码自然就多，分的文件可能也会比较多，这里提几点建议。[1]. js共用的模块抽出来，放到一个文件夹里，取名如common，里面可以再按功能去分更细的模块，如网络请求模块common/net.js，工具方法集common/util.js，websocket相关模块，等等。[2]. 把共用的页面头部、底部，放到page/common/ 里面，记得把js和wxml也放在一起。[3]. 引用外部的库的话，把它们的文件统一放到 lib/ 目录里。[4]. 之前文章提到的页面和文件的目录划分，也不用去改。如page/ 目录专门存放页面，一对名字（xxx.wxml和xxx.js）就对应一个页面，如果只是页面的一部分，可以放到page/[page_name]/ 目录里，表示这个页面专门用的模块，但如果是几个页面共享的，可以放在上面第2点提到的page/common/ 里[5]. 模板放tpl/ 目录里，并按页面来分文件夹放。[6]. 相关的event handler如果逻辑比较多，可以单独抽出来放到一个文件里。4、组件MINA框架给我们提供了很多小组件，它们是视图层的基本组成单元，功能相对比较独立，而且组件风格跟微信保持得比较一致，各自有各自的特有的属性，当然也可以自定义属性（如data-xxx）。这里有所有组件的介绍。后面有一个文章专门介绍几个常用的组件，本文就简单提一下组件。"}
{"title": "微信小程序注册成功后页面抢先看，绑定公众号，模板消息库，内页及身份页 ... ", "author": "天下雪", "pub_time": "2016-11-4 10:47", "article_content": "微信小程序联盟第一时间申请成功，并且将大量截图整体截图，给大家体验！微信公众平台绑定开发者微信公众平台绑定开发者成功微信公众平台绑定选择开发者微信公众平台开发管理页面微信公众平台模板消息库1微信公众平台模板消息库2微信公众平台模板消息库3微信公众平台小程序内页微信公众平台用户身份页面"}
{"title": "杨小事：微信小程序实战（一）：实现登录界面 ", "author": "天下雪", "pub_time": "2016-11-5 16:32", "article_content": "昨天小程序第一天公测，就下载个小程序自带IDE玩了玩，看了看API，撸出了个登录界面给大家分享下。下面是主界面和代码。index.wxml<view class=\"container\">    <view class=\"usermotto\">      <text class=\"user-motto\">{{motto}}</text>      用户名：      <input type=\"text\" bindinput=\"userNameInput\"/>      密码：      <input type=\"text\" bindinput=\"userPasswordInput\" password=\"true\"/>      <button bindtap=\"logIn\">登录</button>    </view>  </view>  index.jsvar app = getApp()  Page({    data: {      motto: '欢迎登录WXapp',      userName:'',      userPassword:'',      id_token:'',//方便存在本地的locakStorage      response:'' //存取返回数据    },    userNameInput:function(e){      this.setData({        userName: e.detail.value      })    },    userPasswordInput:function(e){      this.setData({        userPassword: e.detail.value      })      console.log(e.detail.value)    },    logIn:function(){      var that = this      wx.request({        url: 'http://localhost:8000/admin',        data: {          username: this.data.userName,          password: this.data.userPassword,        },        method: 'GET',        success: function (res) {          that.setData({            id_token: res.data.id_token,            response:res          })          try {            wx.setStorageSync('id_token', res.data.id_token)          } catch (e) {          }          wx.navigateTo({            url: '../components/welcome/welcome'          })          console.log(res.data);        },        fail: function (res) {          console.log(res.data);          console.log('is failed')        }      })    }  })  源码都放在这里了，https://github.com/Yangzhedi/myBlog-wxapp，欢迎star，issue呦~代码就是以上那些，个人感觉小程序和react真的很像，不亏于小程序源码中imoort react的这一句。所以有react基础的会更好上手小程序的吧~js文件里Page里的data就类似与React中的state的机制，之后在js文件中想要调用data里的数据就必须才才用this.data.XXX;但是在wxml中想要绑定data里的数据，就才用双括号的方法，而且！不需要！this.data。直接就是{{XXX}}。在回到代码里看，wxml中主要就是两个input框和一个button。通过小程序input的原生API - bindInput （文档：小程序input），就可以获取input的值，然后在data里定义两个(userName和userPassword)来存取这两个input的输入值。再通过button的 bindTap绑定js文件中的logIn函数。（文档：小程序button）在logIn函数中，就通过this.data.userName和this.data.userPassword来获取曾经输入的两个值。在通过调用微信的发送请求API，把两个值放在请求中，这就有点像ajax发送请求了。再在success中写下成功之后想要做的事情，比如这个例子里，就跳转到welcom页面。项目下载：myBlog-wxapp-master.zip"}
{"title": "秀杰实战教程系列《十二》：基于LeanCloud实现访问网络与数据存储 ... ", "author": "天下雪", "pub_time": "2016-11-1 11:42", "article_content": "目标使用LeanCloud JS_SDK读取电商系统的商品分类准备在https://www.leancloud.cn上注册帐号，创建仓库，建Category表，建title字段无限级分类建表结构建立字段parent，类型为Pointer，指向Category对象下载JS_SDKhttps://unpkg.com/leancloud-storage@2.0.0-beta.2/dist/av-weapp.js文档出处：https://leancloud.cn/docs/weapp.html安装将上面的js文件保存此util目录使用在category.js中引入const AV = require('../../utils/av-weapp.js')连接数据仓库，取查询所有分类Page({\r\n    onLoad: function(){\r\n        AV.init({ \r\n        appId: \"SgHcsYqoLaFTG0XDMD3Gtm0I-gzGzoHsz\", \r\n        appKey: \"xdv2nwjUK5waNglFoFXkQcxP\",\r\n        });\r\n        var query = new AV.Query('Category');\r\n        query.find().then(function (categories) {\r\n            for (var i = 0; i < categories.length; i++) {\r\n                var category = categories[i];\r\n                console.log(category.attributes.title);\r\n            }\r\n        }).catch(function(error) {\r\n            alert(JSON.stringify(error));\r\n        });\r\n    }\r\n})\r\n这时控件台可以看到输出category所有分类潮流女装 连衣裙 针织开衫 羽绒服 时尚T恤 家用电器 电视 空调条件查询获得顶级分类query.equalTo('parent',null);\r\n这时控件台可以看到输出category顶级分类潮流女装 家用电器Pointer方式查询二级分类        // 查询父级分类下的所有子类\r\n        var parent = AV.Object.createWithoutData('Category', '581415bf2e958a005492150b');\r\n        query.equalTo('parent',parent);\r\n这时控件台可以看到输出category潮流女装分类下的所有子类连衣裙\r\n针织开衫\r\n羽绒服\r\n时尚T恤\r\n配合布局与js文件，实现分类页面wxml:<view class=\"container\">\r\n    <!-- 侧边栏 -->\r\n    赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              一斤代码深入理解系列《四》：微信小程序和服务器通信-WebSocket ... ... \n              丛九九微信小程序demo实战教程：Bilibili排行榜 \n            \n             \n            \n                  原作者: 黄秀杰 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 秀杰实战教程系列《一》：记账应用开发\n                                    \n                  • 秀杰实战教程系列《二》：微信小程序绘图课程之饼图\n                                    \n                  • 秀杰实战教程系列《三》：下拉筛选菜单WXDropDownMenu组件\n                                    \n                  • 秀杰实战教程系列《四》：倒计时组件，LXStepper组件-商品数量加减 ...\n                                    \n                  • 秀杰实战教程系列《五》：实战课程之记账应用开发（续）\n                                    \n                  • 秀杰实战教程系列《六》：服务端之用户注册与登录基于ThinkPHP5描述 ...\n                                    \n                  • 秀杰实战教程系列《七》：实现购物车页面\n                                    \n                  • 秀杰实战教程系列《八》：记账应用实战服务端之用户注册与登录基于Codeigniter3描述 ...\n                                    \n                  • 秀杰实战教程系列《九》：应用实例教程服务端登录篇\n                                    \n                  • 秀杰实战教程系列《十》：服务端实现账目CRUD\n                                    \n                  • 秀杰实战教程系列《十一》：对接服务端账目CRUD\n                                    \n                  • leancloud：SDK 跨平台支持常见问题及解决方案实践\n                                    \n                  • 微信小程序取值传值方式小结\n                                    \n                  • Charlotte微信小程序开发（一）--数据存储\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSNBJ0cs', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序第三方框架对比 ( wepy / mpvue / ta2019-01-28微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30分享一款拥有历史搜索记录的微信小程序搜索2019-01-28小程序点睛之三：才不是你想的那种组件2019-01-28微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n微信小程序Demo:Canvas图片拖拽生成实现2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo：精美的画板小程序2019-02-21微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：仿 [one] 微信小程序2019-02-18微信小程序Demo：3D旋转效果2019-02-18微信小程序Demo: flappy-bird小游戏2019-02-15微信小程序Demo：群应用（群通知、群接龙、2019-02-15微信小程序Demo：咩咩单词2019-02-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163938|9f7c34010c58379ef0785be74d2a50d4|2';"}
{"title": "Acmen、L学习案例集锦《一》生命周期，组件 ", "author": "天下雪", "pub_time": "2016-11-1 11:56", "article_content": "一：生命周期在app.js的app()中注册程序  在页面.js中的Page({})中注册页面。  执行效果：  二：组件1.view把文档分割为独立的、不同的部分。view组件类似于html中的div标签，默认为块级元素，独占一行，可以通过设置display:inline-block改为行级元素。view.wxml代码如下：<view class=\"outerView\">\r\n    <view class=\"innerView1\"></view>\r\n    <view class=\"innerView2\"></view>\r\n    <view class=\"innerView3\"></view>\r\n<view>view.wxss代码如下.outerView{\r\n    width:100%;height: 100px;margin: 0 auto;background-color: brown; \r\n}\r\n.innerView1{\r\n    width: 40%;height: 40px;background: blue;display: inline-block;\r\n}\r\n.innerView2{\r\n    width: 40%;height: 40px;background: yellow;display: inline-block;\r\n}\r\n.innerView3{\r\n    width: 40%;height: 40px;background: peru;\r\n}显示效果：2.scroll-view可滚动（点击滑动）视图区域。官方给出的属性列： scroll-view.wxml代码如下：<view class=\"section\">\r\n    <scroll-view scroll-y=\"true\" style=\"height: 200px;\" bindscrolltoupper=\"upper\"\r\n     bindscrolltolower=\"lower\" bindscroll=\"scroll\" lower-threshold=\"50\"  scroll-into-view=\"{{toView}}\"\r\n      scroll-top=\"1000px\">\r\n        <view id=\"green\" class=\"scroll-view-item bc_green\" style=\"width:100px;height:100px;background:red\"></view>\r\n        <view id=\"red\"  class=\"scroll-view-item bc_red\" style=\"width:100px;height:100px;background:blue\"></view>\r\n        <view id=\"yellow\" class=\"scroll-view-item bc_yellow\" style=\"width:100px;height:100px;background:yellow\"></view>\r\n    </scroll-view>\r\n</view>\r\n<view class=\"section section_gap\">\r\n    <scroll-view class=\"scroll-view_H\" scroll-x=\"true\" style=\" white-space: nowrap\" >\r\n        <view id=\"green\" style=\"width:400px;height:100px;background:red;display: inline-block\"></view>\r\n        <view id=\"red\"  style=\"width:400px;height:100px;background:blue;display: inline-block\"></view>\r\n    </scroll-view>\r\n</view>scroll-view.js代码如下：Page({\r\n  data: {\r\n    toView: \"red\",//设置初始滑动区顶部显示的view，可通过this.setdata({toView:\"blue\"})来改变\r\n    scrollTop: 10,\r\n    threshold:0\r\n  },\r\n  upper: function(e) {\r\n    console.log(\"到达顶部\")\r\n  },\r\n  lower: function(e) {\r\n    console.log(\"到达底部\")\r\n  },\r\n  scroll: function(e) {\r\n    console.log(\"一次滑动结束\")\r\n  }\r\n})运行效果： 3.swiper滑动面板，定时滑动切换图片或手动滑动切换图片。swiper.wxml<!--indicator-dots是否显示圆点，autoplay自动播放，current初始显示的item（0代表第一个item）, duration滑动速度， bindchange监听滚动和点击事件，interval滑动间隔时间-->\r\n<swiper indicator-dots=\"true\" autoplay=\"true\" current=\"1\" duration=\"1000\" bindchange=\"listenSwiper\" interval=\"2000\">\r\n<!--swiper-item只能包含一个节点再多会自动删除-->\r\n   \r\n    <swiper-item>\r\n        <view style=\"height: 150px\"><image src=\"../../pic/pic2.png\" style=\"width:100%;height:100%\"/></view>\r\n    </swiper-item>\r\n    <swiper-item>\r\n         <view style=\"height: 150px\"><image src=\"../../pic/pic1.png\" style=\"width:100%;height:100%;\"/>\r\n         </view>\r\n    </swiper-item>\r\n     <swiper-item>\r\n          <view style=\"height: 150px\"><image src=\"../../pic/pic3.png\"  style=\"width:100%;height:100%;\"/>\r\n          </view>\r\n    </swiper-item> \r\n</swiper>运行效果：4.icon，text，progress，checkbox，input，readio-group，slider，switch<!-- type=[ 'success', 'info', 'warn', 'waiting', 'safe_success', 'safe_warn',\r\n'success_circle', 'success_no_circle', 'waiting_circle', 'circle', 'download',\r\n'info_circle', 'cancel', 'search', 'clear'] -->\r\n<icon type=\"success\" size=\"23\" color=\"red\"/>\r\n<view><text>可以长按选中</text></view>\r\n<!-- percent:百分比，active:是否显示从左往右的动画（但是经过测试无论设置为true还是false动画都会显示，去掉该属性则不显示动画），showInfo：是否显示百分比，strokeWidth：进度条宽度 -->\r\n<progress percent=\"100\" active=\"false\" showInfo=\"true\" strokeWidth=\"7\" />\r\n<!-- type：[primary, default, warn],size:[default,mini],loading:按钮前是否带loading图标,plain:按钮是否镂空，disabled：是否生效，formType:[submit,reset],hover-class:按下时的样式类名 -->\r\n<button type=\"warn\" size=\"mini\" loading=\"true\" plain=\"true\" disabled=\"true\" bindtap=\"default\" formType=\"reset\" hover-class=\"none\"> default </button>\r\n<!-- disabled:不可选中，value：当value改变时触发bindchange绑定的函数 -->\r\n<checkbox-group bindchange=\"checkboxChange\">\r\n    <label class=\"checkbox\" wx:for-items=\"{{[1,2,3,4,5]}}\">\r\n        <checkbox value=\"{{item}}\" checked='false' disabled=\"true\"/>{{item}}\r\n    </label>\r\n</checkbox-group>\r\n\r\n<input placeholder=\"禁用了的input\" value=\"禁用了的input\" type=\"text\" auto-focus/>\r\n\r\n<radio-group bindchange=\"test\">\r\n    <label class=\"radio\" wx:for-items=\"{{[1,2,3,4]}}\">\r\n        <radio value=\"{{item}}\" checked=\"true\"/>{{item}}\r\n    </label>\r\n</radio-group>\r\n\r\n<!-- disabled:禁用无法滑动，step:步长如果设置为2则显示value为50 52 54...\r\n     show-value:是否显示当前值\r\n -->\r\n<slider bindchange=\"test\" min=\"50\" max=\"200\" show-value step=\"2\"/>\r\n\r\n<!-- type:[checkbox,switch]两种样式，disabled,checked -->\r\n<switch checked=\"true\" bindchange=\"test\" type=\"checkbox\"/>\r\n<switch checked=\"true\" bindchange=\"test\" type=\"switch\"/>"}
{"title": "Acmen、L学习案例集锦《二》弹框组件modal，底部菜单action-sheet ", "author": "天下雪", "pub_time": "2016-11-1 12:00", "article_content": "一：弹框组件modalmodalmodal类似于javascript中的confirm弹框，默认情况下是一个带有确认取消的弹框，不过点击取消后弹框不会自动隐藏，需要通过触发事件调用函数来控制hidden属性。官方文档.wxml<modal hidden=\"{{hidden}}\" title=\"这里是title\" confirm-text=\"自定义确定按钮\" cancel-text=\"自定义取消按钮\" bindcancel=\"cancel\" bindconfirm=\"confirm\" no-cancel=\"{{nocancel}}\">\r\n    这是对话框的内容。\r\n</modal>.jsPage({\r\n    data:{\r\n        hidden:false,\r\n        nocancel:false\r\n    },\r\n    cancel: function(){\r\n        this.setData({\r\n             hidden: true\r\n        });\r\n    },\r\n    confirm: function(){\r\n        this.setData({\r\n             nocancel: !this.data.nocancel\r\n        });    \r\n        console.log(\"clicked confirm\");\r\n    }\r\n})        运行效果二：底部菜单action-sheetaction-sheetaction-sheet是从底部弹出的选择菜单，子菜单通过action-sheet-item和action-sheet-cancel指定，action-sheet-item是菜单项，action-sheet-cancel顾名思义是取消隐藏菜单，我们可以通过为action-sheet-item添加bindtap来触发点击后作出的相应，点击action-sheet-cancel时会触发action-sheet的bindchange事件。可以在bindchange绑定的函数中控制菜单的显示。另外点击空白处时菜单也会隐藏。官方文档  .wxml<button type=\"default\" bindtap=\"actionSheetTap\">弹出action sheet</button>\r\n<action-sheet hidden=\"{{actionSheetHidden}}\" bindchange=\"actionSheetChange\">\r\n    <block wx:for-items=\"{{actionSheetItems}}\">\r\n        <action-sheet-item  bindtap=\"bind{{item}}\">{{item}}</action-sheet-item>\r\n    </block>\r\n    <action-sheet-cancel >取消</action-sheet-cancel>\r\n</action-sheet>.jsvar items = ['item1', 'item2', 'item3', 'item4']\r\nvar pageObject = {\r\n  data: {\r\n    actionSheetHidden: true,\r\n    actionSheetItems: items\r\n  },\r\n  actionSheetTap: function(e) {\r\n    console.log(this);\r\n    this.setData({\r\n      actionSheetHidden: !this.data.actionSheetHidden\r\n    })\r\n  },\r\n  actionSheetChange: function(e) {\r\n    this.setData({\r\n      actionSheetHidden: !this.data.actionSheetHidden\r\n    });\r\n    console.log(\"点击ation-sheet-cancel，会触发action-sheet绑定的事件。在这里可以通过改变hidden控制菜单的隐藏\");\r\n  }\r\n}\r\n\r\nfor (var i = 0; i < items.length; ++i) {\r\n  (function(itemName) {\r\n    pageObject['bind' + itemName] = function(e) {\r\n      console.log('click' + itemName, e)\r\n    }\r\n  })(items[i])\r\n}\r\n\r\nPage(pageObject)运行效果如何让点击空白处时不隐藏图片呢？另外点击取消的时候自动隐藏菜单不就算了，非要自己写一句话让它隐藏，真麻烦。"}
{"title": "Acmen、L学习案例集锦《三》加载中提示框loading，消息提示框toast，navigator页面跳 ... ", "author": "天下雪", "pub_time": "2016-11-1 12:05", "article_content": "一：加载中提示框loadingloadingloading只有一个属性hidden.wxml<view>\r\n    <loading hidden=\"{{hidden}}\">\r\n        加载中...\r\n    </loading>\r\n    <button bindtap=\"changeHidden\">show/hidden</button>\r\n</view>.jsPage({\r\n    data:{\r\n        hidden:true\r\n    },\r\n    changeHidden: function(){\r\n        this.setData({\r\n            hidden: !this.data.hidden\r\n        });\r\n    }\r\n})        效果当弹框出现后，点击除弹框外不可相应，所以再次点击button并不能隐藏弹框。二：消息提示框toasttoasttoast为消息提示框，无按钮，如需关闭弹框可以添加事件设置hidden为true，在弹框显示后经过duration指定的时间后触发bindchange绑定的函数。官方文档.wxml<view>\r\n     <toast hidden=\"{{hidden}}\" duration=\"2500\" bindchange=\"open\" bindtap=\"close\">\r\n        内容\r\n    </toast>\r\n</view>.jsPage({\r\n    data:{\r\n        hidden:false\r\n    },\r\n    open: function(){\r\n        console.log(\"延时调用\");\r\n    },\r\n    close: function(){\r\n        this.setData({\r\n            hidden:true\r\n    });\r\n        console.log(\"关闭弹框\");\r\n    }\r\n})效果三：navigator页面跳转navigatornavigator跳转页面样式分为两种一种是左上角带返回按钮跳转到新的页面，另一种不带即在本页跳转，通过控制redirect属性.js<view>\r\n    <navigator url=\"../other/other\" hover-class=\"changestyle\">页面跳转，可以返回</navigator>\r\n</view>\r\n<view>\r\n    <navigator url=\"../other/other\" hover-class=\"changestyle\" redirect>页面跳转，无法返回</navigator>\r\n</view>wxss.changestyle{\r\n    color: red;\r\n}效果"}
{"title": "丛九九微信小程序demo实战教程：Bilibili排行榜 ", "author": "天下雪", "pub_time": "2016-11-1 13:06", "article_content": "最近微信小程序很火，于是趁机学了一下。然后做了个小的demo，实现了查看B站排行榜的功能。项目地址 https://github.com/congjiujiu/bilibiliRank由于没有appid，所以没法在微信里面预览。可以clone到本地然后在微信web开发工具里面看到项目。git clone https://github.com/congjiujiu/bilibiliRank.git yourappnamecd yourappname在微信web开发工具里面新建项目，地址选到刚clone的地址即可查看了。效果gif可以看 github 的演示！建立项目先创建初始页面，也就是两部分，顶上图片，以及下方列表。用你喜爱的编辑器打开 pages/index/index.js，编辑一下//index.js//获取应用实例var app = getApp()Page({  data: {    bili: {      list: [        {          id: 0,          name: '全区排行榜'        },        {          id: 1,          name: '番剧排行榜'        },         {          id: 2,          name: '原创视频排行榜'        }    ]}  },  onLoad: function () {    console.log('onLoad');  }})表明有三个列表项，然后就可以在index.wxml里面获得数据了<!--index.wxml--><view class=\"container\">\t<view class=\"header\"></view>\t<view class=\"content\">\t\t<view class=\"cmds\">\t\t\t<navigator wx:for=\"{{bili.list}}\" url=\"../ranklist/ranklist?id={{item.id}}\">\t\t\t\t<view class=\"cmd-list\" data-id=\"{{item.id}}\">{{item.name}}</view>\t\t\t</navigator>\t\t</view>\t</view></view>如上，一个header，通过设置background-image来设置头图，下方通过wx:for方法来循环生成一个列表。navigator标签，可以在点击的时候跳转到url指定的组件内。类似于原生的a标签。然后设置一下css，在app.wxss内：/**app.wxss**/.container {\tmargin: 0;\tpadding: 0;\tfont-family: \"Microsoft YaHei\", Monaco;\theight: 100%;} .header {\theight: 140px;\twidth: 100%;\tbackground-image: url(images/logo.jpg);\tbackground-size: 赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              秀杰实战教程系列《十二》：基于LeanCloud实现访问网络与数据存储 ... \n              Belinda的小程序踩坑记《一》 \n            \n             \n            \n                  原作者: 丛九九 \n                  来自: 原文地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小游戏好友排行榜快速开发教程\n                                    \n                  • 解决微信小游戏排行榜 Android 模糊问题\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSHcp0bv', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序第三方框架对比 ( wepy / mpvue / ta2019-01-28微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30分享一款拥有历史搜索记录的微信小程序搜索2019-01-28小程序点睛之三：才不是你想的那种组件2019-01-28微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n微信小程序Demo:Canvas图片拖拽生成实现2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo：精美的画板小程序2019-02-21微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：仿 [one] 微信小程序2019-02-18微信小程序Demo：3D旋转效果2019-02-18微信小程序Demo: flappy-bird小游戏2019-02-15微信小程序Demo：群应用（群通知、群接龙、2019-02-15微信小程序Demo：咩咩单词2019-02-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163943|ed57579f0f71d614de31828f0fd8d43c|2';"}
{"title": "徐德明：微信小程序浅析 ", "author": "天下雪", "pub_time": "2016-11-1 23:23", "article_content": "目录微信小程序是什么？微信小程序与公众号有什么区别？微信小程序的语法？项目结构页面管理基础组件丰富的API项目运行过程开发者工具（IDE）DEMO目前遇到的问题微信小程序是什么？微信小程序是一种不需要下载安装即可使用的应用，它实现了应用「触手可及」的梦想，用户扫一扫或搜一下即可打开应用。目前是内测阶段，而且采用的是邀请制的方式，据说只有200个。https://mp.weixin.qq.com/debug/wxadoc/dev/?t=1477656487237微信小程序与公众号有什么区别？在没有网络连接的情况下，微信公众号的功能无法使用，但微信小程序而言，只要小程序本身无需联网的工作，它能够在离线的情况下发挥作用。服务号与在微信中加载一般网页相比，小程序的加载十分快捷，会给用户一种使用流畅的感觉。而公众号里无论是访问图文消息，还是打开第三方开发的网页，相比起小程序而言，都会慢许多。微信为小程序提供了更强的绘图能力、丰富的界面控件和更全的操作反馈，这一切使得微信小程序会拥有更好的显示效果和交互能力。小程序不会和公众号一同挤在会话列表中，除了通过一个会话可以直接打开小程序，也能到小程序自己的存放列表搜索和打开小程序。预计小程序的列表入口会放在 \"发现“ \\ “游戏” 的下面。微信小程序提供了更强的网络连接能力，小程序能够更加自由的连接网络，也能更加安全的使用网络。能够便捷地访问智能设备链接，未来在微信中就能直接使用和操作其他智能硬件。微信小程序提供了成熟的媒体组件， 微信小程序的开发者可以更容易地开发视频/音频等多媒体应用，用户使用起来也会更加的流畅。微信小程序不能够向用户推送图文，只能发送模板消息，从而不会无事打扰用户，也失去了通过图文消息激活用户和提高用户粘度的能力。微信小程序的语法？微信提供了丰富的框架组建和API接口供开发者调用，具体包含：界面、视图、内容、按钮、导航、多媒体、位置、数据等等。这些组件和接口能让建立在微信上的小程序在运行能力和流畅度上保持和Native APP一样的体验.项目结构最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。 app.js 小程序运行主要逻辑及入口，里面使用App()函数来注册一个小程序，普通页面的js文件中可以通过 getApp()函数拿到App()函数所拥有的参数，并调用其中的数据。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。小程序里面的JS文件都是模块化的，模块只有通过 module.exports 或者 exports 才能对外暴露接口。App({\r\n  onLaunch: function() {\r\n    //当小程序初始化完成时，会触发 onLaunch（全局只触发一次）\r\n  },\r\n  onShow: function() {\r\n   //当小程序启动，或从后台进入前台显示，会触发 onShow\r\n  },\r\n  onHide: function() {\r\n   //当小程序从前台进入后台，会触发 onHide\r\n  },\r\n  globalData: 'I am global data'\r\n})\r\napp.json 是小程序的全局配置文件。可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口?背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。{\r\n  \"pages\": [\r\n    \"pages/index/index\",\r\n    \"pages/logs/index\"\r\n  ],\r\n  \"window\": {\r\n    \"navigationBarTitleText\": \"Demo\"\r\n  },\r\n  \"tabBar\": {\r\n    \"list\": [{\r\n      \"pagePath\": \"pages/index/index\",\r\n      \"text\": \"首页\"\r\n    }, {\r\n      \"pagePath\": \"pages/logs/logs\",\r\n      \"text\": \"日志\"\r\n    }]\r\n  },\r\n  \"networkTimeout\": {\r\n    \"request\": 10000,\r\n    \"downloadFile\": 10000\r\n  }\r\n}\r\napp.wxss 是一个公共的样式文件，整个项目的每个页面都可以调用，我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则，就如一个全局的css文件。小程序引入了一个rpx的尺寸单位（会内部转成rem），也可以用普通的单位，如px、em、rem、百分比等；/**app.wxss**/\r\n.container {\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  padding: 200rpx 0;\r\n  box-sizing: border-box;\r\n  padding: 10rpx;\r\n} \r\n页面管理框架管理了整个小程序的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。框架采用的是双向数据绑定MVVM的模式。每个页面由4个文件组成，分别是页面逻辑文件JS、页面结构文件WXML、页面样式文件WXSS和页面配置文件JSON（这里的配置会覆盖全局的配置，即app.json）。微信小程序会读取这些文件，并生成小程序实例。小程序拥有全局的 App 和 Page 方法，用于进行程序和页面的注册，并且其中定义的方法可以被相互调用。Page({\r\n  data: {\r\n    text: \"This is page data.\"\r\n  },\r\n  onLoad: function(options) {\r\n    // Do some initialize when page load.\r\n  },\r\n  onReady: function() {\r\n    // Do something when page ready.\r\n  },\r\n  onShow: function() {\r\n    // Do something when page show.\r\n  },\r\n  onHide: function() {\r\n    // Do something when page hide.\r\n  },\r\n  onUnload: function() {\r\n    // Do something when page close.\r\n  },\r\n  // Event handler.\r\n  viewTap: function() {\r\n    this.setData({\r\n      text: 'Set some data for updating view.'\r\n    })\r\n  }\r\n});\r\nWXML<!--index.wxml-->\r\n<view class=\"container\">\r\n  <view  bindtap=\"bindViewTap\" class=\"userinfo\">\r\n    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\r\n    <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\r\n  </view>\r\n  <view class=\"usermotto\">\r\n    <text class=\"user-motto\">{{motto}}</text>\r\n  </view>\r\n</view>\r\n基础组件框架提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑，开发者可以通过组合基础组件，创建出强大的微信小程序。具体基础组件有view、image、text、input、audio、canvas等等，每个组件都有非常丰富的属性及事件绑定； <video id=\"myVideo\" src=\"{{src}}\" binderror=\"videoErrorCallback\" \r\n bindplay=\"bindplayCallback\" autoplay controls></video>\r\n丰富的API提供了丰富的微信原生API，可以方便的调起微信提供的能力，如请求接口、登录，本地存储，上传下载等；wx.request({\r\n  url: 'test.php', //仅为示例，并非真实的接口地址\r\n  data: {\r\n     x: '' ,\r\n     y: ''\r\n  },\r\n  header: {\r\n      'Content-Type': 'application/json'\r\n  },\r\n  success: function(res) {\r\n    console.log(res.data)\r\n  }\r\n})\r\n项目运行过程：第一步:加载项目根目录下的 app.js、 app.json、 app.wxss文件，同时会执行app.js文件，并触发其中的onLaunch 和 onShow 函数;第二步:加载app.json中pages数组中配置的第一个页面，作为项目的欢迎页，同时会执行对应页面js文件，并触发 onLoad / onReady 和 onShow 函数;往后:页面可以通过事件与js文件交互，比如 在标签元素上绑定点击事件，并且指向js文件中的一个函数，就能用js中的逻辑去处理这个事件了开发者工具（IDE）为了帮助开发者简单和高效地开发微信小程序，我们推出了全新的开发者工具，集成了开发调试、代码编辑及程序发布等功能。IDE采用的是node-webkit加react编辑功能开发者可以在这里编写代码，并且有适当的代码提示功能。（建议开发者用专业的IDE开发代码，然后可以利用此工具预览代码）；调试功能这里可以预览开发的小程序，并且提供了丰富的调试工具，分为 6 大功能模块：Wxml、Console、Sources、Network、Appdata、Storage；在IDE上面一栏可以选择手机模式和网络模式，用于模拟各种终端及网络环境下的小程序运行情况；项目功能在这一栏可以设置小程序项目的本地路径，可以上传小程序，生成预览的二维码和一些可选项等等；注：上传及预览需要appid;下载地址https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1477656486010demo由于目前没有appid，只能在IDE中预览小程序目前遇到的问题由于目前还只是内测阶段beta版本，很多功能及bug也正在fix中，微信团队基本按照 2 周一次的节奏发布版本更新;小程序技术规范刚刚起步，复杂的需求还缺乏实施方式；由于小程序不是基于webview，而是运行在JS core中，所以没有window和document对象等，而且是MVVM双向数据绑定的模式，无法进行DOM的操作，所有的数据操作必须基于组件上的事件绑定，利用setData方式改变初始状态，一些浏览器插件也无法使用（因为插件基本都基于window和doucument对象），所有开发模式上要有一定的改变;图片没法根据宽度自适应高度，必须写死高度的值，这给开发造成一定的困扰，特别是宽度为百分比的时候；微信提供了调用接口的方法，但是必须是https协议;一些功能必须依赖于appid，比如登录，socket，支付等等；开发动画的时候，初始样式必须写style属性，写CSS没用；etc..."}
{"title": "微信小程序基础：如何使用Git上传本地项目到github?(mac版) ", "author": "天下雪", "pub_time": "2016-11-2 00:32", "article_content": "在此假设你已经在 github 上创建好了一个项目，像这样：并且你已经完成了自己的项目代码，同时你也已经安装了 git，然后 let's start.首先，建一个文件夹比如文中演示的是 微信小程序 文件夹，然后打开的你的终端，定位到该文件夹，然后输入命令: git init然后配置 ssh , 输入：ssh-keygen -t rsa -C \"jiayi_li10@163.com\" (邮箱替换成你登录github的邮箱)这个地方请注意，它会在你选择的路径下上生成 ssh key，如果你直接点击回车，会在默认路径下创建 ssh 。如果你有多个项目，有工作的，有自己玩的，那么请配置不同的路径，或者一个路径换个文件名，我就用：/Users/lijiayi/.ssh/id_test_rsa 作为演示。输入路径之后点击回车。 这个地方是要你输入密码，直接回车则是不设置密码。直接回车就可以。然后会让你重复密码，也是直接回车。 当你出现如图所示，就代表 ssh 已经生成了。这个执行命令：pbcopy < ~/.ssh/id_test_rsa.pub   这个的作用是将你的 ssh 代码复制到剪贴板。  现在，咱们在重新回到 github 页面，需要将刚才生成的 ssh 配置到 github 里。点击你的呆萌头像：然后点击 settings 设置：点击配置 ssh：点击新建 New SSH key直接 Crl＋v 将刚才你已经复制在剪贴板里的 ssh 复制到 key input 里面，title 你随意起喽。然后点击 Add SSH key. 现在，咱们再打开终端，验证一下是否添加ssh成功了，输入命令： ssh -T git@github.com出现如上图的句子，你就起来跳个舞。倘若是类似如下的句子：The authenticity of host 'git.net (116.211.167.152)' can't be established.ECDSA key fingerprint is SHA256:FQGC9Kn/eye1W8icdBgrQp+KkGYoFgbVr17bmjey0Wc.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'git.oschina.net,116.211.167.152' (ECDSA) to the list of known hosts.Permission denied (publickey).或者permission denied,你就再执行命令：ssh-add ~/.ssh/id_test_rsa再次输入 ssh -T git@github.com 如果提示成功了，咱们就继续，如果没有成功，你就 google 一下报的什么错误。  当你successfully之后，咱们就在 git config 里设置一下你的 github 登录名以及登陆邮箱，执行以下两个命令：git config --global user.name \"your name\"git config --global user.email \"your_email@youremail.com\" 现在咱们就可以上传代码啦！！ 将你的项目代码拉到这个文件夹，执行命令，git status 这个时候你就会看到所有的改动，然后执行 git add .    (有个点哦，这个点表示更改所有的改动)then 执行命令 git commit -m \"第一次更新\" 然后执行命令：git remote add github https://github.com/你的用户名/github项目名.git 最后执行命令：git push -f github （这里的 github 是你创建的远程分支）  现在 回到你的 github 页面，然后刷新该项目页，哇色，这是什么  去跳舞吧～ 一些有可能遇到的问题以及参考网站：＊mac多个git账户配置：http://www.jianshu.com/p/fbbf6efb50ba＊cannot push to github ,keeps saying need merge: http://stackoverflow.com/questions/10298291/cannot-push-to-github-keeps-saying-need-merge＊删除github远程分支：https://my.oschina.net/tsingxu/blog/84601"}
{"title": "微信小程序第一个HELLO WORD程序 ", "author": "天下雪", "pub_time": "2016-11-2 00:38", "article_content": "1，文件分布结构：│ app.wxss│ app.js│ app.json│├─pages│ ├─index│ │ index.js│ │ index.wxml│ │ input.wxml│ │ index.wxss│ ││ ├─main│ │ main.wxss│ │ main.js│ │ main.wxml│ ││ └─logs│ logs.js│ logs.json│ logs.wxss│ logs.wxml│└─utilsutil.js2，业务逻辑部分对于不同的项目，根据其具体的业务逻辑表现，文件有不同的组织方式，但基本元素(页面Page)的结构不变。\r\n在helloworld项目中，如上图绿色所示为：pages/utils。\r\npages：该文件夹下存放不同的业务逻辑页面，在这里为index文件夹(主页面)，logs文件夹(log页面)。\r\nutils：该文件夹下存放工具类函数，并通过module.exports导出formatTime来供其他文件调用。\r\n3,程序主体部分由三个文件组成，必须放在项目的根目录,就是app.wxss、app.js、app.json  \r\n1. app.json 是微信小程序的全局配置文件，决定页面文件的路径、窗口表现、设置网络超时时间、设置多tab等。 \r\n\r\n    {\r\n      \"pages\":[  \r\n        \"pages/index/index\",  \r\n        \"pages/logs/logs\"  \r\n      ],  \r\n      \"window\":{  \r\n        \"backgroundTextStyle\":\"light\",  \r\n        \"navigationBarBackgroundColor\": \"#BF0000\",\r\n        \"navigationBarTitleText\": \"Hello Word\",\r\n        \"navigationBarTextStyle\":\"#FFFFFF\"\r\n      },\r\n        \"debug\": true\r\n    }\r\n\r\n说明：\r\n*  pages：pages接受一个字符串数组，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。  \r\n小程序中新增/减少页面，都需要对pages数组进行修改。pages中的路径为相对路径。文件名不需要写文件后缀，因为MINA会自动去寻找路径.json,.js,.wxml,.wxss的四个文件进行整合。  \r\n\r\n*  window：用于设置小程序的状态栏、导航条、标题、窗口背景色。\r\n*  debug：是输出调试信息\r\n\r\n\r\n2.app.wxss \r\n   WXSS(WeiXin Style Sheets)是MINA设计的一套样式语言，用于描述WXML的组件样式，也用来决定WXML的组件的显示方式。从定位上讲WXSS相当于css \r\n   /**app.wxss**/\r\n\r\n    .container {\r\n      height: 100%;\r\n      display: flex;\r\n      flex-direction: column;\r\n      align-items: center;\r\n      justify-content: space-between;\r\n      padding: 200rpx 0;\r\n      box-sizing: border-box;\r\n    }\r\n\r\n    .mui-bar-tab {\r\n        bottom: 0;\r\n        display: table;\r\n        width: 100%;\r\n        height: 50px;\r\n        padding: 0;\r\n        table-layout: fixed;\r\n        border-top: 0;\r\n        border-bottom: 0;\r\n\r\n    }\r\n4.页面代码说明：1.index.js       \r\n//index.js  \r\n//获取应用实例  \r\n//index.js  \r\n//获取应用实例  \r\n var app = getApp()  \r\n        Page({  \r\n            data: { \r\n                motto: 'Hello World',   \r\n                userInfo: {},   \r\n                item: { \r\n                    index: 0,   \r\n                    msg: 'this is a template',  \r\n                    time: '2016-09-15'  \r\n                }   \r\n            },  \r\n            //事件处理函数      \r\n            bindViewTap: function() {\r\n                wx.navigateTo({\r\n                    url: '../logs/logs' //转到logs页面    \r\n                })\r\n            },\r\n            viewTap: function() {\r\n                console.log('view top');\r\n                //设置一个memberName的值  \r\n                this.setData({\r\n                    memberName: {\r\n                        value: 'ylong52'\r\n                    }\r\n                })\r\n                //转到navigateTo页面  \r\n                wx.navigateTo({\r\n                    url: '../index/input'\r\n                })\r\n            },\r\n            onLoad: function(options) {\r\n                console.log(options)\r\n                var that = this\r\n                this.setData({\r\n                    title: options.title\r\n                })\r\n                //调用应用实例的方法获取全局数据\r\n                app.getUserInfo(function(userInfo) {\r\n                    //更新数据\r\n                    that.setData({\r\n                        userInfo: userInfo\r\n                    })\r\n                    that.update()\r\n                })\r\n            }\r\n        })\r\n注：有一些事件是我做测试放进去的。如：bindViewTap，app.getUserInfo。学习使用，无其它意议\r\n\r\n2. index.wxml和index.wxss 是对index页面html结构和css样式的控制。略"}
{"title": "Belinda的小程序踩坑记《一》 ", "author": "天下雪", "pub_time": "2016-11-2 10:06", "article_content": "微信小程序出来已有段时间，虽还在内测阶段。利用空闲时间，我把蜂贷微信项目部分迁移到小程序上。1.目录结构小程序的主体由三个文件组成，这三个文件要放在项目的根目录下，分别是app.js 配置小程序的逻辑app.json 公共设置app.wxss 公共样式小程序可以自定义 page，但是 page 需要在 app.json 中做出声明，不然IDE会报错，找不到页面。小程序的页面由四个文件组成，分别是.js文件 页面逻辑.wxml 视图层文件，页面结构.wxss 样式文件，页面样式表.json 文件，配置文件，页面配置2.小程序配置app.json 决定页面文件的路径、窗口表现、设置网络超时时间、设置多少 tab 。在 pages 对象里定义页面路径，pages 接受由字符串组成的数组，pages数组的第一个元素就是小程序的首页。window 用于设置小程序的状态栏、导航条、标题、窗口背景色。tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。networkTimeout 用来设置各种网络请求超时时间debug 是布尔类型，用来配置是否在开发者工具中开启 debug 模式3.小程序视图在小程序中，你不能继续用 html 中的标签来构造你的页面，MANA 框架有特定的容器组件，view，scroll-view 以及 swiper。view 是视图容器，类似于 html 中的 div ，但是不同的是，用 view 包裹的内容，在超出设备窗口的时候，它实现的效果如 css 样式设置的 overflow：hidden如果你需要实现类似通讯录或则聊天列表的滚动效果，你需要使用 scroll-view 滚动容器组件，它实现的效果如 css 样式设置的 overflow:scroll 。swiper 是滑块视图组件，如果你要实现类似轮播图的效果的话，他是你的不二之选，你能通过属性配置来控制是否显示圆点，是否自动播放，切换时间，以及切换间隔时间等。小程序的MANA也实现了数据的绑定，写法类似于 Angular 和 Vue，通过双括号的形式 如：{{data}} 即可，值得注意的是，如果你写在容器（为了便于描述和理解，下文会以标签来描述）于之间的话，你直接把变量写在双括号里即可，如：<view>{{data}}</view> ，但是如果你给标签的属性绑定变量，你需要将双括号放在双引号内，如：<view wx:if=”{{data}}”></view>,类似于Angular 和 Vue，你也能在双括号内进行简单的运算，如：<view hidden=”{flag?true:false}”></view>。细心的同学可能发现了在介绍数据绑定的时候我们用了wx:if 的属性，这是 MANA 提供的条件渲染，通过判断 wx:if 传布尔值（非布尔类型进行隐士转化）来控制是否渲染标签中的内容。在 MANA 中还有一个属性能控制内容的显隐，不同的是，wx:if 只有在为 true 的时候才回去渲染标签中的内容，而 hidden 始终会渲染内容，只是根据条件来控制内容的显示与否。此外MANA 也为我们提供了较为实用的列表渲染，wx:for 接受一个数组,在页面中能根据数组中的值来渲染页面列表除了使用列表渲染来复用一块视图外，你还可以通过模版来进行复用，你能在 template 中定义一块代码片段，然后在不同的页面中引用，如：<template name=\"odd\">\r\n  <view> odd </view>\r\n</template>\r\n<template name=\"even\">\r\n  <view> even </view>\r\n</template>\r\n\r\n<block wx:for=\"{{[1, 2, 3, 4, 5]}}\">\r\n    <template is=\"{{item % 2 == 0 ? 'even' : 'odd'}}\"/>\r\n</block>\r\n除了 template 外，MANA 还提供了另外两种方式来进行应用和复用，import 和 include ，import 有作用域的概念，他只会引用目标文件中定义的模版。include可以将目标文件除了<template/>的整个代码引入，相当于是拷贝到include位置上。除MANA 同样也定义了常用的事件分类，如touchstart 手指触摸动作开始touchmove 手指触摸后移动touchcancel 手指触摸动作被打断，如来电提醒，弹窗touchend 手指触摸动作结束tap 手指触摸后马上离开longtap 手指触摸后，超过350ms再离开4.组件样式定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。如果你写过 css ，那你就能轻松驾驭 wxss,wxss 在选择器上做了限制，目前支持的选择器有：.class 如：.intro 选择所有拥有 class=”intro” 的组件#id 如：#firstname 选择拥有 id=”firstname” 的组件element 如： view 选择所有 view 组件element, 如： element view checkbox 选择所有文档的 view 组件和所有的 checkbox 组件::after 如：view::after 在 view 组件后边插入内容::before 如：view::before 在 view 组件前边插入内容开发过移动端的前端er 都知道，苹果手机有物理像素和逻辑像素的区别，比如设备的像素是350px，设计稿的像素是750px；一般在开发过程中，我们会使用自动化构建工具去做像素转化，或则是使用预处理器定义像素转化函数进行处理，在小程序的开发中，大可不必这么麻烦，小程序提供了一个 rpx 的单位，你可以直接写上你在设计稿中测量的数值即可，小程序开发工具在编译过程中会自动帮你做转换。在下次小程序分享《小程序开发踩坑（二）》的时候，会教大家如何与后端进行数据交互，欢迎感兴趣的小伙伴订阅博客。"}
{"title": "websunny：微信小程序那点事：特性总结 ", "author": "天下雪", "pub_time": "2016-11-2 10:12", "article_content": "一、微信小程序运行环境    1、完全封闭的环境不等于浏览器环境    2、WXML/WXSS/JS格式    3、WXML 不等于 HTML    4、WXSS 不等于 CSS3    5、JS：支持ES6，ES5，不支持DOM(window,document,event,etc...)    6、不支持WEBGL,包含部分Canvas API    7、封闭的发布渠道：程序需通过官方IDE提交审核    8、腾讯完全控制客户端底层的内部实现二、微信小程序Canvas游戏限制分析    1、不支持Affine Transform 矩阵设置    2、不支持globalAlpha（忘记淡入淡出）    3、不支持贴图变色（无法创建缓存Canvas对象）    4、不支持图集（无法创建Image对象）    5、不支持BMFont字体    6、不支持剪裁（忘记ScrollView)    7、不支持WebGL，所以不支持任何高级特效    8、严格的模块化，不支持全局变量注入，只支持global下注入    9、不支持项目内文件加载    10、不支持多点触摸    11、不支持文字排版：换行，居中等    12、不支持九宫格、重复填充、网格等渲染模式    13、不支持skew    14、不支持混合模式  *15、支持Creator组件：Label，Sprite,Button,Widget,Layout,Animation,其他都不支持"}
{"title": "Coco-LG的学习笔记《一》事件 ", "author": "天下雪", "pub_time": "2016-11-2 10:32", "article_content": "微信小程序的\"事件\"挺有意思。看了说明文档后发现它的功能很全，事件可以向父节点传递，而且打印这个事件的信息很透明，调试起来应该非常方便。接下来把文档copy过来，原文地址：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html什么是事件事件是视图层到逻辑层的通讯方式。事件可以将用户的行为反馈到逻辑层进行处理。事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。事件对象可以携带额外信息，如id, dataset, touches。事件的使用方式在组件中绑定一个事件处理函数。如bindtap，当用户点击该组件的时候会在该页面对应的Page中找到相应的事件处理函数。<view id=\"tapTest\" data-hi=\"MINA\" bindtap=\"tapName\"> Click me! </view> 在相应的Page定义中写上相应的事件处理函数，参数是event。Page({    tapName: function(event) {      console.log(event)    }  })  可以看到log出来的信息大致如下：{  \"type\": \"tap\",  \"timeStamp\": 1252,  \"target\": {    \"id\": \"tapTest\",    \"offsetLeft\": 0,    \"offsetTop\": 0,    \"dataset\": {     \"hi\": \"MINA\"    }  },  \"currentTarget\": {    \"id\": \"tapTest\",    \"offsetLeft\": 0,    \"offsetTop\": 0,    \"dataset\": {      \"hi\": \"MINA\"    }  },  \"touches\": [{    \"pageX\": 30,    \"pageY\": 12,    \"clientX\": 30,    \"clientY\": 12,    \"screenX\": 112,    \"screenY\": 151  }],  \"detail\": {    \"x\": 30,    \"y\": 12  }  }  事件详解事件分类事件分为冒泡事件和非冒泡事件：冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。WXML的冒泡事件列表：类型触发条件touchstart手指触摸touchmove手指触摸后移动touchcancel手指触摸动作被打断，如来电提醒，弹窗touchend手指触摸动作结束tap手指触摸后离开longtap手指触摸后，超过350ms再离开注：除上表之外的其他组件自定义事件都是非冒泡事件，如的submit事件，的input事件，的scroll事件，(详见各个组件)事件绑定事件绑定的写法同组件的属性，以 key、value 的形式。key 以bind或catch开头，然后跟上事件的类型，如bindtap, catchtouchstartvalue 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。如在下边这个例子中，点击 inner view 会先后触发handleTap3和handleTap2(因为tap事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发handleTap2，点击 outter view 会触发handleTap1。<view id=\"outter\" bindtap=\"handleTap1\">    outer view    <view id=\"middle\" catchtap=\"handleTap2\">      middle view      <view id=\"inner\" bindtap=\"handleTap3\">        inner view      </view>    </view>  </view>  事件对象如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。事件对象的属性列表：属性类型说明typeString事件类型timeStampInteger事件生成时的时间戳targetObject触发事件的组件的一些属性值集合currentTargetObject当前组件的一些属性值集合touchesArray触摸事件，触摸点信息的数组detailObject额外的信息type通用事件类型timeStamp该页面打开到触发事件所经过的毫秒数。target触发事件的源组件。属性说明id事件源组件的iddataset事件源组件上由data-开头的自定义属性组成的集合offsetLeft, offsetTop事件源组件的坐标系统中偏移量currentTarget事件绑定的当前组件。属性说明id当前组件的 iddataset当前组件上由data-开头的自定义属性组成的集合offsetLeft, offsetTop当前组件的坐标系统中偏移量说明: target 和 currentTarget 可以参考上例中，点击 inner view 时，handleTap3收到的事件对象 target 和 currentTarget 都是 inner，而handleTap2收到的事件对象 target 就是 inner，currentTarget 就是 middledataset在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。书写方式：以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.target.dataset 中会将连字符转成驼峰elementType。示例：<view data-alpha-beta=\"1\" data-alphaBeta=\"2\" bindtap=\"bindViewTap\"> DataSet Test </view>  Page({    bindViewTap:function(event){      event.target.dataset.alphaBeta == 1 // - 会转为驼峰写法      event.target.dataset.alphabeta == 2 // 大写会转为小写    }  }) touchestouches是一个触摸点的数组，每个触摸点包括以下属性：属性说明pageX,pageY距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴clientX,clientY距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴screenX,screenY距离屏幕左上角的距离，屏幕左上角为原点，横向为X轴，纵向为Y轴detail特殊事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见组件定义中各个事件的定义。"}
{"title": "Coco-LG的学习笔记《二》view(视图容器) ", "author": "天下雪", "pub_time": "2016-11-2 10:40", "article_content": "示例[html] view plain copy<view class=\"section\">    <view class=\"section__title\">flex-direction: row</view>    <view class=\"flex-wrp\" style=\"flex-direction:row;\">      <view class=\"flex-item bc_green\">1</view>      <view class=\"flex-item bc_red\">2</view>      <view class=\"flex-item bc_blue\">3</view>    </view>  </view>  <view class=\"section\">    <view class=\"section__title\">flex-direction: column</view>    <view class=\"flex-wrp\" style=\"height: 300px;flex-direction:column;\">      <view class=\"flex-item bc_green\">1</view>      <view class=\"flex-item bc_red\">2</view>      <view class=\"flex-item bc_blue\">3</view>    </view>  </view>  示例讲解学过HTML的童靴很容易看懂上面的代码。没用过这种标签语言的，其实也很容易看懂。稍微讲解一下：1.单个的view[html] view plain copy<view class=\"section\">  </view>  这就是一个单个的视图。“section”则是写在.wxss文件中的样式，容器的样式决定它的形状、颜色、位置等属性。例：[html] view plain copy.section{      position: absolute;      top: 28rpx;      right: 44rpx;      width: 32rpx;      height: 32rpx;  }  2.父容器和子容器的嵌套[html] view plain copy<view class=\"flex-wrp\" style=\"height: 300px;flex-direction:column;\">      <view class=\"flex-item bc_green\">1</view>      <view class=\"flex-item bc_red\">2</view>      <view class=\"flex-item bc_blue\">3</view>   </view>  一个父容器中有三个子容器。给视图容器绑定点击事件示例[html] view plain copy<view class=\"widgets__item\" bindtap=\"tapToNext\">  </view>  关键点是 bindtap=\"tapToNext\"，这就绑定了一个点击事件，响应事件的函数名是tapToNext。这个函数在.js文件中。形如[html] view plain copytapToNext:function(event){      console.log(event)      wx.navigateTo({        url: '../logs/logs'      })    }  点击后界面跳到一个名为logs的Page。关于事件的详细讲解见wei小程序-事件"}
{"title": "Coco-LG的学习笔记《三》image(图片) ", "author": "天下雪", "pub_time": "2016-11-2 10:45", "article_content": "在微信小程序中，要显示一张图片，有两种图片加载方式：加载本地图片加载网络图片加载本地图片[html] view plain copy<image class=\"widget__arrow\" src=\"/image/arrowright.png\" mode=\"aspectFill\">  </image>  src=\"/image/arrowright.png\" 这句就是加载本地图片资源的。想想iOS中的加载本地图片，imageName:,类似。加载网络图片微信在加载网络这方面封装的还是很好的，包括语音和视频的加载。直接给'src'这个属性附上地址，它会自动加载。[html] view plain copy<image class=\"image_frame\" src=\"{{imageUrl}}\" mode=\"aspectFill\">  </image>  这个imageUrl是在js文件中数据[html] view plain copydata:{      imageUrl:\"http://img1.3lian.com/2015/w7/85/d/101.jpg\"  },  也可以直接写成[html] view plain copy<image class=\"image_frame\" src=\"http://img1.3lian.com/2015/w7/85/d/101.jpg\" mode=\"aspectFill\">  </image>  下来就看看image的一些属性需要注意的是：image组件默认宽度300px、高度225pxsrc就是上面代码中用到的。mode有12种模式，其中3种是缩放模式，9种是裁剪模式。具体说明建议看官方文档，很详细。点击打开链接很简单就这些。遗留问题在实践中，想实现这样一个功能：点击一个按钮，让这个图片重新加载。不知道怎样可以在js文件中直接操作image。后续学习或许会知道。哪位仁兄知道方法请在留言中不吝赐教。补充遗留问题已经找到答案。在按键的响应方法中直接用setData给imageUrl设定新的地址即可[html] view plain copydownLoadImage:function(event){      console.log(event)      var that = this;      this.setData({          imageUrl:\"http://h.hiphotos.baidu.com/zhidao/pic/item/6d81800a19d8bc3ed69473cb848ba61ea8d34516.jpg\"      })    }  效果如下：附录：1.tabBar不能正确显示建议先看看官方文档中多tabBar的说明：点击打开链接需要注意的是：写在pages数组中的页面，第一项代表小程序的初始页面，这个页面也必须是tabBar的第一项。后面的就无所谓了。tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。2.报错\"Parse app.json error： SyntaxError: Unexpected token / in JSON at position 332\"这个是应为在.json文件中用了注释。该文件是不能有任何注释的。3.想给任意一个页面(Page)添加tabBar?这是不能的。目前微信只能在首页加载。这个和iOS中的tableBar还是不一样滴！"}
{"title": "小程序微信支付不完全接入指南 ", "author": "天下雪", "pub_time": "2016-10-28 13:51", "article_content": "微信支付在 2013 年发布，作为内测开发者一路走来，可以感觉到微信支付接口稳定程度、文档的准确性都有质的提升。围绕支付相关的场景也配备对应的接口。本次小程序的发布，随机附送了一个微信支付模块，该模块使用起来的情况如何，就由我来告诉你吧。业务流抛开小程序的微信支付模块，我们总览微信支付的一些基本情况。微信支付有以下支付模式:微信客户端内的网页支付 (JSAPI)扫码支付 (PC 端，移动支付终端)刷卡支付 (支付终端扫描)app 支付 (iOS, Android)各种支付交互流程可通过微信文档进行查看，在此不赘述。支付发起所有支付方式都需要通过 『统一下单』的 API 来进行获取一个支付凭证，在内测以及刚发布的微信支付，是没有『统一下单』的概念，HTML 5 应用发起支付可以直接通过前端构造参数来进行发起。此时微信支付开发者很容易就造成支付凭证泄露等安全问题。为此，微信支付将其流程做了优化，在所有支付场景中插入『统一下单』，推荐开发者在后端完成支付参数的构建等行为。该优化带来以下好处:尽可能让开发者不犯低级错误，造成财务损失。简化构造支付参数的复杂度，所有支付方式可共享一个支付后端接口通过『统一下单』获取到相对应 prepay_id 或者 code_url 等参数，即可通过各种支付模式的 SDK 来进行微信支付的发起。支付结果接收微信支付发起完成后，微信还需要提供一个通知系统，以便及时让应用知道用户已经完成支付，可以进行下一步的业务操作。通知方式为一个 POST 请求，payload 为支付的状态信息，以及支付订单信息。注意必须对通知参数进行签名验证，以确保安全。进行签名验证时，除去签名字段，一般参数名为: sign，不需要参与签名外，其余所有接收到的参数均需要参与签名。周边接口通过 『支付发起』，『支付结果接收』，即可完成一个简单的微信支付系统。当然，微信还提供一下接口:查询订单取消订单申请退款查询退款下载对账单具体使用可以参考微信文档，根据自身业务情况适当的进行采用。绊脚石嗯，没错，我们吃了一次螃蟹，小程序刚内测，我们就决定使用微信支付模块，毕竟我们要实现的是一个电商应用 (电商没支付算什么嘛。开发过程中，我们掉了一些坑。支付凭证小程序的微信支付需要单独去申请，因为小程序是有独立的 appid，不能使用以前的支付账户，即使是全网发布也不能，因为小程序不是一个 HTML 5 应用。签名方式MD5! MD5! MD5!微信公众文档有很多 SHA1, MD5 的签名要求，微信支付相关的签名，暂时暂时暂时都是使用 MD5。小程序端在发起微信支付的时候是通过以下方式来进行发起:按照微信文档签名的要求，参与签名的字段应该为timeStampnonceStrpackagesignTypeok，按照签名算法得到的签名，去发起支付，居然提示失败了，经过与微信对接人员沟通后，参与签名的字段还需要加上 appid, 哦，不对，是 appId（请严重区分驼峰命名的大小写）。对这样的结果我表示不服，随即我翻阅了微信支付所有文档，终于在微信 JSSDK 的文档中找到一行备注。备注：prepay_id 通过微信支付统一下单接口拿到，paySign 采用统一的微信支付 Sign 签名生成方法，注意这里 appId 也要参与签名，appId 与 config 中传入的 appId 一致，即最后参与签名的参数有appId, timeStamp, nonceStr, package, signType。怪我咯(黑人问号) 点我去取笑!timestamp 类型小程序端发起微信支付的方式已经贴在上面了，但没那么简单，继续贴文档说明。timeStamp DateInt 时间戳从1970年1月1日00:00:00至今的秒数,即当前的时间文档告诉我们 timeStamp 应该带着 int 类型传入。我们前端的同学照做了，然后就过来骂我。你们后端参数是不是有问题!!! 提示 timeStamp 不存在了都经过排查，传入的 timeStamp 的值类型应该为 String结尾语总体上小程序接入微信支付还是比较简单的，没有过多复杂的设置，如果之前开发过微信支付后端的开发者，还可以复用同一个支付模块。文档的编写不严谨，使得开发舒爽度严重被削减。相信随着时间推进，文档会慢慢完善，毕竟以前也是这么过来的。"}
{"title": "微信小程序组件默认样式优先级 bug 解析 ", "author": "天下雪", "pub_time": "2016-10-28 13:54", "article_content": "在当前版本（iOS 客户端 6.3.27，开发工具 0.10.101400）中，微信小程序在 wxss 中存在一个优先级导致的 bug。官方文档中提到可以使用标签选择器，控制同一类组件的样式。如：使用 input 标签选择器控制<input/> 的默认样式此处存在一个比较明显的 bug，小程序中的组件大部分都是有默认的样式的，例如 image 组件就存在四个默认样式，其中一个默认样式为 display: inline-block。如果试图使用上述的标签选择器设置 image 的 display 属性，会发现并没有生效。而通过开发者工具可以查看到，设置没有生效的原因是 image 组件默认的样式优先级高于我们通过标签选择器设置的样式。经过测试，基本上所有组件的默认样式的优先级都会高于通过标签选择器设置的样式，而 class 选择器和 id 选择器的优先级还是高于默认样式。因此，目前如果想改变组件默认的样式，不能标签选择器直接设置，而是应该给需要改变默认样式的组件赋予同样的 class，再通过此 class 来改变默认样式。这个优先级的 bug，除了上述的所有组件默认样式的问题之外，针对某些特殊组件，如 button，还有更进一步的问题。button 组件可以分别设置 size、type 和 plain 三种属性，从而显示不同的按钮样式。测试中发现，如果着三种属性使用了非默认值之外的值，例如 type=“primary”，除了 button 组件默认的样式之外，type 为 primary 的 button 还会有额外的两个默认样式color: #FFFFFF 和 background-color: #1AAD19。此时如果通过 class 选择器设置 color 为其它值，会发现并没有生效。同样，通过开发者工具可以看到，type 为 primary 时的 button 的两个“额外”默认样式的优先级高于 class 选择器。因此在此种情况下，只能通过 id 选择器才能改变上述的两个“额外”默认样式。此外，有一点值得提醒的是。实际开发（真机及模拟器）中会发现目前 wxss 中是可以使用级联选择器的，及类似.parent .child { width: 100%; }由此则衍生出来一个比较优雅的解决上述 bug 的方法：修改 container 下 所有 image 组件的默认样式.container image { display: block; }改变 button[type=”primary”] 的“额外”默认样式.container .btn { color: red; }由此也可猜测上述 bug 出现的原因，可能是由于小程序的组件默认样式的实现过程中使用了类似标签选择器和类选择器，但没有控制好优先级导致。但是，请注意：不要使用此方法！不要使用此方法！不要使用此方法！官方文档中明确说明样式表不支持级联选择器不推荐使用官方文档中明确表明不能使用的方法。目前小程序还是处于内测阶段，此方法还能使用，只是官方的疏忽，很有可能此方法会突然无法使用。此外根据微信小程序内测群中的消息：目前还能用级联选择器是由于还没有过滤掉级联选择器。而级联选择有可能会破坏掉基础组件的一些样式，因此后续有时间了就会加上过滤。推荐使用 BEM，同时，后续也可能会加上不会破坏基础组件的级联方法，不过此需求的优先级会低一些。"}
{"title": "微信小程序之运维小项目 ", "author": "天下雪", "pub_time": "2016-10-28 15:13", "article_content": "自从微信推出小程序以来，现在业界炒的非常的火，具说叫微信小程序是因为某公司不让叫应用号，我在朋友圈也看过pony的和张小龙朋友圈关于名字的讨论截图，不知道是真是假，反正名字是定了，叫啥无所谓，还是知道它是干啥的比较重要， 像网上说什么新风口了，原生APP以后没活路了等相关文章喜欢的可以多看看， 我们今天不会在产品层面上去介绍小程序，因为我们是搞运维的，所以我还是在运维层面怎么使用小程序， 今天我们用实际例子来讲解和普及小小程序如何使用，来实现类似IP138的功能，输入IP可以查看IP的详细信息，包括归属，地点等，我们先看下完成后的效果：基本功能就是做一个IP查询的页面，输入ip，能够查询IP的详细信息，后台调用的淘宝的IP库，OK，界面和功能就是这样了，比较简单，接下来我们来介绍小程序的基本概念和使用。第一步，先下载微信小程序开发者工具，这个是必须的，因为只能在这个工具里去调试你的代码，但写代码不一定要在这个工具里去写，在Sublime 里写也可以，但调试你必须在这工具里，关于怎么下怎么装这我就不多说了，如果这步都没搞定我觉得往下看也没啥意义了，当然是开个玩笑，如果有问题的，可以给我留言。安装后，第一次运行需要用微信扫描，来识别开发者，然后添加项目，微信开发者工具可以帮你生成一个简单的demo项目，生成项目后如图： 我们先看app.js、app.json、app.wxss 这三个，其中app.js 是小程序的脚本代码,可以定义全局变量， 指定小程序的生命周期函数（onLaunch，onShow，onHide，其它），app.json文件是配置文件，主要配置小程序的页面，所有的页面设置都要写在这个文件里app.wxss 是公共样式表文件。除了这些文件，我们还有两个目录，这2个目录展示的是index 页面和 logs 页面，每个目录下如果完整的情况下都会有4个文件：如上图所示，现在每个目录下分别是index.js、index.wxml、index.wxss，其中.js 后缀的文件是脚本文件，.json 后缀的文件是配置文件（非必须），.wxss 后缀的是样式表文件（非必须），.wxml 后缀的文件是页面结构文件。以上就是小程序的基本概念了，了解了这些，就可以开始我们的小项目开发了。首先我们先写index.wxml。代码如下： 因为界面我加了一部分样式，所以要写index.wxss样式文件，代码如下： 有了这些只是个壳子，输入IP点击查询时没有效果的， 因为我们还需要从后台获取数据，现在开始写我们的index.js文件，因为js文件内容比较多，我们分开介绍，先说下下初始化部分，刚开始都是空，然后是我们的核心函数，先判断IP是否为空，如果是就提示IP不能为空，如果有IP，就调用wx.request发请求,将获得的数据然后通过setData来赋值，如网络有问题，就报网络请求失败，代码如下：最后，查询完后需要重新输入，当用户点重置时清空所有的内容，包括刚获取的值，代码如下：完成以上代码就可以在开发者工具里调试下了，如果都正常，这个小项目就算完成了，等微信开发公测的时候就可以传到微信小程序市场里，然后每个人就可以下载去使用了。关于小程序的内容我就介绍到这里，我这里就算是抛砖引玉了，喜欢的小伙伴可以帮忙转发下，让更多的小伙伴可以学习到新的知识，另外因为小程序是非常新的东西，想更深入了解的可以去看小程序的官方文档。"}
{"title": "最新微信小程序开发工具破解v0.10.102800 ", "author": "天下雪", "pub_time": "2016-10-29 00:54", "article_content": "项目地址：https://github.com/jsongo/weApp-ide 项目下载：weApp-ide-master.zip最新版本v0.10.102800的破解文件，欢迎试用。这一次的更新很大，主要变化摘录如下：A 增加 四个文件管理 API wx.getSavedFileList、wx.getSavedFileInfo、wx.removeSavedFile、wx.openDocument 详情A 增加 四个数据管理 API wx.removeStorage、wx.removeStorageSync、wx.getStorageInfo、wx.getStorageInfoSync 详情A 新增 四个交互反馈 API wx.showToast、wx.showModal、wx.hideModal、wx.showActionSheet 详情A 新增 选择地理位置 API wx.chooseLocation 详情A 新增 获取图片信息 API wx.getImageInfo 详情A 新增 两个设备 API wx.getSystemInfoSync、wx.makePhoneCall 详情A 新增 绘图 API wx.canvasToTempFilePath 详情A 新增 音频媒体 API wx.createAudioContext 详情A 新增 开放能力 API wx.checkSession 详情A 新增 wx.navigateBack delta 参数，支持多层级返回 详情A 新增 wx.sendSocketMessage、wx.onSocketMessage 支持收发 ArrayBuffer 数据类型A 新增 getCurrentPages() 方法， 获取页面栈 详情A 新增 Page.onReachBottom() 方法，监听页面到达底部 详情A 新增 事件对象增加 changedTouches 列表，反应手指触摸位置的变化 详情A 新增 <textarea/> 组件 详情A 新增 <canvas/> 多点触摸 详情A 新增 <canvas/> disable-scroll 属性 详情A 新增 <image/> bindload 事件返回图片宽高 详情A 新增 <text/> 嵌套 <text/> 功能 详情A 新增 <video/> controls autoplay 属性 详情A 新增 <video/> 支持设置弹幕、发送弹幕 详情A 新增 <video/> 播放类事件和接口 详情A 新增 WXML wx:key 支持，提升列表渲染时性能 详情A 新增 WXML 关键字、数据路径计算 详情U 新增 app.json tabBar 属性 position 用于指定显示位置 详情F 修复 wx.navigateTo api 超过 5 个页面，调用失败无返回的问题U 修复 <navigator/> 设置 display: flex 失效的问题F 修复 <input/> text-align:center、text-align:right 不支持的问题F 修复 <input/> 聚焦时异常的问题F 修复 <image/> base64 图片显示的问题F 修复 动态节点更新导致表单组件重置问题F 修复 使用 rpx 单位部分手机出现边框显示不全的问题F 修复 不同页面中相同的 canvas-id 共享同一个绘图上下文的问题F 修复 page 里面的属性对象内的 function 失效的问题F 修复 wx.drawCanvas 在 canvas 宽高为 0 的情况下画不出来的问题F 修复 wx.request header 设置 'Content-Type' 异常的问题D 即将移除 App.prototype.getCurrentPage 详情D 即将移除组件： <toast/> <loading/> <action-sheet/> <modal/>D 即将移除 <audio/> action 属性1可以分析它的源码学习这套框架破解方式：把相应的文件做个替换就行。当前文件可破解版本：v0.10.102800mac上：找到开发工具的程序，右击“显示包内容”：Resources/app.nw/app/dist/components/create/createstep.jsResources/app.nw/app/dist/stores/projectStores.jsResources/app.nw/app/dist/weapp/appservice/asdebug.jsResources/app.nw/app/dist/common/assdk/storageSdk.jswindow上：安装完后，一般是放在这个目录里：C:\\Program Files (x86)\\Tencent\\微信web开发者工具找到相应文件再替换：package.nw/app/dist/components/create/createstep.jspackage.nw/app/dist/stores/projectStores.jspackage.nw/app/dist/weapp/appservice/asdebug.js破解的时候，把整个代码大概浏览了一遍，自己折腾了下。（因为之前写过react + flux的代码，所以对这个项目的结构非常熟悉。）主要的修改，如果你有兴趣可以浏览下：1、asdebug.js修改（1）搜索“域名”两个字，找到类似域名校验出错等字眼的那一个function 把整个function内部的内容都注释掉，直接return true;这个主要是为了去掉安全域名的限制（2）搜索“URL 域名不合法，请在 mp 后台配置后，重启项目继续测试” 跟上面一样，把前面if改成if(false)这个修改主要是为了去掉websocket的安全名限制（3）搜索“__wxConfig.isTourist”，把它改成false这个修改是为了去掉游客身份。2、projectStores.js（1）搜索“setProjectConfig: function” 这个函数的定义把“i = e.isTourist”（不一定是i和e，不同的js格式化工具可能会有不一样的结果）这一小段注释掉，把下方的第一个if(i) { ... }整块注释掉。这一个用来判断是否是游客身份，是的话直接返回。但我们不想只是游客身份，所以这里我们不能让它返回，整个注释掉就行了。（2）在上面这个函数从上往下找try catch，把找到的第一个整块注释掉 然后把它下方的第一个if改成if(true)，if里的第一行var赋值语句的等号后面直接改成{Setting: {MaxLocalstorageSize: 10}}，因为在dist/common/assdk/storageSdk.js里有对这个值的引用，如果这里没有设置这个MaxLocalstorageSize的话，wx.setStorage会保存失败，wx.setStorageSync会报错。另外这里设置成if(true)是因为我们在创建项目时随便填appid，所以网络请求返回肯定是error，这里的JSON.parse结果在if里是通不过的。我们把这一整段注释掉，不去管网络返回的error。进if后会在本地存储新建项目的信息。这个地方的修改比较复杂，截图如下：3、createstep.js（1）搜索“当前开发者未绑定此 appid”把第一个if及周边的东西都注释掉，只执行下一个if。这个地方是创建的时候，返回用户信息的地方，上面说过我们创建时返回的肯定是error，所以这里自然也拿不到用户信息，反而是一个用户appId错误提示，所以这里我们动点手脚，把这个判断都注释掉，让它只执行用户信息返回的成功代码，同时我们创建一个假的用户信息object。这个修改比较复杂，截图如下：网络请求的接口，微信做了一些安全限制，要破解才能给任意地址发请求。websocket的接口也是一样。本项目的破解文件已经解决了这些问题。另外，创建出来的demo项目中，调用wx.login是不能成功的，所以改了demo的代码，在app.js里直接给globalData.userInfo赋值即可。init: function() {\r\n  this.globalData.userInfo = {\r\n    \"nickName\": \"jason\",\r\n    \"avatarUrl\": \"http://wx.qlogo.cn/mmopen/icSHGibMIMB82jDEHibGFA1s6dhwMibWrQAPeRvT2w2y2rpZVM5l3BftVEr3rTgX4fXDlznnMmZY0zYtgkfFw7L3o9r0tTblGTxB/0\",\r\n    \"gender\": 1,\r\n    \"province\": \"广东\",\r\n    \"city\": \"深圳\",\r\n    \"country\": \"中国\",\r\n  };\r\n},\r\n然后在onLaunch里调用一下init()就ok几个问题说明MaxRequestConcurrent报错的问题这个在本项目的破解文件里已经直接覆盖了，不会报这个错了。（修改：asdebug.js里，搜MaxRequestConcurrent，很简单，直接把它设置成固定数字即可）页面切换时会出现route错误的问题这个可能是开发工作自身的bug，用一段时间后就会这样，目前还没发现原因，不过解决这个问题很简单，关掉，重新再开就好了。Failed to load resource: net::ERR_NAME_NOT_RESOLVED这个问题gavinkwoe的项目中也说明了，主要是由于代理导致的，打开ide，菜单上选“动作”->“设置”，选直连就行"}
{"title": "微信小程序二三级菜单（navigateTo传递数据的应用） ", "author": "天下雪", "pub_time": "2016-10-29 01:03", "article_content": "今早来之后稍微写了下今天的工作目标然后就是自己犯蠢到现在的过程，所幸最后还是走回了正轨，记录一下我在过程中的内心弹幕，并把最后结果记录一下微信小程序-估价系统-车辆品牌款式等-三级菜单车标省份-城市-二级菜单（二三级菜单首先考虑使用微信小程序的数据缓存，但在不刷新的情况下缓存数据永远是上一次保存的。今天更新了微信小程序开发工具版本，发现写了数据缓存的代码之后后面的跳转语句不能执行无法跳转。打算放弃数据缓存的方式，想到另一种是在数组中加上跳转的目标地址然后直接跳过去，这样的弊端在于需要加上许多的页面比如一个省下的城市页面几十个省要几十个页面，忽然灵光一闪，考虑是否可以跳转中携带数据？马上进行尝试。！！！！我的天，我之前看官方文档都是睡觉去了吗。。。navigateTo的url里是可以带参数的，我没看到！！！！！！！！！！！！！！！！就算没看到以前写过的js都是做梦去了吗！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！我成功了，喜极而泣。）最终代码：toCity:function(e){    var index=e.currentTarget.dataset.hi;    var arr=this.data.provinceList[index].city;     wx.navigateTo({         url:\"../city/city?cityList=\"+arr     })   }跳转的时候url链接里把要传的数据加上就可以，我想传的数据是数组arr在跳转目标的js文件里用以下代码获得数据Page({    onLoad:function(options){        this.setData({            cityList:options.cityList.split(\",\")        })    }})因为直接用options.cityList得到的是字符串我用split转换成了数组。完美有木有。/(ㄒoㄒ)/~~所以当初为什么没有仔细看官方文档效果图如下，点山东跳转到山东的城市"}
{"title": "半桶水技术分享：微信小程序实现跳转传参 ", "author": "天下雪", "pub_time": "2016-10-29 23:20", "article_content": "刚接触微信小程序，多里面的语法和属性还不怎么聊解，如有不多的地方希望各位大神多多指教。今天来说下微信小程序怎么跳转和传参，话不多说直接上代码。实现的功能是给列表增加点击功能传参到下一页；    代码如下：<import src=\"../WXtemplate/headerTemplate.wxml\"/>  <view>      <!--滚动图-->      <view>       <swiper  indicator-dots=\"{{indicatorDots}}\" autoplay=\"{{autoPlay}}\" interval=\"{{intervalTime}}\" duration=\"{{Time}}\">          <block wx:for=\"{{imageURl}}\">              <swiper-item>                   <image src=\"{{item}}\" class=\"imagePX\"></image>              </swiper-item>          </block>      </swiper>      </view>      <!--功能按钮-->      <view class=\"section-bg\">          <block wx:for=\"{{buttonNum}}\">           <!--模版-->              <template is=\"buttonList\" data=\"{{item}}\"/>              <!--<view class=\"section-item\">            <image class=\"section-img\" src=\"{{item.image}}\"></image>              <text class=\"section-text\">{{item.text}}</text>          </view>-->          </block>      </view>      <!--资讯列表-->      <view>          <block wx:for=\"{{listNum}}\">              <template is=\"newList\" data=\"{{item,index}}\"/>          </block>      </view>   </view>  其中<template is=\"buttonList\" data=\"{{item}}\"/> 为模版代码如下<template name=\"buttonList\">       <view class=\"section-item\">            <image class=\"section-img\" src=\"{{item.image}}\" bindtap=\"buttonClick\"></image>              <text class=\"section-text\">{{item.text}}</text>          </view>  </template>  <!--list-->  <template name=\"newList\">       <view class=\"section-list\" bindtap=\"listClick\" id=\"{{index}}\">          <view>              <image class=\"list-img\" src=\"{{item.image}}\"></image>          </view>           <view class=\"section-textt\">               <view class=\"title\"><text>{{item.title}}</text></view>               <view class=\"subTitle\"><text>{{item.subTitle}}</text></view>          </view>      </view>  </template>  这里只为下面的列表增加了点击方法点击列表js代码listClick:function(event){      console.log(event);     var p = event.currentTarget.id      wx.navigateTo({url:'/pages/xiangqing/xiangqing?id=上一页的参数'})    }  其中wx.navigateTo({url:'/pages/xiangqing/xiangqing?id=上一页的参数'}) 为跳转方法，id为需要传的参数 如果参数为动态参数代码如下： <pre name=\"code\" class=\"javascript\"> listClick:function(event){        console.log(event);       var p = event.currentTarget.id        wx.navigateTo({url:'/pages/xiangqing/xiangqing?id='+p})      } 其中p为上面为每一行设置的id值在下一页取值代码如下：<pre name=\"code\" class=\"javascript\">  data:{      // text:\"这是一个页面\"      title:''    },    onLoad:function(options){      // 页面初始化 options为页面跳转所带来的参数    this.setData({      title:options.id    })  然后在页面上显示代码如下：<pre name=\"code\" class=\"html\"><view>{{title}}</view> 最终实现效果："}
{"title": "半桶水技术分享《二》：js实现单选功能 ", "author": "天下雪", "pub_time": "2016-10-29 23:25", "article_content": "初次接触js弄了好长时间才出来效果，但是还是觉的不做梦完美，希望有更好的方式进行交流；实现效果如下：虽说这个小功能但是对于我这个新手来说还是有点难；具体代码如下：WXML：[html] view plain copy<span style=\"color:#333333;\"><view class=\"backgrout-bj\">      <view class=\"header\">          最多可增加4个功能入口      </view>      <view>          <block wx:for=\"{{model}}\">               <view class=\"model-list\" bindtap=\"selectClick\" id=\"{{index}}\">                   <view>                      <image class=\"middle-img\" src=\"{{item.image}}\"></image>                  </view>                   <view class=\"middle-title\">                      <view><text>{{item.title}}</text></view>                       <view class=\"middle-sub\"><text>{{item.sub_title}}</text></view>                    </view>                    <!--<view  hidden=\"{{item.selectImage}}\">                      <image src=\"../image/xuanze.png\" class=\"seletedImage\"></image>                    </view>-->                    <view  wx:if=\"{{item.selectImage==true}}\">                      <image src=\"../image/xuanze.png\" class=\"seletedImage\"></image>                    </view>              </view>                     </block>      </view>  </view></span>  从大的分科分为两个大块一个是上面的header  剩下的列表是另外一个部分，列表中又分为若干个小块，本打算写个模版，但是感觉这样更清晰 WXSS：[css] view plain copy.backgrout-bj{ &n"}
{"title": "半桶水技术分享《三》：wx:key理解 ", "author": "天下雪", "pub_time": "2016-10-29 23:29", "article_content": "个人感觉官方给出的例子不是很明确，官方解释如下：wx:key如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <input/> 中的输入内容，<switch/> 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。wx:key 的值以两种形式提供字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。示例代码：<switch wx:for=\"{{objectArray}}\" wx:key=\"unique\" style=\"display: block;\"> {{item.id}} </switch>\r\n<button bindtap=\"switch\"> Switch </button>\r\n<button bindtap=\"addToFront\"> Add to the front </button>\r\n\r\n<switch wx:for=\"{{numberArray}}\" wx:key=\"*this\" style=\"display: block;\"> {{item}} </switch>\r\n<button bindtap=\"addNumberToFront\"> Add to the front </button>Page({\r\n  data: {\r\n    objectArray: [\r\n      {id: 5, unique: 'unique_5'},\r\n      {id: 4, unique: 'unique_4'},\r\n      {id: 3, unique: 'unique_3'},\r\n      {id: 2, unique: 'unique_2'},\r\n      {id: 1, unique: 'unique_1'},\r\n      {id: 0, unique: 'unique_0'},\r\n    ],\r\n    numberArray: [1, 2, 3, 4]\r\n  },\r\n  switch: function(e) {\r\n    const length = this.data.objectArray.length\r\n    for (let i = 0; i < length; ++i) {\r\n      const x = Math.floor(Math.random() * length)\r\n      const y = Math.floor(Math.random() * length)\r\n      const temp = this.data.objectArray[x]\r\n      this.data.objectArray[x] = this.data.objectArray[y]\r\n      this.data.objectArray[y] = temp\r\n    }\r\n    this.setData({\r\n      objectArray: this.data.objectArray\r\n    })\r\n  },\r\n  addToFront: function(e) {\r\n    const length = this.data.objectArray.length\r\n    this.data.objectArray = [{id: length, unique: 'unique_' + length}].concat(this.data.objectArray)\r\n    this.setData({\r\n      objectArray: this.data.objectArray\r\n    })\r\n  },\r\n  addNumberToFront: function(e){\r\n    this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)\r\n    this.setData({\r\n      numberArray: this.data.numberArray\r\n    })\r\n  }\r\n})这里写下个人的理解，有什么不对的地方希望大家指正：以<switch></switch>为例，如果没有wx:key，选中其中的某个按钮的时候，改变其顺序 或添加选项的时，选中的按钮时不回跟随 上个按钮改变顺序的，会一直在固定位子，如果如果有wx:key则相反，适用于列表或其他标签可以改变顺序或添加项目的情况"}
{"title": "微信小程序准备工作：微信开发实战《一》申请测试号 ", "author": "天下雪", "pub_time": "2016-10-29 23:41", "article_content": "最近微信发布了微信小程序内侧，各位程序员们是不是早就想一展身手，跃跃欲试。但是目前还没有完全开放，所以我们还是先看看微信公众相关的开发，做好准备，等待微信小程序全面开放，到时候期待各位程序员们可以开发出优秀的小程序。本系列实战文章为大家介绍微信开发的相关知识，包括公众号申请、接口开发等。并为程序员们提供微信开发开源代码。后期也会出一些教学视频，和大家一起交流学习。一、公众号开发准备：申请公众号如果你还没有想好公众号的名字、形式（订阅号、服务号），可以先申请一个测试号，用于开发入门阶段的学习。测试号开放的接口比较多，比较方便用于开发测试。如果你想现在就申请正式号，请一定要选择好订阅号还是服务号，相关的区别可以百度一下。最主要的区别是，订阅号每天可以群发1次消息，服务号每月可以群发4次。如果是个人申请，个人建议申请订阅号比较合适。1.1 如何申请测试号？测试号不分订阅号和服务号，包括了它们所有的接口功能。如何申请呢？首先你要有自己的微信号，通过微信号进行申请。访问链接http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login可以看到如下图片的界面：点击 登录 按钮，会弹出一个二维码，用手机微信扫一扫，即可看到如下界面：点击 确认登录 按钮，你的测试号就申请成功了！    测试号信息    接口配置信息    JS接口安全域名    测试号二维码    模板消息接口    体验接口权限表在电脑的网页中可以看到测试号的相关信息，包括：    包括appID 和 appsecret。开发号接入的时候会用到。    开发号接入时配置。    如果需要使用jssdk，这里需要配置。    公众号二维码。    如果你需要使用模板消息，这里可以配置很多。    测试号所具备的所有接口权限。1.2 开发者号部分接口权限一览在测试号页面可以看到 体验接口权限 一览表，以及每天使用频率的限制。接口很多，在此不详细介绍，如下图：二、 开发者接口文档上面图片的每个接口都有对应的文档，打开此链接可以了解详细介绍http://mp.weixin.qq.com/wiki/home/index.html三、公众号登录如果需要申请正式的公众号，打开此链接，即可实现注册和登录https://mp.weixin.qq.com/cgi-bin/loginpage登录成功之后，就看到了公众号所具备的部分功能菜单，如下图：结束语本篇文章简单介绍了如何申请测试号，下篇文章为大家介绍 微信公众平台接口调试工具"}
{"title": "微信小程序学习点滴《六》：保留小数(toFixed) 四舍五入 获取整数 string转int ... ", "author": "天下雪", "pub_time": "2016-10-29 23:58", "article_content": "1.保留小数点后几位小数.方法很简单.toFixed()即可.括号内的数字表示保留的位数.如果是整数,就会不上0特别注意:这方法返回的是String,我开始不知道,拿着返回值去做加法,折腾半个小时都是拼字符串,问了黄秀杰大神才知道搞错了.然后用parseInt()转换类型才拿到值.2.获取几位数 toPrecision()上图;第一组是获取四位数,第二组是获取六位"}
{"title": "微信小程序开发工具v0.10.102800-新增功能解析 ", "author": "天下雪", "pub_time": "2016-10-30 00:16", "article_content": "作者：jsong原文地址（已获授权）作者微信公众号：半圆生活，欢迎关注今天一早起来，发现小程序开发工具被更新到v0.10.102700版本了，随后不久又发布了v0.10.102800修复了点bug。这一次的两个发布新增加了不少api，本文试着向读者分析其中的一些api的用法，帮读者节省些工夫。 1、界面上的更新最主要的更新就是“实时刷新”功能。文件列表跟UI面板可以并排显示了，所以开发时就可以同时显示三个面板了（UI面板、文件面板、代码面板），如果不想看文件列表，可以把中间的这个面板收缩起来，点击这个面板左上角那个树形图标就可以了。当然，如果你不想显示UI面板，也可以把它隐藏起来，方法也是一样的，点击UI面板左上角的小图标就可以了。这个界面上的变化，主要是为了方便开发者，在代码修改的时候，查看实时UI变化。这个实时刷新的功能可能会比较占系统资源，开发者如果不需要这个功能可以把它关掉：在项目的设置里面，如上图，把这个选项前面的钩点掉就行。不过作者试了一下这个操作，居然点掉了还是会实时刷新，可能是工具的bug。 2、文件api（1）wx.getSavedFileList获取本地已保存的文件列表，之前有保存文件的接口，但我们看不到本地到底保存了哪些文件。这次的这个api正是用来解决这个问题的。（2）wx.getSavedFileInfo获取本地具体某个文件的文件信息。（3）wx.removeSavedFile移除本地存储的某个文件。以上三个接口，都只能操作wx.saveFile保存的文件，临时文件是取不到的。我们来写个示例代码测试一下上面三个api。// 从本地选取一个文件，临时存本地\r\nwx.chooseImage({\r\n     success:(res1)=>{\r\n          console.log(res1.tempFilePaths);\r\n          /* 这时wx.getSavedFileList还看不到，要先save */\r\n\r\n          // 保存\r\n          wx.saveFile({\r\n               tempFilePath: res1.tempFilePaths,\r\n               success: (res2)=>{\r\n                    var myFile = res2.savedFilePath;\r\n                    console.log(myFile);\r\n\r\n                    // 这时就可以查看了\r\n                    wx.getSavedFileList({\r\n                         success:(res3)=>{\r\n                              console.log(res3);\r\n                         }\r\n                    });\r\n\r\n                    // 上面的api是取得整个文件列表\r\n                    // 下面我们来取得具体某个文件\r\n                    wx.getSavedFileInfo({\r\n                         filePath: myFile,\r\n                         success: (res4)=>{\r\n                              console.log(res4);\r\n                         }\r\n                    });\r\n\r\n                    // 删除\r\n                    wx.removeSavedFile({\r\n                         filePath: myFile,\r\n                         success: (res)=>{\r\n                              console.log('删除成功: ' + res)\r\n                         }\r\n                    });\r\n               }\r\n          });\r\n     }\r\n});\r\n其中，wx.getSavedFileList返回内容：wx.getSavedFileInfo返回：{errMsg: \"getSavedFileInfo:ok\", size: 71466, createTime: 1477619293}wx.removeSavedFile返回：{errMsg: \"removeSavedFile:ok\"} （4）wx.openDocument新开一个页面，显示某个文档的内容，支持格式有：doc, xls, ppt, pdf, docx, xlsx, pptx这个功能比较强大。不过在工具上测试了下pdf文件，它是用系统默认的工具来打开pdf的。在手机上不知道是什么样。示例代码：wx.downloadFile({\r\n     url: 'http://www.jsongo.com/res/test.pdf',\r\n     success: (res)=> {\r\n          var filePath = res.tempFilePath;\r\n          wx.openDocument({\r\n              filePath: filePath,\r\n              success: function (res) {\r\n                     console.log(res);\r\n              }\r\n          });\r\n    }\r\n});\r\n返回的res内容是：{errMsg: \"openDocument:ok\"} 3、本地存储api（1）wx.removeStorage和wx.removeStorageSync这次终于有删除storage的功能了。之前我们是通过把value设置为null来模拟删除一个key-value对，这次的api更彻底，可以把key也删掉。同样的，也有同步（wx.removeStorage）和异步（wx.removeStorageSync）的方法。var mykey = 'test-key';\r\nwx.setStorage({\r\n     key: mykey,\r\n     data: 'hello',\r\n     success: ()=>{\r\n          setTimeout(()=> {\r\n               // 异步\r\n               wx.removeStorage({\r\n                    key: mykey,\r\n                    success: (res)=> {\r\n                         console.log(res.data);\r\n                    }\r\n               });\r\n               // 同步\r\n               // wx.removeStorageSync(mykey);\r\n          }, 5000);\r\n     }\r\n});\r\n （2）wx.getStorageInfo和wx.getStorageInfoSync获取storage的状态。我们知道storage的空间是有限的，但什么时候用完，什么时候剩下多少我们完全不知道。直到用完的时候，再存入就报错，这是一个很不正常的流程。这次添加的这个api，正好可以让我们在特定时机去检查一下storage，比如每次程序启动的时候，检查一下，如果快满了，那我们可以定一个策略去清理一部分。wx.getStorageInfo({\r\n     success: function(res) {\r\n          console.log(res.keys); // 所有的key\r\n          console.log(res.currentSize); // 当前已用空间\r\n          console.log(res.limitSize); // 当前项目可用的总空间\r\n     }\r\n});\r\n// 同步调用就更简单了\r\n// var res = wx.getStorageInfoSync();\r\n可以取到三部分的内容，一是本项目所有的key，一是当前已用空间，还有一个是当前项目可用的总空间。 4、交互反馈api这个更新非常方便，之前我们都是通过<toast>，<modal>，<loading>和<action-sheet>标签去定义这些交互，而且要自己去控制这些交互组件的显示和隐藏，而像toast的icon还不能改。这次的几个交互api给我们带来了很大的方便，原来的那四个标签全部都废弃了。（1）toast包含显示wx.showToast和隐藏wx.hideToast这两个api，之前的<toast>和<loading>现在都改用这两个函数来实现：wx.showToast({\r\n     title: '成功',\r\n     icon: 'success',\r\n     duration: 2000\r\n});\r\nsetTimeout(function(){\r\n     wx.hideToast()\r\n}, 赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              小程序微信支付不完全接入指南 \n              微信小程序实例教程：实现tabs选项卡效果 \n            \n             \n            \n                  原作者: jsongo0   \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 5款微信小程序开发工具使用报告\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSNH9gX3', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序第三方框架对比 ( wepy / mpvue / ta2019-01-28微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30分享一款拥有历史搜索记录的微信小程序搜索2019-01-28小程序点睛之三：才不是你想的那种组件2019-01-28微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n微信小程序Demo:Canvas图片拖拽生成实现2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo：精美的画板小程序2019-02-21微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：仿 [one] 微信小程序2019-02-18微信小程序Demo：3D旋转效果2019-02-18微信小程序Demo: flappy-bird小游戏2019-02-15微信小程序Demo：群应用（群通知、群接龙、2019-02-15微信小程序Demo：咩咩单词2019-02-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163965|49044fea00f9979c3e68c91070f45e04|2';"}
{"title": "梦断难寻新手入门篇《一》：熟悉项目结构 ", "author": "天下雪", "pub_time": "2016-10-30 00:21", "article_content": "微信小程序创建之后会生成一个项目模板，如下图所示（基本如此，但并不局限于此）现在分别来说明一下每个文件及目录的意思app.js 程序的入口文件，必须存在。app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。app.jsonapp.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释 app.jsonapp.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。 Pages（开发者自行创建）目录是你的页面目录，但不是一定需要叫PagesUtils （开发者自行创建）在本例中是工具类库目录，不是一定需要存在在开发过程中最好遵循以上目录结构，特别Pages，没个页面独立一个文件夹，因为每个页面有自己独立的样式或者Js。未来方便管理。 但是，如果有公共样式的存在，请写在app.wxss"}
{"title": "梦断难寻新手入门篇《二》：获取系统信息，地理位置，用户信息 ... ", "author": "天下雪", "pub_time": "2016-10-30 00:24", "article_content": "三个接口都是微信提供的。 index.js//index.js\r\n//获取应用实例\r\nvar app = getApp()\r\nPage({\r\n  data:{\r\n    userinfo : {},\r\n    systemInfo:{},\r\n    location :{}\r\n  },\r\n  onShow:function(){\r\n    var that = this;\r\n    // 获取用户资料\r\n    wx.getUserInfo({\r\n      success:function(res){\r\n        that.setData({\r\n          userinfo:res.userInfo\r\n        });\r\n      }\r\n    });\r\n\r\n    // 获取系统资料\r\n    wx.getSystemInfo({\r\n      success:function(res){\r\n        that.setData({\r\n          systemInfo : res\r\n        });\r\n      }\r\n    });\r\n    // 获取位置信息\r\n    wx.getLocation({\r\n      success:function(res){\r\n        that.setData({\r\n          location:res\r\n        });\r\n      }\r\n    });\r\n  }\r\n})index.wxml  <view class=\"header\">\r\n    <image class=\"user-header\" src=\"{{userinfo.avatarUrl}}\"></image>\r\n    <text  >{{userinfo.province}}  {{userinfo.city}}</text>\r\n    <text >{{userinfo.nickName}}</text>\r\n  </view>\r\n  <view class=\"slice-line\"></view>\r\n  <view class=\"center\">\r\n    <text class=\"text\">系统信息</text>\r\n  </view>\r\n  <view class=\"info-box\">\r\n    <text class=\"info-text\">手机型号：{{systemInfo.model}}</text>\r\n    <text class=\"info-text\">设备像素比：{{systemInfo.pixelRatio}}</text>\r\n    <text class=\"info-text\">窗口宽度：{{systemInfo.windowWidth}}</text>\r\n    <text class=\"info-text\">窗口高度：{{systemInfo.windowHeight}}</text>\r\n    <text class=\"info-text\">微信设置的语言：{{systemInfo.language}}</text>\r\n    <text class=\"info-text\">微信版本号：{{systemInfo.version}}</text>\r\n  </view>\r\n  <view class=\"center\">\r\n    <text class=\"text\">位置信息</text>\r\n  </view>\r\n  <view class=\"slice-line\"></view>\r\n  <view class=\"info-box\">\r\n    <text class=\"info-text\">纬度：{{location.latitude}}</text>\r\n    <text class=\"info-text\">经度：{{location.longitude}}</text>\r\n    <text class=\"info-text\">速度：{{location.speed}}</text>\r\n    <text class=\"info-text\">位置精确度：{{location.accuracy}}</text>\r\n  </view>\r\n  <view style=\"margin-top:100rpx;width:100%;height:2rpx;\"></view>\r\n  \r\n 最后效果图 好了。文本介绍了三个接口的使用方式，具体怎么发挥，大家自行判断吧。 源码奉上下拉刷新，上拉加载更多.zip快递查询.zip系统-位置-用户信息.zip"}
{"title": "微信小程序实例教程：实现tabs选项卡效果 ", "author": "天下雪", "pub_time": "2016-10-30 00:31", "article_content": "最近微信应用号是炒的如火如荼，热门满满，但是也可以发现搜索关键词出来，各类网站出现的还都是微信的官方文档解释。正好赶上这个热潮，这几天先把小程序技术文档看了个遍，就直接着手写案例了。很多组件微信内部已经封装完了，正好发现没有tab选项卡效果，这两天正好研究了下。思路如下：1、首先点击导航的时候需要两个变量，一个存储当前点击样式类，一个是其它导航默认的样式类2、选项卡内容列表同样也需要两个变量，一个存储当前显示块，一个存储的是其它隐藏的默认块3、使用三目运算通过点击获取导航索引，根据索引判断是否添加当前类【备注，这里我将点击事件绑定在父级导航栏，通过target对象得到点击触发的事件对象属性】 请结合如下效果图：       接下来直接查看源码：demo.wxml：<view class=\"tab\">    <view class=\"tab-left\" bindtap=\"tabFun\">      <view class=\"{{tabArr.curHdIndex=='0'? 'active' : ''}}\" id=\"tab-hd01\" data-id=\"0\">tab-hd01</view>      <view class=\"{{tabArr.curHdIndex=='1'? 'active' : ''}}\" id=\"tab-hd02\" data-id=\"1\">tab-hd01</view>      <view class=\"{{tabArr.curHdIndex=='2'? 'active' : ''}}\" id=\"tab-hd03\" data-id=\"2\">tab-hd01</view>      <view class=\"{{tabArr.curHdIndex=='3'? 'active' : ''}}\" id=\"tab-hd04\" data-id=\"3\">tab-hd01</view>    </view>      <view class=\"tab-right\">      <view class=\"right-item {{tabArr.curBdIndex=='0'? 'active' : ''}}\">tab-bd01</view>      <view class=\"right-item {{tabArr.curBdIndex=='1'? 'active' : ''}}\">tab-bd02</view>      <view class=\"right-item {{tabArr.curBdIndex=='2'? 'active' : ''}}\">tab-bd03</view>      <view class=\"right-item {{tabArr.curBdIndex=='3'? 'active' : ''}}\">tab-bd04</view>    </view>  </view>  demo.js： Page( {    data: {      tabArr: {        curHdIndex: 0,        curBdIndex: 0      },    },    tabFun: function(e){      //获取触发事件组件的dataset属性      var _datasetId=e.target.dataset.id;      console.log(\"----\"+_datasetId+\"----\");      var _obj={};      _obj.curHdIndex=_datasetId;      _obj.curBdIndex=_datasetId;      this.setData({        tabArr: _obj      });    },    onLoad: function( options ) {      alert( \"------\" );    }  });  demo.wxss：.tab{      display: flex;      flex-direction: row;  }  .tab-left{      width: 200rpx;      line-height: 160%;      border-right: solid 1px gray;  }  .tab-left view{      border-bottom: solid 1px red;  }  .tab-left .active{      color: #f00;  }  .tab-right{      line-height: 160%;  }  .tab-right .right-item{      padding-left: 15rpx;      display: none;  }  .tab-right .right-item.active{      display: block;  }      最终演示效果如下： 以上仅是个人方案，如果有更好的方案，欢迎提出~"}
{"title": "一斤代码深入理解系列《一》：微信小程序事件机制 ", "author": "天下雪", "pub_time": "2016-10-31 10:47", "article_content": "事件机制是一种非常典型的通讯方式，可以在代码中的不同对象之间传递信息，也可以在应用的不同层面进行沟通协作。今天我们想看来一下微信小程序框架提供的事件处理机制。小程序官方文档对事件的定义是：- 事件是视图层到逻辑层的通信方式- 事件可以将用户的行为反馈到逻辑层进行处理- 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。- 事件对象可以携带额外信息，如 id, dataset, touches。从这里我们可以看到，官方文档主要将事件用于小程序中针对用户交互行为的处理，即视图层(WXML)到逻辑层(Page)的通信，逻辑层收到这些用户行为事件后，可以进行业务处理，然后根据情况反馈或不反馈结果给用户。好，那我们今天就撇开事件的其他用法，专门就讲视图层和逻辑层之间的事件用法。总体上来说，小程序中的事件机制在工作原理上来讲，和HTML DOM的事件机制是一致的。在HTML中，我们可以通过在HTML元素上设置一个如onclick=\"clickHandler(event)\"的属性来绑定用户的页面点击事件处理函数。而在WXML中，我们为一个组件绑定一个事件处理函数，可以使用如下语法来完成：\r\n这里的bindtap就可以理解为将tap(点击)事件，绑定到一个名为tapName的事件处理函数上来进行处理。然后在相应的Page代码中，我们需要定义这个tapName函数：\r\n这样完成了一个简单的tap事件的处理。当我们在小程序的界面上去点击这个显示为Click me的view组件的时候，view组件捕获到这个tap动作，然后告诉Page中的tapName函数，要对这个动作进行处理，同时，它也为tapName函数提供了足够多的信息，也就是event对象，来帮助我们更好更精准的处理我们的业务逻辑。我们可以来看一下我们这个例子中的event对象里面包含了哪些内容：event\r\n这里我们可以看到，在event对象中，包含了事件的名称，事件目标对象的信息，以及事件发生的在界面上的位置信息等等。我们在组件上设置的data-hi属性的值，也在target中的dataset上被携带了过来，这是比较有用的，在实际开发中，我们可以利用这个特性，来传递更多视图层的信息到逻辑层进行处理。如果你有DOM编程的经验，你就会在这里想到，小程序里事件的冒泡和非冒泡是怎么处理的？如果你还不了解什么是事件冒泡，那我在这里解释一下：在HTML或者WXML这些基于XML的树形结构的界面布局方式中，元素与元素之间是有层级关系的，子级元素上触发的事件，可以向父级元素逐层向上传递，所以，父级元素上也可以捕获子级元素上的事件并进行逻辑处理。这种事件冒泡的机制，在实际的开发中也经常会用到，所以我们有必要来了解下在小程序中，是如何来使用冒泡事件的。WXML中分别提供了两种方式，用来绑定事件处理函数：1. 使用 bind 开头的事件绑定，这种绑定不会阻止冒泡事件向上冒泡2. 使用 catch 开头的事件绑定，这种绑定可以阻止冒泡事件向上冒泡直观起见，我们直接来看一个示例代码：index.wxml\r\nindex.wxss\r\n在这个示例代码中，有三个逐级嵌套的view元素，最里层的是content元素，最外层的为outer-container元素。最里层和最外层的元素上，使用了bind属性绑定了tap事件的处理函数，而中间的innner-container上，使用了catch属性进行tap事件绑定。然后，我们尝试在content上点击一下，可以看到这样的结果：点击content的结果\r\ncontent和inner-container元素的tap事件处理函数被执行了，而outer-container元素的没有被执行。这说明在点击content的过程中，产生的tap事件向父级元素传递，而作为content元素的父级元素inner-container, 它使用了能阻止事件冒泡的catch方式，所以它在捕获通过冒泡形式过来的子级元素事件并执行事件处理函数后，让该事件停止向上传递，因此同样是父级元素的outer-contaner，就不再能收到这个冒泡事件了。然后，来看一下，在不同层级的元素捕获的event对象，在数据方面有什么特点:我们可以看到，在content的tap事件处理函数中，event里面的target和currentTarget的id都是content。\r\n而在inner-container中的event对象里，target的id为content，而currentTarget的id是inner-content。\r\n由此我们可以知道，event对象中的target是事件产生的源头组件，而currentTarget则是当前捕获这个事件的组件。event对象中还包含其他一些有用的信息，如touches和changedTouches表示一个或多个手指在屏幕上的触摸位置和变动位置等信息，可以用来实现多点触摸的高级手势处理。最后，关于事件冒泡，有一点是值得注意一下的：在微信小程序中，并不是所有事件都是冒泡的，从官方文档了解到，<canvas>组件的触摸事件不可冒泡。"}
{"title": "TITF出品：微信小程序实用案例代码片段大全《七》 ", "author": "天下雪", "pub_time": "2016-11-2 11:02", "article_content": "一：获取手机网络状态关键代码.wxml布局文件代码 1<view>手机网络状态：{{netWorkType}}</view> 来自CODE的代码片snippet_file_0.txt.js逻辑文件代码  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15Page({  data: {    netWorkType:''  },   onLoad: function () {    var that=this        wx.getNetworkType({      success: function(res) {        that.setData({          netWorkType:res.networkType        })      }    })  }}) 来自CODE的代码片二：获取手机系统信息关键代码.wxml布局文件代码 1\r\n 2\r\n 3\r\n 4\r\n 5\r\n 6<view>手机型号：{{mobileModel}}</view><view>手机像素比：{{mobileePixelRatio}}</view><view>窗口宽度：{{windowWidth}}</view><view>窗口高度：{{windowHeight}}</view><view>微信设置的语言：{{language}}</view><view>微信版本号：{{version}}</view> 来自CODE的代码片snippet_file_0.txt.js逻辑文件代码  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15\r\n 16\r\n 17\r\n 18\r\n 19\r\n 20\r\n 21\r\n 22\r\n 23\r\n 24\r\n 25\r\n 26var app = getApp()Page({  data: {    mobileModel:'',    mobileePixelRatio:'',    windowWidth:'',    windowHeight:'',    language:'',    version:''  },    onLoad: function () {        var that=this;    wx.getSystemInfo({      success: function(res) {        that.setData({          mobileModel:res.model,          mobileePixelRatio:res.pixelRatio,          windowWidth:res.windowWidth,          windowHeight:res.windowHeight,          language:res.language,          version:res.version        })      }    })  }}) 来自CODE的代码片三：用微信小程序拨打电话关键代码.wxml布局文件代码 1<button type=\"default\" bindtap=\"calling\">拨打电话</button> 来自CODE的代码片snippet_file_0.txt.js逻辑文件代码  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13Page({  calling:function(){    wx.makePhoneCall({      phoneNumber: '12345678900', //此号码并非真实电话号码，仅用于测试      success:function(){        console.log(\"拨打电话成功！\")      },      fail:function(){        console.log(\"拨打电话失败！\")      }    })  }}) 来自CODE的代码片四：打开微信小程序内置地图关键代码.wxml布局文件代码 1<button type=\"default\" bindtap=\"openMap\">打开地图</button> 来自CODE的代码片snippet_file_0.txt.js逻辑文件代码  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15Page({  openMap:function(){    wx.getLocation({      type: 'gcj02', // 默认为 wgs84 返回 gps 坐标，gcj02 返回可用于 wx.openLocation 的坐标      success: function(res){        // success        wx.openLocation({          latitude: res.latitude, // 纬度，范围为-90~90，负数表示南纬          longitude: res.longitude, // 经度，范围为-180~180，负数表示西经          scale: 28, // 缩放比例                  })      }    })  }}) 来自CODE的代码片五：获取用户登录信息关键代码.wxml布局文件代码 1\r\n 2\r\n 3\r\n 4\r\n 5\r\n 6\r\n 7\r\n 8<view>用户昵称：{{nickName}}</view><view style=\"display:flex\">  <view style=\"width:100px;line-height:100px;\">用户头像:</view>  <image style=\"width:100px;height:100px;\" src=\"{{userInfoAvatar}}\"/></view><view>性别：{{sex}}</view><view>所在地址（省）：{{province}}</view><view>所在地址（市）：{{city}}</view> 来自CODE的代码片snippet_file_0.txt.js逻辑文件代码  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15\r\n 16\r\n 17\r\n 18\r\n 19\r\n 20\r\n 21\r\n 22\r\n 23\r\n 24\r\n 25\r\n 26\r\n 27\r\n 28\r\n 29\r\n 30\r\n 31\r\n 32\r\n 33\r\n 34\r\n 35\r\n 36\r\n 37\r\n 38\r\n 39\r\n 40\r\n 41\r\n 42\r\n 43\r\n 44\r\n 45\r\n 46\r\n 47\r\n 48Page({  data: {   nickName:'',   userInfoAvatar:'',   sex:'',   province:'',   city:''  },   onLoad: function () {    var that=this;        wx.getUserInfo({      success: function(res){        // success        that.setData({          nickName:res.userInfo.nickName,          userInfoAvatar:res.userInfo.avatarUrl,          province:res.userInfo.province,          city:res.userInfo.city        })        switch(res.userInfo.gender){          case 0:             that.setData({              sex:'未知'            })          break;          case 1:             that.setData({              sex:'男'            })          break;          case 2:             that.setData({              sex:'女'            })          break;        }      },      fail: function() {        // fail        console.log(\"获取失败！\")      },      complete: function() {        // complete        console.log(\"获取用户信息完成！\")      }    })  }}) 来自CODE的代码片六：获取自己所处的位置坐标关键代码.wxml布局文件代码 1\r\n 2<view>纬度：{{latitude}}</view><view>经度：{{longitude}}</view> 来自CODE的代码片snippet_file_0.txt.js逻辑文件代码  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15\r\n 16\r\n 17\r\n 18\r\n 19Page({  data: {    latitude:'',    longitude:''  },    onLoad: function () {   var that=this;    wx.getLocation({      type: 'wgs84',      success: function(res) {        that.setData({          latitude:res.latitude,          longitude:res.longitude        })      }    })  }}) 来自CODE的代码片"}
{"title": "Acmen、L学习案例集锦《四》video视频播放，audio音频播放 ", "author": "天下雪", "pub_time": "2016-11-2 11:54", "article_content": "一：video视频播放我现在看到的官方文档是不带danmu（弹幕）属性的，之前是有的，不过现在这个属性还可以生效。控制视频的状态可以根据video标签的唯一id得到一个对象实例。video组件并不具备action属性，不能通过action来控制。.wxml<view class=\"section tc\">\r\n  <video src=\"{{src}}\"   controls ></video>\r\n  <view class=\"btn-area\">\r\n    <button bindtap=\"bindButtonTap\">获取视频</button>\r\n  </view>\r\n</view>\r\n\r\n<!-- \r\n  danmu-list:弹幕列表\r\n  enable-danmu:是否显示弹幕\r\n  danmu-btn:弹幕按钮\r\n  controls:是否显示视频控件，并没有什么用\r\n -->\r\n<view class=\"section tc\">\r\n  <video id=\"myVideo\" src=\"http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&bizid=1023&hy=SH&fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400\" binderror=\"videoErrorCallback\" danmu-list=\"{{danmuList}}\" enable-danmu danmu-btn controls></video>\r\n  <view class=\"btn-area\">\r\n    赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              TITF出品：微信小程序实用案例代码片段大全《七》 \n              微信小程序学习点滴《七》：数据存储 参数传递 数据缓存 \n            \n             \n            \n                  原作者: Acmen、L \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • Acmen、L学习案例集锦《一》生命周期，组件\n                                    \n                  • Acmen、L学习案例集锦《二》弹框组件modal，底部菜单action-sheet\n                                    \n                  • Acmen、L学习案例集锦《三》加载中提示框loading，消息提示框toast，navigator页面跳 ...\n                                    \n                  • Acmen、L学习案例集锦《五》接口调用方式\n                                    \n                  • 小程序开发之视频开发 适配、禁止拖动进度\n                                    \n                  • 微信小程序添加视频video组件\n                                    \n                  • 微信小程序播放音频\n                                    \n                  • VIDE支持微信和支付宝小程序开发\n                                    \n                  • 微信小程序音频功能开发实(cai)践(keng)\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cStI8NiH', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551163972|1a52bdeec042ed542ae9fa1183bc9fdf|2';"}
{"title": "干货：微信小程序框架全解脑图，一张图看清组件构造，学习必备！ ... ... ... ... ... ", "author": "天下雪", "pub_time": "2016-11-5 17:27", "article_content": "分享者：职业学姐，已获授权，地址为授权地址\r\n全图部分截图：全图请下载附件：新增：flex全解全图下载：20161101104946886.zip如果有疑问或者对本脑图有什么建议，请在论坛内开贴询问或建议：http://www.wxapp-union.com/forum.php?mod=forumdisplay&fid=2"}
{"title": "天河微信小程序入门《二》：阿里云tomcat免费配置https ", "author": "天下雪", "pub_time": "2016-11-5 23:04", "article_content": "天河君在第一时间通过了微信小程序验证，开启了我的微信小程序之旅。因为天河君之前是一名后端狗，对前端不是很了解，所以几乎可以认为是从零开始学做微信小程序。也希望有志在微信小程序方向做点事情的朋友能够和我一起，共同进步，以致千里。\r\n上一篇是天河君在通过验证之后，兴奋的立即上手，在手机上跑了一回微信小程序。（天河微信小程序入门《一》）\r\n冷静下来后，天河发现，之前的很多demo在手机上都用不了，因为公测后得到了appId，结果导致无法与后台通讯，appId和后台的服务器域名是绑定的。\r\n没有后台的小程序是不完整的，于是天河开始着手打通前后台。碰到的第一个问题就是——微信小程序必须是https通讯。\r\nhttps是加密通讯，显然是微信为了提高安全性，强制要求通过http协议访问的话必须是https，但是之前很多朋友都没有接触过这个东西，突然一下无从下手。\r\n刚好天河是重新租用了一台新的服务器，就在这里介绍一下如何配置https。\r\n天河是用的阿里云ECS服务器，Linux系统，安装的tomcat。\r\n点击地址：云盾证书\r\n打开阿里云盾——CA证书服务，找不到的朋友也可以在下图的菜单中直接点击\r\n\r\n在右边的内容页中点击“购买证书”\r\n\r\n进入购买页后，跟天河一样的选择赛门铁克的1年免费证书\r\n\r\n记得一定要确认金额是0再点击购买哦，如果你们买了5000的，千万不要来找天河君……\r\n后面就是各种支付流程，当然了，既然金额是0，那么也就是不用钱了。\r\n\r\n点击证书控制台，这个时候你会发现你的控制台多了一个未绑定域名的证书（该免费证书只能绑定一个域名，并且不支持通配符哦），同时你会收到一封邮件，告诉你证书购买成功。\r\n\r\n点击该证书的补全信息后，进入绑定域名的流程。\r\n\r\n点击下一步后就要填写个人信息了。\r\n\r\n这里会出现一个分支，就是填写域名验证方式，一种是DNS验证，一种是文件验证。其目的是为了证明这个域名是属于你的。\r\n天河因为是买的阿里云的服务器，域名也是在万网申请的（万网已被阿里云收购），所以我选择了DNS验证，并且勾选了下面的自动完成域名配置选项。这样极大的简化了我后续的操作。至于这个分支会有什么影响，我等会儿再说。\r\n在这里我建议大家如果是后台服务已经搭建好的，可以选择文件验证，如果只是一台空机器，装了个tomcat，还是选择DNS验证简单（但是可以不选择自动配置复选框）。\r\n点击下一步后，来到了上传相关信息页面。\r\n\r\n在这里我强烈建议大家选择系统生成CSR，否则要自己生成CSR文件什么的很麻烦，而且根本没那个必要。\r\n选择系统生成后，点击后面的创建，会在按钮左边出现创建成功的字样，这个时候就可以提交审核了。\r\n这个时候你的证书控制台的那条证书信息会发生变化。\r\n\r\n首先证书绑定了域名，其次状态是正在审核中。\r\n点击后面的进度链接，会出现弹出框。\r\n\r\n这个弹出框就是因为天河在前面的步骤中选择了通过文件验证产生的结果，阿里云会让你下载一个文件，并将它上传到服务器的指定路径（记住这个路径不是你Linux操作系统的路径，而是你的域名所能够访问到的地址，在你没有开启自己的网络服务的前提下，应该是tomcat里面的一个路径），并通过下方的超链接去确认文件上传成功（成功的话你访问这个地址是会看到该文件内容的）。\r\n那么如果你之前选择的是DNS验证呢？阿里云会给你一个指定的域名解析，你需要将这个域名解析放到你的DNS服务提供商所提供的域名解析服务中。\r\n这里天河用的是万网的域名服务，各家不同的提供商可能界面也不一样哟。\r\n\r\n因为天河勾选了自动配置，所以阿里云很体贴的帮我配好了，等我打开这个页面的时候，还被这条陌生的解析吓到了。如果你没有勾选自动配置，就配置一条CNAME记录，按照阿里云提供的字符填入主机记录和记录值，填完后记得保存。\r\n这样配置完毕后，就可以等待审核通过了。我也没有具体掐表算过到底多长时间，反正不超过一个小时吧。\r\n再次刷新证书管理台页面后会发现，通过啦！\r\n\r\n看到那条已签发了么？通过之后就会是这样的显示。这说明你的证书已经申请成功了，接下来就是把它配置到你的服务器中去了。\r\n这个时候，点击后面的下载链接。\r\n\r\n看到了么？它支持5种主流的web容器，还有一个其他可以选择。天河是tomcat的，所以就给大家介绍一下tomcat的配制方法。\r\n天河用的是tomcat7.0，所以是支持PFX格式的证书的，点击“下载证书for tomcat”，会下载一个压缩包，里面有3中类型的证书。\r\n把*.pfx文件解压出来，上传到你的服务器的任何一个可以访问的文件夹。按照下方的介绍去配置tomcat的server.xml文件。\r\n这里天河还弄了一点小误会，天河看到下面的配置说是“订单号”以为就是该页面左上角的订单号，结果配置后发现访问https是404,。后来发现下面说的“订单号”其实就是你那个pfx文件的文件名，所以在配置的时候统一吧“订单号”改成pfx文件的文件名就可以了。\r\n配置完成后去重启tomcat，再用https访问你的tomcat页面（带8443端口，这是默认配的，也可以在server.xml里面改）\r\n\r\n看到那把绿色的锁了么？它就代表你的https已经配置成功，可以正常访问了。至此，https这个问题已经大功告成。后面我们就开始研究如何将微信小程序的前后台连通啦。\r\n如果大家有什么疑问，可以在微信小程序联盟（wxapp-union.com）的原帖下方提出来，天河君看到了会跟大家一起交流的。"}
{"title": "微信小程序request请求实例，网络请求。 ", "author": "天下雪", "pub_time": "2016-11-6 01:43", "article_content": "最近微信小程序开始开放测试了，小程序提供了很多api，极大的方便了开发者，其中网络请求api是wx.request(object)，这是小程序与开发者的服务器实现数据交互的一个很重要的api。官方参数说明如下OBJECT参数说明：参数名类型必填说明urlString是开发者服务器接口地址dataObject、String否请求的参数headerObject否设置请求的 header , header 中不能设置 ReferermethodString否默认为 GET，有效值：OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECTsuccessFunction否收到开发者服务成功返回的回调函数，res = {data: '开发者服务器返回的内容'}failFunction否接口调用失败的回调函数completeFunction否接口调用结束的回调函数（调用成功、失败都会执行）最简单的用法如下（以POST请求为例）[javascript] view plain copybindSearchChange:function(e){     var keyword = e.detail.value;     wx.request({       url:'xxxxxxxxx',       data:{},       header: {'Content-Type': 'application/json'},       success: function(res) {         console.log(res)       }     })   }  下面我们把请求写在service文件下的http.js文件中，代码如下[javascript] view plain copyvar rootDocment = 'hxxxxx';//你的域名  function req(url,data,cb){      wx.request({        url: rootDocment + url,        data: data,        method: 'post',        header: {'Content-Type': 'application/json'},        success: function(res){          return typeof cb == \"function\" && cb(res.data)        },        fail: function(){          return typeof cb == \"function\" && cb(false)        }      })  }      module.exports = {    req: req  }  其中module.exports是将req方法暴露出去使得别的文件中可以使用该方法，由于js函数是异步执行的，所以return 的是回调函数，而不是具体的数据为了其他文件方便调用此方法，我们在根目录的app.js文件中将其注册成为全局函数，如下[javascript] view plain copy//app.js  var http = require('service/http.js')  App({    onLaunch: function () {      //调用API从本地缓存中获取数据      var logs = wx.getStorageSync('logs') || []      logs.unshift(Date.now())      wx.setStorageSync('logs', logs)    },    getUserInfo:function(cb){      var that = this      if(this.globalData.userInfo){        typeof cb == \"function\" && cb(this.globalData.userInfo)      }else{        //调用登录接口        wx.login({          success: function () {            wx.getUserInfo({              success: function (res) {                that.globalData.userInfo = res.userInfo                typeof cb == \"function\" && cb(that.globalData.userInfo)              }            })          }        })      }    },    globalData:{      userInfo:null    },    func:{      req:http.req    }  })  这时这个req就是全局的了，在调用时我们可以使用getApp.func.req()来调用，具体如下[javascript] view plain copyvar app = getApp()  Page({    data: {          },    onLoad: function (opt) {      //console.log(opt.name)     app.func.req('/api/get_data',{},function(res){       console.log(res)      });    }  })  微信小程序提供了很多api，包括网络，媒体，数据等，也提供了很多组件，使开发小程序变得很方便。"}
{"title": "dodo607：微信小程序开发日记：重要的var that=this ", "author": "天下雪", "pub_time": "2016-11-6 02:14", "article_content": "什么是微信小程序\r\n关于什么是微信小程序在网络上已经有很多文章介绍，这里就不再阐述了。简单来说微信小程序应该是嵌套在微信里面的应用，这个应用体现“用完即走”的理念，用户无需安装过多APP，应用无需下载，用完就销毁。\r\n这给我们带来很多的思考，关于微信小程序未来会给我们带来什么样的体验以及更多的思考笔者以后会在其他文章进行阐述，这里就不过多的描述。\r\n\r\n四个交互接口\r\n新版本的微信小程序最新版本号是 0.10.102800，这次更新增加了 四个交互API:\r\n\r\nwx.showToast\r\nwx.showModal\r\nwx.hideModal\r\n\r\nwx.showActionSheet同时停用\r\n<toast/>\r\n<loading/>\r\n<action-sheet/>\r\n<modal/>\r\n\r\n这四个组件。所有微信提供的API接口都是以 wx.开头，并且一般情况下都接收一个对象作为参数。接收的对象中可以指定success, fail, complete这三个函数来接收接口调用结果。回调函数\r\n\r\n\r\n一般情况下。我们调用某个接口后都会在success回调函数里面处理一下成功之后的业务逻辑，比如发送个提示什么的。这里我举例使用 wx.showActionSheet接口，截图看程序\r\n视图页面\r\n视图页面\r\n\r\n<view class=\"btn\">\r\n    <button type=\"primary\" size=\"default\" bindtap=\"showactionsheet\">选择国家</button>\r\n</view>\r\n文件页面\r\nPage({ \r\n      data:{ \r\n          itemLists: ['中国', '美国', '日本', '英国'] \r\n        }, \r\n        showactionsheet: function () { \r\n           wx.showActionSheet({\r\n               itemList: this.data.itemLists, \r\n                 itemColor: \"red\", \r\n                 success: function (res) { \r\n                     if (!res.cancel) { \r\n                         console.log(res); \r\n                     } \r\n                 }\r\n           }) \r\n       }\r\n})\r\n调试窗口\r\n从调试窗口可以看到接口调用成功后 success函数回调返回的参数是一个对象 ，其中只有tapIndex代表点击中的项目索引（从上往下index从0开始），如果用户点击的是取消,则返回一个布尔类型的cancel，并且cancel=\"true\"！这时候，如果我们想打印点击的项目的文本，就只能通过tapIndex索引去数组里面显示，聪明的你一定会想到\r\nfunction (res) { \r\n  if (!res.cancel) {\r\n     console.log(this.data.itemLists[res.tapIndex]); \r\n  } \r\n}\r\n这是时候我们发现报错了报错itemLists 为undefiend\r\n\r\n原因是说itemLists 未定义。我们尝试把对象this.data也打印出来。同样发现是undefined.\r\n重要的 var that=this \r\n原来我们忘记了javascript 语言中 this关键字的用法了。在javascript语言中，this代表着当前的对象，它在程序中随着执行的上下文随时会变化。在本例中回调函数对象相对于showactionsheet点击事件函数对象已经发生了变化。所以已经不是原来的页面对象了。自然就没有了data属性，也没有了data.itemLists属性了。解决的办法就是复制一份当前的对象。所以我们有了这个重要的语句：\r\nvar that=this;//把this对象复制到临时变量that.\r\n这时候我们使用that 就不会找不到原来的对象了。\r\nconsole.log(that.data.itemLists[res.tapIndex]);//使用that.data 属性\r\n正确的结果\r\n\r\n其它接口也一样\r\n这里虽然只是举例了一个接口。但是鉴于微信小程序几乎所有的API接口都会有success, fail, complete三个回调函数来处理业务的后续逻辑，很多时候我们要获取当前页面对象来对视图进行渲染。当我们想要获取页面的初始数据 data时候，在回调函数里面就不能使用 this.data来获取，同样的就不能使用this.setData()函数来渲染视图。我们需要做的就是在把我们想要的this对象想复制到that.因此就有了本文的解说 重要的 var that=this .希望能够给正在学习微信小程序开发的初学者帮助。\r\n关于javascript this的用法大家还是要通过实例去好好理解。这里不再详细的解释。这里附送一个传送门，可以看看这篇写得很好的 关于深入理解this的文章:\r\n深入理解JavaScript中的this关键字"}
{"title": "微信小程序学习点滴《八》：从相册获取图片 使用相机拍照 本地图片上传 ... ... ", "author": "天下雪", "pub_time": "2016-11-6 02:17", "article_content": "今天遇到微信小程序的用户头像设置功能,做笔记.再上代码:小demo,代码很简单.1.index.wxml<!--index.wxml-->  <button style=\"margin:30rpx;\" bindtap=\"chooseimage\">获取图片</button>  <image src=\"{{tempFilePaths }}\" mode=\"aspecFill\" style=\"width: 100%; height: 450rpx\"/> 2.index.js//index.js  //获取应用实例  var app = getApp()  Page({    data: {      tempFilePaths: ''    },    onLoad: function () {    },    chooseimage: function () {      var _this = this;      wx.chooseImage({        count: 1, // 默认9        sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有        sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有        success: function (res) {          // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片          _this.setData({            tempFilePaths:res.tempFilePaths          })        }      })    }  })  API 说明:这里说说sourcetype.默认是从相册获取和使用相机拍照,跟微信现在选择图片的界面一样,第一格是拍照,后面的是相册照片.这里注意:返回的是图片在本地的路径.如果需要将图片上传到服务器,需要用到另一个API.示例代码:wx.chooseImage({    success: function(res) {      var tempFilePaths = res.tempFilePaths      wx.uploadFile({        url: 'http://example.weixin.qq.com/upload', //仅为示例，非真实的接口地址        filePath: tempFilePaths[0],        name: 'file',        formData:{          'user': 'test'        },        success: function(res){          var data = res.data          //do something        }      })    }  })"}
{"title": "微信小程序官方服务条款 ", "author": "天下雪", "pub_time": "2016-11-6 13:00", "article_content": "欢迎你使用微信小程序平台！​ 为使用微信小程序平台服务（以下简称“本服务”或“小程序服务”），你应当阅读并遵守《微信小程序平台服务条款》（以下简称“本条款”），本条款是《微信公众平台服务协议》的补充协议，是其不可分割的一部分。请你务必审慎阅读、充分理解各条款内容，特别是免除或限制责任的相应条款，以及开通或使用某项服务的单独协议，并选择接受或不接受。限制、免责条款可能以加粗形式提示你注意。​ 除非你已阅读并接受本条款所有条款，否则你无权使用微信公众平台服务。你对本服务的登录、查看、发布信息等行为即视为你已阅读并同意本条款的约束。​ 如果你未满18周岁，请在法定监护人的陪同下阅读本条款及其他上述协议，并特别注意未成年人使用条款。一、【协议的范围】​ 1.1 本条款是你与腾讯之间关于你使用小程序服务所订立的协议。“用户”是指注册、登录、使用微信小程序的个人或组织，在本条款中更多地称为“你”或“开发者”。“其他用户”是指包括其他微信小程序用户、微信公众帐号用户和微信用户等除用户本人外与小程序服务相关的用户。​ 1.2 本服务是指腾讯根据本条款向用户提供的技术服务，包括远程接口调用、代码托管服务、服务连接渠道、数据加密传输以及与此相关的互联网远程应用技术系统等。微信用户添加小程序后成为该小程序的关注用户，微信小程序可以通过小程序平台为相关用户提供应用服务。​ 1.3 小程序属于微信公众帐号，在不与本条款冲突的情况下，你应遵守《微信公众平台服务协议》 等协议规则关于微信公众帐号的其他相关规定。二、【小程序注册与审核】​ 2.1 你在使用本服务前需要注册一个微信小程序。微信小程序通过电子邮箱帐号进行绑定注册，请你使用未与微信公众帐号、微信开放平台开发者帐号等微信帐号绑定的电子邮箱帐号注册微信小程序。腾讯有权根据用户需求和产品需要对帐号注册和绑定的方式进行变更，关于你使用帐号的具体规则，请遵守相关帐号使用协议以及腾讯为此发布的专项规则。​ 2.2 用户在注册完成后，你可以通过系统后台生成二维码或名片推荐等方式，供微信用户添加。​ 2.3 注册完成后，你可以对所注册的小程序进行设计、内部测试、编辑维护等初始化开发管理。但在腾讯对小程序的发布审核通过前，小程序将无法进行发布，即不会向其他用户进行展示，其他用户也无法搜索、添加该小程序。​ 2.4 为确保微信小程序平台、微信公众平台、其他用户等各方的安全、稳定及良好的用户体验，腾讯将对需要发布的小程序进行发布审核。​ “发布审核”是指由用户发起，将其完成初始化开发的小程序提交至腾讯，由腾讯自行或委托第三方对该小程序的合法性、合理性、安全性、稳定性、可操作性、用户体验等各方面，采用包括但不限于开发信息核对、安全测试、UI测试、随机测试、动态测试、安全测试等方式，进行审查、甄别、试验与评估的过程。发布审核结果包括审核通过与审核不通过两种。审核不通过的，该小程序将无法发布。​ 2.5 你清楚并同意，小程序发布审核服务是腾讯基于用户提交包括但不限于注册信息、使用范围、声明承诺、开发文档、使用说明等资料，在腾讯的合法权限和能力范围内所综合作出进行合理、谨慎的形式评估和判断服务。但腾讯无法实质审查用户的实际经营、运营以及推广等行为，并不为此提供任何担保。你应仔细阅读有关小程序发布的各项协议、规范和规则，腾讯也尽可能为你提供各项常见拒绝情形，但由于客观上存在不断变化的法律法规、监管要求、产品规范和用户体验需求等各类因素，你的小程序被拒绝的理由未必包含在已经腾讯公布的条款中，由此所产生的法律后果由你独自承担。​ “拒绝”是指提交发布审核的小程序被审核不通过，或者已经审核通过的小程序，被短期、长期或永久封禁，或采取限制或禁止发布等其他方式拒绝提供本服务。​ 2.6 为向用户提供更专业的服务，你同意授权腾讯可以自行委托第三方对你所提交的发布审核申请进行审核。发布审核通过后，用户可以合理的方式、频率向腾讯提交版本优化、更新等发布审核申请。​ 你理解并同意，发布审核将对腾讯产生人力和经济负担，若你在审核服务期内，恶意或非恶意（如技术水平、用户需求等）原因而导致过于频繁提交发布审核申请，腾讯有权对你采取要求支付发布审核服务费、暂停或终止向你提供发布审核服务等措施，由此产生的责任由你独自承担。​ 用户付款后，腾讯将根据用户提交的发票信息向用户开具等额合法有效发票，用户应保证其提交的发票信息真实、准确及有效，否则因此导致的损失由用户自行承担。​ 2.7 微信小程序注册采用实名制，用户应当如实填写和提交帐号注册与认证资料，完成信息登记，并对资料的真实性、合法性、准确性和有效性承担责任。腾讯依据你填写和提交的帐号资料，在法律允许的范围内向其他用户展示你的注册信息。如用户提供服务或内容需要取得相关法律法规规定的许可或进行备案的，用户应当在帐号注册与认证时进行明确说明并提交相应的合法有效的许可或备案证明。否则，腾讯有权拒绝或终止提供本服务，并依照本条款对违规帐号进行处罚。因此给腾讯或第三方造成损害的，你应当依法予以赔偿。三、【小程序认证】​ 3.1 用户基于信息登记或其他需要可以为微信小程序申请微信公众平台认证。完成所有审核流程后，由腾讯作出认证是否成功的判断。微信公众平台认证服务内容仅限于对用户提交的资料及信息进行甄别与核实，腾讯将对用户提交的资料和信息进行合理、谨慎的形式审查，但在腾讯的合法权限和合理能力范围内，腾讯无法实质审查用户的实际经营、运营以及推广等行为，并不为此提供任何担保。因用户行为导致与其他用户或第三方发生争议的，由用户独立对外承担责任，因此给腾讯、其他用户或第三方造成损害的，你应当依法予以赔偿。​ 为向用户提供更专业的服务，你同意授权腾讯可以委托第三方对你所提交的认证资料进行审核，并根据审核情况进行独立判断后确定认证结果。同时，为依法保护相关权利人的在先权利并规范平台运营，部分微信小程序的高级功能需要认证才能使用。关于微信公众平台认证的具体规则，请阅读并遵守《微信公众平台认证服务协议》。四、【用户个人信息保护】​ 4.1 本服务将适用《微信公众平台服务协议》关于“用户个人信息保护”的约定。​ 4.2 你在申请本服务过程中，需要填写一些必要的信息，请保持这些信息的真实、准确、合法、有效并注意及时更新，以便腾讯向你提供及时有效的帮助，或更好地为你提供服务。根据相关法律法规和政策，请你填写真实的身份信息。若你填写的信息不完整或不准确，则可能无法使用本服务或在使用过程中受到限制。你理解并同意，为了向你提供服务，需要在法律允许的范围内向其他用户展示你的注册信息。​ 4.3 你在申请和使用本服务过程中，需要按照要求准确填写、预留你与关注用户、其他用户的直接数据通信方式，以便该等数据能准确地实现加密传输，确保你、相关用户的信息安全。否则，由此造成相关信息的泄漏、丢失、损坏等，均与腾讯无关。五、【知识产权声明】​ 5.1 腾讯在本服务中提供的内容（包括但不限于网页、文字、图片、音频、视频、图表等）的知识产权归腾讯所有，用户在使用本服务中所产生的内容的知识产权归用户或相关权利人所有。​ 5.2 除另有特别声明外，腾讯提供本服务时所依托软件的著作权、专利权及其他知识产权均归腾讯所有。六、【法律责任】​ 6.1 你应遵守《微信公众平台服务协议》中关于“法律责任”的约定，除非该等约定与本条款存在冲突。​ 6.2 你清楚知悉并理解，腾讯在本条款项下仅向你提供小程序服务或相关中立的技术支持服务，并且腾讯有权基于微信以及平台有序运营、健康发展等因素选择使用本服务的用户。​ 6.3 你的小程序由你以其自身名义开发或享有合法的运营权利，任何由你的小程序所产生与任何第三方的纠纷、争议等，均由你独立承担全部责任，且与腾讯无关，腾讯不会、也不可能参与小程序的研发、运营等任何活动，腾讯也不会对你的小程序进行任何的修改、编辑或整理等。​ 6.4 因你的小程序及相关服务产生的任何纠纷、责任等，以及开发者违反相关法律法规或本条款约定引发的任何后果，均由开发者独立承担责任、赔偿损失，与腾讯无关。如侵害到腾讯或他人权益的，开发者须自行承担全部责任和赔偿一切损失。七、【其它】​ 7.1 鉴于本服务将涉及微信公众平台的技术开发，可能会不定期邀请部分用户参与内部测试。若你被邀请且同意参与内部测试，未经腾讯书面同意，请勿向任何第三方以任何形式披露、展示、传递涉及本次内测的相关信息、资料。否则，腾讯可能会取消你本次及其他内测资格等，由此造成腾讯损失的，你也应一并赔偿。​ 7.2 你使用本服务即视为你已阅读并同意受本条款的约束。腾讯有权在必要时修改本条款。你可以在相关服务页面查阅最新版本的条款。本条款变更后，如果你继续使用微信小程序服务，即视为你已接受修改后的协议。如果你不接受修改后的协议，应当停止使用小程序服务。​ 7.3 本条款签订地、争议解决管辖方式，均与《微信公众平台服务协议》一致，即为中华人民共和国广东省深圳市南山区，由本条款签订地有管辖权的人民法院管辖。​ 7.4 本条款的成立、生效、履行、解释及纠纷解决，适用中华人民共和国大陆地区法律（不包括冲突法）。腾讯公司"}
{"title": "微信小程序认证指引 ", "author": "天下雪", "pub_time": "2016-11-6 13:02", "article_content": "一、申请微信认证入口入口一：“设置->基本信息->微信认证”点击“详情”进入。入口二：小程序发布流程页（政府、媒体、其他组织类帐号）二、申请微信认证操作流程签署《微信公众平台认证服务协议》，勾选同意，点击下一步。填写资料：选择认证主体类型，提交相应的认证材料。选择完类型后进入填写认证资料页面，各类型需要提交的资质材料包括但不限于：· 企业法人： 《组织机构代码证》；《企业工商营业执照》；· 媒体： 《组织机构代码证》；《企业工商营业执照》或《事业单位法人证书》；广播电视应上传《广播电视播出机构许可证》或《广播电视频道许可证》 ；报纸需上传《中华人民共和国报纸出版许可证》；期刊杂志需有《中华人民共和国期刊出版许可证》；网络媒体需要提供《互联网新闻信息服务许可证》或《信息网络传播视听节目许可证》。· 政府及事业单位： 《组织机构代码证》。· 其他组织-免费(基金会,外国政府机构驻华办事处)： 《组织机构代码证》；相关登记证书、批文或证明等：基金会请上传《基金会法人登记证书》，外地常设机构请上传其驻在地政府主管部门的批文，外国驻华机构请上传国家有关主管部门的批文或证明。· 社会团体： 《组织机构代码证》；《社会团体登记证证书》；如果是宗教团体还需要提供宗教事务管理部门的批文或证明。· 民办非企业： 《组织机构代码证》；《民办非企业登记证书》；非事业单位的培训教育机构，需要提交其自身所有权的《办学许可证》。非事业单位的医疗机构包括美容，需要提交其自身所有权的《医疗机构执业许可证》等。· 其他组织： 《组织机构代码证》；相关登记证书、批文或证明等。填写发票信息。用户可选择开具普通发票（定额发票）、增值税专用发票。其中增值税专用发票还需提交《税务登记证》（办理三证合一的企业直接上传新的营业执照）、《银行开户证明》，审核公司会对资质进行审核。资质审核通过后由腾讯公司开具并寄送发票。​​支付审核费用，目前仅支持微信支付。微信支付过程如下：​支付完成后，进入认证审核。页面上会公布第三方审核公司的联系方式，在审核过程中该公司将有可能与你联系沟通，如果在审核过程中遇到问题，可以拨打该公司的热线电话进行咨询。三、公众帐号的认证结果说明​ 腾讯及其委托的第三方审核机构按照用户的申请进行认证审核后，腾讯向用户输出的认证结果，认证结果分为成功和失败两种情形。​ 帐号类型为政府、媒体、其他组织的微信应用号，需认证成功后方可提交发布审核，否则，将不能提交发布审核，该微信应用号将无法发布；帐号类型为企业的微信应用号，完成注册后即可取得大部分的初始化开发管理能力，认证成功不作为提交发布审核的前提，但支付功能等腾讯有特别规定的除外。四、支持的认证主体类型支持以下几种认证主体：· 企业（企业法人、非企业法人、外资企业驻华代表处）;· 媒体（事业单位媒体、其他媒体）;· 政府及事业单位;· 其他组织五、各类型认证主体需要提交的资质材料包括但不限于以下材料：企业法人：《组织机构代码证》；《企业工商营业执照》；媒体：《组织机构代码证》；《企业工商营业执照副本》或《事业单位法人证书》；广播电视应上传《广播电视播出机构许可证》或《广播电视频道许可证》 ；报纸需上传《中华人民共和国报纸出版许可证》；期刊杂志需有《中华人民共和国期刊出版许可证》；网络媒体需要提供《互联网新闻信息服务许可证》或《信息网络传播视听节目许可证》。政府及事业单位：《组织机构代码证》其他组织-免费：《组织机构代码证》；相关登记证书、批文或证明等：基金会请上传《基金会法人登记证书》，外地常设机构请上传其驻在地政府主管部门的批文，外国驻华机构请上传国家有关主管部门的批文或证明，居民委员会、村民委员会、社区委员会等其他组织请上传主管部门的批文或证明，独立核算的附属机构请上传主管部门的基本存款账户开户许可证和批文。**社会团体：《组织机构代码证》；《社会团体登记证证书》；如果是宗教团体还需要提供宗教事务管理部门的批文或证明。民办非企业：《组织机构代码证》；《民办非企业登记证书》；非事业单位的培训教育机构，需要提交其自身所有权的《办学许可证》。非事业单位的医疗机构包括美容，需要提交其自身所有权的《医疗机构执业许可证》等。其他盈利组织：《组织机构代码证》；相关登记证书、批文或证明等。六、填写企业开户银行（对公帐户）用来做什么？​ 在认证过程中，为了验证认证主体（企业、媒体）的真实性，第三方审核机构会向申请者填写的对公账户进行小额打款，并在打款时附上备注信息，申请者在收到打款后，将收款的回执证明及时通过微信公众平台认证的补充材料页面提交审核（第三方审核机构会在电话沟通过程中指导您如何提交）。​ 企业收到的打款金额只用于认证审核，无需返还给第三方审核机构或微信。七、管理员身份证件的类型有哪些？1) 中华人民共和国居民身份证。2) 无居民身份证内地居民：可以提交《临时居民身份证》。以上证件必须提供正反面照片。八、认证服务资费​ 除政府、部分组织（基金会、外国政府机构驻华办事处）可免费申请外，其他类型申请微信认证均需支付300元/次的审核服务费用。这是用户基于腾讯提供的资质审核服务而支付的一次性费用，用户每申请一次认证服务需要支付一次审核服务费。无论认证成功或失败，都需要支付审核服务费。九、认证服务资费支付方式支付审核费用，目前仅支持微信支付。十、认证状态和结果查看方式登录公众平台，从“设置->微信认证->查看“查看进度。 也可以拨打第三方审核公司的客服热线咨询审核进度。十一、怎样开具发票在申请认证的第4步可选择发票类型，以及填写发票寄送地址。注意事项如下：1） 发票资料提交后不能修改，请填写正确的发票类型和寄送地址，若填写错误造成发票开具错误、寄送错误或选择不开具发票，后续将无法重新开具并寄送发票。2） 普通发票为定额发票，增值税专用发票的抬头为认证申请机构的全称。3） 增值税专用发票的开票资质需要进行审核，审核结果将在7个工作日内（不包括周末、法定节假日）在通知中心发送审核结果。4） 订单完成后（包括认证成功和失败），腾讯会在45天内开具并寄出普通发票，80天内开具并寄出增值税专用发票。十二、认证通过需要多长时间​ 认证通过取决于用户提交（补交）材料是否完整、及时，腾讯会在15个工作日内展开资质审核工作，用户应积极配合腾讯及第三方审核公司的审核需求。十三、认证失败有哪些原因？1） 企业没有在工商局合法注册。2） 运营者未得到企业授权申请和运营公众账号。3） 运营者身份证信息错误。4） 申请认证资料重填三次都不符合规范。5） 认证超时。自首次打回要求重填认证资料开始计算，30天（自然日）内没有再次提交认证资料的情况属于认证超时，将做认证失败处理。十四、同一个主体可以认证几个小程序？​ 除个体工商户类型可认证5个小程序外，其他类型一个主体可认证50个小程序。十五、第三方审核公司咨询热线1） 上海倍通企业信用征信有限公司​ 咨询电话：021-33977660​ 咨询时间：周一至周五（工作日）8：30-17：302） 北京知道创宇信息技术有限公司​ 咨询电话：028-85182726​ 邮箱：wx@anquan.org​ 客服公众号ID：wxrzkf​ 咨询时间：周一至周五（工作日）9：30-18：003） 长沙公信诚丰信息技术服务有限公司​ 咨询电话：0731-88845400​ 咨询时间：周一至周五（工作日）8：30-17：304） 莱茵技术监督服务（广东）有限公司​ 咨询电话：020-62334422​ 咨询时间：周一至周五（工作日）9：00-18：00十六、如何修改认证资料？​ 在年审之前，暂不允许修改认证资料。十七、认证年审​ 用户帐号审核成功后帐号审核成功状态将会被保留一年（起算日为帐号审核成功日）。用户如需持续保留帐号审核成功状态，保持高级功能的申请、使用权利，则应自帐号审核成功之日起一年内发起并完成年审认证，年审认证流程及帐号审核标准与原认证一致。如用户未能及时完成年审认证并取得认证成功结果，其帐号审核成功状态终止，高级功能的申请、使用权将被取消。十八、认证时能否更换认证主体（认证申请机构）？​ 不能在认证时变更认证主体，如果企业变更了企业名称，可在认证申请时提供相应的工商变更证明，由审核公司审核确认是否准予修改主体名称。微信团队"}
{"title": "微信小程序平台常见拒绝情形 ", "author": "天下雪", "pub_time": "2016-11-6 13:04", "article_content": "除本微信小程序平台常见拒绝情形外，开发者还应遵守《微信小程序平台服务条款》及腾讯公布的相关规则、规范。一、帐号基本信息1. 小程序名称、简介、logo、服务范围、服务标签、帐号基本信息文字均不得：​ （1）侵犯他人权益（著作权、商标权、肖像权、名誉权等）。包括但不限于，使用或包含不属于该小程序主体的品牌或商标、标识等内容或与之相似的内容、信息、特殊角标。示例：检查名称、简介中是否含有该小程序不属于该帐号的权益。​ （2）含有商业化用语的、热门小程序名称、“国家级”、“最高级”等新广告法明令禁止或其他无关的词语。​ （3）含有政治、色情、敏感、暴力血腥、恐怖、其他国家法律法规禁止的词汇及违法内容。2. 特别规则2.1小程序名称、简介：​ （1）小程序的简介需明确介绍小程序的功能点，不能使用模糊的词义表达，比如：该小程序旨在提高用户的生活品味、该小程序旨在提高用户的购物体验。示例：能在简介中提炼该小程序的几个功能点。​ （2）名称、简介的信息表达的意思必须有关联，具有一致性，并应与实际提供的功能一致，不含有与功能无关的搜索热词。示例：简介中能找到小程序名称或者分拆出来的词汇。​ （3）小程序名称不能以电话、邮件、日历等广义归纳类、普遍且不具有识别性词语来命名。示例：名称不是是单词汇，必须是两个词以上的组合，当无法判断时，审核人员可主观判断。2.2小程序头像logo：​ （1）小程序头像logo清晰度不够时，不予通过。示例：无法看清、分辨、识别图片中包含的各个元素，如：文字、物体、形状等。​ （2）小程序头像logo应与名称、简介保持一致2.3小程序的服务范围和服务标签：​ 小程序所设置的服务标签，应与所选的服务范围保持一致。标签不能超出服务范围。示例：服务范围是家政，服务标签是美食。二、服务类目审核​ 服务类目是指开发者按照小程序所提供的服务类型和所涉及的服务内容，在平台提供的分类分级表格中选择对应的行业范围。1. 小程序的类目要和自身所提供的服务一致。​ 2.1.1 小程序服务类目所对应的页面中的核心内容必须与该类目一致。​ 2.1.2 必须保证用户在该页面能使用该服务类目，不得隐藏，不得进行多次跳转。2. 小程序的服务类目链接使用正常，不存在违法违规或不符合与腾讯所签署的相关协议、腾讯公布的相关规则、规范等内容。​ 示例：​ （1） 小程序服务类目所对应的页面链接不能正常打开。​ （2） 小程序服务类目所对应的页面链接加载非法信息。​ （3） 小程序服务类目所对应的页面链接加载恶意、色情广告。​ （4） 小程序服务类目所对应的页面链接加载侵犯他人权益的内容；含有商业化用语的、热门小程序名称、“国家级”、“最高级”等新广告法明令禁止或其他无关的词语、不含有政治、色情、敏感、暴力血腥、恐怖、其他国家法律法规禁止的词汇及其他违法内容。三、小程序整体审核规则1. 小程序基本功能审核规范​ 1.1 小程序所实际提供的功能点，需与小程序的简介一致。示例：功能包括但不限于简介中提炼的功能点；​ 1.2 小程序所提供的所有服务类目功能，必须在小程序首页得到体现，即在小程序首页必须能直达或者经过2次点击到达所有本文档2（服务类目审核）中提交的服务类目页面；​ 1.3 小程序实际所提供的服务不得属于尚未开放的服务范围。不应超出小程序平台已开放的类目库范围。示例：游戏、直播功能尚未开放。​ 1.4 小程序中若存在隐藏或付费功能（比如仅充值可见，仅会员可见等受限功能点），该功能的实现不得含有色情、暴力、政治敏感或其他违法违规内容，开发者提供的测试号需可完整呈现和体验该功能；​ 1.5 小程序的功能应具有使用价值，不能过于简单，示例：只有一个页面，只有一个按钮；​ 1.6 未经腾讯公司授权的情况下，不得在小程序中提供与微信客户端功能相同或类似的功能，示例：小程序功能不能包含朋友圈、漂流瓶等。​ 1.7 在未经允许或未经腾讯公司授权的情况下，不得展示和推荐第三方小程序。示例：不能做小程序导航，不能做小程序链接互推，小程序排行榜等。​ 1.8 小程序功能的使用，无需以关注或使用其他号为条件。示例：使用A小程序时，必须同时使用B小程序2. 小程序页面内容审核规范​ 2.1 小程序的页面内容中，存在诱导类行为，包括但不限于诱导分享、诱导添加、诱导关注公众号、诱导下载等，要求用户分享、添加、关注或下载后才可操作的程序，含有明示或暗示用户分享的文案、图片、按钮、浮层、弹窗等的小程序，通过利益诱惑诱导用户分享、传播的小程序，用夸张言语来胁迫、引诱用户分享的小程序，强制或诱导用户添加小程序的，都将会被拒绝；​ 2.2 小程序的页面内容中，主要为营销或广告用途（如内含空白广告位、招商广告等），将会被拒绝；示例：漂浮悬浮广告，含有功能使用的页面中的广告展示比例超过50%，广告遮挡功能。​ 2.3 小程序的页面内容中，存在对用户产生误导、引发用户恐惧心理、严重破坏用户体验或损害用户利益的谣言类等内容的，将会被拒绝；​ 2.4 小程序的页面内容中，不能存在测试类内容；示例：算命，抽签，星座运势等。​ 2.5 小程序的页面内容中不能存在虚假、欺诈类内容，包括但不限于虚假红包、虚假活动、宣传或销售侵害他人合法权益的商品，仿冒腾讯官方或他人业务，其他可能造成微信用户混淆的内容和服务等；​ 2.6 小程序的页面中不能含有传播骚扰信息、广告信息和垃圾信息等内容；​ 2.7 小程序的页面中不得含有可能违反与腾讯签订的、任何形式的服务协议、平台协议、功能协议的内容；​ 2.8 含有发布、传送、传播、储存违反国家法律法规的或含有以下信息内容的，将会被拒绝：​   2.8.1反对宪法所确定基本原则的，危害国家安全、泄露国家秘密、颠覆国家政权、破坏国家统一 、损害国家荣誉和利益的小程序；​   2.8.2任何带有虚假、欺诈内容等的小程序不予通过；​   2.8.3任何召集、推销、鼓动犯罪或有明显侵犯社会善良风俗行为的小程序不予通过；​   2.8.4任何包含法律法规禁止传播内容的小程序不予通过；​   2.8.5小程序内容包含反政府、反社会或不符合主流政治的行为的，或存在煽动性的涉政言论或国家法律禁止的内容的，或含有散布谣言，扰乱社会秩序，破坏社会稳定信息的，不予通过；​   2.8.6小程序内容不能含有色情素材（即旨在激发情欲，对性器官或性行为的明确描述或展示，而无关美学），或存在涉嫌宣扬传播淫秽、色情内容信息，包括暴露图片、挑逗内容等的，或包含非法色情交易的信息；​   2.8.7小程序内容不能包含煽动民族仇恨、民族歧视、破坏民族团结的内容、破坏国家宗教政策、宣扬邪教和封建迷信的；​   2.8.8小程序内容不能包含展示人或动物被杀戮、致残、枪击、针刺或其他伤害的真实图片，描述暴力或虐待儿童的，或包含宣扬暴力血腥内容的，或包含侮辱或者诽谤他人，侵害他人合法权益信息的，将会被拒绝；​   2.8.9小程序内容不能包含赌博、竞猜和抽奖的。​ 2.9 小程序内的图片上不能含有广告、网址或虚假内容。​ 2.10 小程序代替用户发表、发送、转交任何内容前，必须征得用户明确同意和授权。​ 2.11 小程序的服务提供者必须提供过滤不当内容的措施。示例：设置对发布色情、赌博等涉嫌违法违规的词汇进行过滤提示的措施。​ 2.12 小程序页面中不能存在误导和错误暗示腾讯公司与该小程序有任何合作、投资、背书关系的内容，例如误导和错误暗示腾讯公司是该小程序运营者，或者误导和错误暗示腾讯公司以任何形式表示认可其质量、服务或与其存在合作关而该小程序事实上并非为腾讯公司运营。3. 可用性和完整性​ 3.1 提交的小程序须是一个完成品，要求可以打开，可以运行，且不可以是一个测试版。示例：不可运行、存在崩溃、闪退、按钮没有响应、文字表述不完整等。​ 3.2 本身会崩溃，或小程序程序会造成微信客户端崩溃的，将会被拒绝。​ 3.3 存在严重Bug的小程序（如无法添加和打开、无法返回和退出、卡顿严重等），将会被拒绝。​ 3.4 若小程序中存在帐号体系，需提供测试号，包含帐号和密码（可以体验所有功能）。4. 用户隐私和数据安全​ 4.1 在收集和使用用户任何数据时，必须明确告知用户该数据的用途，确保经过用户明确同意和授权，并应在用户同意和授权的范围内进行合理使用。在用户注销帐号后应相应删除相关数据。数据包括但不限于获取地理位置、用户通讯录、用户手机号码等。​ 4.2 不得在小程序任何页面请求或诱导用户输入微信用户的用户名或密码。​ 4.3 不得将搜索小程序功能加入小程序。​ 4.4 不得在页面中进行或将通过小程序收集到的用户数据私下进行出售、转交、交易、越权披露或泄露。​ 4.5 不得在未经用户授权同意的情况下，显示用户相关数据，比如：头像，昵称等信息。​ 4.6 小程序不得要求用户降低手机操作系统安全性（如要求iPhone 用户越狱、Android 用户ROOT 等）后，方能使用相关功能。​ 4.7 若小程序有需要追踪用户的地理位置的功能，则必须提供退出该位置追踪的功能和明确指示。5. 技术实现规范性​ 5.1 需要提供小程序文档和说明​ 5.2 禁止视频、音乐、语音等多媒体的自动播放​ 5.3 安装或运行其他可执行代码的程序，将会被拒绝​ 5.4 违规加载或更新代码，将会被拒绝​ 5.5 如果小程序有账户系统，必须提供能正常使用且易于发现的“退出”账户选项。6. UI 规范​ 6.1 符合WeApp UI 规范​ 6.2 小程序页面内的浮层和弹窗可关闭​ 6.3 小程序的界面必须遵守微信的外观和功能，不得提供改变微信外观和功能的产品体验。​ 6.4 小程序的界面不得模仿系统通知或警告诱导用户点击。​ 6.5 小程序头像logo需使用透明或有色背景。若使用白色背景，需使用有色边框。微信团队"}
{"title": "微信小程序跳坑指南系列《一》：新坑30枚 ", "author": "天下雪", "pub_time": "2016-11-6 15:14", "article_content": "微信公众号：产品立方1、小程序名称可以由中文、数字、英文。长度在3-20个字符之间，一个中文字等于2个字符。2、小程序名称不得与公众平台已有的订阅号、服务号重复。如提示重名，请更换名称进行设置。3、小程序名称在帐号信息设置时完成，请谨慎设置，一旦设置暂不支持修改。4、更换名称进行设置。如果企业商标，组织名称等名称被侵权，可通过公众平台侵权投诉流程发起投诉，取回名称使用权。5、个人开发者无法申请微信小程序；目前微信仅支持企业、政府、媒体、其他组织申请。6、一个主体可以注册30个，一个绑定身份的开发者只能创建5个微信小程序。* 对于员工来说，请不要随便借给你的老板你的微信来注册微信小程序，因为你这样就没有机会了。* 对于老板来说，请不要随便借给你的员工微信来注册微信小程序，因为你可能要不回来。7、如果你不是特殊组织，你还是要花300元进行认证。*  即使你对公帐号已经验证，你也需要缴纳300元（支持微信支付）进行验证，这样才能够打开审核开关，发布小程序。* 微信支付需要微信认证后才能使用。8、<"}
{"title": "安肖雄：微信小程序教程入门篇《一》：10分钟从0开始写一个hello-world-极其详细 ... ", "author": "天下雪", "pub_time": "2016-11-7 10:21", "article_content": "微信专门为小程序开发了一个ide叫做微信开发者工具。最新一版的微信开发者工具，把微信公众号的调试开发工作也集成了进去，可见微信对小程序多么的充满信心。对于初学者来说，微信小程序的所有开发工作以后最好都在这个【微信开发者工具】上完成，编辑完了就可以调试真的很方便。微信给这个ide开发了window64、 window32 、max三个版本，连window都开发了两个版本，真的很佩服微信的用户体验。ide大家可以去百度搜索下载下载安装完【微信开发者工具】打开ide看到的第一个画面图1：\r\n上面的按钮是小程序调试，下面的按钮是公众号调试，今天就只讲小程序了，公众号以后再讲或者直接略过了。选择“本地小程序项目”进入第二个画面，在这个画面里填写小程序的appid和项目名称以及项目所在目录。因为熊熊没有内测资格，所以我没有appid，这里就点击第一个框的右下方绿颜色字“没有appid”就行。然后填写项目名称，自己爱写什么就写什么好了，不过我建议大家不要随意，最好按照标准的流程来，写的正式一点，这是一个开发者的态度，我们应该重视每一个项目即使是一个小的学习demo。最后选择项目所在目录，这里也一样你可以选择任何一个目录，不过我还是希望大家能够为这个项目专门做一个目录。好了所有的都填完点击右下角“添加项目”就可以了。图2：\r\n接下来就进入了项目的正式开发的界面了，现在来说下这个界面：左边是小程序的页面效果展示界面，小程序的页面结构样式等效果会在左边显示出来。中间是项目的源文件结构目录。最右边是编码窗口可以在这里编辑代码。我们新建的项目进入以后什么都没有是空的，需要我们一点一点的手动编写代码。图3：\r\n好了接下来就带大家一步一步写一个hello world。编码之前讲一下小程序的开发规矩（担心有些初学者理解不了姑且叫规矩吧）接下来的内容很重要，仔细看哦！小程序开发需要三个描述整体程序的app文件 和 一个描述多个页面的 pages文件夹。（1）三个app文件分别是app.js,app.json,app.wxss。app.js文件是脚本文件处理一些公共的或者全局的逻辑。比如在这里定义全局变量处理登录逻辑指定首页等。app.json文件是小程序的整体配置文件。我们必须要在这个文件中配置小程序是由哪些页面组成的，我们还可以在这个文件中配置整个小程序的统一的窗口 背景色，导航条  样式，默认标题。但是必须注意该文件不可添加任何注释。app.wxss文件是整个小程序的公共样式表。我们可以在小程序子页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。也就是说在这个文件里定义的样式在其他任何的子页面中都可以使用。这个也是为了代码的简洁和整体风格的统一。（2）接下来说pages文件夹：小程序的所有显示的页面都必须以子文件夹的形式存放在pages文件夹里面，包括首页。项目展示多少个页面，在pages文件夹下就要新建多少个子文件夹。每个页面的子文件夹，必须包括这四个文件：*.js   ,  *.wxml   ,  *.wxss  和 *.json（* 表示文件名）。这四个文件的文件名必须和子文件夹的名字一样。*.js文件是当前页面脚本文件，也是业务逻辑的处理文件，当前页面的所有和后端服务器接口的交互，请求数据的逻辑都在这个文件完成，是核心文件，必须创建。*.wxml文件是搭建当前页面元素的文件。负责搭建当前页面的结构和布局，相当于网页开发中的*.html文件，这个文件中存放一些类似于div  span  form  input  sectiond等布局代码，必须创建。*.wxss文件是当前页面的样式文件。负责调整当前页面的样式，元素之间的间距，字体的大小，字体颜色，背景图等，相当于网页开发中的css文件，需要时创建。*.json文件是当前页面的配置文件。配置当前页面的窗口背景色，导航条样式，默认标题等，需要时创建不需要千万不要创建，这里我发现一个bug，就是如果创建了这个配置文件，但是配置文件中没有任何内容，那么页面渲染的时候什么也显示不出来，所以如果创建了这个文件，那么就必须在这个文件里写点什么即使写“{}”也行，要不然就不要创建。（个人猜测：是如果json文件为空，小程序在加载的时候就认为这个json配置是错的，页面渲染终止。我已经把这个bug提交给微信官方了！！！）以上这四个文件只作用于当前的页面，不作用于整体和其他页面手册截图，图4：\r\n说了这么多，现在要正式开发啦：1、点击 目录窗口 右上角的 + 号，创建一个pages文件夹和app.js，app.json，app.wxss文件。创建完成以后就是下面这个样子：图5\r\n2、此时pages文件夹下还没有任何的页面，现在我们的项目需要一个首页，那么就需要在pages目录下新建首页的子文件夹，点击 pages那行的最右边的 +号创建index子文件夹，然后点击index那行的最右边的+号，在这个子文件夹里把那3个文件创建完（鉴于上文发现的bug，这里就先不创建index.json文件，需要时再创建）。这里要注意，3个文件必须和目录同名。完成以后，就是下面这样图6：\r\n3、页面结构现在已经完成了，该有的页面也有了。但是，此时此刻页面上居然什么也没有显示，当然了，因为我们还没写代码呢！好吧，接下来，开始敲~~~代~~~码~~~~上面已经说了，wxml是搭建页面元素的文件。我从子页面的wxml文件开始，来一点一点的编写。写下第一行代码：hello world!写完了，crtl+s保存就行。今天子页面的代码编写工作已经完成了，是不是很惊悚，很难以置信。今天，子页面就写这一行代码。如图7：\r\n4、首页页面虽然我们写好了，但是现在小程序的页面上还是什么都没有显示。别着急！这是因为我们还没有配置。如果想要页面显示出来，就必须在app.json中配置小程序的页面，参数为pages。pages是一个数组，其中的每个元素都是每个页面的相对根目录的路径+文件名，文件名不需要写后缀，小程序运行的时候会自动去寻找.json  .wxml .wxss .js四个文件。数组的第一项表示小程序的初始页面，也就是首页，小程序的每个页面都需要在数组中配置，并且以后小程序页面增加或者减少都需要修改pages数组。现在我们在app.json中写下我们的配置信息，我们把index做为小程序的初始页面，代码如下：{\"pages\": [\"pages/index/index\"]}图8：\r\n注意：配置文件的编写遵循json的格式，参数需要用双引号\"\"括起来，配置文件的开始和末尾需要用大括号\"{\"\"}\"包含。"}
{"title": "stiller：微信小程序教程入门篇兄弟篇：从零开始完整基础流程 ... ", "author": "天下雪", "pub_time": "2016-11-7 10:28", "article_content": "扫描二维码登录进入微信开发者工具\r\n（如下图）新建一个项目，勾选在当前目录中创建 quick start 项目\r\n\r\n\r\n（如下图）就会出现一个HelloWorld的APP实例。\r\n\r\n编辑菜单就是对于项目文件的编辑和修改，项目目录如下：\r\n\r\n其中调试菜单可以看到你对于代码的修改，每一次的修改需要点击重启服务\r\n\r\n同样，在此菜单出可以选择对于不同机型进行不同的适配，默认是iPhone6和wifi环境下，可以对于不同网络环境和屏幕大小进行APP的优化选择。\r\n\r\n项目菜单，可以用来打开或者新建新的项目，并且对于已经开发好的项目可以上传处理。\r\n\r\n新建一个项目，打开一个HelloWorld\r\n\r\n\r\n\r\n\r\n\r\n看一下项目目录的文件。\r\n\r\n\r\n\r\n\r\n这个项目目录中，app.js是小应用的基本入口，包含了对于登录接口的调用，获得用户数据\r\n\r\n\r\n\r\napp.json这个文件是对于这个应用外观的一些配置项，包括字体和导航菜单等样式的配置以及对于路由页面的配置在说一下对于一个完整的页面而言，其实小程序就是对于node和react的打包实现所以基本的一个页面也是采用HTML+CSS得实现方式，那么对于一个页面而言，比如说index页面部分，.wxml，.xss就是包装版的HTML（XML）或是CSS。\r\n那么尝试些一个小的应用\r\n\r\n\r\n先在app.json中进行配置,新增一个新的页面，就直接丢到index下新建一个hello.wxml和一个hello.js ，因为不做特别的用处，所以直接将index.js的代码copy过来就好了同样操作hello.wxml为了区别它和index的不同，给它加上一个<image>标签，随便丢张图片Paste_Image.png\r\n\r\n\r\n再在配置文件app.json中加上一个list作为一个导航链接切换到调试界面点击重启，观看效果\r\n\r\n\r\n\r\n\r\n暂时就到这里吧，可以还不能在真机上进行测试~唉参考文档"}
{"title": "kamidox：微信小程序背后运行原理分析 ", "author": "天下雪", "pub_time": "2016-11-7 10:37", "article_content": "写在前面\r\n微信小程序使用了前端技术栈 JavaScript/WXML/WXSS。但和常规的前端开发又有一些区别：\r\n\r\nJavaScript: 微信小程序的 JavaScript 运行环境即不是 Browser 也不是 Node.js。它运行在微信 App 的上下文中，不能操作 Browser context 下的 DOM，也不能通过 Node.js 相关接口访问操作系统 API。所以，严格意义来讲，微信小程序并不是 Html5，虽然开发过程和用到的技术栈和 Html5 是相通的。\r\nWXML: 作为微信小程序的展示层，并不是使用 Html，而是自己发明的基于 XML 语法的描述。\r\nWXSS: 用来修饰展示层的样式。官方的描述是 “ WXSS (WeiXin Style Sheets) 是一套样式语言，用于描述 WXML 的组件样式。WXSS 用来决定 WXML 的组件应该怎么显示。” “我们的 WXSS 具有 CSS 大部分特性...我们对 CSS 进行了扩充以及修改。”基于 CSS2 还是 CSS3？大部分是哪些部分？是否支持 CSS3 里的动画？不得而知。\r\n\r\n在微信小程序官方文档上，有下面这段话：\r\n\r\n微信小程序运行在三端：iOS、Android 和 用于调试的开发者工具\r\n\r\n在 iOS 上，小程序的 javascript 代码是运行在 JavaScriptCore 中\r\n在 Android 上，小程序的 javascript 代码是通过 X5 内核来解析\r\n在 开发工具上， 小程序的 javascript 代码是运行在 nwjs（chrome内核） 中\r\n\r\n\r\n我们先从开发工具谈起。\r\n开发工具\r\n小程序的 javascript 代码运行在 nwjs 中。nwjs 是什么鬼呢？官方介绍是这样写的：\r\nNW.js (previously known as node-webkit) lets you call all Node.js modules directly from DOM and enables a new way of writing applications with all Web technologies.\r\nnwjs 合并 Browser 和 Node.js 的运行时，可以使用前端开发技术来开发跨平台的应用程序。借助 Node.js 访问操作系统原生 API 的能力，可以开发中跨平台的应用程序。微信小程序开发工具就是使用 nwjs 开发的。如果你是 Mac 用户，进入目录 /Applications/wechatwebdevtools.app/Contents/Resources/app.nw/app 可以看到开发工具的实现代码，当然代码是经过混淆的。网上流行的破解版本开发工具原理上就是修改这里面的代码。\r\n与此类似的，一个更火的项目是 Electron，由 GitHub 推出的，它也是把 Browser 和 Node.js 结合，用来开发跨平台的应用程序。程序员们应该听说过 Atom 这个编辑器界的后起之秀。包括微软拥抱开源社区的编辑器 vscode 也是使用 Electron 开发的。\r\nElectron vs nwjs\r\n这两个平台有什么区别？为什么微信选择 nwjs 呢？我们不妨猜一猜。\r\n从技术角度来讲：\r\n\r\n应用程序入口不同：Electron 入口是一个 javascript 脚本，脚本里要自己负责创建浏览器窗口，加载 html 页面。而 nwjs 的入口就是一个 html 页面，框架自己会创建浏览器窗口来显示这个 html 页面。\r\nNode.js 集成方式不同：Electron 直接使用 Node.js 的共享库，不需要修改 Chromium 代码。而 nwjs 为了集成 Node.js ，需要修改 Chromium 代码，以便在浏览器里能通过 Node.js 访问系统原生 API。\r\nMulti-Context: nwjs 有多个上下文，一个是浏览器的上下文，用来访问 Browser 相关 API，比如操作 DOM ，另外一个是 Node 上下文，用来访问操作系统 API。Electron 没有使用多个上下文，对开发者更友好。\r\n\r\n从应用角度来讲：\r\n\r\n打包后的文件大小：Electron 打包后文件会比 nwjs 小不少。一个 18M 的程序，使用 Electron 打包后是 117M，而使用 nwjs 打包后的程序是 220M。微信小程序开发工具打包后是 219M (v0.10.102800)。没有亲测，评价来源参考文档。\r\n代码保护：Electron 只支持代码混淆来保护，而 nwjs 把核心代码放在 V8 引擎里，不但可以保护代码，还可以提高执行效率。\r\n开源社区活跃度：Electron 应该是完胜的。看看使用 Electron 构建的应用程序就知道了。而据说 nwjs 的开发文档有些都没有及时更新。\r\n应用程序启动时间：Electron 会稍微快一点。没有亲测，评价来源参考文档。\r\n\r\n从这个分析猜测，微信选择 nwjs 的原因可能是出于代码保护。毕竟开发工具可以上传小程序，有些接口和数据需要比较严密的保护。哪位大牛可以挖挖看哪些代码被保护起来了。\r\n真机运行环境\r\n下面内容完全是猜测的，如有言中，实属运气。\r\n微信小程序的运行环境应该更类似 ReactNative 之类，而不是纯 Html5。两者最大的不同在于，ReactNative 的界面是由原生控件渲染出来的，而 Html5 的界面是由浏览器内核渲染出来的。两者在性能上有较大的差异，感兴趣的可以参阅我的另外一篇文章《跨平台 App 开发技术方案汇总》。\r\n原理上，小程序是如何在微信 App 里运行的呢？\r\n\r\n微信 App 里包含 javascript 运行引擎。\r\n微信 App 里包含了 WXML/WXSS 处理引擎，最终会把界面翻译成系统原生的控件，并展示出来。这样做的目的是为了提供和原生 App 性能相当的用户体验。\r\n\r\n我们来意淫一下小程序加载运行的过程：\r\n\r\n用户点击打开一个小程序\r\n微信 App 从微信服务器下载这个小程序\r\n分析 app.json 得到应用程序的配置信息（导航栏，窗口样式，包含的页面列表等）\r\n加载并运行 app.js\r\n\r\n加载并显示在 app.json 里配置的第一个页面\r\n\r\n这个只是从开发者眼中看到的一个简化版的过程，实际过程应该比这要复杂得多，涉及到浏览器线程（就是运行我们的逻辑层代码 app.js 等的线程）和 AppService 线程之间的交互。从官方网站上的一个图片可以看出端倪：\r\n生命周期\r\n\r\n至于微信 App 是如何与小程序的逻辑层 javascript 交互的呢？可以简单地归纳如下：\r\nJavaScript 是脚本语言，可以在运行时解释并执行。微信 App 里包含了一个 JavaScript 引擎，由它来负责执行逻辑层的 JavaScript 代码。那么 JavaScript 调用的小程序相关 API 怎么实现的呢？答案是最终会被翻译成实现在微信 App 里的原生接口。比如开发者调用 wx.getLocation(OBJECT) 获取当前地理位置，微信 App 里的 JavaScript 引擎在执行这个代码时，会去调用微信 App 里实现的原生接口来获取地理位置坐标。\r\n感兴趣的朋友可以阅读我之前推荐过的一篇文章《React Native 从入门到原理》。文章分析的虽然是 ReactNative，但实际上原理是相通的。\r\n总结\r\n微信小程序最大的好处是不需要做设备适配，只要微信能运行，小程序就能运行。小程序虽然是一个封闭形态下的前端开发技术，但借助微信的巨大影响力，几乎所有人都在往里面冲。微信小程序太火了，内测火，公测更火。内测刚出来，就有人用微信小程序实现了商城，并开源。感叹一下：你的热情，就像一把火，燃烧了整个沙漠。\r\n作为开发者，提几个不足：\r\n\r\n不支持从 node_modules 中加载模块。这样无形中就把 npm 排除在外了。从开发生态角度，这个应该是微信小程序下一步要重点解决的问题吧。\r\n开发工具自带的代码编辑器还是太简陋了。不知道为什么微信要重复发明轮子。理论上，给流行的代码编辑器 (sublime/atom/vscode etc.) 开发个插件。然后用户直接到小程序后台上传提交审核就好了。程序员是挑剔到近乎偏执的物种，代码编辑器又是程序员时刻打交道的工具，要做好实属不易。\r\n\r\n参考文档\r\n\r\nhttps://github.com/electron/electron/blob/master/docs/development/atom-shell-vs-node-webkit.md\r\nhttps://www.akawebdesign.com/2015/05/06/electron-vs-nwjs/\r\nhttps://www.akawebdesign.com/2015/11/02/electron-vs-nwjs-part-2/"}
{"title": "手机预览微信小程序demo流程 ", "author": "天下雪", "pub_time": "2016-11-4 14:07", "article_content": "微信小程序公测了，喜大普奔。终于可以在自己的手机上看到自己的作品了。然而有很多小伙伴还不知道怎样在自己的手机上预览之前下载的那些demo，这里天河就为大家带来手机预览微信小程序的流程。首先大家需要注册一个微信小程序开发号。这里需要声明的是，这个开发号不能以前的——订阅号、服务号、企业号等，也不能用以前用过的邮箱，这就比较坑了，公司光注册微信的这些乱七八糟的东西就申请了6、7个邮箱了，而且全部认证了，7*300=？我算算……\r\n目前小程序开发号不支持个人申请，必须是企业、政府、组织等。具体的注册流程请到这里（http://www.wxapp-union.com/portal.php?mod=view&aid=264）\r\n注册成功后，等待微信验证，就可以进到小程序主页了。它是这个样子的。\r\n\r\n点击左边列表的设置按钮，进入到设置页面。\r\n\r\n这里需要填写小程序的基本信息——小程序名称等各种信息，但是天河还没有想好做一个什么样的小程序，所以暂时没填。\r\n这个也没有影响，因为我们只做预览调试，并不需要现在就确定小程序到底做什么。\r\n点击上面的开发设置标签。\r\n\r\n看到了么？你已经拥有之前百般折磨你的appId了。是不是很6？\r\n打开你的微信小程序开发工具，点击添加项目\r\n\r\n填入你的appID，然后按照之前的方法导入你下好的demo（http://www.wxapp-union.com/forum ... =158&extra=page%3D1）\r\n然后添加该项目，点击左边菜单的“项目”按钮。\r\n\r\n然后可以看到如上的画面，记得是点左边的“项目”菜单哦。然后点击预览按钮，如上图所示，会有一个上传中的过程，上传成功后，会弹出一个二维码的框。\r\n\r\n用开发人员（就是你登陆这个开发工具时，扫描登陆二维码用的那个微信）的微信扫描该二维码，就可以在手机上预览你的demo啦，怎么样？第一次在手机上体验小程序，是不是感觉很独特啊？$('swf_L45').innerHTML=AC_FL_RunContent('width', '520', 'height', '390', 'allowNetworking', 'internal', 'allowScriptAccess', 'never', 'src', encodeURI('http://player.youku.com/player.php/sid/XMTgwNTEyODU4NA==/v.swf'), 'quality', 'high', 'bgcolor', '#ffffff', 'wmode', 'transparent', 'allowfullscreen', 'true');\r\n对了，有一点要提示一下，按照（http://www.wxapp-union.com/portal.php?mod=view&aid=260）这里的内容下载最新版的微信客户端，才可以预览微信小程序哦。"}
{"title": "豆豆尖的入门之旅：可爱的小程序《一》 ", "author": "天下雪", "pub_time": "2016-11-4 16:28", "article_content": "本人真的是前端的入门级菜鸟，但公司的技术大大们对我都好好，给我很多锻炼机会，因此我决定好好学习总结，随时记录自己的心得，争取在几年内达到一个让自己满意的水平。小程序这个东西确实比较新，但是写起来蛮有意思，比起Vue这种框架好理解太多！福音哪~~~       感觉实在没法把这东西写个教程，暂且算成自己的开发心得？这里主要讲一下刚开始接触小程序需要知道的基本知识，话不多说，开搞哈哈。。我们知道开发小程序前首先要获取微信小程序的APPID，不然，真的就只能看文档玩儿啦~然后还要安装个微信开发者工具，就可以开始创建项目了，如下：\r\n这里提一句，如果是多人开发的话，开发目录最好是统一将代码文件放在桌面。添加完后，左侧导航栏可以选择项目进行预览，调试，编辑代码（也可以在自己本地编译器编辑），纯属吐槽一下自带的编译器是真不好用→_→左侧导航条\r\n代码部分：微信小程序已经存在初始化的一些文件：app.js、app.json、app.wxssapp.js是小程序的脚本代码，这个文件中可以监听并处理小程序的生命周期函数、声明全局变量，调用丰富的API：app.js\r\n可以看到，wx.login( )  wx.UserInfo( ) 等都是开放接口，获取用户登录的相关信息。app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。但需注意该文件不可添加任何注释：app.json\r\napp.wxss 是整个小程序的公共样式表:app.wxss\r\n创建：接下来说说具体的创建页面：我们会在pages下新建项目文件夹，比如index文件夹，里面包含index.js， index.wxml，index.wxss， index.json （wxml可看做html,wxss可看做css）。需要强调的是，index.wxml 里搭建页面结构时，基本用<bock>, <view>（块级）,<text>（行内）,<image>等标签组成，同时可以在上面绑定数据和交互处理函数。而index.json可对该页做一些配置，例如窗口title：{\"navigationBarTitleText\": \"首页\"}还有像下面这种底部菜单导航条的配置：底部导航\r\n底部导航\r\nindex.js里，生命周期运作流程如下：index.js\r\n路由：开发中很核心的一个东西就是路由了，不需要我们配置，微信已经封装得棒棒的三种跳转方法：wx.navigateTo(object)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。wx.redirectTo(object)：关闭当前页面，跳转到应用内的某个页面。wx.navigateBack()：关闭当前页面，回退前一页面大家看过微信文档应该知道，微信限制了保留页面的跳转(navigateTo)只能有5层，所以当超过5层时，就可以考虑(redirectTo)即关闭当前页面的跳转了。"}
{"title": "_Wake：新手入门攻略《一》视图与渲染，点击事件 ", "author": "天下雪", "pub_time": "2016-11-4 17:01", "article_content": "一：视图与渲染1.组件使用     组件的使用非常简单，从开发者文档中可直接复制到 wxml 文件中     例： wxml文件：<button type=\"primary\" > 登陆按钮 </button>2.数据绑定，使用双花括号  {{}} ，在页面实例Page的 data中设置数据data: {\r\n        text : \"登陆按钮\"\r\n}<button type=\"primary\" > {{text}} </button>3.点击事件        1>组件标签中添加 bindtap (绑定-点击)<button type=\"primary\" bindtap=\"btnClick\"> {{btnText1}} </button>2>在页面实例Page中 添加方法\r\nbtnClick :function () {\r\n        console.log(\"按钮被点击，打印日志\")\r\n        this.setData{ text : \"登陆按钮已被点击\"}\r\n}\r\n4.渲染标签        1>判断是否显示，true为显示,false不显示<view wx:if=\"{{bool}}\"> 1 </view><view wx:else > 2 </view>2>循环\r\nwx:for=\"{{data}}\"      wx:for-itme=\"vo\"(若不设置，默认为item)\r\n<view wx:for=\"{{news}}\" wx:for-item=\"a\" wx:for-index=\"b\">\r\n{{a}} {{b}}\r\n</view>\r\n5.模版方法1:<include src=\"../templates/header\"  />等同于复制模版文件中的代码,模版中直接使用页面中的变量\r\n方法2:          设置模版:模版1 - {{text}}<template name=\"footer1\">模版1 - {{text}}</template>          模版引入：\r\n<import src=\"../templates/footer />\"\r\n<template is=\"footer1\" data=\"{{text : '给模版传的文本'}}\"\r\nis=\"footer1\" data=\"{{text : '给模版传的文本'}}\"二：点击事件1.点击事件       bindtap 绑定事件 ：所有层都可触发       catchtap 绑定事件： 只有最顶层可触发2.事件event      currentTarget:                          当前组件      target：                                    事件源组件      currentTarget.dataSet:            数据     \r\n  dataset:Object\r\n  id:\"100\"\r\n  title:\"新闻标题\"\r\n3.输入框绑定输入事件  bindinput ,     取出输入框当前的 值   this.setData({expressNu: event.detail.value})\r\n4.回调函数中，无法获取  this\r\nbtnClick: function() {\r\n    var thispage = this; //..\r\n    app.getExpressInfo(this.data.expressNu,function(data) {\r\n      //把值传给当前页面的变量\r\n      thispage.setData({expressInfo: data});\r\n    })\r\n  }"}
{"title": "_Wake：新手入门攻略《二》配置及生命周期，布局基础&样式基础 ... ", "author": "天下雪", "pub_time": "2016-11-4 17:20", "article_content": "一、app生命周期\r\nApp({\r\n  onLaunch: function () {\r\n    //App Launch ,生命周期函数--监听小程序初始化\r\n    // 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）\r\n  },\r\n  onShow: function () {\r\n    // onShow,生命周期函数--监听小程序显示\r\n    // 当小程序启动，或从后台进入前台显示，会触发 onShow\r\n  },\r\n  onHide: function () {\r\n    // onHide,生命周期函数--监听小程序隐藏\r\n    // 当小程序从前台进入后台，会触发 onHide\r\n  }\r\n})\r\n二、page生命周期\r\nPage({\r\n  data:{\r\n    //页面的初始数据\r\n  },\r\n  onLoad:function(options){\r\n    // 生命周期函数--监听页面加载\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n    // 一个页面只会调用一次。\r\n  },\r\n  onReady:function(){\r\n    // 生命周期函数--监听页面初次渲染完成\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 生命周期函数--监听页面显示\r\n    // 页面显示,每次打开页面都会调用一次。\r\n  },\r\n  onHide:function(){\r\n    // 生命周期函数--监听页面隐藏\r\n    // 页面隐藏,当navigateTo或底部tab切换时调用。\r\n  },\r\n  onUnload:function(){\r\n    // 生命周期函数--监听页面卸载\r\n    // 页面关闭,当redirectTo或navigateBack的时候调用。\r\n  }\r\n})\r\n三、页面跳转1.wx.navigateTo ，压栈式跳转，跳转后首页隐藏 onHide，自带返回2.wx.redirectTo ,   跳转后 首页关闭 onUnload， 不带返回3.tabBar跳转，页面相互切换 onShow 与 onHide4.页面传值：跳转链接url后添加参数 url: '../logs/logs?id=1'表示传 id=1 的参数\r\n补充： 跳转方法可以通过 bindtap=“click\"绑定点击事件来触发，也可以直接写在wxml中<navigator url=\"../logs/logs?id=23&title=标题>也可以添加 redirect执行 redirect 跳转<navigator url=\"../logs/logs?id=23&title=标题\" redirect>四、布局基础\r\n\r\nflex容器属性 flex-direction： 决定元素的排列方向,同时决定主轴与交叉轴的方向  `row`：横向排列，`column`：纵向排列\r\n flex-wrap： 决定元素如何换行 (排列不下时)  `nowrap`：不换行，`warp`：自动换行，`reverse`：反转换行\r\n flex-flow： flex-direction和flex-wrap的简写 例如： `flex-flow:row wrap;`\r\n justify-content： 元素在主轴上的对齐方式` center`: 在主轴上居中对齐，\r\n `flex-start(flex-end)`：从左(右)开始对齐\r\n `space-around`：每个元素的padding相同\r\n `space-between`：每个元素间隔相同\r\n align-items： 元素在交叉轴的对齐方式 `flex-start(flex-end)`：从上(下)开始对齐\r\n `baseline`：根据元素内文本对齐\r\n\r\nflex元素属性 `flex-grow`：当有多余空间时，元素的放大比例\r\n `flex-shrink`： 当空间不足时，元素的缩小比例\r\n `flex-basis`： 元素在主轴上占据的空间\r\n `flex`： 是 grow、shrink、basis的简写\r\n      例如：`flex: 0 1 50px;`\r\n `order`定义元素的排列顺序,默认为0\r\n `align-self` 定义元素自身的对齐方式\r\n\r\n相对定位和绝对定位 相对定位的元素是相对自身进行定位，参照物是自己。\r\n例如：position: relative;      // 相对定位\r\nleft: 150rpx;               // 与原位置的左端距离150\r\ntop: 50rpx;                // 与原位置的上端距离50\r\n 绝对定位的元素是相对离它最近的一个已定位的父级元素进行定位。\r\n例如：position: absolute;      // 绝对定位\r\nleft: 50rpx;                // 与已定位的父级元素左端距离50\r\ntop: 50rpx;                // 与已定位的父级元素上端端距离50\r\n\r\n\r\n五、样式基础\r\n 1. 尺寸\r\n  width: 228rpx;   // 宽度\r\n  height: 228rpx; //  高度\r\n  min-width:     //最小宽度\r\n  max-width:    //最大宽度\r\n  min-height:   //最小高度\r\n  max-height:  //最大高度\r\n  ...\r\n  2. 背景\r\nbackground-color: darkcyan;   //背景颜色\r\n...\r\n  3. 边框\r\n  border-radius: 20%;    //边框圆角\r\n  border-width: 5px;      //边框宽度\r\n  border-color: #ddd;    //边框颜色\r\n  border-style: solid;     //边框样式\r\n  ...\r\n  4. 边距\r\nmargin: 20rpx;      //外边距，边框距离父级元素的距离\r\nmargin: 10rpx 20rpx 30rpx 40rpx;    // 上右下左\r\npadding: 20rpx;    //内边距，边框距离元素的距离\r\npadding: 10rpx 20rpx 30rpx 40rpx;    // 上右下左\r\n  5. 文本\r\nfont-size: 30px;    //字体大小\r\n  6. 其它(列表、内容、表格...)\r\nPS：样式选择器 与CSS选择器相同，部分不可用"}
{"title": "微信小程序学习《三》：配置详解 ", "author": "天下雪", "pub_time": "2016-11-4 17:40", "article_content": "一、全局配置1.官方的文档中就有对小程序配置的专门讲解，我们可以先到官网看下相关的讲解方便我们更好的了解“配置”这部分的知识点。官方的网址：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html2.因为两个星期没学小程序了，刚打开，发现开发工具更新了，可以直接在“编辑”界面中看到页面的变化了，这样就方便了很多，而且部分组件的bug也进行了修复，总之，小程序在逐步的完善中，很期待它正式发布之后，所带来的变化。回归正题，app.json文件来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。之前文章的简介中，也对app.json文件进行过简单的介绍，然后刚看了下官方的文档，介绍的好详细：3.虽然官方有详细的解析，而且也难，本来想偷懒看完官方文档就过了的，最后还是决定都操作一遍吧，毕竟实践才是验证真理的唯一方式。4.window属性跟着文档玩玩5.tabBar如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。自己也写一个：看下具体的效果：6.networkTimeout可以设置各种网络请求的超时时间。7.最后需要注意的一点是，跟android的编程原理甚至是其他的编程原理一样，对单个页面设置的样式是可以覆盖全局样式的Demo下载地址：Demo3.zip"}
{"title": "toBeMN：微信小程序填坑之路《一》POST请求，图片处理 ", "author": "天下雪", "pub_time": "2016-11-5 10:22", "article_content": "一：POST请求声明一下，本小白只是在敲代码的过程中遇到问题后网上找到的解决方法，所以请注意我只是代码的搬运工。。。对于小程序的get请求就不多说了，因为文档都有例子ctrl+c ctrl+v就好了而对于POST请求就有一些坑了，有三点需要注意的1.’Content-Type’: ‘application/json’用在get请求中没问题.POST请求就不好使了.需要改成: “Content-Type”: “application/x-www-form-urlencoded”2.一定要加上method: “POST”，不然就GG了3.data: { cityname: “厦门”, key: “1430ec127e097e1113259c5e1be1ba70” }写成json格式这样也是请求不到数据的.需要转格式，下面的例子里面就在util.js文件中写好了转格式的方法json2Form()，只要调用就好了上例子：首先呢就是目录结构啦其次在看看转格式的json2Form方法注意下面的exports不要忘了写index.wxml然后是index.js没法全截图，分两张图片效果二：图片处理微信小程序的一大特点就是“小”，小到什么程度呢，看图就知道了那小程序为什么要这么小呢，因为他想做到即扫即用，即用即走的理念，宏观的说微信小程序是不需要下载，通过扫码等方法直接在微信平台上使用的软件。其实微观上，在第一次使用软件的时候还是会下载下来的，之后就不会在下载。而在这个4G、wifi满天飞的时代，1M的软件下载能需要几秒，所以可以理解成是一个不需要下载就能使用的软件。废话说完了进入正题，既然小程序限制了项目的大小，而项目不可避免的会用到图片、音频、视频等相对来说的大东西，要怎么处理呢。我知道三个小方法仅供参考1.将图片转成base64编码，可以使用代码来转换，当然我才不愿意特意写代码转，我懒，献上一个在线图片转base64的地址：http://tool.css-js.com/base64.html这会得到一个很长很长很长的字符串，但是比较一下，是图片占容量还是字符串占容量，我就放心的使用了base64的格式data:[][;charset=][;base64],在html中使用的方法<img src=\"data:image/jpg;base64,/9j/4QMZRXhpZgAASUkqAAgAAAAL....\" />在css中使用的方法.demoImg{ background-image: url(“data:image/jpg;base64,/9j/4QMZRXhpZgAASUkqAAgAAAAL….”); }2.使用外部链接推荐使用七牛，不仅能弄图片，还能把本地的音频（试验过可以）、视频（我猜可以）等转成外部链接，这就更小了，一个链接解决这些占空间的资源，大家不妨学习学习3.如果你有强迫症一定要看到图片那就压缩图片吧，我这里有一个压缩图片的网址，压缩的效果相当显著https://tinypng.com/这就是三种小方法，仅供参考仅供参考仅供参考，不说三遍我怕被人喷一脸"}
{"title": "wyfeng1：微信小程序简单入门 ", "author": "天下雪", "pub_time": "2016-11-5 11:03", "article_content": "参考文档：https://mp.weixin.qq.com/debug/wxadoc/dev/index.html1  创建项目开发者工具安装完成后，打开并使用微信扫码登录。选择创建“项目”，填入上文获取到的 AppID ，（无appid直接选择）设置一个本地项目的名称（非小程序名称），比如“我的第一个项目”，并选择一个本地的文件夹作为代码存储的目录，点击“新建项目”就可以了。为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择“是”，开发者工具会帮助我们在开发目录里生成一个简单的 demo。 2 创建页面目录结构我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。utils：入口文件 3 逻辑层代码结构index.wxml是xml格式，用于界面布局,类似于html，很多标签直接使用的就是html标签；<view class=\"warp\"><view class=\"title\">aaaaaaa</view><view class=\"cTime\">2016-10-25 14:28</view><view class=\"img\"><image src=\"../../images/1.png\" class=\"in-img\" background-size=\"cover\" model=\"scaleToFill\"></image></view><view class=\"content\">驻马店位于河南中南部北接漯河南临信阳地处淮河上游的丘陵平原地区,,因历史上南来北往的信使,官宦在此驻驿歇马而得名,驻马店承东启西,贯南通北,素有豫州之腹地,天下之最中的美称.</view><view class=\"close\" bindtap=\"closepage\"> 返回 </view></view>view标签相当于div；index.wxss是css样式定义，语法与css是一样的;/**app.wxss**/.container {height: 100%;display: flex;flex-direction: column;align-items: center;justify-content: space-between;padding: 200rpx 0;box-sizing: border-box;}index.js是js文件，定义了事件处理过程(是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。)。将界面布局与处理代码分离，看起来比较干净简单。//app.jsApp({onLaunch: function () {//调用API从本地缓存中获取数据var logs = wx.getStorageSync('logs') || []logs.unshift(Date.now())wx.setStorageSync('logs', logs)},getUserInfo:function(cb){var that = this;if(this.globalData.userInfo){typeof cb == \"function\" && cb(this.globalData.userInfo)}else{//调用登录接口wx.login({success: function () {wx.getUserInfo({success: function (res) {that.globalData.userInfo = res.userInfo;typeof cb == \"function\" && cb(that.globalData.userInfo)}})}});}},globalData:{userInfo:null}})app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。{\"pages\":[\"pages/index/index\",\"pages/logs/logs\"],\"window\":{\"backgroundTextStyle\":\"light\",\"navigationBarBackgroundColor\": \"#fff\",\"navigationBarTitleText\": \"WeChat\",\"navigationBarTextStyle\":\"black\"}}注册页面每个页面必须在此处注册，不然无法编译做个小页面1，建一个新页面建.wxml文件<view class=\"about\"><view class=\"about-wei\"><view class=\"about-img\"><image src=\"\" class=\"in-img\" background-size=\"cover\" model=\"scaleToFill\"></image></view><view class=\"about-title\">千峰科技有限公司</view></view><view class=\"about-content\">驻马店位于河南中南部北接漯河南临信阳地处淮河上游</view><view class=\"about-addr\"><view class=\"about-tab\">联系方式</view><view>地址:</view><view>联系电话：</view><view>商务合作：</view></view></view>建.js(必须有）//获取应用实例var app = getApp()Page({data: {motto: 'Hello',userInfo: {}},//事件处理函数bindViewTap: function() {wx.navigateTo({url: '../logs/logs'})},onLoad: function () {console.log('onLoad')var that = this//调用应用实例的方法获取全局数据app.getUserInfo(function(userInfo){//更新数据that.setData({userInfo:userInfo})})}})样式控制.wxss.userinfo {display: flex;flex-direction: column;align-items: center;}.userinfo-avatar {width: 128rpx;height: 128rpx;margin: 20rpx;border-radius: 50%;}.userinfo-nickname {color: #aaa;}.usermotto {margin-top: 200px;}关于样式：尺寸单位rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 外部样式引入：使用语句可以导入外联样式表，后跟需要导入的外联样式表的相对路径，用表示语句结束。示例代码：/** common.wxss **/.small-p {padding:5px;}/** app.wxss **/@import \"common.wxss\";.middle-p {padding:15px;}内联样式：style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。<view style=\"color:red;\" />注意：小程序里面对于代码规范很严格，空标记必须有结束标记，结束时分号等必须写完整，不然报错全局样式与局部样式定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。底部tab\"tabBar\": {\"list\": [{\"pagePath\": \"pages/lists/lists\",\"text\": \"首页\",\"iconPath\":\"images/1.png\",//默认图片路径\"selectedIconPath\":\"images/2.png\"//点击时图片路径}, {\"pagePath\": \"pages/aboutme/aboutme\", \"text\": \"关于我们\",\"iconPath\":\"images/3.png\",\"selectedIconPath\":\"images/4.png\"}]}最多有五个tab;在app.jsop里面进行页面注册{\"pages\":[\"pages/obtume/obtume\",\"pages/index/index\",\"pages/logs/logs\"],然后进行编译页面就出来了2，替换数据把页面里面的数据换成非固定的初始化数据初始化数据将作为页面的第一次渲染。data 将会以 JSON 的形式由逻辑层传至渲染层，所以其数据必须是可以转成 JSON 的格式：字符串，数字，布尔值，对象，数组。示例：<view>{{text}}</view><view>{{array[0].msg}}</view>  Page({data: {text: 'init data',array: [{msg: '1'}, {msg: '2'}]}}).js文件更改var app = getApp()Page({data: {img: '../../images/logo.png',title: \"千峰科技有限公司\",intro:\"驻马店位于河南中南部北接漯河南临信阳地处淮河上游\",contab:\"联系方式\",address:\"北京昌平区老牛湾10号\",mobile:\"0755-23729769\",email:\"weiphp@weiphp.cn\"},.wxml更改<view class=\"about\"><view class=\"about-wei\"><view class=\"about-img\"><image src=\"{{img}}\" class=\"in-img\" background-size=\"cover\" model=\"scaleToFill\"></image></view><view class=\"about-title\">{{title}}</view></view><view class=\"about-content\">{{intro}}</view><view class=\"about-addr\"><view class=\"about-tab\">{{contab}}</view><view>地址: {{address}}</view><view>联系电话：{{mobile}}</view><view>商务合作：{{email}}</view></view></view>然后刷新就OK了"}
{"title": "伊尔今夏：iOS 开发的微信小程序初体验 ", "author": "天下雪", "pub_time": "2016-11-5 11:28", "article_content": "本职是iOS 移动开发的，最近研究了一下比较火的微信小程序。前端0基础，研究也不是很透彻，所以大家一定要保持怀疑的态度看这一篇分享。由于是本职是iOS开发所以在开发小程序的时候也会按照之前iOS开发的一点点经验来搭建小程序。所以主要是从几个应用框架层来比较说明一下iOS 和 微信小程序之间的异同点。理论基础来自官方文档再加上自己一点点实践（从图可以看出这渲染跟原生App很相像了）微信小程序\r\n1.网络层       网络层：这是必要的基础建设。小程序：上图是小程序的后台服务器配置，必须要事先配置好服务器，否则在程序中是无法正常请求的。一个小程序同时只能有一个 WebSocket连接，并且同时也只能有5个网络请求连接。请求的服务器地址必须是HTTPS协议的，看了后台服务器地址配置，上传和下载文件的服务器也是单独设置。很重要的一点也令人头疼的是小程序是不支持H5页面跳转也是不支持cookie。iOS ：苹果规定从2017年1月起App内的网络链接强制使用HTTPS协议的，iOS 可以设置网络请求数的。通过参数maxConcurrentOperationCount 来设置请求数，但是也不是任意设置的，在2G网络一次只能维持1个链接，3G是2个，在WiFi和4G网络环境下是不限链接数的，这里说明下并不是并发链接数越多越好，越多占用带宽越高，请求时间反而会延迟。所以这里对小程序同时有5个网络请求有点疑惑，是否不区分网络？这里数据回调处理比较类似。（小程序有点类似block)2.本地持久化存储/数据层小程序：为每一个小程序提供了10M的缓存，用来存储数据和文件，现在是内测阶段，不知道以后会不会扩容。数据：看官方的API目前只支持”key-data”的简单键值存储以及set/get/remove/clear数据操作，还不支持数据库。文件：在文件存储方面，小程序是默认都是临时路径，本次程序运行期间可以正常读取，退出程序后就删除。所以如果要持久存储，需要再调用wx.saveFile放到本地存储，下次打开程序还能正常访问到。iOS：为每一个App创建一个沙盒，沙河有3个文件夹Document/Library/tmp，根据这个文件夹的命名大概就可以猜出它们不同用途。iOS 这边存储方案就种类繁多，品种丰富。Core Data、SQLite、NSUserDefaul、keychain、plist、archive根据自己的需求选取数据存储方案。这里只是简单说明一下iOS 持久化存储，其实它是非常庞大的一个点，iOS是一个小型的操作系统，存储和文件操作是有一套完整的方案。3.业务层/UI层\r\n        在小程序中一个完整的页面page是由.js/.json/.wxml/.wxss这四个文件组成，每个界面.js .wxml是必选项其它两项选填。iOS并没有这样的强制规定，一个界面可以完全在一个UIViewController里面完成，复杂的页面iOS也是可以通过类似的文件拆分使得结构更加清晰明了。.js：页面逻辑\r\n         iOS中一个完整界面可以只有一个UIViewController，在UIViewController中实现了页面的大部分逻辑代码，在可读性可以规范一下页面的代码布局，属性初始化，生命周期函数，回调函数，事件处理，自定义方法等。代码结构布局大概是这样子，但是也不一定所有的UIViewController都要有。同样小程序中也有同样结构数据，生命周期，控件绑定事件，自定义方法。这样可以提高代码的可维护性和可读性。毕竟小程序还没有 control + 6这样的快捷键。页面代码布局规范\r\n看到上面对比，发现两者还是很相似的，这样对比看还是有助我们了解小程序。简单看生命周期函数，是不是很眼熟，很熟悉，很亲切.....生命周期\r\n.json 公共配置\r\n        在.json文件中可以配置导航栏的样式，tarBar的配置，刷新控件，网络超时时间等。一个小程序只有一个总的app.json公共配置，其它的page也有.json文件但是只能配置导航栏的样式，其它都继承app.json里面的公共配置。很重要的一点就是你创建所有的.js的文件都需要添加到app.json中。不添加编译器也不会报错，但是你会发现跳转到某个页面一直不成功一直显示不出来，这个时候就要检查一下有没有在app.json中添加改文件了。.wxml 页面结构.wxss 页面组件样式        这个.wxml可以想象成在UIViewController里面放一些控件，比如这个页面有多少图片，按钮，已经控件之间的层级关系，绑定事件等。但是呢，在.wxml里面不能设置图片的大小，圆角，位置。这时候.wsxx的作用就体现出来了，.wxss主要是用来描述.wxml组件的样式。举个例子：在App 中应用广泛的UITableView在小程序中是怎么实现的\r\n小程序实现UITableView\r\n       小程序提供了很多UI组件，基本可以满足大部分界面需求。这些组件基本都能在iOS中找到相对应的。在小程序中这些组件是有一些共同属性，同时每个组件又有自己一些独有的属性。跟在iOS 中很多UI控件都继承同一个大类UIView是一样的道理的。组件列表\r\n4.动画\r\n canvas：画布。这是要单独拿出来讲，动画这个东西呢，真是一言难尽，水太深，有点淌不动。iOS 动画框架Core Animation 功能也是很庞大，有兴趣可以看《iOS Core Animation: Advanced Techniques》5.消息通知      小程序消息通知并没有实践实现过，只能是看着文档来瞎猜了。先看下iOS客户端关于push消息通知的实现。APNs\r\n\r\niOS ：主要是devToken,Provider,APNs这三者之间的交互。App向注册通知之后系统会返回一个devToken，然后将这个devToken上传服务器Provider。Provider将要发送给用户的消息和devToken发送给APNs，最后由APNs向用户设备发送通知消息（iOS 10 新增了Notification Extension的扩展，使得Local Notification和Remote Notification都变得非常丰富。）小程序：小程序这边并不能像App那样发送通知，但是提供了另一种通知方式-模板消息。这边使用AppID 和 AppSecret 注册获取access_token。这个access_token是通过中控服务器来获取和刷新。所以我想把access_token看作devToken,中控服务器就是Provider,微信下发模板消息的服务器就是APNs。小结：devToken是客户端获取上传到Provider服务器，这边access_token是中控服务器来维护。还有小程序中模板消息的发起方还是要求证一下，跟微信服务器交互的是中控服务器还是小程序本身？具体模板消息参数设置官方API6.支付\r\n        第三方支付接入客户端都没有接触过。但是在微信小程序里面直接呼起微信支付应该比较简单，小程序也提供了接口，去看官方API吧。7.开发工具\r\n       开发工具调试页面中wxml类似于Reveal界面调试工具，可以动态查看和修改应用程序的界面，对于我这种新手学习和调试CSS各控件的样式觉得非常的方便。开发工具还在不断更新，补充一些新的功能，更新API，要是看到API跟本文有所不同请以官方API文档为准，写这篇文章的时候官方又有新的更新....8.总结\r\n       小程序是个小而美的东西，某些方面可以渲染的跟native一样，也提供了消息通知和本地存储的能力，完全可以替代一些对native要求不是很高的App。但从微信限定的10M内存，页面层级不能超过5层来说，小程序也不适合太过深度的用户体验。"}
{"title": "eiun ：Android 开发的微信小程序初体验 ", "author": "天下雪", "pub_time": "2016-11-5 11:57", "article_content": "Android最近不好混了，打算学学微信小程序，在这方面我绝对是很菜的菜鸟，只是大概看了遍JS 的基础语法，最基础那种，就开始想着写小程序了，因为我一直都觉得实践才是最好的学习方法。\r\n说点题外话，Android的知识我就是这样学过来的，现在也能做做应用，一般的功能啊什么的没问题，公司里面写代码速度，对接口的速度啊应该也不差，但是咧，java基础就真的不好了，一般面试的时候问到各种知识都答不上来，所以啊会做有时候并没有什么用，会说有时候真的很好用···但是现在有空再回去翻一遍java的话估计会好很多，等我有耐心的时候吧。\r\n扯远了，回来继续，打算先做点东西出来，回头再继续补JS和CSS，H5的话其实在小程序里用的不是特别多，因为控件都换成自带的了。\r\n0基础：先看点JS语法咯，大概看一遍也好，再过一遍微信的官方文档，我觉得开发工具那里仔细看看吧，对着开发工具看，记得把demo也下了，运行来到处戳戳就好。\r\n微信官方文档\r\n小程序开发工具下载地址\r\n下面讲讲基本配置\r\n小程序demo目录\r\n\r\n这个就是小程序目录了，app.js文件是全局配置，现在不用管\r\napp.json比较重要，页面配置啊，什么的都在里面，一会有用到\r\napp.wxss全局CSS的配置\r\n\r\n\r\n先新建个目录，比如叫 test目录下新建两个文件，js和wxml是必须的，其它的不管建好了以后就这样子\r\n\r\n\r\n文字里面是空的，啥都木有\r\n先打开 wxml 文件随便加个东西\r\n<text>text{{me}}</text>\r\n就加个文本吧，text是文字后面双括号的是变量，可以在js里面配置\r\n接着js里面打个page按确定就自动生成基本函数了\r\nPage({  data:{    me:\"文字\"  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数    String2  },  onReady:function(){    // 页面渲染完成    String3  },  onShow:function(){    // 页面显示    String4  },  onHide:function(){    // 页面隐藏    String5  },  onUnload:function(){    // 页面关闭    String6  }})\r\nme:\"文字\"这个是我加上去的，绑定wxml里面的那个变量，很容易理解。\r\n哦很重要的一点，改了数据后记得按 ctrl+s去保存才有用，表示用AS过来的新手很不习惯，每次更改都要手动保存，难道不能自动保存么。\r\n最后要加上很重要的一点就是在上文说过的那个app.json里面配置一下\"pages/test/test\"\r\n\r\n别忘了前面要加上 逗号 \r\n在自动生成的index.js里面加个跳转，点击头像跳到自己刚配置的页面url: '../test/test'\r\n\r\n好了，运行一下\r\n\r\n\r\n最最最基本的效果了，后面的话去看看官方文档就慢慢会了，我也在努力学习中~"}
{"title": "豆豆尖的入门之旅：可爱的小程序《二》 ", "author": "天下雪", "pub_time": "2016-11-5 12:06", "article_content": "如果我们想写一个下面这种列表页：列表页\r\n我们先看index.wxml部分：index.wxml\r\n整页都是view标签看起来好蓝瘦。。。下面的列表部分，我们用到了wx:for这个指令来循环这个列表，这里的用法跟vue真是神似，下面依旧是模板数据填充，bindtap用于绑定一个方法，用法可以在后面的index.js里看到。接下来wxss就直接贴个图好了:index.wxss\r\n这里提一句，小程序的单位统一为rpx,同样是根据屏幕宽度进行自适应的，但存在一个像素的问题，在不同手机里边框的1px是不同的视觉感受，不过搜到一个比较靠谱的解决办法，就是在公共wxss里进行如下设置：（例）.border-top-hack {position: relative}.border-top-hack:after {position: absolute;content: '';width: 100%;left: 0;height: 1px;background-color: #dadada;-webkit-transform: scale(1,.5);transform: scale(1,.5);-webkit-transform-origin: center top;transform-origin: center top;}接下来,看看index.js部分：我们通过require 把需要用的模块引入进来。若需要对一个值进行重新设置，一定要用上this.setData()index.js\r\nwx.request( )发送一个获取列表的请求，将返回值push出去，然后如前所说wx:for将列表渲染出来index.js-跳转事件\r\n之前我们在wxml里用bindtap绑定了一个toItem( )的方法，点击时就会触发这个事件，使用小程序封装得路由，wx.navigateTo 跳转到 下一页，并带上本条列表的id值。       这是一个简单的列表页，用到的api也就那么几个，但小程序提供了丰富的api,有兴趣可以直接看小程序官方文档，感觉已经写得非常全面了~小程序一直在更新组件，前天刚写了wx.navigateTo 这玩意儿只能跳转五层→_→，今天发现又更新了！！！新出炉的API，wx.navigateBack(OBJECT)，可关闭当前页面，返回上一页面或多级页面。通过getCurrentPages()) 可获取当前的页面栈，决定需要返回几层。这就解决了上次说的只能返回5层的问题，里面的参数delta即返回的页面数，如果 delta 大于现有页面数，则返回到首页。哈哈，第二篇小例子就说到这儿啦，感觉还是没办法把一个东西的精髓讲出来，看来自己还需要在这条路上慢慢修炼呐??~"}
{"title": "申请免费的SSL证书 ", "author": "天下雪", "pub_time": "2016-11-5 15:30", "article_content": "申请免费的SSL证书此段时间通过沃通申请了免费的SSL证书, 这两天发现Chrome提示证书不安全, Chrome已经对沃通证书不认证了. 打开网站会出现红色的标志, 很烦的!!我们通过https://www.sslforfree.com/来申请免费的SSL的证书, 并且各大浏览器都认证.打开网站sslforfree网址: https://www.sslforfree.com/输入自己的域名, 点击Create Free SSL Certificate认证域名选择手动认证. 点击Verify Domain按照提示下载两个文件, 放到你的网站的目录下, 然后点击Download SSL Certificate.下载证书配置Nginx下载下来的证书有三个文件.ca_bundle.crtca_bundle.crtprivate.keyNginx 配置SSLssl on;ssl_certificate /data/itjh_net/ssl/sslforfree/cert_chain.crt;ssl_certificate_key /data/itjh_net/ssl/sslforfree/private.key;ssl_certificate文件需要合并ca_bundle.crt + ca_bundle.crt 文件. 执行命令cat certificate.crt ca_bundle.crt >> cert_chain.crt⚠️合并以后的文件会出现下面的错误nginx: [emerg] PEM_read_bio_X509_AUX(\"/data/itjh_net/ssl/sslforfree/cert_chain.crt\") failed (SSL: error:0906D066:PEM routines:PEM_read_bio:bad end line)这是因为cert_chain.crt文件有问题, 文件中有-----END CERTIFICATE----------BEGIN CERTIFICATE-----这样是错误的, 需要修改成-----END CERTIFICATE----------BEGIN CERTIFICATE-----然后保存, 重启Nginx.service nginx restart验证结果打开网站IT江湖www.itjh.net.绿色的小图标又出现了. 好棒"}
{"title": "微信小程序里使用免费的https证书 ", "author": "天下雪", "pub_time": "2016-11-5 15:35", "article_content": "在小程序的文档里我们看到这么一个重要接口说明。wx.request发起的是https请求。一个微信小程序，同时只能有5个网络请求连接。而小程序需要同服务器交互的时候，必定要用到这个接口。https？对于大部分同学来说，了解https的详细过程似乎没太大必要，我们直接先说第一个结论。https证书一般是需要购买的，而且价格不低。自己签发的证书是不被公众认可的，所以就要找大机构拿证书。这时候就要交证书的费用。比如下图：最近的某Sign公司的证书又出了信任危机，有没有更有性价比的方案呢？有！！同城圈联盟现在就教你免费获得靠谱的https证书！我们先教大家如何获取和配置证书！下面一段适合程序员来看。非程序员需要配置的，可以联系离你最近的程序员（比如页面底部那个）请教他。前提：Linux服务器，Python2.7首先从著名同性交友社区下载需要的脚本和配置模板wget https://raw.githubusercontent.com/xdtianyu/scripts/master/lets-encrypt/letsencrypt.confwget https://raw.githubusercontent.com/xdtianyu/scripts/master/lets-encrypt/letsencrypt.shchmod +x letsencrypt.sh然后可以看到 letsencrypt.conf 的内容是这样的DOMAIN_KEY是保存的文件名，比如我们设成 sub.mydomain.cn.key DOMAIN_DIR是WEB的根目录，也就是/index.html, /index.php … 所在的那个目录。DOMAINS是这个WEB目录上绑定的域名。常见的就是根域或是www域，或是你需要的子域名。比如我修改成这个样子?ACCOUNT_KEY=\"letsencrypt-account.key\"DOMAIN_KEY=“sub.mydomain.com.key\"DOMAIN_DIR=“/var/www/path/to/mydomain/\"DOMAINS=“DNS:sub.mydomain.com\"?然后确认 sub.mydomain.com 是可以正常访问的。因为生成证书的时候会对域名可访问性做验证。然后执行./letsencrypt.sh letsencrypt.conf如果正常的话，这时候会在当前目录下生成一堆文件。其中会有一个 sub.chained.crt 和 sub.mydomain.com.key 。这两个文件一会儿我们会用到。现在去 nginx 下添加一个443端口的虚拟主机。server  {    listen 443;    ssl on;    ssl_certificate /root/letsencrypt/sub.chained.crt;    ssl_certificate_key /root/letsencrypt/sub.mydomain.com.key;    server_name  sub.mydomain.com;    index index.php;    root  /var/www/path/to/mydomain/;    if (-f $request_filename/index.php){                rewrite (.*) $1/index.php;        }        if (!-e $request_filename){                rewrite (.*) /index.php;        }    location ~ .*\\.(php|php5)?$    {      fastcgi_pass  127.0.0.1:9001;      fastcgi_index index.php;      include fastcgi.conf;    }  }红字部分需要重点看！（敲黑板）重启 Nginx ，访问 https://sub.mydomain.com 就发现有绿色的证书标志啦！对的，这个过程中我们没花一分钱。证书都会过期的嘛，但这个证书是可以免费续期的！先在 letsencrypt.sh 的最后加一行 service nginx reload 表示执行成功之后重启一下 Nginx。然后在crontab里加一行，表示每个月1号0点自动续期，这样就可以保证这个证书状态一直是正常的了。记得改！路！径！0 0 1 * * /etc/nginx/certs/letsencrypt.sh /etc/nginx/certs/letsencrypt.conf >> /var/log/lets-encrypt.log 2>&1如果你用的是Apache，那把 Nginx 配置https的方法换成 Apache 对应的就可以了，证书获取方法是不一样的。这个证书实际是从 letsencrypt.org 项目获得的。Let’s Encrypt CA项目由Mozilla、思科、Akamai、IdenTrust和EFF等组织发起，向网站自动签发和管理免费证书，加速将Web从HTTP过渡到HTTPS。ISRG则是开发Let’s Encrypt CA的非营利组织。而目前，Let's Encrypt项目和互联网安全研究组（ISRG）都有Linux基金会托管。所以证书的干爹还是靠谱的。写这个教程的同学也是靠谱的。可能有的同学会找到官方的一个脚本来安装证书，为什么本文不推荐？因为那个脚本需要暂停Web服务！这篇文章的方法就不需要长时间暂停Web服务了。现在你可以创建一个 https 站点，然后通过小程序调用这个接口了。有点爽么？"}
{"title": "Rebecca Han：微信小程序仿知乎Demo实战教程（适用1028版本） ", "author": "天下雪", "pub_time": "2016-11-5 15:52", "article_content": "之前有很长一段时间我算是知乎重度依赖, 所以这次 demo 的模仿对象选择的是知乎(但是写到一半发现我这个决定坑了, 这是后话).demo 的界面设计以及交互设计均来自于知乎 Android 版本 _工具_: [微信 web 开发者工具](https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1477579747265)已经全面对非邀请内测用户开放, 且在持续更新 (我码代码的过程中就更新了两版, 所以开发时 IDE 版本不唯一)不过其实忍受了半个小时微信的开发者工具之后, 我就改在 webstorm 中编辑了, 微信工具成了运行预览的工具, 不过听说IDE 中预览的效果, 也不能保证与真机一样哦~ _设计和功能_: 知乎安卓版本 非常之简易版 _数据_: 毕竟是知乎, 为了防止版权问题, fake 的数据使用的是我自己的回答, 所以... _项目地址_: GitHub - RebeccaHanjw/weapp-wechat-zhihu: 微信中的知乎--微信小程序 demo // Zhihu in Wechat1.  基础文件app.json:{\r\n  \"pages\":[\r\n    \"pages/index/index\",\r\n    \"pages/discovery/discovery\",\r\n    \"pages/notify/notify\",\r\n    \"pages/chat/chat\",\r\n    \"pages/more/more\",\r\n    \"pages/answer/answer\",\r\n    \"pages/question/question\"\r\n\r\n  ],\r\n  \"window\":{\r\n    \"backgroundTextStyle\":\"light\",\r\n    \"navigationBarBackgroundColor\": \"#0068C4\",\r\n    \"navigationBarTitleText\": \"知乎\",\r\n    \"navigationBarTextStyle\":\"white\",\r\n    \"enablePullDownRefresh\":true\r\n  },\r\n  \"tabBar\": {\r\n    \"color\": \"#626567\",\r\n    \"selectedColor\": \"#2A8CE5\",\r\n    \"backgroundColor\": \"#FBFBFB\",\r\n    \"borderStyle\": \"white\",\r\n    \"list\": [{\r\n      \"pagePath\": \"pages/index/index\",\r\n      \"text\": \"\",\r\n      \"iconPath\": \"images/index.png\",\r\n      \"selectedIconPath\": \"images/index_focus.png\"\r\n    }, {\r\n      \"pagePath\": \"pages/discovery/discovery\",\r\n      \"text\": \"\",\r\n      \"iconPath\": \"images/discovery.png\",\r\n      \"selectedIconPath\": \"images/discovery_focus.png\"\r\n    }, {\r\n      \"pagePath\": \"pages/notify/notify\",\r\n      \"text\": \"\",\r\n      \"iconPath\": \"images/ring.png\",\r\n      \"selectedIconPath\": \"images/ring_focus.png\"\r\n    }, {\r\n      \"pagePath\": \"pages/chat/chat\",\r\n      \"text\": \"\",\r\n      \"iconPath\": \"images/chat.png\",\r\n      \"selectedIconPath\": \"images/chat_focus.png\"\r\n    }, {\r\n      \"pagePath\": \"pages/more/more\",\r\n      \"text\": \"\",\r\n      \"iconPath\": \"images/burger.png\",\r\n      \"selectedIconPath\": \"images/burger_focus.png\"\r\n    }]\r\n  },\r\n  \"networkTimeout\": {\r\n    \"request\": 10000,\r\n    \"downloadFile\": 10000\r\n  },\r\n  \"debug\": true\r\n}\r\napp.json文件中是对整个小程序的全局配置, 主要用到的字段有pages, window, tabBar, networkTimeout.* pages 字段:  所有小程序的页面都要在该字段中注册, 该字段数组中的第一个page 默认为小程序首页(设置tab 除外), 没有在 pages 字段注册过的页面貌似不能够进行有效的编译(之前版本的编辑器可以,只是会影响配置文件等的生效, 编辑器更新后会报未注册的错误).* window 字段:  大多是关于小程序顶部 navigationbar 的一些设置* tabBar字段: 如果你需要首页面底部带tabbar的样式, 那么就在 tabBar 字段中设置每个 tab 对应的页面, 按顺序对应左至右, 包括路径, tab 文字, tab图标和选中状态图标.* netwoTimeout: 设置网络超时时间.* debug: 开启 debug 模式.app.wxss 文件中为全局样式, 也就是说这个文件中的样式在所有的 page 中均可使用, 若其他页面文件的 wxss 中定义了与该样式文件中相同的属性, 则该文件中的样式被覆盖, 规则与 css 优先规则大致相通.app.js: 调用 login接口, 回调, 周期函数, 本地存储等等逻辑代码.2. 页面文件:页面文件由四部分组成例如我们有一个首页叫做 index, 则需要在 pages 文件夹下创建文件名相通的三个必要文件: index.wxml index.wxssindex.js*另外 index.json文件为可选, 功能与 app.json 相同, 为该页面的配置文件, 但定义功能有限.*3.  UI跟平时开发一样, 最开始当然是码 UI除了需要依照微信的一些新的标签和样式规则, 其他与平时码 UI 并没有太大的不同需要强调的是, flex 布局在微信小程序中 hin~~~~好用不过, 同时作为女生和程序员, 不挑刺可就不是我了, 所以下面列举了一些我遇上的坑, 其中有些也许不正确(多多包涵啦\\(//?//)\\), 有些也许已在 IDE 更新中修正坑们:1. 有一些 css 样式在微信 IDE 中不支持, 例如 font-weight, letter-spacing(及类似调整字间距的样式)等2. <text/>不支持嵌套, 两层<text/>嵌套的结构下, 内层<text/>中的内容会连续显示两次(在 IDE 后续更新中已修正)3. 若<view/>与<text/>在结构上并列的话, 显示上会重合, 感受上类似<view/>级别高于<text/>, 防止内容相叠, 必须使用<view/>相并列. 所以并不能像某些地方说的, 把<view/>当做<div>去使用!4. 元素之前有垂直相邻 margin 的时候(符合 margin 折叠规则), 在微信小程序中会double 显示, 即两个元素的 margin 均摊开, 不遵循 margin 折叠规则.5. <view/>标签 hidden 属性无效 ( v0.10.101400 中已修正 )6. 部分情况下, 平级标签 A 与 B 并列, 当 B 通过某些调整向 A 元素位置相叠的时候, 微信 IDE 解析出的效果是 A 的内容和背景色会覆盖 B 元素与之重叠的部分. ( 普通浏览器解析应该是 B 覆盖 A ).7. 如果用模板+列表渲染的方式来渲染数据的话, 在模板中使用列表渲染的{ {item}}是无效的, 无法被正确识别, 所以列表渲染的时候要把复用的部分写在列表渲染的代码块内 ( 属于数据渲染部分, 后面会提到 )( 待续... ... )后面将对于一些我 demo 中写到用到的部分进行说明列表式的数据渲染首页类似于首页以及发现页这种标准列表式的数据展现方式, 微信提供了很好的方案---列表渲染<block wx:for=\"{{feed}}\" wx:for-index=\"idx\" wx:for-item=\"item\" data-idx=\"{{idx}}\">\r\n   <view class=\"feed-item\">\r\n       <view class=\"feed-source\">\r\n           <a class=\"\">\r\n               <view class=\"avatar\">\r\n                   <image src=\"{{item.feed_source_img}}\"></image>\r\n               </view>\r\n               <text>{{item.feed_source_name}}{{item.feed_source_txt}}</text>\r\n           </a>\r\n           <image class=\"item-more\" mode=\"aspectFit\" src=\"../../images/more.png\"></image>\r\n       </view>\r\n       <view class=\"feed-content\">\r\n           <view class=\"question\" qid=\"{{question_id}}\" bindtap=\"bindQueTap\">\r\n               <a class=\"question-link\">\r\n                   <text>{{item.question}}</text>\r\n               </a>\r\n           </view>\r\n           <view class=\"answer-body\">\r\n               <view bindtap=\"bindItemTap\">\r\n                   <text class=\"answer-txt\" aid=\"{{answer_id}}\">{{item.answer_ctnt}}</text>\r\n               </view>\r\n               <view class=\"answer-actions\" bindtap=\"bindItemTap\">\r\n                   <view class=\"like dot\">\r\n                       <a>{{item.good_num}} 赞同 </a>\r\n                   </view>\r\n                   <view class=\"comments dot\">\r\n                       <a>{{item.comment_num}} 评论 </a>\r\n                   </view>\r\n                   <view class=\"follow-it\">\r\n                       <a>关注问题</a>\r\n                   </view>\r\n               </view>\r\n           </view>\r\n       </view>\r\n   </view>\r\n</block>\r\n可以直观的看出, 就是 for 循环来用重复的结构渲染一组数据for=\"{{}}\"中的内容是想要循环的一组数据, 最外层为数组结构for-item 指定数组中当前元素的变量名for-index 指定数组中当前元素下标变量名 同样也使用了 for 渲染的还有顶部的发现页和通知页等顶部的自定义 tabbar顶部 tabbar 实现微信只提供了底部 tabbar, 所以顶部的要自己写喽~顶部 tabbar 的实现在于 for 列表渲染以及 js 配合wxml:<view class=\"top-tab flex-wrp flex-tab \" >\r\n  <view class=\"toptab flex-item {{currentNavtab==idx ? 'active' : ''}}\" wx:for=\"{{navTab}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\" data-idx=\"{{idx}}\" bindtap=\"switchTab\">\r\n    {{itemName}}\r\n  </view>\r\n</view>\r\n<scroll-view scroll-y=\"true\" class=\"container discovery withtab\" bindscrolltoupper=\"upper\" bindscrolltolower=\"lower\"  scroll-into-view=\"{{toView}}\" scroll-top=\"{{scrollTop}}\">\r\n  <view class=\"ctnt0\" hidden=\"{{currentNavtab==0 ? '' : true}}\">\r\n  </view>\r\n  <view class=\"ctnt1 placehold\" hidden=\"{{currentNavtab==1 ? '' : true}}\">\r\n    <text>圆桌</text>\r\n  </view>\r\n  <view class=\"ctnt2 placehold\" hidden=\"{{currentNavtab==2 ? '' : true}}\">\r\n    <text>热门</text>\r\n  </view>\r\n  <view class=\"ctnt3 placehold\" hidden=\"{{currentNavtab==3 ? '' : true}}\">\r\n    <text>收藏</text>\r\n  </view>\r\n</scroll-view>\r\njs://discovery.js\r\nPage({\r\n  data: {\r\n    navTab: [\"推荐\", \"圆桌\", \"热门\", \"收藏\"],\r\n    currentNavtab: \"0\"\r\n  },\r\n  onLoad: function () {\r\n    console.log('onLoad')\r\n  },\r\n  switchTab: function(e){\r\n    this.setData({\r\n      currentNavtab: e.currentTarget.dataset.idx\r\n    });\r\n  }\r\n});\r\n由于微信不支持任何 dom 和 window 对象, 所以 tabbar的实现依赖于微信提供的视图层的展示逻辑, 以及视图与数据之间的绑定机制.绑定点击事件, 通过改变一个 data- 属性的值, 来控制元素的类的改变( 从而改变样式等 )轮播图<swiper class=\"activity\" indicator-dots=\"{{indicatorDots}}\"\r\n       autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">\r\n <block wx:for=\"{{imgUrls}}\">\r\n   <swiper-item>\r\n     <image src=\"{{item}}\" class=\"slide-image\" width=\"355\" height=\"155\"/>\r\n   </swiper-item>\r\n </block>\r\n</swiper>\r\nimgUrls: [\r\n '../../images/24213.jpg',\r\n '../../images/24280.jpg',\r\n '../../images/1444983318907-_DSC1826.jpg'\r\n],\r\nindicatorDots: false,\r\nautoplay: true,\r\ninterval: 5000,\r\nduration: 1000,\r\nfeed: [],\r\nfeed_length: 0\r\n轮播图的实现使用的是微信提供的 swiper 组件, 该组件贴心的提供了各种属性选择, 常用的包括autoplay, interval 时间, duration等<swiper-item>中包含的是所有轮播的图片, 为了方便修改图片数据, 同样采用 for 渲染绑定 data 的方式下拉刷新, 上拉加载, 以及数据请求刷新及继续加载的动作, 依靠的是<scroll-view>标签, 及配套的upper 和 lower 事件<scroll-view>标签的属性提供了 bindscrolltoupper 和 bindscrolltolower来绑定滚动到顶部及底部所触发的事件, 同时upper-threshold 和 lower-threshold 能够调整触发时距边界的距离除上述之外, 还提供横向滚动, 滚动触发事件, 及设置滚动条位置等...<scroll-view scroll-y=\"true\" class=\"container\" bindscrolltoupper=\"upper\" upper-threshold=\"10\" lower-threshold=\"5\" bindscrolltolower=\"lower\"  scroll-into-view=\"{{toView}}\" scroll-top=\"{{scrollTop}}\">\r\n    <block wx:for=\"{{feed}}\" wx:for-index=\"idx\" wx:for-item=\"item\" data-idx=\"{{idx}}\">\r\n        <view class=\"feed-item\">\r\n            <view class=\"feed-source\">\r\n                <a class=\"\">\r\n                    <view class=\"avatar\">\r\n                        <image src=\"{{item.feed_source_img}}\"></image>\r\n                    </view>\r\n                    <text>{{item.feed_source_name}}{{item.feed_source_txt}}</text>\r\n                </a>\r\n                <image class=\"item-more\" mode=\"aspectFit\" src=\"../../images/more.png\"></image>\r\n            </view>\r\n            <view class=\"feed-content\">\r\n                <view class=\"question\" qid=\"{{question_id}}\" bindtap=\"bindQueTap\">\r\n                    <a class=\"question-link\">\r\n                        <text>{{item.question}}</text>\r\n                    </a>\r\n                </view>\r\n                <view class=\"answer-body\">\r\n                    <view bindtap=\"bindItemTap\">\r\n                        <text class=\"answer-txt\" aid=\"{{answer_id}}\">{ {item.answer_ctnt}}</text>\r\n                    </view>\r\n                    <view class=\"answer-actions\" bindtap=\"bindItemTap\">\r\n                        <view class=\"like dot\">\r\n                            <a>{{item.good_num}} 赞同 </a>\r\n                        </view>\r\n                        <view class=\"comments dot\">\r\n                            <a>{{item.comment_num}} 评论 </a>\r\n                        </view>\r\n                        <view class=\"follow-it\">\r\n                            <a>关注问题</a>\r\n                        </view>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n    </block>\r\n</scroll-view>\r\n滚动至顶或至底时, 触发的加载数据的事件, 本应该调用微信提供的网络请求 API 来获取数据. 但是比较坑的是, 我在选择写仿知乎 demo 的时候没有注意到知乎不提供开放 API, 而微信的 API 不支持直接对.json 文件进行本地请求, 无奈之下, 选择在 js 文件中伪造一段数据, module.exports抛出, 来 fake 数据请求upper: function () {\r\n    wx.showNavigationBarLoading()\r\n    this.refresh();\r\n    console.log(\"upper\");\r\n    setTimeout(function(){wx.hideNavigationBarLoading();wx.stopPullDownRefresh();}, 2000);\r\n  },\r\n  lower: function (e) {\r\n    wx.showNavigationBarLoading();\r\n    var that = this;\r\n    setTimeout(function(){wx.hideNavigationBarLoading();that.nextLoad();}, 1000);\r\n    console.log(\"lower\")\r\n  },\r\n  //scroll: function (e) {\r\n  //  console.log(\"scroll\")\r\n  //},\r\n\r\n  //网络请求数据, 实现刷新\r\n  refresh0: function(){\r\n    var index_api = '';\r\n    util.getData(index_api)\r\n        .then(function(data){\r\n          //this.setData({\r\n          //\r\n          //});\r\n          console.log(data);\r\n        });\r\n  },\r\n  //使用本地 fake 数据实现刷新效果\r\n  refresh: function(){\r\n    var feed = util.getDiscovery();\r\n    console.log(\"loaddata\");\r\n    var feed_data = feed.data;\r\n    this.setData({\r\n      feed:feed_data,\r\n      feed_length: feed_data.length\r\n    });\r\n  },\r\n  //使用本地 fake 数据实现继续加载效果\r\n  nextLoad: function(){\r\n    var next = util.discoveryNext();\r\n    console.log(\"continueload\");\r\n    var next_data = next.data;\r\n    this.setData({\r\n      feed: this.data.feed.concat(next_data),\r\n      feed_length: this.data.feed_length + next_data.length\r\n    });\r\n  }\r\n由于是 fake 的数据, 所以这个 demo 并没有做真实的带参跳转, 查询等功能加载数据的同时, 使用微信提供的加载动画wx.showNavigationBarLoading();其他绑定点击事件, 进行页面的跳转wx.navigateTo部分模块化input, image 组件等后续其实还有大量的组件和 API 还没有用过, 这个 demo 也许后续还会有更新呦, 这取决于懒癌少女的病情严重程度了项目地址传送门: GitHub - RebeccaHanjw/weapp-wechat-zhihu: 微信中的知乎--微信小程序 demo // Zhihu in Wechat项目下载：weapp-wechat-zhihu-master.zip也许算是些感受?其实作为一个小前端, 由于工作中的原因, 使用 MVVM 其实非常少的, 不过写了这个微信小程序 demo 之后, 更加把这方便的思维理顺了. 当然, 写完之后回头看, 还是有超多的不足, 明明好些地方能再换一种写法的. 不过毕竟是我第一次尝试用新鲜热乎的东西写小 demo, 也是第一次尝试写教程...或者算是记录? whatever~~还有, 非项目的配图均来自网络哦~~Anyway~ 希望除了写代码之外, 还能在码文字的道路上也多走走吧, 毕竟我是要做代码小仙女的人呀\\(≧?≦)ゞ"}
{"title": "一斤代码深入理解系列《五》：微信小程序中使用Promise进行异步流程处理 ... ... ... ", "author": "天下雪", "pub_time": "2016-11-5 16:04", "article_content": "我们知道，JavaScript是单进程执行的，同步操作会对程序的执行进行阻塞处理。比如在浏览器页面程序中，如果一段同步的代码需要执行很长时间（比如一个很大的循环操作），则页面会产生卡死的现象。\r\n所以，在JavaScript中，提供了一些异步特性，为程序提供了性能和体验上的益处，比如可以将代码放到setTimeout()中执行；或者在网页中，我们使用Ajax的方式向服务器端做异步数据请求。这些异步的代码不会阻塞当前的界面主进程，界面还是可以灵活的进行操作，等到异步代码执行完成，再做相应的处理。\r\n一段典型的异步代码类似这样：function asyncFunc(callback) {\r\n  setTimeout(function () {\r\n    //在这里写你的逻辑代码\r\n    //...\r\n\r\n    //逻辑代码结束，执行一个回调函数\r\n    callback();\r\n  }, 5000);\r\n}\r\n\r\n或者：\r\n\r\nfunction getAccountInfo(callback, errorCallback) {\r\n  wx.request({\r\n    url: '/accounts/12345',\r\n    success: function (res) {\r\n      //...\r\n      callback(data);\r\n    },\r\n    fail: function (res) {\r\n      //...\r\n      errorCallback(data);\r\n    }\r\n  });\r\n}\r\n然后我们这样调用：asyncFunc(function () {\r\n  console.log(\"asyncFunc() run complete\");\r\n});\r\n\r\ngetAccountInfo(function (data) {\r\n  console.log(\"get account info successfully:\", data);\r\n}, function () {\r\n  console.error(\"get account info failed\");\r\n});这是一种使用了回调函数来控制代码执行流程的方式。这样看起来没问题，也挺容易理解。\r\n但是，如果我们一段代码中，异步操作太多，又要保证这些异步操作是有顺序的执行，那我们的代码就看起来非常糟糕，就像这样：asyncFunc1(function(){\r\n  //...\r\n  asyncFunc2(function(){\r\n    //...\r\n    asyncFunc3(function(){\r\n      //...\r\n      asyncFunc4(function(){\r\n        //...\r\n        asyncFunc5(function(){\r\n           //...\r\n        });\r\n      });\r\n    });\r\n  });\r\n});\r\n这样的代码可读性和可维护性可想而知了。还有，回调函数真正的问题在于：\r\n它剥夺了我们使用 return 和 throw 这些关键字的能力。\r\n那有什么办法来改善这个问题呢？答案是肯定的，Promise这种概念的产生，很好地解决了这一切。关于什么是Promise，一搜一大把介绍，我这里就不复制粘贴了，我主要是讲一下我们怎么用它来解决我们的问题。\r\n我们来看一下，上面的例子如果使用Promise，它会是什么样子?我们先将这些函数变成Promise的方式：function asyncFunc1(){\r\n  return new Promise(function (resolve, reject) {\r\n    //...\r\n  })\r\n}\r\n\r\n// asyncFunc2,3,4,5也实现成跟asyncFunc1一样的方式...\r\n然后看一下他们是怎么样被调用的：asyncFunc1()\r\n  .then(asyncFunc2)\r\n  .then(asyncFunc3)\r\n  .then(asyncFunc4)\r\n  .then(asyncFunc5);\r\n这样，这些异步函数就会按照顺序一个一个依次执行了。\r\nES6中原生支持了Promise，不过在原生不支持Promise的环境中，我们有很多第三方库来支持，比如Q.js和Bluebird。它们一般都除了提供标准Promise的API外，还提供了一些标准之外但非常有用的API，使得异步流程的控制更加优雅。\r\n从微信小程序的API文档中我们可以看到，框架提供的JavaScript API中很多函数其实都是异步的，如wx.setStorage(), wx.getStorage(), wx.getLocation()等等，它们也是提供的回调的处理方式，在参数中传入success, fail，complete回调函数，就可以对运行成功或失败进行分别处理。\r\n如：\r\nwx.getLocation({ \r\n  type: 'wgs84', \r\n  success: function(res) { \r\n    var latitude = res.latitude \r\n    var longitude = res.longitude \r\n    var speed = res.speed \r\n    var accuracy = res.accuracy \r\n  },\r\n  fail: function() {\r\n    console.error(\"get location failed\")\r\n  }\r\n})\r\n我们能不能让微信小程序的异步API支持Promise呢？答案是肯定的，我们当然可以一个一个的用Promise去包装这些API，但是这个还是比较麻烦的。不过，由于小程序的API的参数格式都比较统一，只接受一个object参数，回调都是在这个参数中设置，所以，这为我们的统一处理提供了便利，我们可以写一个非侵入性的工具方法，来完成这样的工作：\r\n假设我们将这个工具方法写到一个名为的util.js的文件中：\r\nvar Promise = require('../libs/bluebird.min')  //我用了bluebird.js\r\n\r\nfunction wxPromisify(fn) {  \r\n  return function (obj = {}) {    \r\n    return new Promise((resolve, reject) => {      \r\n      obj.success = function (res) {        \r\n        resolve(res)      \r\n      }      \r\n\r\n      obj.fail = function (res) {        \r\n        reject(res)      \r\n      }      \r\n\r\n      fn(obj)    \r\n    })  \r\n  }\r\n}\r\n\r\nmodule.exports = {  \r\n  wxPromisify: wxPromisify\r\n}\r\n之后，我们来看一下如何使用这个方法，将原来回调方式的API变成Promise的方式：\r\nvar util = require('../utils/util')\r\n\r\nvar getLocationPromisified = util.wxPromisify(wx.getLocation)\r\n\r\ngetLocationPromisified({\r\n  type: 'wgs84'\r\n}).then(function (res) {\r\n  var latitude = res.latitude \r\n  var longitude = res.longitude \r\n  var speed = res.speed \r\n  var accuracy = res.accuracy \r\n}).catch(function () {\r\n  console.error(\"get location failed\")\r\n})\r\n是不是很容易理解？\r\n关于使用Promise处理异步流程，就先讲到这里，有什么疑问，可以留言给我。不对之处，欢迎指正。"}
{"title": "微信小程序开发系列分析《五》主界面 ", "author": "天下雪", "pub_time": "2016-11-2 17:27", "article_content": "先来看看我们本文相关的demo，地址：https://github.com/jsongo/weApp-frame，三个页面：weApp-frame-master.zip为了展示页面的主框架，这里做了三种风格的页面。第一个是个图片列表，从花瓣上抓的。第二个是个外卖的页面。第三个是个人中心页面。一、页面功能简述1、花瓣图片列表用两列的瀑布流来展示，在顶部向下拉可以加载更多，滑动到底部可以加载更多图片。在网络请求数据的时候，会出现一个浮层，展示加载中的loading图标，顶部的title旁边也会出来加载中图标，等数据加载完，这两个图标都会消失。这个页面还有个子页面，图片查看页，往后可以滑动到下一张，往前可以滑动到前一张。列表数据来源：分析了下花瓣的网站，随便拿了个数据列表接口，通过传入不同参数来取得分页数据。本页主要介绍：列表的排布、加载中图标的实现方式、下拉刷新的实现方式、滑动到底部加载更多的实现、navigator及参数传递的实现、引用传递的实现。2、外卖订餐页面页面顶部是个轮播图，几个图片轮流播放。下半部分是两个滑动的列表，菜品分类列表，和菜品详细列表，它们可以分开滑动。本页主要介绍：轮播图组件、页面分区及各自列表滑动。3、个人中心页面上半部分是个人信息，下方是菜单列表。退出按钮点击后，可以从下方弹出菜单。本页主要介绍：模态窗口、下文弹出菜单列表、toast另外，还有下方tab菜单的实现方式。二、图片列表的实现1、底部加载更多用户滑动到底部的时候，列表会自动加载下一页。实现也比较简单，在scroll-view标签中的bindscrolltolower绑定个事件响应函数，当滑动到底部时，这个事件就会被触发。不过这里有个问题要注意下，scroll-view要设置一个高度才行，要不然经常会滑到底部没反应，没触发。获取窗口的高度，把它设置给scroll-view就可以了：wx.getSystemInfo({    success: ( res ) => { // 用这种方法调用，this指向Page        this.setData({            winH: res.windowHeight        });    }});在界面中，把winH设置给scroll-view的height<scroll-view …（省略其它属性）... style=\"height: {{winH}}px;\">这样scroll-view才能正常在滑动到底部的时候触发bindscrolltolower事件。加载完数据后，可以用之前我们在《【微信小程序开发•系列文章三】数据层》里讲过方法来追加数据。下面我们再介绍一种方法来追加数据。追加的时候，我们的主要目的是保证data里的items数组的地址不变。所以其实可以直接拿到这个items数组的引用，然后给它push数据，方法如下：var arr = this.data.items;arr.push(…newList); // ...三个点是用了es6的解包的语法this.setData({items: arr}); // 一定要记得setData这个方法比较hack，先用arr变量来保存this.data.items的引用，push操作不会改变原数组的地址，push完之后，还没更新界面，这时一定要记得再调用一下setData方法，用它来触发界面更新。所以这里，我们其实是把setData当然是UI update的方法来用。亲测了一下，整个列表没看到有全局刷新的问题。2、下拉刷新微信小程序提供了下拉刷新的样式。这个我们能修改的不多，只能配置内容和简单的修改几个地方的显示。（1）配置我们的程序中有一个app.json，在“window” 这一项里添加 enablePullDownRefresh: true ，小程序的页面在顶部下拉的时候，就会出现下拉刷新的样式。（2）事件当下拉被触发的时候，MINA框架会去找当前页面的page里是否有onPullDownRefresh这个事件响应函数，如果有就会调用。所以这里在实现下拉刷新的时候，就要定义这个函数，然后在里面去做刷新。（3）刷新的思路当前列表数据可能不是最新的，如果这时重新去拉一次第一页的数据，可能会出现前面几项不在当前列表里，这些就是要刷新进来的数据。思路就是去比对id，先取原列表中第一个id，如果在列表里找到这个id的项，则停止，把这个项之前的数据都追回到列表里。但是如果在新加载的第一页中没找到这个id，说明这次加载的数量还不够，还要再加载一次。为了避免出bug时，或数据出问题的时候，无限加载的问题，我们设置一个MAX_PREPEND来限制最多加载的页数。我们用数字来代表列表里的一项，简化下模型，让读者更容易理解。比如我们第一次加载的列表是[0,1,2,3,4,5,6,7,8,9] 这10项（一次加载10项），第一个id是0。过了5个小时，列表数据有更新了，这时用户下拉刷新，我们拉到了[-28,-27,-26,-25,-24,-23,-22,-21,-20,-19] 这10项，这时我们发现，我们这次加载的新数据没有第一个id，即0，所以中间肯定还有一些项我们要再加载的。所以我们发了第二个请求，这次拉到了[-18,-17,-16,-15,-14,-13,-12,-11,-10,-9]，这里又没有出现0，所以发起第三个请求去拉数据，这时我们拿到了[-8,-7,-6,-5,-4,-3,-2,-1,0,1]，这次0这个id出现了。所以我们把0前面的8项也全都加入到新列表中。为了安全，我们设置了MAX_PREPEND，比如为3，表示最多发三个请求，如果这中个请求还没有拉到0这个id，那我们也不再发请求了。怕出现无限循环加载的情况，出现bug的时候可能会出现，或者后台把0这条数据删除了，后面这几次请求返回的列表里都不可能出现0，这时也会出现无限加载的情况。当然上面这个逻辑还是有bug，假如真出现了后台把0这个项删除掉的时候，那我们加载的数据就可能会出现数据重复的现象。所以真正产品化的时候，如果有可能删除数据的情况，最好还是不要用拿第一个id的去对比的方法，因为可能会出现重复。这时要使用另一种算法，即，可以把所有的id都存到一个数组里，新数据拉回来的时候，一个个拿去数组里对比，没在数组中的就加载到界面中，有的话就忽略。然后出现全部项都在这个数组中的时候，就停止加载。有点复杂。其实如果把这个逻辑放到后台去做，会简单很多，我们让id有序，有大小可以比较，或者用时间戳的方式来判断，前端做有点复杂。我们这个demo中能拿到的数据id也无序，时间也无序，情况远比上面的数字复杂很多，所以没办法只能暂时这么做。读者如果是自己的团队做后台的话，一定要把返回的数据按一定的规则有序化。接下去讨论数据如果插入到界面中列表的前端去。前面讨论追加列表数据的时候，说到了一种方法，取数组的引用，在保证数组地址不变的情况下，去往里面添加数据。push是一个不会改变地址的操作，不过是往数组后面添加的，那么要往前端插入，就要用unshift，它也会在保证数组地址不变的情况下，在前面添加新数据。（4）停止刷新的样式当我们加载完数据，刷新完的时候，要把微信帮我们做的加载图标隐藏掉，它自己不会正好在我们加载完数据的时候隐藏，虽然它有一个默认的隐藏时间。框架给我们提供了一个wx.stopPullDownRefresh方法，我们在加载完数据，render完时，调用一下它就可以了。（5）数据请求关于数据请求，这里补充一点。花瓣对请求做了点限制，直接请求地址会返回一个页面，需要加两个头部才行：X-Request: JSONX-Requested-With: XMLHttpRequest而第二个头部，X-Requested-With，框架默认已经帮我们加了。我们只要在请求的时候，加上一个第一个header就行了。另外，小程序开发工具一开始的时候，有一个头部重复的问题，不过从v0.10.101000开始，就修复了。3、图片列表图片列表其实就是传统网页的布局，没有用到flex，只是让元素浮动float，然后限制一下宽度和高度，它自然就排成两行了。有兴趣的读者可以尝试用flex或table去实现一下。4、图片播放的实现（1）点击跳转列表里的每一项都加了navigator组件包裹着，它就相当于<a>标签，用来做跳转。不过要注意的一点是，navigator的宽高都被框架设置成auto，所以在wxss里设置宽高没有用，但在元素里内嵌样式是可以的，这里我们换种做法。在navigator里放个view把它撑开，给它固定个宽高就可以了，这时对navigator里面元素的点击，事件都会冒泡到navigator元素上，就会触发它的页面跳转。（2）播放哪张图？很简单，在跳转的时候，给跳转的地址加个参数就可以了，参数带上点击的这张图在数组中的index。那么问题来了，在跳过去的页面怎么取得这个参数？微信小程序官方文档里没有特别提到onLoad里，其实还可以传入一个参数options，它用来接收跳转时地址后面带的参数。这个就非常方便我们使用了。比如地址是 ../pic/pic?index=1，那么这里，我们用options.index就可以拿到1这个数据了。onLoad拿到index数据后，setData来修改并指定当前图片列表播放这个index的图片就行了。（3）播放的图片数据来源播放图片，我们不是一张一张来显示的，因为如果只播放一张的话，用户在向左或向右滑动的时候，我们得去找这张图片的上一张图或下一张图来显示，这样做就比较复杂了。所以我们在界面上放一个swiper组件，把当前列表里的所有图片全部设置到里面去。上面我们拿到的index，在这里就可以使用，swiper组件有个current属性用来指定当前显示哪一张图。这个列表数据，我们不需要从index页面重新拷贝一份过来。数组，其实存一个引用就行了，这样的两个好处是：1节约内存，2更新的时候更新一个地方的数据就行。实现方式是，在index的onLoad方法里，把this.data.items的引用存到app的globalData里，再在图片播放页的onLoad方法里从app取出这个引用，把它设置给这个页面的data里就行。当前为了界面及时更新，我们把这个操作放到播放页面的onShow里好些，这样，每天切换到播放页来查看图片的时候，都会去更新图片列表，保证数据是最新的。（4）播放页界面的实现先加一个view组件，设置成整个页面大小，背景设置成顶部bar的颜色，这样看起来比较像一个整体。上面提到，我们的图片是显示在swiper组件里的，因为这是一个可左右滑动的组件，不用我们自己去做滑动的事件处理。不过这个组件有个问题，它的高度也是在框架中固定死的，固定成150px，我们在wxss里改变它的值也没有作用。还好，在标签里内嵌样式可以把框架中定义的样式给覆盖掉。那么为了让图片垂直居中，我们第一想到的可能是，取到图片高度，把它设置给swiper的内嵌样式的height里，再用margin-top等方式让它居中。这里介绍另一种方式让图片居中。当父元素被设置成 display:flex 时，加上几个center就可以让其内部元素自然水平和垂直居中：display:flex;justify-content:center;align-items: center;text-align: center;所以我们也把swiper组件的高度设置成整个窗口的高度，再用上面的方法把里的image元素自然居中就可以了。image元素的mode设置成aspectFit，它会保持原有的宽高比例，image只有这个mode值是保持图片完整的。更多mode属性可以看官方文档。另外，图片播放页面是第二层弹出页面，没有底部菜单，这样就可以全屏。5、loading样式的实现微信小程序提供了两种loading的样式，一种是在顶部bar的标题旁边显示转动的图标，另一种是用浮层的形式在页面中间显示一个加载图标。第一种的实现也比较简单显示：wx.showNavigationBarLoading隐藏：wx.hideNavigationBarLoading第二种要wxml和js一起配合wxml代码：<loading hidden=\"{{!loading}}\">    加载中...</loading>js的代码做的事情就是用setData来修改上面的loading这个数据，设为true则显示加载图标，false不显示（注意wxml里的loading前面加了!感叹号）这个loading组件的样式微信已经帮我们做好了，其它的不用我们处理。三、外卖页面的实现1、页面布局外卖页面基本可以分为三部分，顶部轮播图组件、下半部分是两个横排的滑动列表，他们可以各自滑动。轮播组件可查看官方文档介绍。几个关键的参数，autoplay设置是否自动播放，current设置当前播放第几张，indicator-dots设置是否显示面板上的指示点。在上面的图片播放页中，我们把autoplay和indicator-dots都设置成false。注意这些true/false都要写成 false 的形式。在这个页面中，我们模仿美团外卖中的首页，自动轮播顶部的广告图片。除了autoplay和indicator-dots设置成true外，还可以修改interval参数来设置等多久再播放下一个，修改duration来设置滑动的时长。2、页面分区主要是用wxss来控制，这里依然用flex简单的布局方式，按1:5的比例来放置两边的滚动区域。左边的列表，给每个项都添加一个事件，每次点击某个项的时候，它的底色要变。这里我们通过控制class来改变样式，在class里添加：{{item.id==chosenType?'selected':''}}当选中的项的id为choseType时，class就添加selected，这样，我们就可以通过choseType这个变量来改变列表选中的项的样式。那怎么实现两个列表数据的联动呢？我们在每个项中也埋下了data-id，点击的时候就知道当前项的id，再拿它去请求相关的列表数据，从而可以拿到右侧的餐品列表数据，再更新到右侧列表上去就可以了。每个列表都是独立的，可以各自设置scroll-y让他们各自滚动，互不影响。四、个人中心页面的实现整体布局其实就是wxss完成的，也没什么可讲。这一部分主要讨论：模态窗口、下文弹出菜单列表、toast的实现。1、模态窗口其实也就是我们网页中的alert、confirm这些。当他们弹出来的时候，后面的窗口是不可以操作的，这类窗口称为模态窗口。小程序框架只提供了一个组件：modal组件。不过我们可以用它来实现alert / confirm / prompt。<modal title=\"标题\" confirm-text=\"确定\" cancel-text=\"取消\"     hidden=\"{{modalHidden}}\" bindconfirm=\"modalChange\" bindcancel=\"modalChange\">    这是对话框的内容。</modal>先看几个参数：title设置上面的标题标签中间的文本就是对话框中部灰色的内容no-cancel 设置是否显示取消按钮bindconfirm和bindcancel分别是两个按钮的事件（1）alert框只要把no-cancel设置成true就可以了（2）confirm框默认的就是confirm的样式（3）prompt弹出输入框modal组件中间是允许插入wxml标签的，所以我们如果插入一个input组件，它自然就成了prompt弹出框，如果需要用户输入的时候，可以用这个办法弹出。（4）modal的显示与隐藏上面的代码中，用modalHidden变量来控制是否hidden。我们在bindconfirm和bindcancel两个事件里面都加上一个setData，把modalHidden设置成true就可以隐藏了。同样的，要显示的时候，setData把modalHidden设置成true就可以了。modalChange: function() {    this.setData({        modalHidden: !this.data.modalHidden    });}2、toast默认样式，上面有个打钩图标，目前微信没有提供定制的属性。如果要显示打叉x的图标，恐怕还没法用。期待后面会更新。<toast hidden=\"{{toastHidden}}\" duration=\"3000\" bindchange=\"toastChange\">{{toastMsg}}</toast>我们demo中用toast来提示注销成功。这个toast组件还是需要我们自己写点代码的，如上，duration设置这个toast的显示时间，当时间到的时候，它不会主动消失，而是去调用bindchange绑定的回调函数，这时，我们得在这个回调中，去把toastHidden设置成true，才能把这个toast隐藏掉，可见这个toast的使用还不是很方便。那么我们可否把它打包成一个组件呢？可惜框架中没有提供自定义框架的办法，所以这里我们只能在每个用到的页面中，都写一遍相关的js代码，wxml是可以通过模板的形式引入达实现共用，js恐怕就比较难。js实现代码如下：data: {    toastHidden: true,    toastMsg: 'message'},toast: function(msg) {    this.setData({        toastHidden: false,        toastMsg: msg    });},toastChange: function(event) {    if (event.detail.value === false) {        this.setData({            toastHidden: true        });    }},我们封装成一个toast方法，同个Page里面就可以通过this.toast( )来调用而直接弹出。可惜现在每个用到的页面都得拷贝一次上面这个代码，希望小程序的这个框架不久后能提供自定义组件的方法。3、action-sheetaction-sheet就是下文往上弹出来的小菜单，实现方式也比较简单：<action-sheet hidden=\"{{actionSheetHidden}}\" bindchange=\"actionSheetChange\">    <action-sheet-item class=\"item\" bindtap=\"doLogout\">    确定注销    </action-sheet-item>    <action-sheet-cancel class=\"cancel\">取消</action-sheet-cancel></action-sheet>action-sheet 有一个 bindchange 方法，当用户点击上面半透明背景时，会被触发。action-sheet-item标签可以用多个，它会从上往下依次排列。每个上面都可以单独绑定事件。action-sheet-cancel标签用来是额外提供的，它跟action-sheet-item的差别是，它点击后会触发action-sheet的bindchange方法。当然这个标签也可以不使用。 如果没有实现bindchange方法，点击背景时是不会把action-sheet隐藏起来的。所以我们需要实现它，很简单，也只需要setData把actionSheetHidden设置为true就行了。五、其它1、各页面标题每个页面有不同的标题。在用v0.10.101400版本开发的时候，测试wx.setNavigationBarTitle方法设置的标题没有作用，会被改回去。这里的wx.setNavigationBarTitle问题，怀疑是这个版本的工具问题，之前有个版本是可以的，更新后，在onLoad和onShow里设置title都会被覆盖回去。所以这里就只能在xxx.json里设置新的title把原来的覆盖。demo代码中，除index页面外，其它页面都有一个xxx.json文件，内容大致如下：{    \"navigationBarTitleText\": \"图片详情\",    \"enablePullDownRefresh\": false}第一个设置标题，第二个enablePullDownRefresh的作用是，在不需要下拉刷新的页面中，覆盖window中的这个参数，让它下拉不了。这个方法还可以用来覆盖其它参数，如页面背景，字体颜色等等。2、demo中的下文菜单这个是在app.json里设置的，跟window并列，添加一个tabBar：  \"tabBar\": {      \"list\": [{        \"pagePath\": \"pages/index/index\",        \"iconPath\": \"res/img/tab/home-off.png\",        \"text\": \"首页\",        \"selectedIconPath\": \"res/img/tab/home-on.png\"      }, {        \"pagePath\": \"pages/waimai/waimai\",        \"iconPath\": \"res/img/tab/wm-off.png\",        \"text\": \"外卖\",        \"selectedIconPath\": \"res/img/tab/wm-on.png\"      }, {        \"pagePath\": \"pages/my/my\",        \"iconPath\": \"res/img/tab/my-off.png\",        \"text\": \"我的\",        \"selectedIconPath\": \"res/img/tab/my-on.png\"      }],      \"color\":\"#174578\",      \"selectdColor\":\"#3cc51f\",      \"borderStyle\":\"white\",      \"backgroundColor\":\"#116fb6\"  },list定义tab信息，只能配置最少2个、最多5个。每个tab可以用pagePath指定页面，用iconPath指定选中前的图标，selectedIconPath指定选中后的图标，text指定tab名称。样式的设置，跟list并列，用color设置文字颜色，用selectdColor设置选中时的文字颜色，borderStyle设置顶部边框颜色，而且只支持black/white，backgroundColor设置tab背景色。子菜单还不支持。"}
{"title": "微信小程序学习：下拉刷新上拉加载与弹窗的两种姿势 ", "author": "天下雪", "pub_time": "2016-11-12 11:04", "article_content": "作者：弓长剑明   原文地址一：下拉刷新上拉加载的两种姿势在js文件里直接重写\"onPullDownRefresh\"和\"onReachBottom\"方法即可；\r\n\r\n\r\n文档地址：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html?t=20161107\r\n\r\n\r\nxml\r\n<scroll-view scroll-y = true >    .........</scroll-view>\r\n\r\n\r\njs\r\nonPullDownRefresh: function() {    // Do something when pull down.     console.log('刷新'); }, onReachBottom: function() {    // Do something when page reach bottom.     console.log('circle 下一页'); },\r\n\r\n\r\n\r\n\r\n在scroll-view里设定bindscrolltoupper和bindscrolltolower，然后在js里写好触发事件后对应的方法。[注意，使用这个模式一定要设置scroll-view的高度，100%不知道为什么设置后没效果，建议使用100vh]\r\n\r\n\r\n文档地址：https://mp.weixin.qq.com/debug/wxadoc/dev/component/scroll-view.html?t=20161107\r\n\r\n\r\nxml\r\n<scroll-view scroll-y = true bindscrolltolower=\"loadMore\" bindscrolltoupper=\"refesh\">    ..........</scroll-view>\r\n\r\n\r\njs\r\nonPullDownRefresh: function() {    // Do something when pull down.     console.log('刷新'); }, onReachBottom: function() {    // Do something when page reach bottom.     console.log('circle 下一页'); },二：弹窗的两种姿势直接在代码里控制\r\n\r\n\r\n文档地址：https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-react.html?t=20161107#wxshowtoastobject\r\n\r\n\r\njs\r\nshowLoading:function(){        wx.showToast({         title: '加载中',         icon: 'loading'        });     },cancelLoading:function(){        wx.hideToast();     }\r\n\r\n\r\n\r\n\r\n在wxml文件里布局弹窗，利用条件渲染，在js代码里控制是否显示\r\n\r\n\r\n文档地址:https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/list.html?t=20161107\r\n\r\n\r\nwxml\r\n<view >    <loading wx:if=\"{{showLoading}}\">加载中</loading></view>\r\n\r\n\r\njs\r\ndata: {      showLoading:true},showLoading:function(){     this.setData({        showLoading:true     })  },cancelLoading:function(){    this.setData({        showLoading:false})"}
{"title": "哈欠：微信小程序开发工具的数据,配置,日志等目录在哪儿? 怎么找? ... ... ... ", "author": "天下雪", "pub_time": "2016-11-12 13:24", "article_content": "本文由本站halfyawn原创：感谢原创者；如有疑问，请在评论内回复还是先把问题列出来,让问题来驱动探索:微信小程序开发工具的数据,配置,日志等目录在哪儿? 怎么找?首先分析了一下源码,日志目录应该同NW.JS的应用目录相关,,,查查查,,一直查到NW.JS的C++源码,搞得太复杂,大概知道位置,但还是不确切.决定不往这条线找,换另一条路: 把日志文件修改输出到我指定目录,再把原来目录输出出来.修改了这个文件,其实只修改了一句代码.其它代码作了些命名重构和格式化处理,看起来好看些.//app/dist/common/log/log.jsfunction init() {    var _log, fs = require('fs'),        log = require('log'),        path = require('path'),        dirConfig = require('../../config/dirConfig.js'),        // logPath = dirConfig.WeappLog,        logPath = 'D:/develop/wxapplet_devtool/log/', //dxb20161111 为方便，这儿暂时写死        a = 10;    if (global.isDev || process.execPath.match('nw.exe') ||        process.execPath.match('nwjs.app'))        _log = console;    else {        var n = JSON.parse(localStorage.logFiles || '[]'),            date = new Date,            logName = date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate() +            '-' + date.getHours() + '-' + date.getMinutes() + '-' + date.getMilliseconds() +            '.log',            logFilename = path.join(logPath, logName);        if (n.length > a) {            var p = n.shift();            fs.unlink(p, function() {})        }        n.push(logFilename), localStorage.setItem('logFiles', JSON.stringify(n)),            _log = new log('info', fs.createWriteStream(logFilename))    }    _exports = _log}var _exports;init(), module.exports = _exports;然后就用它找找我想需要的东西吧,,比如说,,之前说的日志与配置文件夹不好找....我就用日志文件把它输出来...://app/dist/utils/tools.js 约40行处,(位置与变量名可能不一样,我手工重构过)        getAppConfig: function() {            var dataPath = nw.App.getDataPath(),                configPath = path.join(dataPath, '..', 'config.json'),                appCfg = {                    isDev: !!process.execPath.match('nw.exe') ||                        !!process.execPath.match('nwjs.app')                },                hasConfig = fs.existsSync(configPath);            log.info('[MY DEBUG]dataPath=' + dataPath); //加上这么一句.. 好了,现在打开微信小程序工具一运行..看见有日志在指定目录生成了...我知道答案了:C:\\Users\\(这儿是WINDOWS登录用户名)\\AppData\\Local\\微信web开发者工具\\User Data以下为几个目录：\r\n基本的数据目录\r\nC:\\Users\\(这儿是WINDOWS登录用户名)\\AppData\\Local\\微信web开发者工具\\User Data\r\n日志目录\r\nC:\\Users\\(这儿是WINDOWS登录用户名)\\AppData\\Local\\微信web开发者工具\\User Data\\WeappLog\r\n\r\n项目列表\r\nC:\\Users\\(这儿是WINDOWS登录用户名)\\AppData\\Local\\微信web开发者工具\\User Data\\WeappProject\r\n内容是JSON文件,,,可以文本编辑或者程序处理JSON格式..\r\n\r\n开发环境中小程序运行存储的数据\r\nC:\\Users\\(这儿是WINDOWS登录用户名)\\AppData\\Local\\微信web开发者工具\\User Data\\WeappStorage\r\n\r\n........\r\n其它目录有兴趣的朋友自己研究吧..."}
{"title": "微信小程序学习点滴《十二》：图片等比例缩放 获取屏幕尺寸图片尺寸 自适应 ... ... ", "author": "天下雪", "pub_time": "2016-11-12 14:33", "article_content": "早上在论坛上看到有人写了关于图片等比例缩放的文章,只是判断了图片宽是否大于屏幕宽.我之前在做Android的时候也会遇到图片等比例缩放的问题.应该是用图片宽高比和屏幕宽高比做判断.做个笔记.老规矩,先上图.1.图片高宽比小于屏幕高宽比2.图片高宽比大于屏幕高宽比3.这种其实也是图片高宽比小于屏幕高宽比,但是高宽都大于屏幕高宽.所以不能简单用高宽来判断,应该是用高宽比判断后做缩放.上代码:1.index.wxml<!--index.wxml-->  <!--图片宽大于屏幕宽-->  <image style=\"width: {{imagewidth}}px; height: {{imageheight}}px;\"  src=\"{{imagefirstsrc}}\" bindload=\"imageLoad\"></image>  <!--图片高大于屏幕高-->  <!--<image style=\"width: {{imagewidth}}px; height: {{imageheight}}px;\"  src=\"{{imagesecondsrc}}\" bindload=\"imageLoad\"></image>-->  <!--图片宽高大于屏幕宽高-->  <!--<image style=\"width: {{imagewidth}}px; height: {{imageheight}}px;\"  src=\"{{imagethirdsrc}}\" bindload=\"imageLoad\"></image>-->2.index.js//index.js  //获取应用实例  var imageUtil = require('../../utils/util.js');  var app = getApp()  Page({    data: {      imagefirstsrc: 'http://bpic.588ku.com/back_pic/00/03/85/1656205138bbe2d.png',//图片链接      imagesecondsrc: 'http://bpic.588ku.com/back_pic/04/07/63/28581203949ca9d.jpg!/fw/400/quality/90/unsharp/true/compress/true',//图片链接      imagethirdsrc:'http://img1.gtimg.com/ent/pics/hv1/13/71/2061/134034643.jpg',      imagewidth: 0,//缩放后的宽      imageheight: 0,//缩放后的高    },    onLoad: function () {    },    imageLoad: function (e) {      var imageSize = imageUtil.imageUtil(e)      this.setData({        imagewidth: imageSize.imageWidth,        imageheight: imageSize.imageHeight      })    }  })  3.util.js//util.js  function imageUtil(e) {    var imageSize = {};    var originalWidth = e.detail.width;//图片原始宽    var originalHeight = e.detail.height;//图片原始高    var originalScale = originalHeight/originalWidth;//图片高宽比    console.log('originalWidth: ' + originalWidth)    console.log('originalHeight: ' + originalHeight)    //获取屏幕宽高    wx.getSystemInfo({      success: function (res) {        var windowWidth = res.windowWidth;        var windowHeight = res.windowHeight;        var windowscale = windowHeight/windowWidth;//屏幕高宽比        console.log('windowWidth: ' + windowWidth)        console.log('windowHeight: ' + windowHeight)        if(originalScale < windowscale){//图片高宽比小于屏幕高宽比          //图片缩放后的宽为屏幕宽           imageSize.imageWidth = windowWidth;           imageSize.imageHeight = (windowWidth * originalHeight) / originalWidth;        }else{//图片高宽比大于屏幕高宽比          //图片缩放后的高为屏幕高           imageSize.imageHeight = windowHeight;           imageSize.imageWidth = (windowHeight * originalWidth) / originalHeight;        }      }    })    console.log('缩放后的宽: ' + imageSize.imageWidth)    console.log('缩放后的高: ' + imageSize.imageHeight)    return imageSize;  }  module.exports = {    imageUtil: imageUtil  }"}
{"title": "微信小程序学习点滴《十三》：音乐播放器 真机测试 audio API ", "author": "天下雪", "pub_time": "2016-11-12 14:36", "article_content": "简单的试了试播放器,还是有不少坑的.开始在模拟器上跑,一直没有声音,总是刚开始播放就暂停.做个笔记.准备资源:音乐图片地址:http://ac-5g9r20ds.clouddn.com/63bedb5f584234b6827c.jpg音乐mp3地址:http://ac-5g9r20ds.clouddn.com/e54ad7f0a834b9c07ec6.mp3我用leancloud做的后台.真机测试有效上张图,这是在模拟器上跑的.播放也能正常运行.右边是获取到的播放状态参数.代码部分说.下面是真机上的图.同样可以获取到播放状态参数:在不关闭音乐的情况下,退出小程序,是这样的.我当时就惊呆了.这会让小程序有更多露脸的机会啊.我一定的写个能播放音频的小程序.哈哈.再次进入的时候是这样的,图片是在js里面设置的.就在开始说的链接.代码:1.index.wxml[html] view plain copy<!--index.wxml-->    赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序学习点滴《十二》：图片等比例缩放 获取屏幕尺寸图片尺寸 自适应 ... ... \n              微信小程序真机预览体验测试教程 \n            \n             \n            \n                  原作者: dzp_coder \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序学习点滴《一》：如何获取时间，页面跳转，传递参数 ... ...\n                                    \n                  • 微信小程序学习点滴《二》：开发者工具快捷键，轮播图 swiper图片组件 ...\n                                    \n                  • 微信小程序学习点滴《三》：开发工具及开发环境配置，尺寸单位rpx与px,rem相互转换 ...\n                                    \n                  • 微信小程序学习点滴《四》：网络请求\n                                    \n                  • 微信小程序学习点滴《五》：网络请求(POST请求)填坑指南\n                                    \n                  • 微信小程序学习点滴《六》：保留小数(toFixed) 四舍五入 获取整数 string转int ...\n                                    \n                  • 微信小程序学习点滴《七》：数据存储 参数传递 数据缓存\n                                    \n                  • 微信小程序学习点滴《八》：从相册获取图片 使用相机拍照 本地图片上传 ... ...\n                                    \n                  • 微信小程序学习点滴《九》：本地图片上传(leancloud)\n                                    \n                  • 微信小程序学习点滴《十》：真机测试 地图定位 map API 无法获取当前位置的问题 ... ...\n                                    \n                  • 微信小程序学习点滴《十一》：选择器 时间选择器 日期选择器 地区选择器 ... ...\n                                    \n                  • 微信小程序学习点滴《十二》：图片等比例缩放 获取屏幕尺寸图片尺寸 自适应 ... ...\n                                    \n                  • 微信小程序学习点滴《十五》：用户系统 一键登录 获取session_key和openid ...\n                                    \n                  • 微信小程序学习点滴《十六》：下拉刷新 上拉加载\n                                    \n                  • 微信小程序媒体组件（一）audio\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSUii610', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164017|4ae6757e277193361dbd26cfa2a728af|2';"}
{"title": "经典教程：一个微信小程序的实现--简易计算器（附小程序方向思考图） ... ... ... ... ", "author": "天下雪", "pub_time": "2016-11-12 16:30", "article_content": "作者：游泳的石头前言我想，小程序其实不必多说。网上有很多小程序和方向的分析文章，昨天晚上我也在思考小程序的第一波红利将会是哪些方向，哪些人拿到。于是默默的打开手机应用时长，耐心的刷完了应用市场下载排行榜前1000的app，整理了这样一份微信小程序适合方向的清单出来，仅供大家参考。小程序方向思考图\r\n小程序的注册已经开放了，相信第一波红利将很快到来。不能马上启动开发的同学有好的idea也可以试试注册一下，占个坑也是好的呀。画完这张图之后，我就琢磨怎么快速开发一个简单的小程序出来。想了想，貌似计算器应该是开发起来最快的，也是抽了点时间马上做了一个简易计算器出来。简易计算器先看效果图（不知这张gif为何只能播一遍）效果图\r\n代码就不多说了，已经推到github上（传送门），欢迎大家star和clone。界面全部使用flex布局，这里也不多说，不懂的同学请点这里查看阮一峰老师的文章，应该是讲的非常明白的，我的代码也很清楚。这里主要介绍一下下面这张状态机图。计算器状态机\r\n在这个简单的计算器里，我一共定义了6个状态，分别是：\r\ninit: 初始状态。最初进入时的状态，或者重置后的状态。\r\nfirst_undot: 第一个操作数录入中, 无小数点。这个状态下界面上显示的是第一个操作数。\r\nfirst_dot: 第一个操作数录入中, 有小数点。这个状态下界面上显示的是第一个操作数。\r\nsecond_undot: 第二个操作数录入中, 无小数点。这个状态下界面上显示的是第二个操作数。\r\nsecond_dot: 第二个操作数录入中, 有小数点。这个状态下界面上显示的是第二个操作数。\r\nresult: 结果状态。这个状态下界面上显示的计算结果。\r\n上图就是这6个状态的转换关系。状态机在计算机系统中其实被大量使用，编译器里面用得最多。随手贴个TCP协议的状态机图给大家看看。TCP状态机图\r\n结束语简易计算器Github传送门：https://github.com/boyce-ywr/wxapp-calc。欢迎参考。、文件下载：wxapp-calc-master.zip对于熟悉前端开发，熟悉angularjs或react开发的同学，微信小程序的开发应该是非常快的。微信小程序完全支持ES6语法，强烈推荐使用flex布局。"}
{"title": "官方文档浓缩系列《三》官方运营文档解读 ", "author": "天下雪", "pub_time": "2016-11-12 16:44", "article_content": "解读后全文篇幅不到原文档的三分之一，希望能帮小程序开发者节省阅读文档的时间，同时，避开小程序开发中的大坑。　　小程序官方运营文档解读　　你的小程序能过审吗？　　想做一个微信小程序？有想法是很好，但是在动手之前，需要注意你的想法适不适合做成微信小程序。　　以下是微信官方禁止的小程序类别表：非法、违反公序良俗等功能过于简单以传播谣言为目的测试抽签（星座血缘等等）以分级推销为目的微信已有的功能（比如漂流瓶等）恐怖性质较强（会给用户带来恐惧感）要求用户越狱/root 后才能使用　　除此之外，不在小程序服务范围的类别也无法通过审核。知晓程序（微信号 zxcx0101）在此特意提醒大家： 在开发之前，一定要检查小程序的分类是否能够通过审核。　　关注知晓程序（微信号 zxcx0101），回复「服务范围」即可获得小程序服务范围的高清表格。　　设计注意事项　　想法有了，接下来就是设计小程序的功能和界面。　　在设计的过程中，除了界面需要遵循官方的设计文档外，功能设计上也有许多需要注意的事情。　　1. 核心功能　　微信官方希望小程序能以最快的速度解决用户发出的任务。因此， 在功能设计上，小程序必须以解决问题为核心。　　微信团队规定， 小程序必须将核心功能前置，即用户打开小程序后，进入核心功能不得超过两次点击。　　此外，每个页面都有唯一一个功能，在页面设计的过程中，页面的跳转必须符合用户的预期。　　如果小程序页面中含有太多与主要功能无关的功能，就比较容易被拒绝。这点在设计中值得注意。　　2. 广告　　在设计文档中提到对广告和推广的限制。　　而在微信官方的运营文档中， 广告可以说是被严格限制的。　　如果要在小程序中做推广，不可对用户造成严重的骚扰：首先不要投放全屏广告，也不能让广告在页面的主要部分被凸显。　　在设计阶段，务必严格按照官方设计文档来进行。如果还想知道小程序中怎样的广告是可以接受的，那么微信官方的朋友圈广告和公众号末尾广告都可以作为参考。　　3. 信息收集与处理　　微信官方对使用小程序收集和处理信息的行为，进行了严格规定。　　首先，在小程序与服务器交换数据时，所有数据都必须通过加密的 HTTPS 443 进行连接。　　在收集数据的时候， 需要明确告知用户数据收集的内容和目的，由用户决定是否提交数据。　　如果小程序有外部分享功能（如分享至微博等），也需要明确告知用户小程序正在分享、分享的内容是什么等等。　　在设计的过程中，建议在用于提交数据的元素（例如文本框等）中，需要对用户提交的数据进行明显的提示，不要出现含糊不清的情况。　　如果小程序带有持续性位置数据获取功能，也需要在设计中有明显提示。例如，增加「正在获取位置信息」的文案，或是在小程序中展示带有相同意义的 icon。　　如果有能力，开发者可以与用户签订 ToS（Term of Services，服务协议）以及隐私声明等方式，来提示用户数据使用的目的等。　　4. （被禁止的）诱导　　小程序在功能设计的时候， 万不可诱导用户先关注某些公众号或小程序，才能使用功能。　　目前，许多 app（特别是在 Android）有一种「自定义组件」的方式，即下载安装主程序（本体）之后，用户可以依照自己的需要下载安装其他组件，以完成功能。　　在 iOS 和 Android 上，这种方式有助于压缩应用体积并提高运行效率。但在小程序中，这种行为涉嫌诱导关注。所以知晓程序（微信号 zxcx0101）建议：用一个独立小程序直接完成所有任务。　　例如「欢迎扫码关注 xxx 公众号」「欢迎扫码下载 xxx 应用」「关注或下载 xxx 方可查看」，以及「不关注 xxx 不是中国人」这种事情还是少干为妙。　　5. 运维功能　　在功能设计的过程中，需要注意添加一些运维性功能。　　所有的小程序都需要有应用内反馈机制，以便用户在应用内进行问题反馈。在设计和规划时，这个功能就应该被考虑在内。　　对于社区及 UGC 小程序，小程序内也需要提供举报（报告疑虑）机制，以便管理员能够即时对违反 ToS 及相关法律法规内容进行处理。　　开发注意事项　　设计完小程序，总算可以步入开发阶段了。　　微信官方提供的运营文档中，明确标明了 审核时需要提交一份技术说明文档。目前尚不清楚是需要在提交审核的时候提交，还是在审核人员要求时才需要提交。　　所以， 在小程序的开发过程中，开发人员需要注意记录每一个功能点，包括功能名称、触发位置、实现手段等等，以便于在审核时进行提交。对于功能较多的小程序，这部分的总结工作更需要留意。　　对于包含用户中心功能，或需要用户登录才能使用某些功能的小程序， 需要在技术说明文档中提供一份用于审核的用户名和密码，以便审核人员能够完整审核小程序。　　知晓程序建议：在开发的过程中提供一个供审核人员使用的入口。　　开发的最后，还需要检查小程序本身能否正常运行。如果审核时小程序出现严重的不正常情况，是不能通过审核的。　　有多媒体播放功能的小程序还需检查是否有多媒体意外自动播放的情况，自动播放多媒体也是审核被拒绝的原因之一。　　审核之前，你需要注意　　只有拿到了 App ID 的小程序才能进行调试，并提交审核。　　在此之前，还需要完成小程序的资料填写等过程。　　填写资料时，小程序的名称除了不能与现有的公众号重名之外，还需要注意以下几个方面：名称需要与小程序相关不能直接起名为泛名称，类似「电话」、「短信」、「邮件」等不能出现新广告法明令禁止或其他无关的词语对于预留名称，需要提交额外资料进行审核　　上传小程序 Logo（头像）时，图片需保持简洁、清晰、可辨识。同时，微信官方不建议在小程序 Logo 上加背景和边框等（类似一些 app 处理 iOS 应用图标的情况）。　　此外，小程序简介需要与小程序本身有相关性，即介绍小程序的功能和作用。　　知晓程序（微信号 zxcx0101）再次提醒：提交审核前，请以正常用户的身份再测试一次小程序。　　运营　　如果通过了审核，那么，你的小程序就可以正式上线了，恭喜！　　但是，未来的运营中也有许多情况需要多加留意，以免小程序被勒令取消发布。　　1. 内容运营　　在日常的运营过程中，小程序的内容不能出现以下信息：违法、违规谣言、虚假不实的消息等诱导性信息（诱导关注公众号、添加小程序）造成骚扰的信息，或进行恶意营销会对用户造成恐惧的信息　　此外，如果你的小程序有 UGC 功能，则需要及时审核，以便尽早发现违规内容，避免小程序因为以上违规内容的传播而带来不必要的麻烦。　　2. 信息安全　　不能在未经用户同意的前提下，擅自转移或销毁用户数据。如果小程序的生命周期结束或被收购，那么，小程序的运营方需要为用户提供数据处理的解决方案。　　不能私下买卖和泄露用户在小程序中提交的数据，未经用户同意对外展示的资料也不允许公开。　　总之，在小程序中使用数据会受到严格的控制，开发者需要尊重用户对于数据的控制权并保障数据安全。　　3. 模板消息　　小程序具有模板消息推送能力。通过模板消息功能，小程序可以向用户推送重要通知。　　需要注意的是， 小程序中的模板消息只具有通知功能。而且，触发特定事件（如生成订单等）后，小程序才能向用户推送消息。　　小程序主动发送模板消息，或诱导用户触发模板消息的行为，都违反了相关条例中的说明。　　微信官方更倾向于将模板消息作为一种通知手段，而非一种推广方式。如果小程序违规使用模板消息，微信团队会对小程序做出处罚，甚至会让小程序下架。　　4. 服务可靠性　　如果小程序的运行依赖运营方提供的服务器，那么运营方需要保证服务器的稳定。不稳定的服务器不仅会影响用户体验，而且可能会让小程序下架。　　对于更新周期较长的小程序，知晓程序（微信号 zxcx0101）也建议运营方时常登录小程序公众号后台，以免小程序因长期不登录而被下架。　　某些小程序可能会通过热更新的形式动态加载代码，以缩短小程序的更新周期。虽然热更新的内容不需要另行经过审核，但其中也不能出现任何违规行为。一旦热更新的内容被发现违反相关规定，那么小程序有可能会被勒令下架。　　以上就是知晓程序对官方运营文档的全部解读，希望开发者仔细阅读文章内容，避免未来出现违规行为，而导致自己的小程序处罚下架。"}
{"title": "微信小程序真机预览体验测试教程 ", "author": "天下雪", "pub_time": "2016-11-13 01:13", "article_content": "友情提醒：社区综合交流版块里还有2-3个剩余的开发者账号，有兴趣的请及时申请：http://www.wxapp-union.com/forum.php?mod=viewthread&tid=523本友情提醒有效期至11月16日：此日期后，请勿继续申请，假如有新的开放资源，会及时通知大家；前言从小程序内测开始，有很多优秀的创意、想法已经在内测阶段开发完成。目前小程序开始公测，开放了小程序的申请和注册，但是还无法正式发布。那么我们在未正式发布之前，能不能在真机上体验一回微信小程序呢。答案是肯定的。真机体验截图首先，我们先看一下在真机里微信小程序的手机截图，如果不明确的跟你说，这是微信小程序的话，估计你也会认为这是一个APP界面。但…..但这是如假包换的微信小程序呀，而且页面切换非常的流畅。这张截图，是在微信开发者工具的开发界面。教程步骤我们现在直接进入主题，微信小程序如何在真机体验测试的教程。首先，我们要确保已经申请注册好了微信小程序，如果还未申请注册的，那接下来的教程内容你可以大概了解就行了，不用细读，浪费你的时间。填写AppID在添加项目时，请填写AppID，如图。此处的AppID，请填写真实有效的，是在微信小程序官网后台拿到的AppID，要不然你是无法在真机是体验测试的。预览体验小程序我们添加好项目之后，打开了开发小程序的界面。看到左边，有一个功能名称叫项目（截图中的1），点击打开之后，会看到预览按钮已不是灰色的了（截图中的2）。如果未填写AppID，这个预览功能是灰色的。点击预览之后，我们会看到弹出了一个二维码，并且是有时效性的二维码，同时只能是开发者本人的微信号才能扫一扫，在真机上进行预览体验测试。这个是特别强调的地方，只能是开发者本人的微信号才能扫一扫，在真机上进行预览体验测试，那意味着，我们把这个二维码分享给别人，别人是无法进行体验的。真机上的调试模式微信小程序，在真机的体验真的很棒，对用户而言，好用可用流畅是第一要点。其实小程序对于我们开发者，也提供了很友好的界面和完善的调试功能，让我万万没想到的是，在真机上微信小程序也给我们开发者提供了调试模式，请看图片，童鞋们。看着这调试界面，是不是有点回家的感觉，哈哈。有点类似我们用chrome-devtools开发web一样。这里主要是提供了console.log的打印调试，还有手机系统信息。那我们是如何开始这个真机上的调试模式的呢。我们在真机上打开微信小程序后，看到右上角的三个点，打开之后我们就会看到有打开调试的字眼，直接选择打开即可，这里有一个重启小程序的过程，再次扫一扫二维码进入就可以看到调试了。结束微信小程序真机预览体验测试教程的教程已经讲完，教程并不复杂，最主要的一点是，你有一个真实有效的AppID，是在微信小程序官网后台拿到的AppID，否则你是无法预览小程序的。"}
{"title": "微信小程序页面跳转的数据传递，页面跳转的两种方式 ", "author": "天下雪", "pub_time": "2016-11-13 12:29", "article_content": "作者：变身为小灰驴的驴小毛；拍照要说耶诶一：跳转的数据传递类似Android的Intent传值，微信小程序也一样可以传值：      例如：wxml中写了一个函数跳转：<view class=\"itemWeight\" catchtap=\"jumpToOverMissionList\">      <view class=\"textStatus\">已完成任务</view>      <view class=\"containVertical textNum\">{{finishedMissionCount}}</view>  </view>         在js代码中写：其中，url是跳转的相对路径，？问号后面加的是参数，以key－value的方式，这里传了个value为2的参数过去//跳转到已结束任务列表页  jumpToOverMissionList:function(){      wx.navigateTo({          url:\"mission/missionList/missionList?type=2\"      });  },        然后在missionList.js中的OnLoad()方法得到值：option.type就可以得到了onLoad: function (option) {      this.setData({          type:option.type,      });      console.log(option.type);  } 二：页面跳转今天尝试了下小程序点击页面跳转，有两种方式：navigator组件跳转和添加点击事件跳转。1.navigator组件跳转和a标签跳转差不多，给navigator添加要跳转到的url地址即可（这里需要注意下，我们在使用微信web开发者工具按enter自动补全时生成的组件有错，navigator闭合标签的“/”位置应该是在navigator前，而自动生成的是,导致编译报错，同样的还有image组件等）<span style=\"font-size:14px;\"><navigator url=\"../logs/logs\">点击跳转到logs页面</navigator></span> 2.为组件绑定跳转事件    index.wxml中为image绑定事件<span style=\"font-size:14px;\">  <image src=\"{{item.imgsrc}}\" bindtap=\"tz\"></image></span>    index.js文件中添加跳转方法：<span style=\"font-size:14px;\">tz: function(){      wx.navigateTo({        url: '../logs/logs',        success: function(res){          // success        },        fail: function() {          // fail        },        complete: function() {          // complete        }      })    }</span>"}
{"title": "MaShiYong：微信小程序组件属性配置简介 ", "author": "天下雪", "pub_time": "2016-11-13 12:38", "article_content": "1.window配置 -----设置微信小程序状态栏,导航栏,标题和窗口背景色\r\n\r\n2.tabBar配置\r\n3.页面基本生命周期\r\n\r\n\r\n4.scroll配置\r\n5.swiper配置\r\n6.icon配置\r\n7.text配置通常text是不在wxml中设置,要不就通过wxml中绑定 在js中设置\r\n<view>      <text>{{name}}</text></view>\r\n\r\n\r\nPage({    data{        name:\"这是MaShiYong的简书\"}})\r\n8.progress进度条配置\r\n9.button配置"}
{"title": "踩一踩微信小程序开发的坑---tabBar ", "author": "天下雪", "pub_time": "2016-11-13 12:45", "article_content": "新手跳坑系列：新手跳坑指南《一》：真机上预览，背景图无效新手跳坑指南《二》：app.json之pages路径重复错误新手跳坑指南《三》：宽高设置百分比无效果新手跳坑指南《四》：智能补全bug新手跳坑指南《五》：this与that：this.setData报错新手跳坑系列《六》：找不到自己的相匹配手机预览页面新手跳坑系列《七》tabBar不显示新手跳坑系列《八》MAC版微信WEB开发者工具无法显示二维码新手跳坑系列《九》：post请求新手跳坑系列《十》修改配置域名后，提示不在合法域名内新手跳坑指南《十一》require 和hidden不生效，@import无效新手跳坑指南《十二》事件绑定调用多次新手跳坑指南《十三》手机中浏览时显示空白页新手跳坑指南《十四》真机预览限制大小1024K新手跳坑指南《十五》view标签设置背景图片手机无法预览 新手跳坑系列《十六》没有配置路由，input，空格回车，中文新手跳坑指南《十七》：设置tabBar图片无法显示新手跳坑指南《十八》wx.showToast消息显示框手机预览失败...新人跳坑系列《十九》swiper无法保持宽高比 最近忙于开发视频直播的项目，小程序学习也放置了两三个星期了，web开发者工具更新到新版，发现上个版本做的demo不显示了"}
{"title": "微信小程序开发小 tips： XXX API 无法使用，富文本，POST 请求，less/sass ... ", "author": "天下雪", "pub_time": "2016-11-13 13:06", "article_content": "为什么 XXX API 无法使用？A：因为小程序屏蔽了一部分原生的 API 接口，以下为被屏蔽列表：window document framesself location navigator localStorage history Caches screen alert confirmprompt XMLHttpRequest WebSocket建议开发者尽可能使用微信官方提供 API 实现相应功能。小程序如何支持富文本显示？小程序没有提供富文本渲染的接口，需要等待相关接口开放才能显示富文本，目前普遍做法是去掉文本的 html 标签，显示纯文本。例如使用：simplehtmlparser如何执行动态生成的 javascript 代码？小程序屏蔽了 eval 和 Function API，无法执行动态的 javascript 代码，请避免使用。如何使用 POST 请求？原因是浏览器 CORS 限制，而且小程序 request API 为了保持和 jQuery 的一致，在发送请求时会自动添加 x-requested-with：XMLHttpRequest 这个 header，你需要在服务端返回上加入响应头：Access-Control-Allow-Headers: x-requested-with 参考 stackoverflow，否则浏览器会认为请求非法。WEPT 可以帮你从后端代理发送请求，无需针对 CORS 特别处理。如何查看前端页面的源码？官方的开发者工具默认屏蔽了 UI 层的右键 inspect 功能，可以对官方开发者工具做些修改来开启右键（开启该功能会造成 wxml 面板不可用以及页面无法响应点击等严重 bug），首先使用 js-beautify 对代码批量格式化：cd /Applications/wechatwebdevtools.app/Contents/Resources/app.nw\r\nfind . -type f -name '*.js' -not -path \"./node_modules/*\" -not -path \"./modified_modules/*\" -exec js-beautify -r -s 2 -p -f '{}' \\;\r\n注释掉文件 app/dist/app.js 44 行和 app/dist/components/simulator/webviewbody.js 149 行preventDefault 调用。101100 版本还需要修改 package.json 文件，去掉 --disable-devtools。最后重启开发者工具即可。小程序支持 es6 吗？官方 IDE 101100 已经支持 es6 语法，可以放心使用。wept 0.3.0 开始也加入了 es6 的支持如何让小程序支持 less/sass？官方 IDE 暂时还没有提供 less 和 sass 等 css 预编译器支持，不建议使用。微信小程序能当成app的客户端使用吗？理论上讲肯定是完全可以的，只是你需要用 Java 和 Object-C 实现同微信一样的多层通讯逻辑以及各种底层和 UI 上的组件。"}
{"title": "微信小程序初接触与踩坑日记 ", "author": "天下雪", "pub_time": "2016-11-13 21:30", "article_content": "作者：xiadd    原文地址一：微信小程序初接触微信主要做了这么几件事：不怎么流通的数据流指定ui破破烂烂的ide尤其自带的ide简直不能忍受想要用其他ide（编辑器）写微信小程序，我们需要做下面的事：将html编译成wxml将sass编译成wxss由于json的难阅读所以使用yml进行配置gulp配置var gulp = require('gulp')\r\nvar fs = require('fs')\r\nvar sass = require('gulp-sass')\r\nvar rename = require('gulp-rename')\r\nvar yaml = require('gulp-yaml')\r\nvar babel = require('gulp-babel')\r\nvar image  = require('gulp-image');\r\n\r\ngulp.task('wxml', function () {\r\n  gulp.src('./app/**/*.html')\r\n  .pipe(rename(function (path) {\r\n    path.extname = '.wxml'\r\n  }))\r\n  .pipe(gulp.dest('build/'))\r\n})\r\n\r\ngulp.task('sass', function () {\r\n  gulp.src('./app/**/*.scss')\r\n  .pipe(sass({outputStyle: 'expanded'}))\r\n  .pipe(rename(function (path) {\r\n    path.extname = '.wxss'\r\n  }))\r\n  .pipe(gulp.dest('build'))\r\n})\r\n\r\ngulp.task('yml', function () {\r\n  gulp.src('./app/**/*.yml')\r\n  .pipe(yaml({ space: 2 }))\r\n  .pipe(gulp.dest('build'))\r\n})\r\n\r\ngulp.task('js', function () {\r\n  gulp.src('./app/**/*.js')\r\n  .pipe(babel({\r\n    presets: ['es2015']\r\n  }))\r\n  .pipe(gulp.dest('build'))\r\n})\r\n\r\ngulp.task('image', function () {\r\n  gulp.src(['./app/**/*.png', './app/**/*.jpg'])\r\n  .pipe(image())\r\n  .pipe(gulp.dest('build'))\r\n})\r\n\r\ngulp.task('default', ['wxml', 'sass', 'yml', 'js'], function () {\r\n  gulp.watch('./app/**/*.html', ['wxml'])\r\n  gulp.watch('./app/**/*.scss', ['sass'])\r\n  gulp.watch('./app/**/*.yml', ['yml'])\r\n  gulp.watch('./app/**/*.js', ['js'])\r\n})下面是非前端或者非nodejs开发者看的：首先你得安装nodejs和npm，然后执行npm i -g gulp-cli。然后git clone 项目。进入文件夹中执行npm install，然后执行gulp即可进行编译。将编译后的build/目录作为小程序主目录。完成。atom 插件个人花了点时间搞了一个atom插件。作为atom开发的补充，具有部分自动补全的功能，都是体力活。atom搜索安装wxapp插件就好。重启编辑器后直接使用基础配置微信已经将目录结构定死了所以可以发挥的余地也不是很大，基本来说只要跟着他的教程走做个简单的应用还是很容易的模板目录如下：weapp/\r\n\tapp/\r\n\t\tpages/\r\n\t\t\tindex/\r\n\t\t\tlogs/\r\n\t\tutils/\r\n\t\tapp.js\r\n\t\tapp.scss\r\n\t\tapp.yml\r\n\tnode_modules/\r\n\tbuild/\r\n\t.gitignore\r\n\tgulpfile.js\r\n\tpackage.json\r\n其中build为打包后的目录，微信小程序就运行该目录。另外我个人搞了个atom插件（我习惯用atom）包括了部分自动提示，还可以。小程序示例接下来我们将使用v2ex的接口来进行简单的示例。v2ex的接口相当简洁，非常时候做示例。接口整理最热主题：url: https://www.v2ex.com/api/topics/hot.jsonmethod: get节点信息url: https://www.v2ex.com/api/nodes/show.jsonmethod: getquery: name最新主题url: mehtod: get用户主页url: https://www.v2ex.com/api/members/show.jsonmethod: getquery: id or username简单配置后台由于小程序域名有所限制，所以这里自己搭个后台简单转发一下，代码如下：var https = require('https')\r\nvar express = require('express')\r\nvar fs = require('fs')\r\nvar request = require('request')\r\n\r\nvar app = express()\r\n\r\nvar options = {\r\n  key: fs.readFileSync('./wechat/wechat.key'),\r\n  cert: fs.readFileSync('./wechat/wechat.pem')\r\n}\r\n\r\napp.get('/', (req, res) => {\r\n  res.json({\r\n    name: 1\r\n  })\r\n})\r\n\r\napp.get('/hot', (req, res) => {\r\n  var url = 'https://www.v2ex.com/api/topics/hot.json'\r\n  request(url, (err, result, body) => {\r\n    res.json(body)\r\n  })\r\n})\r\n\r\napp.get('/newest', (req, res) => {\r\n  var url = 'https://www.v2ex.com/api/topics/latest.json'\r\n  request(url, (err, result, body) => {\r\n    res.json(body)\r\n  })\r\n})\r\n\r\napp.get('/profile', (req, res) => {\r\n  var username = req.query.username\r\n  var url = 'https://www.v2ex.com/api/members/show.json?username=' + username\r\n  request(url, (err, result, body) => {\r\n    res.json(JSON.parse(body))\r\n  })\r\n})\r\n\r\nvar server = https.createServer(options, app)\r\n\r\nserver.listen(443, () => console.log('server is running'))这里是申请的阿里云免费证书在本地起个服务器，然后用natapp（natapp.cn）进行转发。如图服务器搭起来了（就是简单的转发了三个接口。而且v2ex的接口也实在太简单了），下面就是小程序的工作了。二：踩坑日记如果pages里的js文件是空的，微信小程序未递补上去，然后后面的page js文件就为空，真是奇奇怪怪的bugimage标签有问题，有待探究不知道为何连websocket显示是xhr请求"}
{"title": "微信小程序购物车实战：加减商品数量，汇总价格，全选与全不选 ... ... ", "author": "天下雪", "pub_time": "2016-11-13 21:59", "article_content": "微信小程序，这里实现微信小程序checkbox,有需要此功能的朋友可以参考下。摘要: 加减商品数量，汇总价格，全选与全不选设计思路：一、从网络上传入以下Json数据格式的数组  1.标题title 2.图片地址 3.数量num 4.价格price  5.是否选中selected 二、点击复选框toggle操作 如已经选中的，经点击变成未选中，反之而反之 点击依据index作为标识，方便遍历三、全选操作 首次点击即为全部选中，再次点击为全不选，全选按钮本身也跟随toggle变换四、点击结算按钮，将已选中的数组取出，以供通过网络提交到服务端，这里给个toast作为结果演示。五、利用stepper作加减运算，同样依据index作为标识，点完写回num值。六、布局，全选与结算按钮底部对齐，购物车商城自适应高度，类似于Android的weight。步骤：初始数据渲染1.1 布局与样式表上方是一个商品列表，下方是一个全选按钮与立即结算按钮商品列表左部为商品缩略图，右上为商品标题，右下为商品价格与数量，先看一下效果图：页面代码如图:<view wx:for=\"{{carts}}\" class=\"carts-item\" data-title=\"{{item.title}}\" data-url=\"{{item.url}}\" bindtap=\"bindViewTap\"><view class=\"my-wrap\"> <view class=\"my-tlt\">{{item.title}}</view><view class=\"my-list bordernone\"><icon wx:if=\"{{item.selected}}\" type=\"success_circle\" size=\"20\" bindtap=\"bindCheckbox\" data-index=\"{{index}}\" class=\"my-check\"/><icon wx:else type=\"circle\" size=\"20\" bindtap=\"bindCheckbox\" data-index=\"{{index}}\" class=\"my-check\"/><image src=\"{{item.image}}\" class=\"my-pic\" mode=\"aspectFill\"></image><view class=\"my-left\"><view class=\"my-title\"> K金砖玉石电视背景墙砖</view><text class=\"my-txt\">尺寸：800X800</text><view class=\"my-bnt\"><!-- 减号 --><text class=\"{{minusStatuses[index]}} bnt\" data-index=\"{{index}}\" bindtap=\"bindMinus\">-</text><!-- 数值 --><input type=\"number\" bindchange=\"bindManual\" class=\"int\" value=\"{{item.num}}\" /><!-- 加号 --><text class=\"normal bnt\" data-index=\"{{index}}\" bindtap=\"bindPlus\">+</text>]</view></view><view class=\"my-right\"><icon class=\"iconfont del\"/><text class=\"gay\">￥{{item.price}}</text></view></view></view><view class=\"float\"><!-- 全选 --><view bindtap=\"bindSelectAll\" class=\"my-sel\" ><icon wx:if=\"{{selectedAllStatus}}\" type=\"success_circle\" size=\"20\" class=\"l-mycheck\"/><icon wx:else type=\"circle\" size=\"20\" class=\"l-mycheck\"/><text>全选</text></view><view class=\"my-rightbox\"><view class=\"my-count\" data='{{sep}}'><!-- 统计 -->合计（不含运费）：￥<text>{{count}}</text></view><view class=\"my-bnts\" bindtap=\"setPayment\" >结算（<text>{{number}}</text>）</view></view></view>这里css自己去写,这里不做多介绍，只做效果：首先：先定义js在page.data里面赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (3)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (3 人)\r\n\r\n\r\n\r\n\r\nwx_0bc8f44a82\r\n\r\n\r\n\r\n时代奇迹\r\n\r\n\r\n\r\nweining\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              经典教程：一个微信小程序的实现--简易计算器（附小程序方向思考图） ... ... ... ... \n              前端圈：微信小程序开发一周总结 \n            \n             \n            \n                  原作者: 廖毅 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序 全选和取消全选\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    5 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n     \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         wx_251417f03b\r\n                \r\n       \r\n       2017-5-2 11:34\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    地址呢\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n          \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         wx_0bc8f44a82\r\n                \r\n       \r\n       2017-2-20 11:31\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    nb\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n          \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         a公子小白\r\n                \r\n       \r\n       2016-11-15 10:11\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    地址呢\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n          \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         a公子小白\r\n                \r\n       \r\n       2016-11-15 10:10\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    6666666666666\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n          \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         weining\r\n                \r\n       \r\n       2016-11-14 10:06\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    牛\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n             \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSMqXrHG', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序第三方框架对比 ( wepy / mpvue / ta2019-01-28微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30分享一款拥有历史搜索记录的微信小程序搜索2019-01-28小程序点睛之三：才不是你想的那种组件2019-01-28微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n微信小程序Demo:Canvas图片拖拽生成实现2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo：精美的画板小程序2019-02-21微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：仿 [one] 微信小程序2019-02-18微信小程序Demo：3D旋转效果2019-02-18微信小程序Demo: flappy-bird小游戏2019-02-15微信小程序Demo：群应用（群通知、群接龙、2019-02-15微信小程序Demo：咩咩单词2019-02-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164029|74d37d82d3b2ae1b58371579caf51b65|2';"}
{"title": "必看！官方文档没有！从零接入微信小程序支付（微信支付） ... ", "author": "天下雪", "pub_time": "2016-11-14 10:26", "article_content": "本文作者：jeffchen，是微信支付部门的员工，微信小程序官方文档中并没有微信支付的部分，所以他特意写了一份，感谢作者！本文已获授权；小程序中微信支付的能力，是随着小程序的发布一并推出的，然而小程序文档里关于微信支付接口只有一个requestPayment函数的描述。这个requestPayment函数确实是小程序前端唯一需要调用的函数，但是微信支付的成功接入实际远远不止这一个函数，对于没有接入过微信支付的开发者，会觉得一头雾水，完全没法下手。本文阐述如何从零开始接入小程序支付，尤其适合那些没有微信支付接入经验的开发者。1. 申请微信支付小程序认证以后，可以在小程序后台，微信支付菜单栏，申请微信支付。填写企业信息和对公账户，微信支付会打一笔随机金额到对公账户，输入金额完成验证后，在线签署迁移，即完成了微信支付的申请流程.。微信支付申请完，会发送微信支付商户号，商户平台用户名密码等信息到注册者邮箱。2. 准备工作2.1  配置小程序密钥小程序后台设置页，点击生成，管理员验证二维码后，会随机生成AppSecret。请妥善保管好Appsecret，不要明文存储于服务器，AppSecret用于和微信服务器交互。比如获取用户的openid接口就需要用到.2.2  设置密钥和下载证书用申请微信支付获得的用户名和密码，登录商户平台(http://pay.weixin.qq.com)，在账户中心，API安全中下载证书和设置密钥。密钥是32位，设置以后需要妥善保管，因为无法查看密钥，所有微信支付相关的接口都会使用这个密钥加密。2.3 配置Https服务器小程序的前端是使用微信提供的框架开发，但是后台依然是开发者自己的服务器。小程序发起的是https请求，意味着小程序开发者必须配置https服务器。配置https服务器之前，先要获取证书，证书可以向相关机构购买，腾讯云目前可以向用户提供免费的证书.证书安装指引，可以参考这里： https://www.qcloud.com/doc/product/400/41433. 微信支付流程微信支付有多种支付方式，包括刷卡支付，公众号支付，扫码支付，APP支付，所有微信支付的接口都可以在这里找到：https://pay.weixin.qq.com/wiki/doc/api/index.html小程序是在微信里调起支付的，其实是公众号支付，关于公众号支付的详细文档可以这里找到： https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_1所有公众号支付相关的链接都可以在此链接找到，开发者首先需要大概了解这些接口小程序公众号支付的主要流程如下（本图只考虑了正常流程，异常流程参考公众号支付文档）：3.1 关于openid上述流程中请求openid，用的是小程序最新api中的接口，开发者可以查看小程序的登录接口。开发者从第三方服务器获得的openid，在统一下单的接口里面需要使用到.3.2 关于小程序调起微信支付上述流程中的小程序调起微信支付，用的是小程序微信支付接口wx.requestPayment，该接口的详细描述可以查看小程序的微信支付API。这个接口中的package和timeStamp参数是从开发者的第三方服务器返回的，package是第三方服务器从统一下单接口回复中获得。接口中其他的参数，appId，noceStr，signType以及paySign则由小程序这边存储或者计算而得。其中paySign是签名，签名算法文档在这里：https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=4_3&t=20161107整个公众号支付的主要流程基本都是在第三方服务器上实现，开发者需要熟读公众号支付文档，了解消息交互流程以及每个接口。这里并没有描述正常微信支付必不可少的一些功能：异常处理，查询订单，发起退款，下载对账单等等。4.  小程序与JSSDK微信支付比较JSSDK的微信支付接口是公众号里用JS调起公众号支付的方法，具体可以参考公众平台的文档。可以看到，小程序和JSSDK的微信支付非常类似，这里比较一下2者的区别：最后欢迎关注作者订阅号，主要分享一些移动支付相关的技术和观点：“移动开发技术”"}
{"title": "小程序之scroll-view ", "author": "天下雪", "pub_time": "2016-11-10 14:07", "article_content": "原文地址：https://vincentcwlove.github.io/2016/11/07/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8Bscroll-view/scroll-view 的属性属性名类型默认值说明scroll-xBooleanfalse允许横向滚动scroll-yBooleanfalse允许纵向滚动upper-thresholdNumber50距顶部/左边多远时（单位px），触发 scrolltoupper 事件lower-thresholdNumber50距底部/右边多远时（单位px），触发 scrolltolower 事件scroll-topNumber设置竖向滚动条位置scroll-leftNumber设置横向滚动条位置scroll-into-viewString值应为某子元素id，则滚动到该元素，元素顶部对齐滚动区域顶部bindscrolltoupperEventHandle滚动到顶部/左边，会触发 scrolltoupper 事件bindscrolltolowerEventHandle滚动到底部/右边，会触发 scrolltolower 事件bindscrollEventHandle滚动时触发，event.detail = {scrollLeft, scrollTop, scrollHeight, scrollWidth, deltaX, deltaY}使用竖向滚动时，需要给一个固定高度，通过 WXSS 设置 height。示例代码选中pages文件夹下的detail文件夹下的detail.wxml文件,键入如下代码：<!--scroll-view组件--><block wx:if=\"{{index == 1}}\">    <!--横向滚动-->    <view class=\"menu\">        <scroll-view scroll-x=\"true\" class=\"top-nav\">            <view class=\"top_btn top_btn_select\">栏目1</view>            <view class=\"top_btn\">栏目2</view>            <view class=\"top_btn\">栏目3</view>            <view class=\"top_btn\">栏目4</view>            <view class=\"top_btn\">栏目5</view>            <view class=\"top_btn\">栏目6</view>            <view class=\"top_btn\">栏目7</view>            <view class=\"top_btn\">栏目8</view>        </scroll-view>    </view>    <!--竖向滚动-->    <scroll-view scroll-y=\"true\" class=\"content\">        <view class=\"cell\">cell1</view>        <view class=\"cell\">cell2</view>        <view class=\"cell\">cell3</view>        <view class=\"cell\">cell4</view>        <view class=\"cell\">cell5</view>        <view class=\"cell\">cell6</view>        <view class=\"cell\">cell7</view>        <view class=\"cell\">cell8</view>    </scroll-view>选中pages文件夹下的detail文件夹下的detail.wxss文件,键入如下代码：/*scroll-view 组件样式*//*水平*/.menu{  position: fixed;  top: 0;  left: 0;  z-index: 10;  width: 100%;  background: #fff;  border-top:#eee solid 1px;  border-bottom:#eee solid 1px;}.top-nav{    white-space: nowrap;    display: flex;}.top_btn {    display: inline-block;    margin: 10px;    font-size: 1rem;    color: gray;}.top_btn_select {    color: red;    font-size: 1.5rem;}/*垂直*/.content{    height: 100%;    width: 100%;    margin-top:45px; }.cell {    display: inline-block;    margin: 10px 20px;    width: 90%;    height: 200px;    border: #e9e9e9 solid 1px;    text-align: center;    background-color: red;    color: white;}本文代码wechatpra-master.zip"}
{"title": "廖马儿：IOS程序员学微信小程序开发系列《四》：逻辑层、视图层、配置文件 ... ", "author": "天下雪", "pub_time": "2016-11-10 14:29", "article_content": "1.配置文件\r\npage.json来决定\r\n初始化项目的时候，文件自动生成app.json来对小程序进行全局配置。\r\n2.逻辑层（App Server）\r\n小程序开发框架的逻辑层是由JavaScript编写。\r\n逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。 在 JavaScript的基础上，做了一些修改，以方便地开发小程序。\r\n1)增加 App 和 Page方法，进行程序和页面的注册。\r\nApp（）函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。\r\nApp.prototype.getCurrentPage()getCurrentPage() 函数用户获取当前页面的实例。\r\nvar appInstance = getApp()\r\nconsole.log(appInstance.globalData) // I am global data\r\n2）App()叫做注册程序，Page()叫做注册页面\r\nPage（）接受一个 object参数,指定页面的初始数据、生命周期函数、事件处理函数等\r\n3）初始化数据\r\n初始化数据将作为页面的第一次渲染。data将会以 JSON 的形式由逻辑层传至渲染层，所以其数据必须是可以转成JSON的格式：字符串，数字，布尔值，对象，数组。\r\n渲染层可以通过WXML 对数据进行绑定。eg:下面这个是一段wxml的代码\r\n<view>{{text}}</view>\r\n<view>{{array[0].msg}}</view>\r\n下面这个是一段.js代码，data是初始化页面数据\r\nPage({\r\n   data: {\r\n   text: 'init data',\r\n   array: [{msg: '1'}, {msg: '2'}]\r\n   }\r\n})\r\n4）页面的生命周期函数\r\na)onLoad: 页面加载一个页面只会调用一次。参数可以获取wx.navigateTo和wx.redirectTo及<navigator/>中的 query。这个是什么意思呢？\r\nonLoad:function(options){\r\n    // options 就是参数\r\n    // options.redirect\r\n}\r\nb)onShow: 页面显示\r\n每次打开页面都会调用一次。\r\nc)onReady: 页面初次渲染完成\r\n一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互\r\n对界面的设置如wx.setNavigationBarTitle请在onReady之后设置\r\nd)onHide: 页面隐藏\r\n当navigateTo或底部tab切换时调用。\r\ne)onUnload: 页面卸载\r\n当redirectTo或navigateBack的时候调用。\r\n5)页面相关事件处理函数\r\nonPullDownRefresh: 下拉刷新\r\n监听用户下拉刷新事件。需要在config的window选项中开启enablePullDownRefresh。\r\n6)事件处理函数\r\n除了初始化数据和生命周期函数，Page 中还可以定义一些特殊的函数：事件处理函数。在渲染层可以在组件中加入事件绑定，当达到触发事件时，就会执行Page 中定义的事件处理函数。\r\neg:\r\n\r\n// .wxml\r\n<view bindtap=\"tap_view\"> click me!</view>\r\n\r\n// .js\r\nPage({\r\n    tap_view:function(){\r\n        console.log('view taped!');\r\n    }\r\n})\r\n7)Page.prototype.setData()\r\nsetData函数用于将数据从逻辑层发送到视图层，同时改变对应的this.data的值。\r\n注意：1.直接修改 this.data无效，无法改变页面的状态，还会造成数据不一致。2.单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。\r\n<!--index.wxml-->\r\n<view>{{text}}</view>\r\n<button bindtap=\"changeText\"> Change normal data </button>\r\n<view>{{array[0].text}}</view>\r\n<button bindtap=\"changeItemInArray\"> Change Array data </button>\r\n<view>{{obj.text}}</view>\r\n<button bindtap=\"changeItemInObject\"> Change Object data </button>\r\n<view>{{newField.text}}</view>\r\n<button bindtap=\"addNewField\"> Add new data </button>\r\n\r\n//index.js\r\nPage({\r\n  data: {\r\n    text: 'init data',\r\n    array: [{text: 'init data'}],\r\n    object: {\r\n      text: 'init data'\r\n    }\r\n  },\r\n  changeText: function() {\r\n    // this.data.text = 'changed data'  // bad, it can not work\r\n    this.setData({\r\n      text: 'changed data'\r\n    })\r\n  },\r\n  changeItemInArray: function() {\r\n    // you can use this way to modify a danamic data path\r\n    this.setData({\r\n      'array[0].text':'changed data'\r\n    })\r\n  },\r\n  changeItemInObject: function(){\r\n    this.setData({\r\n      'object.text': 'changed data'\r\n    });\r\n  },\r\n  addNewField: function() {\r\n    this.setData({\r\n      'newField.text': 'new data'\r\n    })\r\n  }\r\n})\r\n这里的this指的是.js文件\r\n8）.页面的路由\r\n小程序中所有页面的路由全部由框架进行管理路由方式：\r\na.初始化打开新页面：调用 API wx.navigateTo 或使用组件<navigator />（节点方式）\r\nb.打开新页面,相当于iOS中的nav的push调用 API wx.navigateTo 或使用组件 <navigator />，调用后路由前页面函数：onHide\r\nc.页面重定向调用 API wx.redirectTo 或使用组件 <navigator />,调用后路由前页面函数：onUnload\r\nd.页面返回调用 API wx.navigateBack或用户按左上角返回按钮\r\ne.Tab切换\r\n多Tab模式下用户切换Tab\r\n9）文件作用域\r\n在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。\r\n通过全局函数 getApp() 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置\r\n10)模块化\r\n我们可以将一些公共的代码抽离成为一个单独的js 文件，作为一个模块。模块只有通过 module.exports 才能对外暴露接口。\r\nmodule.exports = {\r\n    sayHello: sayHello\r\n}\r\nfunction sayHello(name){\r\n    console.log('Hello' + name + '!');\r\n}\r\n// 使用\r\nvar common = require('common.js');   \r\nPage({\r\n    helloMaer:function(){\r\n        common.sayHello('Maer');\r\n    }\r\n})\r\n11)API\r\n小程序开发框架提供许多原生api，可以方便的掉漆微信提供的功能，eg:获取用户信息，本地存储，微信支付等.\r\nwx.on开头的API是监听某个时间发生的API接口，接受一个CALLBACK函数作为参数。当该时间触发的时候，会调用callback函数。如果没有特殊约定，其他的api接口都接受一个object作为参数。object中可以指定success, fail, complete来接收接口调用结果。\r\n success     Function        接口调用成功的回调函数\r\n fail        Function        接口调用失败的回调函数\r\n complete    Function        接口调用结束的回调函数（调用成功、失败都会执行）\r\n这里举例几个常用的api接口：\r\nwx.request    发起的是https请求。**一个微信小程序，同时只能有5个网络请求连接。**\r\n数据 API 列表：\r\nwx.getStorage  // 获取本地数据缓存\r\nwx.setStorage  // 设置本地数据缓存\r\nwx.clearStorage // 清除本地数据缓存\r\n获取网络类型\r\nwx.getNetworkType(OBJECT)\r\neg：\r\nwx.getNetworkType({\r\n    success:function(res){\r\n        var networkType = res.networkType;  // 返回网络类型2g,3g,4g,wifi\r\n    }\r\n})\r\n界面 API 列表：\r\n 参考：https://mp.weixin.qq.com/debug/wxadoc/dev/api/\r\n3.视图层\r\n框架的视图层由WXML 与 WXSS编写，由组件来进行展示。\r\n将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。\r\n组件(Component)是视图的基本组成单元。\r\n1)WXML\r\nWXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。\r\nwxml作用主要有：数据绑定、列表渲染、条件渲染、模板、事件、引用\r\n数据绑定：\r\n// wxml\r\n<view>{{message}}</view>\r\n\r\n// page.js\r\n   Page({        data:{           message: 'Hello world'!        }    })\r\n列表渲染\r\n// wxml\r\n<view wx:for=\"{{array}}\">{{item}}</view>\r\n// page.js\r\nPage({\r\n    data:{\r\n        array：[0, 1, 2, 3, 4]\r\n    }\r\n})\r\n条件渲染\r\n<!--wxml--><view wx:if=\"{{view == 'WEBVIEW'}}\"> WEBVIEW </view>\r\n<view wx:elif=\"{{view == 'APP'}}\"> APP </view>\r\n<view wx:else=\"{{view == 'MINA'}}\"> MINA </view>\r\n\r\n// page.js\r\nPage({\r\n     data: { \r\n        view: 'MINA' \r\n     }\r\n })\r\n<block/>并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性\r\n <block wx:if=\"{{true}}\"> \r\n    <view> view1 </view> \r\n    <view> view2 </view>\r\n</block>\r\n模板\r\n总结：在属性中的值都要加“”.<template is=\"staffName\" data=\"{{...staffA}}\"></template>扩展运算符...来将一个对象展开\r\nPage({\r\n    data:{\r\n         staffA:{firstname:'a', lastname:'b'}\r\n    }\r\n})\r\n注意： \r\n如果js:Page({    data:{        foo:'a',        bar:'b'    }})`\r\n<template data={{foo, bar}}>  data组合对象为：{foo:'a', bar:'b'}\r\n<template data={{'A':foo, 'B':bar}}>  data组合对象为:{'A':'a', 'B':'b'}\r\n模板拥有自己的作用域，只能使用data传入的数据。\r\n事件eg:\r\n<view bindtap=\"add\">{{count}}</view>\r\n\r\nPage({\r\n    data:{\r\n         count:1\r\n    }\r\n    add: function(e){\r\n         this.setData({\r\n             count:this.data.count + 1\r\n         })\r\n    }\r\n})\r\n2)wxml为了适应广大的前端开发者，WXSS具有 CSS 大部分特性。 同时为了更适合开发微信小程序，对 CSS 进行了扩充以及修改。尺寸单位rpx（responsive pixel） 规定屏幕宽为750rpx样式导入使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。"}
{"title": "廖马儿：IOS程序员学微信小程序开发系列《五》：扩展阅读：javascript基础 ... ... ", "author": "天下雪", "pub_time": "2016-11-10 14:37", "article_content": "本篇仅为扩展阅读，让一部分人恢复记忆而用，并非完全可适用于微信小程序内；仅供参考，测试不可行后，请立刻停止并优先使用官方提供的方法；第一部分：1.HTML DOM (Document Object Model)\r\ndocument.getElementById(\"some id\"): 这样的document就是DOM对象JavaScript 能够改变任意 HTML 元素的大多数属性\r\n*注意：html - dom - document浏览器 - bom - window\r\n2.match()函数\r\nmatch() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。\r\n语法：stringObject.match(searchvalue) :必需。规定要检索的字符串值。stringObject.match(regexp):必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象\r\n我们可以使用全局匹配的正则表达式来检索字符串中的所有数字：<script type=\"text/javascript\">\r\n    var str=\"1 plus 2 equal 3\"\r\n    document.write(str.match(/\\d+/g))\r\n</script>3.Date()函数\r\nDate()在js中直接调用结果：Sun Oct 09 2016 14:37:15 GMT+0800 (CST)var date = new Date();var year = date.getFullYear();\r\nvar month = date.getMonth();\r\nvar day = date.getDay();\r\nalert(\"今天是\"+year+\"年\"+month+\"月\"+day+\"日\");4.js对象:{firstName:\"John\"， lastName:\"Doe\", age:40, eyeColor:\"blue\"}*注意： notation:n. 符号；乐谱；注释；记号法json： javascript object notation\r\n5.数据类型\r\nJavaScript 有多种数据类型：数字，字符串，数组，对象等等\r\n*注意：16 + \"你好\" => \"16你好\"\r\n5.JavaScript 使用Unicode字符集。Unicode覆盖了所有的字符，包含标点等字符。JavaScript 中，常见的是驼峰法的命名规则，如 lastName (而不是lastname)。\r\n6.innerHTML与innerText 区别：\r\n1)innerHTML:　　也就是从对象的起始位置到终止位置的全部内容,包括Html标签。2)innerText:　　从起始位置到终止位置的内容, 但它去除Html标签 \r\n<div id=\"test\"> \r\n   <span style=\"color:red\">test1</span> test2 \r\n</div>\r\n获取id=test节点：它的innerHTML就是：test1test2它的innerText是：test1test2\r\n*注意：　　innerHTML是符合W3C标准的属性，而innerText只适用于IE浏览器，因此，尽可能地去使用innerHTML，而少用innerText，如果要输出不含HTML标签的内容，可以使用innerHTML取得包含HTML标签的内容后，再用正则表达式去除HTML标签，下面是一个简单的符合W3C标准的示例：去除HTML标签后的文本\r\n7.对代码行进行折行\r\ndocument.write(\"你好 \\   \r\n 是加尔！\");\r\n*注意：JavaScript 是脚本语言。浏览器会在读取代码时，逐行地执行脚本代码。而对于传统编程来说，会在执行前对所有代码进行编译。\r\n8.声明\r\nvar carname;在计算机程序中，经常会声明无值的变量。未使用值来声明的变量，其值实际上是 undefined。\r\n在执行过以下语句后，变量carname的值将是 undefined：\r\nvar carname=\"Volvo\"; var carname;  // 在以下两条语句执行后，变量 carname 的值依然是 \"Volvo\"：\r\n9.JavaScript 对象\r\n对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：\r\neg:var person={firstname:\"John\", lastname:\"Doe\", id:5566};\r\nvar person={\r\n     firstname : \"John\",\r\n     lastname  : \"Doe\",\r\n     id        :  5566\r\n };\r\n对象属性有两种寻址方式：\r\nname=person.lastname;\r\nname=person[\"lastname\"];\r\n*注意：键加\"\"双引号也可以的\r\nvar person={\r\n     firstname : \"John\",\r\n     \"lastname\"  : \"Doe\",\r\n     id        :  5566\r\n };\r\n10.Undefined 和 Null区别\r\nUndefined 这个值表示变量不含有值。可以通过将变量的值设置为 null 来清空变量。cars = nullperson = null\r\n之后alert(cars) 结果为null,注意不是undefined\r\n11.声明变量类型\r\n当您声明新变量时，可以使用关键词 \"new\" 来声明其类型：\r\nvar carname=new String;\r\nvar x=      new Number;\r\nvar y=      new Boolean;\r\nvar cars=   new Array;\r\nvar person= new Object;\r\nJavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。\r\n12.js的对象\r\n1)键值对，对象属性可以说 \"JavaScript 对象是变量的容器\"。我们通常认为 \"JavaScript 对象是键值对的容器\"。键值对在 JavaScript对象通常称为 对象属性。\r\n对象键值对的写法类似于：PHP 中的关联数组Python 中的字典C 语言中的哈希表\r\n2)对象方法\r\n对象的方法定义了一个函数，并作为对象的属性存储。对象方法通过添加 () 调用 (作为一个函数)。\r\nname = person.fullName();  // person.fullName() 调用person对象的方法，返回的值赋值给了name\r\nJavaScript对象是属性和方法的容器\r\n在微信小程序中：wx.request({     url:\"http://www.xxxx\",\r\n     method:'GET',\r\n     data:{},\r\n     header:{\r\n         'Accept':'application/json'\r\n     },\r\n     success:function(res){\r\n          that.setData({\r\n                images:res.data\r\n          })\r\n     }\r\n})\r\n\r\n// wx.request();  调用函数.传入的是 js对象 {}\r\n*注意：函数属性作为一个方法访问与函数属性作为一个属性访问。\r\nvar person = {\r\n    firstName: \"John\",\r\n    lastName : \"Doe\",\r\n    id       : 5566,\r\n    fullName : function() {\r\n       return this.firstName + \" \" + this.lastName;\r\n    }\r\n};\r\n\r\ndocument.getElementById(\"demo\").innerHTML = person.fullName();  // 方法访问\r\ndocument.getElementById(\"demo\").innerHTML = person.fullName;\r\n13.JavaScript 变量的生存期\r\nJavaScript 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除。全局变量会在页面关闭后被删除。\r\n14.向未声明的 JavaScript 变量分配值\r\n如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。carname=\"Volvo\";将声明一个全局变量 carname，即使它在函数内执行。\r\n函数参数只在函数内起作用，是局部变量。\r\n15.html中的全局变量\r\n在html中，全局变量是window对象：所有数据变量都属于window对象\r\nfunction myFunction() {     carName = \"Volvo\";} myFunction()；//此处可使用 window.carName\r\n注意：要先执行myFunction()之后才能使用全局变量carName\r\n16.js事件\r\nHTML 事件是发生在HTML 元素上的事情。当在HTML 页面中使用 JavaScript时， JavaScript可以触发这些事件。\r\nHTML 事件可以是浏览器行为，也可以是用户行为。\r\n常见的html事件：\r\nonchange:HTML 元素改变onclick:用户点击 HTML 元素onmouseover:用户在一个HTML元素上移动鼠标onmouseout:用户从一个HTML元素上移开鼠标onkeydown:用户按下键盘按键onload:浏览器已完成页面的加载\r\n17.js字符串\r\nvar answer = \"He is called 'Johnny'\";\r\n1)alert(answer[13]) ;  // '2)answer.length3)特殊字符\r\n在 JavaScript 中，字符串写在单引号或双引号来中。\"We are the so-called \"Vikings\" from the north.\"如何解决以上的问题呢？可以使用反斜杠 () 来转义 \"Vikings\" 字符串中的双引号，如下:\"We are the so-called \\\"Vikings\\\" from the north.\"\r\n特殊字符的转义：\r\n\\'    单引号\r\n\\\"    双引号\r\n\\\\    反斜杠\r\n\\n    换行\r\n\\r    回车\r\n\\t    tab(制表符)\r\n\\b    退格符\r\n\\f    换页符\r\n18.字符串可以是对象\r\n通常，JavaScript 字符串是原始值，可以使用字符创建：var firstName = \"John\"\r\n但我们也可以使用 new 关键字将字符串定义为一个对象：var firstName = new String(\"John\")\r\n不要创建String对象。它会拖慢执行速度，并可能产生其他副作用：\r\nvar x = \"John\";              \r\nvar y = new String(\"John\");\r\n(x === y) // is false because x is a string and y is an object.\r\n1）字符串属性\r\nconstructor  返回创建字符串属性属性的函数length  返回字符串的长度prototype  允许您向对象添加属性和方法\r\n2）字符串方法charAt()    返回指定索引位置的字符\r\ncharCodeAt()    返回指定索引位置字符的 Unicode 值\r\nconcat()    连接两个或多个字符串，返回连接后的字符串\r\nfromCharCode()    将字符转换为 Unicode 值\r\nindexOf()    返回字符串中检索指定字符第一次出现的位置\r\nlastIndexOf()    返回字符串中检索指定字符最后一次出现的位置\r\nlocaleCompare()    用本地特定的顺序来比较两个字符串\r\nmatch()    找到一个或多个正则表达式的匹配\r\nreplace()    替换与正则表达式匹配的子串\r\nsearch()    检索与正则表达式相匹配的值\r\nslice()    提取字符串的片断，并在新的字符串中返回被提取的部分\r\nsplit()    把字符串分割为子字符串数组\r\nsubstr()    从起始索引号提取字符串中指定数目的字符\r\nsubstring()    提取字符串中两个指定的索引号之间的字符\r\ntoLocaleLowerCase()    根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射\r\ntoLocaleUpperCase()    根据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射\r\ntoLowerCase()    把字符串转换为小写\r\ntoString()    返回字符串对象值\r\ntoUpperCase()    把字符串转换为大写\r\ntrim()    移除字符串首尾空白\r\nvalueOf()    返回某个字符串对象的原始值\r\n19.js中的break与continue\r\nbreak 语句可用于跳出循环。break 语句跳出循环后，会继续执行该循环之后的代码（如果有的话）：\r\ncontinue 语句中断循环中的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代。 该例子跳过了值 3：eg:\r\nfor (i=0;i<=10;i++)\r\n  {\r\n      if (i==3) continue;\r\n      x=x + \"The number is \" + i + \"<br>\";\r\n   }\r\n20.JavaScript typeof, null, 和 undefined\r\n数组是一种特殊的对象类型。 因此 typeof [1,2,3,4]返回object。\r\n在 JavaScript中 null表示 \"什么都没有\"。\r\n用typeof检测 null返回是object。\r\n可以设置为 null 来清空对象:var person = null;\r\n可以设置为 undefined 来清空对象:var person = undefined;\r\n在 JavaScript 中, undefined 是一个没有设置值的变量。typeof 一个没有值的变量会返回 undefined。\r\nUndefined和Null的区别：\r\ntypeof undefined             // undefined\r\ntypeof null                  // object\r\nnull === undefined           // false\r\nnull == undefined            // true\r\n请注意：\r\nNaN 的数据类型是 number数组(Array)的数据类型是 object日期(Date)的数据类型为 objectnull 的数据类型是 object未定义变量的数据类型为 undefined\r\n21.JavaScript 类型转换\r\nNumber() 转换为数字， String() 转换为字符串， Boolean() 转化为布尔值。\r\n22.JavaScript 数据类型\r\n在 JavaScript 中有 5 中不同的数据类型：\r\nstring\r\nnumber\r\nboolean\r\nobject\r\nfunction\r\n3 种对象类型：\r\nObject\r\nDate\r\nArray\r\n2 个不包含任何值的数据类型：\r\nnull\r\nundefined\r\n23.JavaScript 类型转换\r\n1）将数字转换为字符串\r\n String(x)         // 将变量 x 转换为字符串并返回\r\n String(123)       // 将数字 123 转换为字符串并返回\r\n String(100 + 23)  // 将数字表达式转换为字符串并返回\r\n\r\nx.toString()\r\n(123).toString()\r\n(100 + 23).toString()\r\n2）将布尔值转换为字符串\r\n全局方法 String() 可以将布尔值转换为字符串。\r\nString(false)        // 返回 \"false\"\r\nString(true)         // 返回 \"true\"\r\nBoolean 方法 toString() 也有相同的效果。\r\nfalse.toString()     // 返回 \"false\"\r\ntrue.toString()      // 返回 \"true\"\r\n3）将日期转换为字符串\r\n全局方法 String() 可以将日期转换为字符串。String(Date())    // 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)\r\nDate 方法 toString() 也有相同的效果。Date().toString()   // 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)\r\n4)将字符串转换为数字\r\n赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              廖马儿：IOS程序员学微信小程序开发系列《四》：逻辑层、视图层、配置文件 ... \n              微信小程序开发注意事项，实现机制，开发前须知，路由，Tab页，页面结构 ... ... \n            \n             \n            \n                  原作者: 廖马儿 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 廖马儿：IOS程序员学微信小程序开发系列《一》：入门及框架 ...\n                                    \n                  • 廖马儿：IOS程序员学微信小程序开发系列《二》：组件，API，工具 ... ...\n                                    \n                  • 廖马儿：IOS程序员学微信小程序开发系列《三》：经验及知识点 ... ...\n                                    \n                  • 廖马儿：IOS程序员学微信小程序开发系列《四》：逻辑层、视图层、配置文件 ...\n                                    \n                  • iOS码农的微信小程序开发总结\n                                    \n                  • iOS 开发者的微信小程序初体验\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSt1oCpo', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序第三方框架对比 ( wepy / mpvue / ta2019-01-28微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30分享一款拥有历史搜索记录的微信小程序搜索2019-01-28小程序点睛之三：才不是你想的那种组件2019-01-28微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n微信小程序Demo:Canvas图片拖拽生成实现2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo：精美的画板小程序2019-02-21微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：仿 [one] 微信小程序2019-02-18微信小程序Demo：3D旋转效果2019-02-18微信小程序Demo: flappy-bird小游戏2019-02-15微信小程序Demo：群应用（群通知、群接龙、2019-02-15微信小程序Demo：咩咩单词2019-02-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164034|f4225ed4c5d0b23e9df80afe4e7470df|2';"}
{"title": "微信小程序开发注意事项，实现机制，开发前须知，路由，Tab页，页面结构 ... ... ", "author": "天下雪", "pub_time": "2016-11-10 19:38", "article_content": "原文作者：iamxwk；github地址第一部分：开发注意事项：颜色限制navigationBarTextStyle 导航栏标题颜色仅支持 black/whitebackgroundTextStyle 下拉背景字体、loading 图的样式，仅支持 dark/lightborderStyle tabbar上边框的颜色， 仅支持 black/white程序限制脚本内不能使用window等对象zepto/jquery 会使用到window对象和document对象，所以无法使用。样式表不支持级联选择器本地资源无法通过 css 获取 background-image：可以使用网络图片，或者 base64，或者使用标签不支持 A 标签，无法打开普通网页数量限制底部或顶部可以添加tab按钮区域 tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。一个应用同时只能打开5个页面大小限制tabBar 上面的按钮 iconPath 图片路径，icon 大小限制为40kbtabBar 上面的按钮 selectedIconPath 选中时的图片路径，icon 大小限制为40kbsetData 页面传递数据单次设置的数据不能超过1024kBsetStorage 本地缓存最大为10MB小程序源码打包后的大小限制为1M消息限制支付当用户在小程序内完成过支付行为，可允许开发者向用户在7天内推送有限条数的模板消息（1次支付可下发1条，多次支付下发条数独立，互相不影响）提交表单 当用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的，开发者需要向用户提供服务时，可允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下发条数独立，相互不影响）审核说明标题标题不能存在相同标题意思不能存在过度相似标题必须以“提醒”或“通知”结尾标题不能带特殊符号、个性化字词等没有行业通用性的内容标题必须能体现具体服务场景标题不能涉及营销相关内容，包括不限于：消费优惠类、购物返利类、商品更新类、优惠券类、代金券类、红包类、会员卡类、积分类、活动类等营销倾向通知关键词同一标题下，关键词不能存在相同同一标题下，关键词不能存在过度相似关键词不能带特殊符号、个性化字词等没有行业通用性的内容关键词内容示例必须与关键词对应匹配关键词不能太过宽泛，需要具有限制性，例如：“内容”这个就太宽泛，不能审核通过违规说明除不能违反运营规范外，还不能违反以下规则，包括但不限于：不允许恶意诱导用户进行触发操作，以达到可向用户下发模板目的不允许恶意骚扰，下发对用户造成骚扰的模板不允许恶意营销，下发营销目的模板不允许通过服务号下发模板来告知用户在小程序内触发的服务相关内容处罚说明处罚结果及原因以站内信形式告知根据违规情况给予相应梯度的处罚，一般处罚规则如下：第一次违规，删除违规模板以示警告，第二次违规，封禁接口7天，第三次违规，封禁接口30天，第四次违规，永久封禁接口第二部分：实现机制及其他一 、小程序是什么？一种介于原生app、和web app的hybrid, 比web app 的开发成本还低;通过微信进行加载;相对原生app来说，更加轻量、更新实时、跨平台;相对web app来说，资源离线，体验更流畅。可以使用微信的支付功能开发者工具 开发文档二 、实现机制基于微信提供的一套应用框架。微信通过封装微信客户端提供的文件系统、网络通信、任务管理、数据安全等基础功能，对上层提供了一套完整的Javascript Api，开发者能够非常方便的调用微信客户端提供的各种基础功能。视图层描述语言 .WXML 和 .WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层之间通过 单向数据 绑定进行数据传输三 、开发前须知AppStore问题;发布的项目包体积 < 1M, 只适合轻量级 ;开发基于微信框架，部分功能受限, 不能操作DOM, 没有script标签，要引入则需加入项目文件夹;没有与浏览器BOM相关的API;没有cookie ;用 storage 替代了H5中的localstorage、sessionstorage、 storage对每个小程序的大小是 10M，支持 同步 和 异步 。同时只能存在 5 个url请求;小程序页面只能同时打开 5 个，如果交互流程较长难以支持;注释方式： // comment, /** comment **/;注意：cookie问题，在请求发送时，可以动态设置Header发送报文的cookie，但是 cookie本身不能在客户端进行读写。wx.request({\r\n    header: {cookie: \"abcd1234\"},\r\n    url: \"/getinfo\",\r\n    data: {},\r\n    ...\r\n})\r\n四、路由pages 里面的第一个元素即为首页;每个页面需要手动在app.json中进行注册，否则不能访问;路由跳转： 组件跳转(navigator) ／ API跳转wx.navigateTo({  // 保留当前页\r\n    url: \"\",\r\n    ...\r\n}) \r\n\r\nwx.navigateTo({  // 关闭当前页\r\n    url: \"\",\r\n    ...\r\n})\r\n五、Tab页由app.json定义；配置最少2个、最多5个；每个页面的 .json 文件可以覆盖定义导航栏。六、页面结构由同路径下同名的四个不同后缀文件的组成：.js 文件是脚本文件.json 文件是配置文件.wxss 是样式表文件.wxml 文件是页面结构文件.wxml 文件// wxml语法\r\n\r\n<block wx:for=\"{{shareItems}}\" wx:for-index=\"idx\">\r\n    <view id=\"{{idx}}\" class=\"flex share-item box box-tb\">\r\n      <view class=\"flex box box-lr article-info\">\r\n        <view class=\"flex title\">{{item.articleInfo.title}}</view>\r\n      </view>\r\n      <view class=\"user-info box box-lr\">\r\n        <image src=\"{{item.articleInfo.isApproved ? icon.approved : icon.approve}}\" class=\"icon approve-icon\"></image>\r\n      </view>\r\n    </view>\r\n</block>.wxml 文件通过相同的名称，将页面与逻辑js、样式、配置进行关联匹配.wxml 组件语法.wxml 提供两种文件引用方式import(有作用域)和include事件绑定方式// test.wxml\r\n\r\n{{userName}}\r\n\r\n// test.js\r\n\r\npage({\r\n    data: {},\r\n    getInfo: function() {\r\n        this.setData({\r\n            userName: \"Tom\"\r\n        })\r\n    }\r\n})\r\n.wxss 文件/** app.wxss **/\r\n\r\n@import \"common.wxss\";\r\n\r\nview {\r\n  padding:15px;\r\n}\r\n可通过 @import (后跟相对路径)样式表;尺寸单位：有两种单位：(1)、引入rpx(根据屏幕宽度进行自适应)的概念； (2)、rem；支持内联选择器：不再支持媒体查询，支持 .demo, #demo, view, view input, view::after, view::before;增加了app的flex布局;目前还不支持动画 ;weui 官方样式库 规定屏幕宽为750rpx, 如iPhone6, 1rpx = 1物理像素 = 0.5px;规定屏幕宽度为20rem, 1rem = (750/20)rpx;.js 文件模块运行（类似node，框架自动添加外层define）;形式上支持CommonJs，通过require加载;data应约定为只读，不能直接修改data值，否则 容易造成data中的数据与view不一致;更新View需使用setData()，与data中的数据进行Diff比较，不同才会更新。setData() 单次设置的数据 < 1M，要避免一次设置过多的数据;支持ES6中的 … 操作符展开模块数据。// js引入 \r\n\r\n// a.js\r\nfunction sayHi() {\r\n    console.log(\"hello wxAPP!\");\r\n}\r\nmodule.exports = {\r\n    say: sayHi\r\n}\r\n\r\n// b.js\r\nvar say = require(\"a.js\");\r\n// data 操作 \r\n\r\npage({\r\n    data: {\r\n        name: 'one'\r\n    },\r\n    handleData() {\r\n\r\n        // 错误操作方式，虽不会报错，但不会更新view\r\n        this.data.name = 'two';\r\n\r\n        // 正确操作方式\r\n        this.setData({\r\n            name: 'tow'\r\n        })\r\n    }\r\n})\r\n.json 文件各个页面的配置性文件"}
{"title": "疯狂早茶基础篇《二》：回调函数，匿名函数，闭包 ", "author": "天下雪", "pub_time": "2016-11-11 00:45", "article_content": "回调函数\r\n回调函数，对于初入编程这一行的同学可能会有些难以理解，毕竟回调函数的使用和程序顺序执行的直观流程是相悖的。\r\n想象你定了一个外卖，一种是你定时去查看外卖有没有到，一种是你出示电话号码给外卖员，到达的时候电话通知你。\r\n很容易可以看出第二种是更加高效的方案，其实这种通知机制应用到编程领域，就是回调函数了。\r\n熟悉win32开发的同学应该知道，典型的windows程序框架就是一个消息循环外加一个窗口过程函数。其中windows系统接管消息接受，之后调用开发者的窗口过程函数来完成具体的消息处理逻辑。窗口过程函数就是一个回调函数。\r\n为什么需要回调函数\r\n以上面的 win32程序为例。我们知道出于安全性考虑，windows操作系统是不允许开发者直接访问硬件资源的。微软的开发者提供了api来处理消息循环，但是具体消息的响应逻辑需要开发者来提供，这种情形下，回调函数就是很好的实现方案。\r\n再举一个例子，想象你参与一个手机设备管理软件项目的开发工作，你负责底层设备通信模块。当用户插入设备到电脑中时，你需要通知上层的模块进行处理。出于灵活性和通用性的考虑，你不可能将设备连接时的处理逻辑放在你负责的模块中，此时可以由上层调用者提供一个回调函数，在设备连接时你的模块调用回调函数即可。\r\n关于回调函数，有一个所谓的好莱坞准则：Don't call me; I'll call you！\r\n匿名函数\r\n在c，c++等语言中，当需要使用回调函数时，需要预先定义一个函数体。而回调函数通常只是提供给其它模块进行调用，为了简化编码，后续的javascript等脚本语言中提供了对匿名函数的支持。(注: 新的c++标准也开始支持匿名函数，称为Lambda函数)\r\ngetUserInfo:function(cb){\r\n    var that = this\r\n    if(this.globalData.userInfo){\r\n      typeof cb == \"function\" && cb(this.globalData.userInfo)\r\n    }else{\r\n      //调用登录接口\r\n      wx.login({\r\n        success: function () {\r\n          wx.getUserInfo({\r\n            success: function (res) {\r\n              that.globalData.userInfo = res.userInfo\r\n              typeof cb == \"function\" && cb(that.globalData.userInfo)\r\n            }\r\n          })\r\n        }\r\n      })\r\n    }\r\n  },\r\n上面的代码来自于上一篇教程中的app.js，在调用wx.login时，传递了一个匿名函数进行调用成功后的逻辑处理，就是success后面的部分。可以看到这里只有函数定义而没有函数名称，因此除了作为回调函数外，也无法在其它地方调用该函数。\r\n实际上匿名函数仅仅是一种编码简化而已，不过它带来的好处却不仅仅是减少编码而已。\r\n闭包\r\n在编程技术中，闭包应该属于较高级的技术了。当使用回调函数时，通常会涉及到一些上下文的传递。在c/c++等语言中，会使用全局变量或堆内存来传递上下文。全局变量的缺点很明显，而堆内存又很容易发生内存泄漏。而在更高级的脚本语言中，可以通过闭包技术来轻松的完成上下文传递。\r\n以上面的代码为例，在回调函数中执行了that.globalData.userInfo = res.userInfo来保存用户信息，其中that变量由var that = this赋值，因此该变量指向app对象本身，所以才能成功保存用户信息。\r\n我们可以看到that对象是getUserInfo方法栈上的变量，如果没有闭包技术，此处的匿名回调函数是不能直接使用that变量的，就需要将app对象传递给回调函数(全局变量或函数参数的方式)，而在闭包技术的支持下，回调函数可以像使用函数内部变量一样来访问that变量，语法上便捷了许多。"}
{"title": "疯狂早茶微信小程序基础篇《三》：index 页面解析，logs页面解析 ... ... ", "author": "天下雪", "pub_time": "2016-11-11 00:50", "article_content": "第一部分：index 页面解析这边教程主要对默认生成的index 页面进行讲解。在之前的教程中有写道，每一个页面都包含.js(处理逻辑)，.wxml(描述页面内容)，.wxss(配置页面样式)三个文件，index 页面也是如此。\r\n讲解之前先上图这里写图片描述\r\nindex页面的内容不多，只有一个用户头像，用户姓名，和一个\"Hello World\"，首先来看看index.wxml的内容<!--index.wxml-->\r\n<view class=\"container\">\r\n  <view  bindtap=\"bindViewTap\" class=\"userinfo\">\r\n    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\r\n    <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\r\n  </view>\r\n  <view class=\"usermotto\">\r\n    <text class=\"user-motto\">{{motto}}</text>\r\n  </view>\r\n</view>该页面的层级结构比较简单，三个view标签，一个image以及两个text标签，其中view为容器标签，image用来显示用户头像，第一个text用来显示用户昵称，第二个text则是\"Hello World\"\r\n可以看到页面描述文件中绑定了几个变量，分别是第二个view标签的 bindtap=\"bindViewTap\"，image标签的src=\"{{userInfo.avatarUrl}} 以及两个text标签的内容文本。那么这些变量定义在哪里呢，答案就在index.js中//index.js\r\n//获取应用实例\r\nvar app = getApp()\r\nPage({\r\n  data: {\r\n    motto: 'Hello World',\r\n    userInfo: {}\r\n  },\r\n  //事件处理函数\r\n  bindViewTap: function() {\r\n    wx.navigateTo({\r\n      url: '../logs/logs'\r\n    })\r\n  },\r\n  onLoad: function () {\r\n    console.log('onLoad')\r\n    var that = this\r\n    //调用应用实例的方法获取全局数据\r\n    app.getUserInfo(function(userInfo){\r\n      //更新数据\r\n      that.setData({\r\n        userInfo:userInfo\r\n      })\r\n    })\r\n  }\r\n})index.js代码定义了Page对象，该对象中定义了index.wxml绑定的变量，其中onLoad方法会在页面加载时被调用，该方法会调用app对象的getUserInfo方法来获取用户信息并赋值给userInfo属性，这样界面就可以显示用户头像和昵称了。而\"Hello World\"的显示则是由motto属性直接指定。\r\nPage对象还定义了bindViewTap方法，该方法通过调用wx.navigateTo导航到logs页面。关于页面导航的更多内容将在后面的教程中讲解。在该例子中，当用户点击用户头像和昵称的视图区域时，程序便会显示logs页面。\r\n最后简单看下index.wxss/**index.wxss**/\r\n.userinfo {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n}\r\n\r\n.userinfo-avatar {\r\n  width: 128rpx;\r\n  height: 128rpx;\r\n  margin: 20rpx;\r\n  border-radius: 50%;\r\n}\r\n\r\n.userinfo-nickname {\r\n  color: #aaa;\r\n}\r\n\r\n.usermotto {\r\n  margin-top: 200px;\r\n}该文件定义了index.wxml中使用到的样式选择器，这部分比简单，在这里就不多做解释了。第二部分：logs页面解析老规矩先上图\r\nlogs页面\r\n\r\n该页面包含返回按钮(用于返回index页面)，页面title和程序启动日志列表。和index页面相比，logs页面多了一个logs.json文件，来配置页面title的内容{\r\n    \"navigationBarTitleText\": \"查看启动日志\"\r\n}\r\n更多配置项可以参考配置  小程序<!--logs.wxml-->\r\n<view class=\"container log-list\">\r\n  <block wx:for=\"{{logs}}\" wx:for-item=\"log\">\r\n    <text class=\"log-item\">{{index + 1}}. {{log}}</text>\r\n  </block>\r\n</view>\r\n在logs.wxml中，定义了三个标签，分别为view，block和text，其中view标签为容器，block用于绑定logs数组，而text标签用于显示每一条log。wx:for和wx:for-item是小程序框提供的列表绑定语法，更多详情请参考列表渲染//logs.js\r\nvar util = require('../../utils/util.js')\r\nPage({\r\n  data: {\r\n    logs: []\r\n  },\r\n  onLoad: function () {\r\n    this.setData({\r\n      logs: (wx.getStorageSync('logs') || []).map(function (log) {\r\n        return util.formatTime(new Date(log))\r\n      })\r\n    })\r\n  }\r\n})\r\nlogs.js定义了logs数组，并在onLoad方法中从本地缓存中获取程序启动时间数据，之后调用数组的map方法来将时间格式化为字符串.log-list {\r\n  display: flex;\r\n  flex-direction: column;\r\n  padding: 40rpx;\r\n}\r\n.log-item {\r\n  margin: 10rpx;\r\n}\r\n最后仍然是logs.wxss，对页面样式进行控制。\r\n到此为止，默认生成程序的解析部分就结束了。这个解析过程是为了对微信小程序有个总体上的理解，所以很多地方并没有深入。在后面的教程中，我会继续讲解微信小程序开发的各个方面。"}
{"title": "微信小程序开发SSL证书配置，解决request fail问题 ", "author": "天下雪", "pub_time": "2016-11-11 10:15", "article_content": "作者： vcvit 微信小程序强制所有接口必须使用https进行访问，但是服务器配置好证书之后，使用IDE可以正常访问，但是使用真机就一直报错（ios和andriod都会）。显示request fail 未能完成操作。KCFErrorDomainCFNetwork 错误301.\r\n\r\n\r\n解决方法\r\n1、Geotrust先检查下你的站点。把一些常规的问题解决掉，比如中级证书没装，等等问题。2、微信支持，且只支持ssl_protocols TLSv1 TLSv1.1 TLSv1.2;所以，你需要把SSL V2，SSL V3这些协议都删掉3、加密方式ssl_ciphers AES128+EECDH:AES128+EDH:!aNULL;\r\n解决之后\r\n配置完之后，检测一下，会变成这个样。还会有个BEAST的info，这个不用处理。\r\n\r\n\r\n腾讯给的参考在 https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=10_4\r\n但是腾讯这个坑爹货，ssl_ciphers  ALL：!ADH：!EXPORT56：RC4+RSA：+HIGH：+MEDIUM：+LOW：+SSLv2：+EXP;标点符号是 中文 ，所以，你懂的。\r\n如果nginx使用上面的配置文件配置就好了，如果你用iis，google一下就会有注册表的修改方法，改完注册表，重启服务器，就好了。更多检测地址参考：《二十四》request:fail错误（含https解决方案）（真机预览问题"}
{"title": "微信小程序学习实践：swiper的使用，checkbox的使用 ", "author": "天下雪", "pub_time": "2016-11-11 10:40", "article_content": "第一部分：入门实践1.下载微信小程序编辑器：下载微信小程序编辑器\r\n2.创建小程序应用：打开刚才下载的dmg，用微信扫面二维码登陆。点击本地小程序项目，就可以开始开发了。\r\n3.先介绍下目录结构：\r\npages文件夹中放的都是页面，app.js相当于iOS的appdelegate,app.json就是app的配置,app.wxss就是css样式文件。每一个页面都单独有一个js，json，wxss文件。4.app.json文件分析\r\n{//所有的页面都在这里列出来\r\n  \"pages\":[\r\n    \"pages/index/index\",\r\n    \"pages/logs/logs\",\r\n    \"pages/button/button\"\r\n  ],\r\n  \"window\":{ //app的样式\r\n    \"backgroundTextStyle\":\"light\",\r\n    \"navigationBarBackgroundColor\": \"#fff\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\":\"black\"\r\n  }\r\n}\r\n5.先做一个小demo(js，json，wxml，wxss都是新建的)代码：\r\n//获取应用实例\r\nvar app = getApp()\r\nPage({\r\n  data:{\r\n    count:0,\r\n    text: '加载了了0次',\r\n    loadingstatus: false,\r\n  },\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n    console.log(\"onLoad\");\r\n\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n    console.log(\"onReady\");\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n    console.log(\"onShow\");\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n    console.log(\"onHide\");\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n    console.log(\"onUnload\");\r\n  },\r\n  button1click: function(){\r\n   var that = this;\r\n   that.data.count++;\r\n   that.setData({ //更改属性的值\r\n       text:'加载了'+that.data.count+'次',\r\n       loadingstatus:that.data.count%2 == 0 ? true:false,\r\n   })\r\n  },\r\n})\r\n\r\n//这里的data就是页面的数据和函数，\r\nonShow,onHide,onReady,onUnload都是生命周期函数，\r\nbutton1Click是button的click函数\r\n这框架是data和页面的绑定起来的，只要改变data的值，页面就会随着变化，这点和iOS有点不同。\r\n\r\nbutton.json 文件\r\n{\r\n     \"navigationBarTitleText\": \"ButtonDemo\" 这是页面的title\r\n}\r\n\r\nbutton.wxml文件\r\n\r\n<view class=\"container\"> \r\n    <view class=\"button-wrapper\">\r\n    <button type=\"default\" bindtap=\"button1click\"  size=\"default\"  \r\n    loading=\"{{loadingstatus}}\" > 点我\r\n    </button>\r\n     </view>\r\n<text class=\"countClick\" id=\"text1\">{{text}}\r\n</text>\r\n</view>\r\n\r\nbutton.wxss\r\n\r\n.countClick{\r\n    margin-top: 100rpx;\r\n    width: 200rpx;\r\n    height: 50rpx;\r\n    text-align: center;\r\n    font-size: 1em;\r\n    background-color: cadetblue;\r\n}\r\n\r\n bindtap=\"button1click\"  绑定点击事件到buttonclick函数\r\n{{text}}   {{data中的属性}}\r\n今天还看到一段比较好玩的代码：\r\nfor (var i = 0; i < types.length; ++i) {\r\n  (function(type) {\r\n    pageObject[type] = function(e) {\r\n      var key = type + 'Size'\r\n      var changedData = {}\r\n      changedData[key] =\r\n        this.data[key] === 'default' ? 'mini' : 'default'\r\n      this.setData(changedData)\r\n    }\r\n  })(types[i])\r\n可能做iOS的没看过js的人这点看不太懂，我也是新手，哪里说的不对，欢迎前端大神指正。大概意思是：\r\nfor (var i = 0; i < types.length; ++i) { 循环数组\r\n  (function(type) { //写法js(function)(item)\r\n    pageObject[type] = function(e) { //添加属性函数 就是增加了几个函数。\r\n      var key = type + 'Size' //拼接字符串\r\n      var changedData = {} //字典\r\n      changedData[key] = //字典赋值\r\n        this.data[key] === 'default' ? 'mini' : 'default'\r\n      this.setData(changedData) //相当于iOS的kvo用hash值的方式给自己的属性赋值\r\n    }\r\n  })(types[i]) //执行函数第二部分：swiper的使用\r\n这个类似iOS的滚动视图，里边也可以放一下其他的东西。先讲一下属性：\r\n\r\n\r\n\r\n属性名\r\n类型\r\n默认值\r\n说明\r\n\r\n\r\n\r\n\r\nindicator-dots\r\nBoolean\r\nfalse\r\n是否显示面板指示点\r\n\r\n\r\nautoplay\r\nBoolean\r\nfalse\r\n是否自动切换\r\n\r\n\r\ncurrent\r\nNumber\r\n0\r\n当前所在页面的 index\r\n\r\n\r\ninterval\r\nNumber\r\n5000\r\n自动切换时间间隔\r\n\r\n\r\nduration\r\nNumber\r\n1000\r\n滑动动画时长\r\n\r\n\r\nbindchange\r\nEventHandle\r\n\r\ncurrent 改变时会触发 change 事件，event.detail = {current: current}\r\n\r\n\r\n\r\nswiper.js文件\r\nvar app = getApp();\r\nPage({\r\n  data:{\r\n    indicatordos:true,\r\n    autoplay:true,\r\n/*图片数组*/\r\n    imgUrls: [\r\n      'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg',\r\n      'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg',\r\n      'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg',\r\n      'http://imgsrc.baidu.com/forum/pic/item/1080fc8b87d6277f026c80b428381f30e824fc46.jpg',\r\n      'http://imgsrc.baidu.com/forum/pic/item/2eadcbef76094b366ac0bf0da3cc7cd98c109d84.jpg',\r\n      'http://img1.tgbusdata.cn/v2/thumb/jpg/MGNlNiw3MzAsNzMwLDQsMSwxLC0xLDAscms1MA==/u/olpic.tgbusdata.cn/uploads/allimg/130124/62-130124160054.jpg'\r\n    ],\r\n    vertical:true,\r\n  },\r\n\r\n  displaychange:function(event){\r\n      console.log(event.detail.current);//输出来当前swiper-item的index\r\n   },\r\n\r\n  changeautodisplay:function(){\r\n    this.setData({\r\n      autoplay:!this.data.autoplay//设置是否自动播放\r\n  })\r\n  },\r\n  changeindicator:function(){\r\n    this.setData({\r\n  indicatordos:!this.data.indicatordos//隐藏图片那个点\r\n})\r\n  },\r\n  changevertical:function(){\r\n    this.setData({//设置水平方向\r\n      vertical:!this.data.vertical\r\n    })\r\n  }\r\n\r\n})\r\nswiper.xml文件\r\n<view class=\"container\">\r\n    <view class=\"swiperview\">\r\n        <swiper class=\"swiperitem\" indicator-dots=\"{{indicatordos}}\" autoplay=\"{{autoplay}}\"\r\n          bindchange=\"displaychange\" duration=\"1000\" interval=\"2000\"\r\n          vertical=\"{{vertical}}\"\r\n        >\r\n        <block wx:for=\"{{imgUrls}}\">\r\n            <swiper-item>\r\n                <image src=\"{{item}}\"></image>\r\n            </swiper-item>\r\n        </block>\r\n        </swiper>\r\n    </view>\r\n    <view vlass=\"bottomview\">\r\n        <button type=\"default\" bindtap=\"changeautodisplay\" class=\"bottomButton\">autodisplay:{{autoplay?\"YES\":\"NO\"}}</button>\r\n        <button type=\"default\" bindtap=\"changeindicator\" class=\"bottomButton\">indicatordots:{{autoplay?\"YES\":\"NO\"}}</button>\r\n        <button type=\"default\" bindtap=\"changevertical\" class=\"bottomButton\">水平:{{autoplay?\"YES\":\"NO\"}}</button>\r\n//这里边用了一个简单的判断语句 :{{autoplay?\"YES\":\"NO\"\r\n    </view>\r\n</view>\r\n效果如下:\r\n第三部分：checkbox的使用其实就是复选框：\r\n下边用了text显示了当前选中的name。js文件\r\n首先要设置data的list\r\nPage({\r\n  data:{\r\n     items: [\r\n      {name: 'USA', value: '美国'},\r\n      {name: 'CHN', value: '中国', checked: 'true'},\r\n      {name: 'BRA', value: '巴西'},\r\n      {name: 'JPN', value: '日本'},\r\n      {name: 'ENG', value: '英国'},\r\n      {name: 'TUR', value: '法国'},\r\n    ],\r\n    text:'',//用来显示选中的box\r\n  },\r\n\r\n  onShow:function(){\r\n    // 页面显示 第一次进入页面统计选中的box 调用函数。\r\n    this.check();\r\n  },\r\n\r\n  change:function(e){\r\n      console.log(e.detail.value);\r\n      var te=\"暂时没选中\";\r\n      if(e.detail.value.length == 0)\r\n        { \r\n        } else {\r\n         te = e.detail.value;\r\n        }\r\n         this.setData({\r\n        text:te\r\n      })\r\n\r\n  },\r\n********遍历是否有选中的***********\r\n  check:function(){\r\n    var te=\"\";//遍历是否有选中的\r\n    for(var i = 0;i < this.data.items.length;i ++){\r\n      var item = this.data.items[i];\r\n      if(item.checked){ //如果选中 加到字符串中\r\n        te += item.value;\r\n      }\r\n    }\r\n      if(te.length == 0)\r\n        { \r\n         te = \"暂时没选中\" ;\r\n        }\r\n         this.setData({\r\n        text:te\r\n      })\r\n    }\r\n})\r\nxml文件\r\n<view class = \"contain\">\r\n    <view class=\"bd\">\r\n        <checkbox-group bindchange=\"change\"> //绑定事件\r\n            <label class=\"checkbox\" wx:for=\"{{items}}\">//循环绑定到item\r\n                <checkbox value=\"{{item.value}}\" checked=\"{{item.checked}}\"\r\n                > \r\n                {{item.value}}\r\n                </checkbox>\r\n            </label>\r\n        </checkbox-group>\r\n    </view>\r\n\r\n    <view class=\"checkfooter\">\r\n    <text >{{text}}</text>//显示选中的数据的name\r\n    </view>\r\n</view>\r\ncss文件\r\n.bd{\r\n    width: 800rpx;\r\n    height: 500rpx;\r\n    margin-left: 50rpx;\r\n}\r\n.checkbox{\r\n   display: block;//这个要一定写的 暂时没搞懂意思  应该是一种布局方式。\r\n   margin: 20;\r\n}\r\n.checklabel{\r\n    width: 500rpx;\r\n    height: 200rpx;\r\n}\r\n.checkfooter{\r\n    margin-left: 50rpx;\r\n}\r\n效果如下：\r\ndemo下载：https://github.com/ifgyong/WeChatDemo下载地址：WeChatDemo-master.zip"}
{"title": "微信小程序开发和 Rails 开发相似之处 ", "author": "天下雪", "pub_time": "2016-11-11 10:46", "article_content": "微信小程序通过 Data 构建页面首先看下 Page 生命周期图, 这张图来自于微信小程序的官方文档。截取 onReady 到 onHide 之间的图:从截图中我们可以看到在微信小程序的生命周期中，它大部分时间干的事情是 AppSerivce Thread 向 View Thread 发送数据, 然后 View Thread 接收数据,进行渲染, 最后生成页面。 这个和我们经常在浏览器端使用的面向 DOM 的编程有很大的区别，在 DOM 编程中我们使用 jquery 之类的库或者 api 直接操作 DOM 元素来构建页面, 比如: $('.a').addClass('foo')。在微信小程序中没有 DOM 这一概念, 我们没有办法通过操作 DOM 元素来构建微信小程序的页面。微信小程序和 Rails 程序的相似之处Rails 程序在 Rails 程序中，客户端的请求 (request) 会到达对应的 Controller 实例，然后由这个 Controller 实例中的对应的action 来处理请求, 处理后的数据会通过 render 方法响应给客户端。微信小程序在微信小程序中，View 对象发送事件 (event) 到对应的 Page 对象中，然后由这个 Page 对象中的对应的event_handler 来处理事件, 处理后的数据会通过 setData 方法响应给 View对象。"}
{"title": "微信小程序实际案例详解：页面搭建 ", "author": "天下雪", "pub_time": "2016-11-11 11:43", "article_content": "首先看一下本文要实现的页面效果：\r\n\r\n\r\n开发工具下载\r\n微信官方有开发者工具，集成了开发调试、代码编辑及程序发布等功能。 下载地址  \r\n微信小程序架构\r\n\r\n\r\n这个就是程序的基本架构。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。\r\n底部标签\r\n底部标签是一个tabBar。实现比较简单，只需要简单配置一下即可。 app.json\r\n{\r\n  \"pages\":[\r\n    \"pages/function/function\",\r\n    \"pages/pay/pay\",\r\n    \"pages/account/account\",\r\n    \"pages/index/index\",\r\n    \"pages/logs/logs\"\r\n  ],\r\n  \"tabBar\":{\r\n    \"color\": \"#464a56\",\r\n    \"selectedColor\": \"#6595e9\",\r\n    \"backgroundColor\": \"#FFFFFF\",\r\n    \"borderStyle\": \"white\",\r\n    \"list\": [{\r\n        \"pagePath\": \"pages/function/function\",\r\n        \"text\": \"功能\",\r\n        \"iconPath\": \"images/tab_function_default.png\",\r\n        \"selectedIconPath\": \"images/tab_function_sel.png\"\r\n    },{\r\n        \"pagePath\": \"pages/pay/pay\",\r\n        \"text\": \"收款\",\r\n        \"iconPath\": \"images/tab_consume_default.png\",\r\n        \"selectedIconPath\": \"images/tab_consume_sel.png\"\r\n    },{\r\n        \"pagePath\": \"pages/account/account\",\r\n        \"text\": \"账户\",\r\n        \"iconPath\": \"images/tab_account_default.png\",\r\n        \"selectedIconPath\": \"images/tab_account_sel.png\"\r\n    }]\r\n  },\r\n  \"window\":{\r\n    \"navigationBarBackgroundColor\": \"#6595e9\",\r\n    \"navigationBarTextStyle\":\"white\",\r\n    \"navigationBarTitleText\": \"V50\",\r\n    \"backgroundColor\": \"#eeeeee\",\r\n    \"backgroundTextStyle\":\"light\"\r\n  }\r\n}\r\n值得注意的地方，就是 pages 接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。文件名不需要写文件后缀，因为框架会自动去寻找路径.json, .js , .wxml, .wxss的四个文件进行整合。\r\n页面标题\r\n\r\n这个标题如何实现？ 我们翻看一下官方文档。\r\n\r\n看到这里，你应该就知道了，需要在指定页面的json文件中进行页面配置。继续查看官方的文档\r\n原来如此！我们只需要把所有页面通用的配置放在 page.json，然后在各个page的 .json文件里面配置每个页面特有的属性即可。因为在上面的 app.json 中已经配置了通用页面的 window属性了，我们只需要在function.json中配置页面标题即可：\r\n   {\r\n     \"navigationBarTitleText\": \"功能\"   \r\n   }\r\n轮播图\r\n接下来实现顶部的轮播图。微信提供了一个swiper组件来实现轮播图。\r\n\r\n\r\n代码也就出来了：function.wxml\r\n<swiper indicator-dots=\"{{indicatorDots}}\"\r\n    autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">\r\n    <block wx:for=\"{{imgUrls}}\">\r\n      <swiper-item>\r\n        <image src=\"{{item}}\" class=\"slide-image\" />\r\n      </swiper-item>\r\n    </block>\r\n</swiper>\r\nfunction.js\r\n//function.js\r\nPage({\r\n  data: {\r\n    indicatorDots: true,\r\n    autoplay: true,\r\n    interval: 5000,\r\n    duration: 1000,\r\n    imgUrls: [\r\n       'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg',\r\n       'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg',\r\n       'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg'\r\n     ],  \r\n  },\r\n})\r\n没错，微信小程序的轮播图就是这么简单！在这里可能有的同学要问了：“轮播图的图片用的是url地址，如果我想用本地的图片呢？能不能实现？ ” \r\n这个官方文档没有介绍，兔子哥经过测试，是可以实现的。代码如下：\r\nimgUrls: [\r\n    '../../images/adv_50.png',\r\n    '../../images/adv_60.png',\r\n    '../../images/adv_80.png' \r\n],\r\n中间功能模块\r\n中间的8个功能模块，类似Android的GridView效果。本文采取循环的方式来实现：function.wxml\r\n  <view class='function_container'>\r\n    <view class='function_item' wx:for=\"{{functions}}\" wx:for-index=\"idx\" wx:for-item=\"function\">\r\n        <image class='function_img' src='{{function.pic_url}}'/> \r\n        <view class='function_name'>{{function.name}}</view>\r\n    </view>\r\n  </view>\r\nfunction.js\r\nfunctions: [\r\n      {\r\n        \"name\": \"刷卡消费\",\r\n        \"pic_url\": '../../images/icon_consume.png'\r\n      },\r\n      {\r\n        \"name\": \"提现\",\r\n        \"pic_url\": '../../images/icon_withdrawals.png'\r\n      },\r\n      {\r\n        \"name\": \"交易记录\",\r\n        \"pic_url\": '../../images/icon_records.png'\r\n      },\r\n      {\r\n        \"name\": \"实名认证\",\r\n        \"pic_url\": '../../images/icon_auth.png'\r\n      },\r\n      {\r\n        \"name\": \"飞机票\",\r\n        \"pic_url\": '../../images/icon_airplane.png'\r\n      },\r\n      {\r\n        \"name\": \"火车票\",\r\n        \"pic_url\": '../../images/icon_train.png'\r\n      },\r\n      {\r\n        \"name\": \"手机充值\",\r\n        \"pic_url\": '../../images/icon_phone_recharge.png'\r\n      },\r\n      {\r\n        \"name\": \"水电煤\",\r\n        \"pic_url\": '../../images/icon_water.png'\r\n      }\r\n    ]\r\nfunction.wxss\r\n/**function.wxss**/\r\n.container {\r\n    height: 650px;\r\n}\r\n.slide-image{\r\n    display: block;\r\n    height: 280rpx;\r\n    width:100%\r\n}\r\n.function_container{\r\n    display:flex;\r\n    flex-wrap: wrap;\r\n    width:100%;\r\n}\r\n.function_item{\r\n    width:25%;\r\n    display:flex;\r\n    flex-direction:column;\r\n    justify-content:center;\r\n    align-items:center;\r\n    font-size:12px;\r\n    box-sizing:border-box;\r\n    padding-bottom:10px;\r\n    padding-top:10px\r\n}\r\n.function_img{\r\n    width:60px;\r\n    height:60px;\r\n}\r\n.function_name{\r\n    padding-top:10px\r\n}\r\n这里通过width:25% 来实现每行排列四个功能按钮的效果。\r\n完整代码\r\n下面的布局就比较简单了，直接上完整的代码了：function.wxml\r\n<!--function.wxml-->\r\n<scroll-view scroll-y=\"true\" class=\"container\">\r\n  <swiper indicator-dots=\"{{indicatorDots}}\"\r\n    autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">\r\n    <block wx:for=\"{{imgUrls}}\">\r\n      <swiper-item>\r\n        <image src=\"{{item}}\" class=\"slide-image\" />\r\n      </swiper-item>\r\n    </block>\r\n  </swiper>\r\n\r\n  <view class='function_container'>\r\n    <view class='function_item' wx:for=\"{{functions}}\" wx:for-index=\"idx\" wx:for-item=\"function\">\r\n        <image class='function_img' src='{{function.pic_url}}'/> \r\n        <view class='function_name'>{{function.name}}</view>\r\n    </view>\r\n  </view>\r\n\r\n  <view class='divider' />\r\n\r\n  <view class='specialities_layout'>\r\n      <view class='view_divider' />\r\n      <text class=\"specialities_text\">特色业务</text>\r\n  </view>\r\n  <image class='bottom-image' src='../../images/app_banner.jpg'/> \r\n</scroll-view>\r\nfunction.wxss\r\n/**function.wxss**/\r\n.container {\r\n    height: 650px;\r\n}\r\n.slide-image{\r\n    display: block;\r\n    height: 280rpx;\r\n    width:100%\r\n}\r\n.function_container{\r\n    display:flex;\r\n    flex-wrap: wrap;\r\n    width:100%;\r\n}\r\n.function_item{\r\n    width:25%;\r\n    display:flex;\r\n    flex-direction:column;\r\n    justify-content:center;\r\n    align-items:center;\r\n    font-size:12px;\r\n    box-sizing:border-box;\r\n    padding-bottom:10px;\r\n    padding-top:10px\r\n}\r\n.function_img{\r\n    width:60px;\r\n    height:60px;\r\n}\r\n.function_name{\r\n    padding-top:10px\r\n}\r\n.divider{\r\n    background: #f5f5f5;\r\n    height: 40rpx;\r\n    width:100%;\r\n}\r\n.specialities_layout{\r\n    display:flex;\r\n    flex-wrap: wrap;\r\n    width:100%;\r\n    flex-direction:row;\r\n    margin-left: 16px;\r\n    margin-top:16px;\r\n    margin-bottom: 16px;\r\n}\r\n.view_divider{\r\n    background: #EEA9B8;\r\n    height: 40rpx;\r\n    width:10rpx;\r\n}\r\n.specialities_text {\r\n    margin-left: 8px;\r\n    font-size: 16px;\r\n    height: auto;\r\n    width:auto;\r\n    margin-top: 6rpx;\r\n}\r\n.bottom-image{\r\n    height: 280rpx;\r\n    width:100%;\r\n}\r\n.Absolute-Center {\r\n  margin: auto;\r\n  position: absolute;\r\n  top: 0; left: 0; bottom: 0; right: 0;\r\n}\r\nfunction.js\r\n//function.js\r\n//获取应用实例\r\nvar app = getApp()\r\nPage({\r\n  data: {\r\n    userInfo: {},\r\n    indicatorDots: true,\r\n    autoplay: true,\r\n    interval: 5000,\r\n    duration: 1000,\r\n    // imgUrls: [\r\n    //   'http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg',\r\n    //   'http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg',\r\n    //   'http://img06.tooopen.com/images/20160818/tooopen_sy_175833047715.jpg'\r\n    // ],\r\n    imgUrls: [\r\n      '../../images/adv_50.png',\r\n      '../../images/adv_60.png',\r\n      '../../images/adv_80.png'\r\n    ],\r\n    functions: [\r\n      {\r\n        \"name\": \"刷卡消费\",\r\n        \"pic_url\": '../../images/icon_consume.png'\r\n      },\r\n      {\r\n        \"name\": \"提现\",\r\n        \"pic_url\": '../../images/icon_withdrawals.png'\r\n      },\r\n      {\r\n        \"name\": \"交易记录\",\r\n        \"pic_url\": '../../images/icon_records.png'\r\n      },\r\n      {\r\n        \"name\": \"实名认证\",\r\n        \"pic_url\": '../../images/icon_auth.png'\r\n      },\r\n      {\r\n        \"name\": \"飞机票\",\r\n        \"pic_url\": '../../images/icon_airplane.png'\r\n      },\r\n      {\r\n        \"name\": \"火车票\",\r\n        \"pic_url\": '../../images/icon_train.png'\r\n      },\r\n      {\r\n        \"name\": \"手机充值\",\r\n        \"pic_url\": '../../images/icon_phone_recharge.png'\r\n      },\r\n      {\r\n        \"name\": \"水电煤\",\r\n        \"pic_url\": '../../images/icon_water.png'\r\n      }\r\n    ]\r\n  },\r\n  //事件处理函数\r\n  bindViewTap: function () {\r\n    wx.navigateTo({\r\n      url: '../logs/logs'\r\n    })\r\n  },\r\n  onLoad: function () {\r\n    console.log('onLoad')\r\n    var that = this\r\n    //调用应用实例的方法获取全局数据\r\n    app.getUserInfo(function (userInfo) {\r\n      //更新数据\r\n      that.setData({\r\n        userInfo: userInfo\r\n      })\r\n      that.update()\r\n    })\r\n  }\r\n})"}
{"title": "微信小程序开启实战之旅《一》：知乎日报 ", "author": "天下雪", "pub_time": "2016-11-11 15:39", "article_content": "前言\r\n看了那么多的小程序入门，想必各位看官也差不多对小程序已经有了一定的了解。这篇文章就不再主讲入门，现在我们要通过一个知乎日报的小程序去实践一下，加深对微信小程序API的理解。\r\n对了，入门可以看这篇文章，里面有工具的初步使用介绍：\r\n http://www.jianshu.com/p/37dfcea4a2f8     微信小程序开发入门教程https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html  微信小程序开发工具下载https://mp.weixin.qq.com/debug/wxadoc/dev/index.html   微信小程序官方文档http://doc.pietian.com/  微信小程序开发文档离线下载地址\r\n好了，下面我们开始吧。\r\n实战开始\r\n首先先看看我们今天要做的知乎日报的成果。如下图。不过由于篇幅问题，今天只讲首页的完成，里面包含了与后端的交互，页面的布局，数据的渲染，事件响应等，基本上囊括了如何制作一个单页所有开发。\r\n知乎日报小程序首页\r\n\r\n1. 资源准备\r\n知乎日报-简要版 API：\r\nhttp://news-at.zhihu.com/api/4/news/latest 今日热文http://news.at.zhihu.com/api/4/news/before/  更多往日热文\r\n上面这两个地址是我们今天要做的首页的API，我们将发起request请求，拿回数据做渲染。\r\n2.首页JS\r\n下面我们将开始编写代码，请保持首页目录结构跟我下图一致。\r\n首页三个文件\r\n\r\n好，首先我们先写JS文件,代码如下，而且我都加了详细的注释。\r\n// index.js\r\n\r\n//index.js\r\n//获取应用实例\r\nvar app = getApp()\r\nvar utils = require('../../utils/util.js');\r\n//初始化数据\r\nPage({\r\n  data: {\r\n    list: [],\r\n    duration: 2000,\r\n    indicatorDots: true,\r\n    autoplay: true,\r\n    interval: 3000,\r\n    loading: false,\r\n    plain: false\r\n  },\r\n  //onLoad方法，程序启动自执行，请求知乎日报今日热闻接口\r\n  onLoad: function () {\r\n    var that = this;\r\n    wx.request({\r\n      url: 'http://news-at.zhihu.com/api/4/news/latest',\r\n      headers: { // http头数据\r\n        'Content-Type': 'application/json'\r\n      },\r\n      success: function (res) { //请求成功后的回调\r\n         that.setData({   // 设置返回值\r\n           banner: res.data.top_stories,  //banner图片数据\r\n           list: [{ header: '今日热闻' }].concat(res.data.stories)  //热闻数据list\r\n         })\r\n      }\r\n    })\r\n    this.index = 1;   //方便下拉点击更多时的计数下标，暂可忽略\r\n  },\r\n  //下拉滚动条，点击更多的响应\r\n  loadMore: function (e) {\r\n    if (this.data.list.length === 0) return\r\n    var date = this.getNextDate()\r\n    var that = this\r\n    that.setData({ loading: true });\r\n    wx.request({  // 再次发起请求，请求上一天的热闻\r\n      url: 'http://news.at.zhihu.com/api/4/news/before/' + (Number(utils.formatDate(date)) + 1),  //此此API需要带日期\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      success: function (res) {  // 成功回调\r\n         that.setData({\r\n           loading: false,\r\n           list: that.data.list.concat([{ header: utils.formatDate(date, '-') }]).concat(res.data.stories)\r\n         })\r\n      }\r\n    })\r\n  },\r\n  //事件处理函数\r\n  bindViewTap: function(e) {\r\n    wx.navigateTo({\r\n      url: '../detail/detail?id=' + e.target.dataset.id\r\n    })\r\n  },\r\n  //转换时间函数\r\n  getNextDate: function (){\r\n    var now = new Date()\r\n    now.setDate(now.getDate() - this.index++)\r\n    return now\r\n  },\r\n\r\n})\r\n这里我们简单讲下几个要点：\r\n2.1 设置data值\r\n目前微信小程序只能支持 \r\nthis.setData({....});\r\n无法直接指定一个值\r\nthis.data.xxxx = '';  //记住，这样是不行的。\r\n2.2 onLoad\r\n这是页面生命周期里的一个监听页面加载的方法，就是说每一次进入这个页面开始都要执行这里面的方法，和JS中load一样。\r\n2.3 和服务端交互\r\n微信小程序中和后端交互也是采用的请求接口，具体样例如下，我已经加了注释了，想必都能看懂。\r\nwx.request({\r\n  url: 'test.php', //接口地址\r\n  data: {  // 参数\r\n     x: '' ,\r\n     y: ''\r\n  },\r\n  header: {  // 头信息\r\n      'Content-Type': 'application/json'\r\n  },\r\n  success: function(res) {  // 成功 回调\r\n    console.log(res.data)\r\n  }\r\n})\r\n3.首页布局 index.html\r\n好了，写完了和后端交互的js代码，这样我们就拿到了数据，现在我们开始写页面的布局。\r\n其实微信小程序在渲染页面这块，采用的也是一种模板引擎的方式。而且页面取值方式都比较通用。和其他一些页面模板引擎都是差不多的。\r\n好，我们开始吧。这个页面布局还是比较简单的。\r\n布局划分\r\n\r\n3.1 banner块\r\n首先，我们去找下文档，会有专门的banner组件，swiper(点击可以跳转文档)\r\n我们就用这个swiper组件写咱们的bannner模块，这里有个注意点\r\n在 swiper 组件中只可放置<swiper-item/>组件，其他节点会被自动删除。\r\n// index.html banner模块代码\r\n\r\n<swiper indicator-dots=\"{{indicatorDots}}\"\r\n  autoplay=\"{{autoplay}}\" class=\"banners\" interval=\"{{interval}}\" duration=\"{{duration}}\">\r\n    <!-- 循环bannner图片开始-->\r\n    <block wx:for=\"{{banner}}\"> \r\n      <swiper-item class=\"banner\" >\r\n          <image src=\"{{item.image}}\"  data-id=\"{{item.id}}\" bindtap=\"bindViewTap\" class=\"banner-image\" width=\"100%\" height=\"100%\"/>\r\n          <text class=\"banner-title\">{{item.title}}</text>\r\n      </swiper-item>\r\n    </block>\r\n     <!-- 循环bannner图片结束-->\r\n  </swiper>\r\n3.2 热闻列表模块\r\n其实下面的一个热闻列表也就是一个list循环，这边怎么做循环呢，同样我们可以查询API文档可得。利用 wx-for 属性，但是这只是一个属性，我们需要把它加到一个标签上面才能执行，为了承载这个属性，微信小程序专门定义了一个无其他作用的标签 <block>。\r\n另外注意，微信小程序里有很多默认：\r\n在组件上使用wx:for控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item，如果需要修改的话，使用 wx:for-item 可以指定数组当前元素的变量名。\r\n所以对下面的item.header不要惊讶，item哪来的。\r\n代码如下：\r\n<view class=\"news-item-container\">\r\n    <block wx:for=\"{{list}}\" wx:for-index=\"id\">\r\n      <text wx:if=\"{{item.header}}\" class=\"sub-title\">{{item.header}}</text>\r\n      <navigator wx:else url=\"../detail/detail?id={{item.id}}\">\r\n        <view class=\"news-item\" >\r\n          <view class=\"news-item-left\">\r\n            <text class=\"news-item-title\">{{item.title}}</text>\r\n          </view>\r\n          <view class=\"news-item-right\">\r\n            <image src=\"{{item.images[0]}}\" class=\"news-image\"/>\r\n          </view>\r\n        </view>\r\n      </navigator>\r\n    </block>\r\n    <button type=\"primary\" class=\"load-btn\" size=\"mini\" loading=\"{{loading}}\" plain=\"{{plain}}\" bindtap=\"loadMore\"> 更多 </button>\r\n  </view>\r\n另外，这里有个更多的点击响应，使用的是 bindtap 属性指定响应方法名。\r\n4.样式表 index.wxss\r\n这个就不单独说了，跟平时写的 css几乎没啥区别。最后也会放出源代码给大家下载。\r\n5. 写在最后\r\n这篇小文，只是带领大家做一个和服务端进行交互的小demo，加深下对微信小程序的前前后后的理解。后续的正在coding中....敬请期待。\r\ngithub代码地址：https://github.com/XuXiaoGH/wechat-app-zhihudaily文件下载：wechat-app-zhihudaily-master.zip"}
{"title": "微信小程序学习笔记《一》：项目路径，使用页面，新建多一页面 ... ", "author": "天下雪", "pub_time": "2016-11-11 21:49", "article_content": "作者：hero82748274，原文地址微信的小程序已经推出了，相继的教程也有。官方网页推出API和接口说明，目前来讲暂时足够。 可以进入该链接查看。微信官网今天尝试一下下载该web的开发工具，从目前来讲，使用了一个下午。目前版本给人的感觉还有待继续提升的恐惧。从编码的体验来讲，对一个重度用户来讲并不算太好用。但足够对付一个轻量级的程序。在调试的过程，由于经常切换显得不是太舒服。1.注意项目路径由于第一次初始的时候，下载的demo，由于没有注意app.json的放置的文件夹位置，导致了多了一层，导致老是报一个错误。经同事指点后，将文件和项目文件夹放置同一级处，这样就可以顺利调试到。由于appid申请不到，在公众号那里需要公测，因此只能有限制使用。一个下午经过调试了一下临时搭建了一个没有功能的界面。2.使用组件微信这里提供了很多组件，这个和之前的微信样式有点类似。通过组件的组合可以拼接一些界面使用。这个有点像css那样，据官方说wxss文件和css有点相似，区别和限制。配置一个Tabbar，一个Tabbar最多是5个，相应的字段需要对其进行配置，提供了图片，点击的关联的页面。选择的图标状态。官方的代码如下：\r\n\r\n  \"tabBar\": {\r\n      \"color\": \"#dddddd\",\r\n      \"selectedColor\": \"#3cc51f\",\r\n      \"borderStyle\": \"black\",\r\n      \"backgroundColor\": \"#ffffff\",\r\n    \"list\": [{\r\n      \"pagePath\": \"pages/index/index\",\r\n      \"iconPath\": \"image/icon_component.png\",\r\n      \"selectedIconPath\": \"image/icon_component_HL.png\",\r\n      \"text\": \"首页\"\r\n    }, {\r\n      \"pagePath\": \"pages/logs/logs\",\r\n      \"iconPath\": \"image/icon_API.png\",\r\n      \"selectedIconPath\": \"image/icon_API_HL.png\",\r\n      \"text\": \"我的\"\r\n    }]123456789101112131415161718123456789101112131415161718使用视图，图片，文本，按钮  <view class=\"card\">\r\n      <view class=\"shopitem\">\r\n      <image class=\"shopimg\" src=\"http://img12.360buyimg.com/n5/jfs/t1174/338/865120803/45181/e564982f/5563cb4cNa42cf32c.jpg\"></image>\r\n      <text class=\"title\">小米充电宝</text>\r\n       <text class=\"price\">$69元</text>  \r\n       <button class=\"buy\" type=\"primary\">购买</button>\r\n    </view>\r\n   </view>1234567812345678按钮提供了一些使用的样式类型。3.使用页面创建Tabbar按钮，需要关联一些页面，页面的命名方式需要保持一致。 如文件夹为index，里面js wxml 和wxss保持 前缀一样。 index.js index.wxml index.wxss 切换页面的时候，可以在js里面控制一些行为。下面可以看到，通过app来获取用户的基本信息。定义数据  data: {\r\n    motto: 'Hello World',\r\n    userInfo: {}//用户的基本信息，微信用户的信息\r\n  },12341234//官方案例\r\n//index.js\r\n//获取应用实例\r\nvar app = getApp()\r\nPage({\r\n  data: {\r\n    motto: 'Hello World',\r\n    userInfo: {}\r\n  },\r\n  //事件处理函数\r\n  bindViewTap: function() {\r\n    wx.navigateTo({\r\n      url: '../logs/logs'\r\n    })\r\n  },\r\n  onLoad: function () {\r\n    console.log('onLoad')\r\n    var that = this\r\n    //调用应用实例的方法获取全局数据\r\n    app.getUserInfo(function(userInfo){\r\n      //更新数据\r\n      that.setData({\r\n        userInfo:userInfo\r\n      })\r\n    })\r\n  }\r\n})\r\n1234567891011121314151617181920212223242526272812345678910111213141516171819202122232425262728数据绑定通过加载的数据，获取到了用户的基本信息userInfo。通过数据绑定来显示微信的头像和名字。  <view  bindtap=\"bindViewTap\" class=\"userinfo\">\r\n    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\r\n    <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\r\n  </view>123412344.新建多一页面编辑器里面新增一个页面，并且在app.json里面配置多一页面，把相应的页面配置一下。 在pages里面进行配置新增多一页面。并在tabBar里面新增一个选项指向我们刚创建的页面。{\r\n  \"pages\":[\r\n    \"pages/index/index\",\r\n    \"pages/logs/logs\",\r\n    \"pages/me/me\"\r\n  ],\r\n  \"window\":{\r\n    \"navigationBarTitleText\": \"初心暖暖心意\",\r\n     \"navigationBarBackgroundColor\": \"#000\",\r\n     \"navigationBarTextStyle\":\"white\"\r\n\r\n  },\r\n    \"tabBar\": {\r\n      \"color\": \"#dddddd\",\r\n      \"selectedColor\": \"#3cc51f\",\r\n      \"borderStyle\": \"black\",\r\n      \"backgroundColor\": \"#ffffff\",\r\n    \"list\": [{\r\n      \"pagePath\": \"pages/index/index\",\r\n      \"iconPath\": \"image/icon_component.png\",\r\n      \"selectedIconPath\": \"image/icon_component_HL.png\",\r\n      \"text\": \"首页\"\r\n    }, {\r\n      \"pagePath\": \"pages/logs/logs\",\r\n      \"iconPath\": \"image/icon_API.png\",\r\n      \"selectedIconPath\": \"image/icon_API_HL.png\",\r\n      \"text\": \"日志\"\r\n    },\r\n    {\r\n      \"pagePath\": \"pages/me/me\",\r\n      \"iconPath\": \"image/icon_API.png\",\r\n      \"selectedIconPath\": \"image/icon_API_HL.png\",\r\n      \"text\": \"我的\"\r\n    }]\r\n  },\r\n  \"debug\":true\r\n}\r\n12345678910111213141516171819202122232425262728293031323334353637381234567891011121314151617181920212223242526272829303132333435363738在me.js里面定义一个数据//index.js\r\n//获取应用实例\r\nvar app = getApp()\r\nPage({\r\n  data: {\r\n    name: 'weChat',\r\n    age:\"qqq\"\r\n  },\r\n  onLoad: function () {\r\n\r\n  }\r\n})\r\n1234567891011121312345678910111213界面如下，同时绑定了我们创建的字段。<view>\r\n  <text>我叫{{name}}微信</text>\r\n</view>123123初步的页面也实现出来了。5.不足的地方用起来的时候，软件启动起来十分慢，其次是部分文档出现了错误（同事发现了标签不对的地方）。软件调试提示性一般对wxml支持不够好，编写起来会有点吃力。提示这块存在薄弱的地方。（1）建立文件的时候，还需要填写后缀名，这一点让我不理解 （2）软件经常切换调试，如果能实时刷新这个效果不错。类似ReactNative那样 （3）启动画面比较慢 （4）提示比较薄弱，对wxml提示比较差。对这种重度用户而言，用起来不够智能。 （5）文档复制代码比较槽糕，选取的时候经常选取不到。加个复制按钮如何？ （6）代码区域不能拖动，编译的时候为何不在加一个按钮在编辑区域里？6.app和小程序争论焦点凭借小程序曝光，很多媒体过渡阅读这个小程序可以消灭app这样的说法。app的开发门槛相对小程序要高，对于游戏而言，能不能进去还是未知之数。小程序限制了document和window对象，也不能操控dom，因此在制作上会有所限制。app的门槛高，这个其实h5和app争执的观点。在app上性能更加有所保障，对硬件底层支持更足。这也是小程序很难比较的。目前还没有公测，对小程序可以发挥到什么商业价值。这还有待观察。 我们在微信可以看到滴滴打车也就是一个一类的小程序了。对于小程序可以消灭app这样说法，笔者还是要持怀疑态度。"}
{"title": "微信小程序学习笔记《二》：触发按钮点击，调用接口，选择图片，视图更新 ... ", "author": "天下雪", "pub_time": "2016-11-12 00:19", "article_content": "作者：hero82748274     原文地址今天继续看了一些文档相关的内容，同时也试了视频组件和网络请求的接口。小程序没有document，window操控提供。很多数据要换成类似vuejs和React Native的这种方式来看待。数据绑定的支持可以对一些视图进行刷新。1.开发思维需要转变jQuery 在操作dom是非常好用和便利。然而在小程序开发就要换成了数据驱动就要对其换一种开发思维方式了。因为小程序目前文档中已经说明了限制了window和document。 很多年前adobe flex的推出mxml的语言，这种早期的设计后来也被证实是超前的设计。在angular 和现在微信开发依旧可以看到一些缩影。微信wxml会倾向于React native的方案。采取数据data绑定视图变化也是传统的mvc方式。 类似input这些组件，在过去我们经常使用$(“#id”).val().获取id值去调用文本输入框内容是判断否为空。而采用数据的方式，则先定义一个文本变量。然后通过输入事件获得内容，再用这个方式去和数据进行判断。内容会通过这个事件通知来得到当前的值。<view class=\"container2\">\r\n  <view class=\"panel\">\r\n      <label class=\"title\">请输入查询内容</label>\r\n      <input class=\"inputarea\"  bindinput=\"onInput\"/>\r\n      <button bindtap='onRequest' type=\"primary\" class=\"searBtn\">查询</button>\r\n  </view>\r\n</view>12345671234567Page({\r\n  data: {\r\n      inputValue:\"\"\r\n  },\r\n  onInput:function(event){\r\n      inputValue = event.detail;//记录输入的值\r\n  });12345671234567.container2{\r\n background-color: #efeff4;\r\n height:100%\r\n}\r\n\r\n.panel{\r\n\r\n padding-top: 20px;\r\n}\r\n\r\n.title{\r\n    margin-left: 4%;\r\n}\r\n\r\n.inputarea{\r\n  width: 100%;\r\n  height: 60px;\r\n  background-color: #ffffff;\r\n  margin-top: 10px;\r\n  }\r\n\r\n.searBtn{\r\n  margin-top: 40px;\r\n  width: 92%;\r\n}1234567891011121314151617181920212223242512345678910111213141516171819202122232425我们可以不用理会样式先，关注是文本框如何获取到内容。input支持事件获取。有这个字段就可以获得用户输入的内容了。2.如何触发按钮点击大部分想在测试过程调用一个接口，这个调用方式是最直接也是最傻瓜。在小程序提供案例请求了个人微信信息，返回后可以获取到小头像和名字的基础信息。 好了，按钮是如何点击处理？ 同样 <button bindtap='onRequest' type=\"primary\" class=\"searBtn\">查询</button>11定义按钮绑定一个点击触控行为bindtap=’onRequest’，通过这个点击事情获取文本输入的内容。然后在me.js里面进行对代码编辑。加入onRequest的函数处理。Page({\r\n  data: {\r\n      inputValue:\"\"\r\n  },\r\n  onInput:function(event){  \r\n      inputValue = event.detail;//记录输入的值\r\n  },\r\n  onRequest:function(){\r\n    console.log(\"我点击了\"+inputValue );\r\n });12345678910123456789103.点击后我希望调用接口网络请求支持https 和websocket。方法API如下 wx.request(OBJECT) 这里提供了相应参数说明文档。我们尝试调用豆瓣的电影接口，返回一些数据回来。它可以处理成功的函数调度，同时在错误的时候，也可以进行输出反馈。  wx.request({\r\n      url: 'https://api.douban.com/v2/movie/top250',\r\n      header: {\r\n          'Content-Type': 'application/json'\r\n      },\r\n      success: function(res) {\r\n\r\n        console.log(res.data);\r\n        wx.redirectTo({\r\n              url: '../logs/logs'\r\n          })\r\n\r\n      },\r\n      fail:function(){\r\n\r\n          console.log(\"接口调用失败\");\r\n      }\r\n    })123456789101112131415161718123456789101112131415161718通过点击这个按钮后，出现了我们想要的数据。 效果图展示。 这几天断断续续查看小程序的开发。在熟悉的过程，发现微信提供的这个开发工具还没完善，提示代码几乎无法玩。这套东西也是基于vscode。为何不在单独的vscode完善一下？对于维护这套ide而言，对web开发工具还需要时间完善。4.选择图片微信小程序提供了一个选择图片的接口，查看了一些图片选择的接口。熟悉这个接口，可以查看如下链接wx.chooseImage(OBJECT)    wx.chooseImage({\r\n    count: 1, // 默认9\r\n    sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n    sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n    success: function (res) {\r\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n      var tempFilePaths = res.tempFilePaths;\r\n      console.log(JSON.stringify(res));\r\n    }123456789123456789选择图片的时候，发生了一个奇怪事情，在选择项目外的图片不行。而选择项目内的图片是可以的。返回的一个叫res的参数，通过json化可以看到内容。临时的路径tempFilePaths，通过绑定一个图片后，可以显示其选取的内容。设置多张图片会返回一个组列。{\"errMsg\":\"chooseImage:ok\",\"tempFilePaths\":[\"apptmpfile__880781730_o6zAJs-Eqx6eMblKlbSsiLa1FgnY_1474972522650\"]}115.绑定图片，视图更新这个框架似乎严格执行了mvc的设计。使用数据驱动方式来驱动视图变化。在普通赋值，视图并不会改变。需要使用setData的内置方法来驱动。<view class=\"container2\">\r\n  <view class=\"tabtab\">\r\n     <label>首页</label>\r\n     <label>最新</label>\r\n     <label>最热</label>\r\n  </view>\r\n   <view class=\"panel\">\r\n    <button bindtap='onRequest' type=\"primary\" class=\"searBtn\">查询</button>\r\n     <image src=\"{{imagesrc}}\" class=\"icon\"/>\r\n   </view> \r\n</view>12345678910111234567891011下面程序，通过点击一个按钮，选取一个图片。图片的链接，我们需要声明一个变量来保存。变量绑定在视图中 <image src=\"{{imagesrc}}\" class=\"icon\"/>\r\n   </view> 1212js代码//index.js\r\n//获取应用实例\r\nvar app = getApp()\r\n\r\nPage({\r\n  data: {\r\n      inputValue:\"\",\r\n      imagesrc:\"\"\r\n  },\r\n  onReady: function (e) {\r\n\r\n  },\r\n  onInput:function(event){\r\n\r\n      inputValue = event.detail;//记录输入的值\r\n  }\r\n  ,\r\n  onRequest:function(){\r\n\r\n    var self = this\r\n        wx.chooseImage({\r\n    count: 1, // 默认9\r\n    sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n    sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n    success: function (res) {\r\n        // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n        var tempFilePaths = res.tempFilePaths;\r\n       //imagesrc = tempFilePaths;\r\n\r\n       self.setData({ imagesrc: tempFilePaths})\r\n\r\n        console.log(JSON.stringify(res));\r\n    }\r\n   })\r\n  }\r\n\r\n})\r\n12345678910111213141516171819202122232425262728293031323334353637381234567891011121314151617181920212223242526272829303132333435363738在更新视图过程，需要调用setData的方式，由于受到作用域的问题，this需要定义一个临时值 var self = this;在编辑器提供的机制里面，对写不写分号似乎没有严格限制。习惯了分号写起来还是会忍不住添加上了。选择图片后，我们可以提供json化处理对象，查看返回的对象信息。目前文档里面返回的对象信息并没有提供。这也是文档所缺陷。console.log(JSON.stringify(res));发现选取图片的时候，要是不在项目内提供的，返回不到。显示不出来，不知道为什么会这样。效果图展示：选取后可以展示一张图片。"}
{"title": "hbblzjy：微信小程序基础《一》创建使用教程 ", "author": "天下雪", "pub_time": "2016-11-12 00:24", "article_content": "本文档将带你一步步创建完成一个微信小程序，并可以在手机上体验该小程序的实际效果。这个小程序的首页将会显示欢迎语以及当前用户的微信头像，点击头像，可以在新开的页面中查看当前小程序的启动日志.1. 获取微信小程序的 AppID登录 https://mp.weixin.qq.com ，就可以在网站的“设置”-“开发者设置”中，查看到微信小程序的 AppID 了，注意不可直接使用服务号或订阅号的 AppID 。（一般这个AppID需要公司营业许可证，还必须要缴费才可获得，与公众号的注册类似，所以如果只是游客，不需要看这些，直接下载开发工具，写Demo即可）注意：如果要以非管理员微信号在手机上体验该小程序，那么我们还需要操作“绑定开发者”。即在“用户身份”-“开发者”模块，绑定上需要体验该小程序的微信号。本教程默认注册帐号、体验都是使用管理员微信号。2. 创建项目我们需要通过开发者工具，来完成小程序创建和代码编辑。开发者工具安装完成后，打开并使用微信扫码登录。选择创建“项目”，填入上文获取到的 AppID ，设置一个本地项目的名称（非小程序名称），比如“我的第一个项目”，并选择一个本地的文件夹作为代码存储的目录，点击“新建项目”就可以了。为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择“是”，开发者工具会帮助我们在开发目录里生成一个简单的 demo。项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在“编辑”里可以查看和编辑我们的代码，在“调试”里可以测试代码并模拟小程序在微信客户端效果，在“项目”里可以发送到手机里预览实际效果。3. 编写代码创建小程序实例点击开发者工具左侧导航的“编辑”，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。想了解更多可用 API，可参考 API 文档//app.jsApp({  onLaunch: function () {    //调用API从本地缓存中获取数据    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)  },  getUserInfo:function(cb){    var that = this;    if(this.globalData.userInfo){      typeof cb == \"function\" && cb(this.globalData.userInfo)    }else{      //调用登录接口      wx.login({        success: function () {          wx.getUserInfo({            success: function (res) {              that.globalData.userInfo = res.userInfo;              typeof cb == \"function\" && cb(that.globalData.userInfo)            }          })        }      });    }  },  globalData:{    userInfo:null  }})app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。更多可配置项可参考配置详解{  \"pages\":[    \"pages/index/index\",    赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序学习笔记《二》：触发按钮点击，调用接口，选择图片，视图更新 ... \n              微信小程序基础《二》新建项目文件详细图解，最简单Demo设计 ... ... \n            \n             \n            \n                  原作者: hbblzjy \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序基础《二》新建项目文件详细图解，最简单Demo设计 ... ...\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSCjrSrT', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序第三方框架对比 ( wepy / mpvue / ta2019-01-28微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30分享一款拥有历史搜索记录的微信小程序搜索2019-01-28小程序点睛之三：才不是你想的那种组件2019-01-28微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n微信小程序Demo:Canvas图片拖拽生成实现2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo：精美的画板小程序2019-02-21微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：仿 [one] 微信小程序2019-02-18微信小程序Demo：3D旋转效果2019-02-18微信小程序Demo: flappy-bird小游戏2019-02-15微信小程序Demo：群应用（群通知、群接龙、2019-02-15微信小程序Demo：咩咩单词2019-02-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164045|87fb72bdb3e6fba27b40fc836dac04a9|2';"}
{"title": "微信小程序基础《二》新建项目文件详细图解，最简单Demo设计 ... ... ", "author": "天下雪", "pub_time": "2016-11-12 00:28", "article_content": "第一部分：新建的项目文件图解第二部分：最简单的Demo设计使用这个小Demo，代码量不多：导航样式、View、Text、点击、JS交互的使用，主要是理解每个后缀文件的功能，然后才能更好的使用开发.......（下面代码和源代码没差别，实在想要的请留言，谢谢。。。）首先在index.wxml中创建相关控件<!--创建一个背景为蓝色的View，并且添加点击事件,输出启动日志-->  <view  bindtap=\"bindViewTap\" class=\"myView\">    <text class=\"myView-clickK\">点我点我</text>  </view><!--创建了一个text标签，然后执行了JS交互，在indexindex.js中进行赋值-->  <view class=\"usermotto\">    <text class=\"user-motto\">{{motto}}</text>  </view></view> 然后在index.wxss中设计控件位置和属性样式，/**rpx单位是微信小程序中css的尺寸单位，rpx可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。开发建议：开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。UI设计图建议：使用设计稿使用设备宽度750px比较容易计算750px的话1rpx=1px，这样的话，设计图上量出来的尺寸是多少px就是多少rpx**/.myView{  width: 200rpx;  height: 200rpx;  margin-top: -100rpx;  background-color: blue;}.myView {  display: flex;  flex-direction: column;  align-items: center;  width: 200rpx;  height: 200rpx;  margin: 20rpx;  border-radius: 50%;}.myView-clickK {  margin-top: 75rpx;  height: 50rpx;  color: red;}.usermotto {  margin-top: 100rpx;}涉及到交互功能，所以在index.js中，设置内容data: {    motto: 'Hello World，你好，世界！'  },  //事件处理函数  bindViewTap: function() {    wx.navigateTo({      url: '../logs/logs'    })  },设置导航样式，需要在app.json中进行设置效果展示："}
{"title": "微信小程序开发系列分析《六》生命周期和路由 ", "author": "天下雪", "pub_time": "2016-11-2 17:34", "article_content": "作者：jsong原文地址（已获授权）作者微信公众号：半圆生活，欢迎关注一、生命周期先来分析一下小程序官网给的这张图，它指的是Page的整个生命周期。要理解它，我们还是先回顾一下react.js的渲染机制。react里面有一个virtual DOM的概念，它实际上是把界面中的每个元素，用js实现的树形数据结构对应起来，结构里记录了节点的所有信息。我们可以把这个virtual DOM看成一个独立的线程（js里没有真正的多线程），我们暂时称它为view线程，它的工作就是负责界面的渲染。当virtual DOM上的数据发生变化的时候，界面的相应的部分就会跟着更新，更新机制被称为DOM diff，这里有篇文章详细地分析了这种更新机制：http://calendar.perfplanet.com/2013/diff/，不过可惜的是它要翻墙才能看，后面发现segmentfault上有人把它转成中文描述了：https://segmentfault.com/a/1190000000606216，有兴趣的读者可以阅读一下这篇文章。这里简单地介绍下：React.createClass创建的类都有一个render方法，它返回的不是真正的html代码，而是我们上面讲到的virtual DOM，每一次渲染会直接按内部转换关系画到界面上，这个流程跟传统的网页渲染差不多。但是当要修改界面上某些元素的时候，react的性能才会真正的突显出来，它会去调用setState方法，这时有内置的算法会去比对这次操作引起的变化前后，最小的差异是什么，然后把这个最小的差异更新到界面上。DOM diff的这篇文章讲到，传统的两个树形结构要分析出差异，复杂度至少要O(n^3)，但react巧妙地把这个复杂度做到了接近O(n)，优化了非常多，这也是它的核心算法。这整个东东，就是我们上面讲到的“view线程”，它负责拿到数据后去做界面的更新，不过这个“线程”不处理主业务逻辑，只负责view层，用react的时候，它的内部框架已经帮我们做好了，所以react被称为是一个view层的框架。那么我们还需要一个“线程”来处理主逻辑，这些就是我们自己要写的主要的代码。微信小程序跟react一样，也帮我们做好了这种渲染的算法。上图中，左侧绿色的部分，可以理解为上文中的“view线程”，应用启动时，他会用Page里的data初始值去Init出一个初始的virtual DOM，当setData被调用的时候，MINA就会触发我们上面讨论的DOM diff的过程，自动去更新界面。这也是为什么我们直接修改data无效的原因，一定要调用setData界面才会有变化。上图右侧的“AppService线程”，其实就是我们说的主业务逻辑“线程”，我们就是跟它打交道。下面简述一下整个生命周期的过程：“view线程”和“AppService线程”在Page({… })被执行时差不多同时启动（实际上，个人理解，后者应该要先一步启动，因为它要接收notify，纯属猜测）。前者init结束时，发送一个notify到后者。后者在create完成后，会同时触发Onload和Onshow回调（至于为什么要同时触发两个看起来差不多的状态，在下方会分析到），在这两个函数里面对page的data做一些修改（setData），然后挂起进入等待状态，等“view线程”init完，才会进行下面的流程，因为对用户来说这个应用的直接使用方式就是界面，背后逻辑用户不管，所以一定要等“view线程”准备好后，再做下面的事情才有意义。如果Onload和Onshow有对data做修改，收到notify通知前也不会做什么动作，直到收到通知才会把变化发送给“view线程”，之后的流程里，setData就不用等通知了，因为这个通知只是为了让“AppService线程”知道“view线程”已经准备好了，进入可用状态了，后面就可以随意setData了，“view线程”随时都会做出响应，一发现数据变化就会重新render然后做DOM diff操作，去更新界面。而当用户进入另一个页面时（wx.nativateTo）,onHide函数被触发，页面被切换到后台，可以看成是挂起状态，不会有什么动作。而当用户切换回来的时候（wx.navigateBack），onShow会被触发，但onLoad不会，onLoad只会在page初始化完成时触发一次，后面不会再进入了，所以对于只需要做一次的操作，千万不要写到onShow里面，如请求页面初始数据，要写到onLoad里。上面讲到“AppService线程”初始化的时候要同时触发onShow和onLoad，虽然字面上理解起来比较相似，但其实是不一样的过程，触发条件也是不一样的。二、路由路由的控制逻辑主要在WAService.js里，这个文件，当程序在运行时，调试工具里可以查看。可惜的是，这个文件是压缩过的，格式化之后，还是很难看懂主要的逻辑。不过上表微信官方给的也表述得比较明显。大概按这表介绍下路由的几种情况。（1）当程序打开的时候，第一个页面会被加载（第一个页面，指在app.json里的pages配置的第一项），先初始化，这时这个页面的onLoad和onShow会被调用。（2）从第一个页面跳到其它页面（navigateTo），这时第一个页面的onHide会被调用，跳过去的其它页面onLoad和onShow会被调用。（3）如果是redirectTo跳转，则第一个页面被触发的是onUnload，其它跟（2）一样（4）页面返回时，前一个页面被onUnload卸掉，返回后的页面onShow被调用。从这可以看出，返回时，前一个页面被销毁了。（5）tab的切换，就只有onShow和onHide，当然第一个出现页面还有一个onLoad。这几个情况也比较直观。"}
{"title": "微信小程序学习点滴《七》：数据存储 参数传递 数据缓存 ", "author": "天下雪", "pub_time": "2016-11-3 11:20", "article_content": "微信小程序开发内测一个月.数据传递的方式很少.经常遇到页面销毁后回传参数的问题,小程序中并没有类似Android的startActivityForResult的方法,也没有类似广播这样的通讯方式,更没有类似eventbus的轮子可用.现在已知传递参数的方法只找到三种,先总结下.由于正处于内测阶段,文档也不是很稳定,经常修改,目前尚没有人造轮子.先上GIF:1.APP.js我把常用且不会更改的参数放在APP.js的data里面了.在各个page中都可以拿到var app = getApp();app上就可以拿到存在data中的参数.2. wx.navigateTo({})中URL携带参数demo中已经写出: wx.navigateTo({      url: \"../newpage/newpage?infofromindex=\" + this.data.infofromindex,  });3.wx.setStorage(OBJECT) 数据缓存微信开发文档中的数据缓存方法:①存储数据 try {      wx.setStorageSync('infofrominput', this.data.infofrominput)    } catch (e) { }②获取数据  //获取        wx.getStorage({            key: 'infofrominput',            success: function (res) {                _this.setData({                    infofromstorage: res.data,                })            }        })key是本地缓存中的指定的 key,data是需要存储的内容.详情见微信小程序开发文档:文档贴上代码:1.index.js赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              Acmen、L学习案例集锦《四》video视频播放，audio音频播放 \n              新手入门选修教程：小程序的框架及逻辑层 \n            \n             \n            \n                  原作者: dzp_coder \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序学习点滴《一》：如何获取时间，页面跳转，传递参数 ... ...\n                                    \n                  • 微信小程序学习点滴《二》：开发者工具快捷键，轮播图 swiper图片组件 ...\n                                    \n                  • 微信小程序学习点滴《三》：开发工具及开发环境配置，尺寸单位rpx与px,rem相互转换 ...\n                                    \n                  • 微信小程序学习点滴《四》：网络请求\n                                    \n                  • 微信小程序学习点滴《五》：网络请求(POST请求)填坑指南\n                                    \n                  • 微信小程序学习点滴《六》：保留小数(toFixed) 四舍五入 获取整数 string转int ...\n                                    \n                  • 微信小程序学习点滴《八》：从相册获取图片 使用相机拍照 本地图片上传 ... ...\n                                    \n                  • 微信小程序学习点滴《九》：本地图片上传(leancloud)\n                                    \n                  • 微信小程序学习点滴《十》：真机测试 地图定位 map API 无法获取当前位置的问题 ... ...\n                                    \n                  • 微信小程序学习点滴《十一》：选择器 时间选择器 日期选择器 地区选择器 ... ...\n                                    \n                  • 微信小程序学习点滴《十二》：图片等比例缩放 获取屏幕尺寸图片尺寸 自适应 ... ...\n                                    \n                  • 微信小程序学习点滴《十三》：音乐播放器 真机测试 audio API\n                                    \n                  • 微信小程序学习点滴《十五》：用户系统 一键登录 获取session_key和openid ...\n                                    \n                  • 微信小程序学习点滴《十六》：下拉刷新 上拉加载\n                                    \n                  • 微信小程序缓存：本地缓存，同步缓存，异步缓存\n                                    \n                  • 微信小程序之页面跳转、传参，参数传递\n                                    \n                  • 微信小程序学习笔记《一》：页面的生命周期与参数传递\n                                    \n                  • 微信小程序Wxml Panner失效坑，小程序参数传递\n                                    \n                  • Charlotte微信小程序开发（一）--数据存储\n                                    \n                  • 小程序 LRU 存储设计\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSJ0dqDJ', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164054|4fe48c69afbea650007d8f768dfd3628|2';"}
{"title": "Vincent：微信小程序实战教程《一》小程序文件介绍 ", "author": "天下雪", "pub_time": "2016-11-3 11:55", "article_content": "小程序的-AppID\" style=\"box-sizing: border-box; font-family: 'Open Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif; line-height: 1.1; color: rgb(64, 64, 64); margin-top: 20px; margin-bottom: 10px; font-size: 30px; background-color: rgb(255, 255, 255);\">获取微信小程序的 AppID如果你是收到邀请的开发者，登录 https://mp.weixin.qq.com ，就可以在网站的“设置”-“开发者设置”中，查看到微信小程序的 AppID ;创建项目我们需要通过开发者工具，来完成小程序创建和代码编辑。note:如果没有受到邀请，选择 “无AppID”选项，然后给你的项目取名称，放到合适的文件目录下面文件工程界面当我们创建好我们的项目的时候，IDE已经为我们构建了一些文件，并且可以看到一个简单的页面工程中文件介绍app.js : 小程序的脚本代码监听并处理小程序的生命周期函数声明全局变量调用小程序框架提供的丰富的APIapp.json: 小程序的全局配置文件配置小程序主界面由多少个页面组成配置小程序整体风格note:此文件不能有任何注释,我为了方便大家理解在下面加注释{\r\n  \"pages\":[\r\n    \"pages/index/index\",\r\n    \"pages/logs/logs\"\r\n  ], //两个页面 index 和 logs，大家可以删掉pages/index/index来看下项目的运行情况\r\n  \"window\":{\r\n    \"backgroundTextStyle\":\"light\", //文本颜色\r\n    \"navigationBarBackgroundColor\": \"#fff\",//导航栏颜色\r\n    \"navigationBarTitleText\": \"WeChat\",//项目名称\r\n    \"navigationBarTextStyle\":\"black\"//导航栏文本颜色\r\n  }\r\n}\r\napp.wxss: 整个小程序的公共样式表,相当于前端编程中的 base.csspages： 该项目的页面目录，如果你的项目有多少个页面，你就可以在里面创建多少个文件夹,并且在 app.json 里面配置indexindex.js : 页面脚本代码，处理该页面的响应事件index.wxml : 页面，相当于 html,这个里面只能使用小程序提供的内置标签，关于小程序内置标签将在后面介绍index.wxss : 页面样式，相当于 css，和 css写法没什么区别logslogs.jslogs.json : 该页面的配置文件，如果你想要这个页面有单独的呈现效果，可以在该页面进行样式配置，它的优先级高于app.jsonlogs.wxmllogs.wxss可以建很多个note:一个页面必须要有 .js .wxml .wxss 三个文件，如果你这个界面对于全局有不一样特点，我们可以创建一个.json 文件来进行配置utils : 工具库，用于处理某些需求，如 formatTime：格式化输出时间"}
{"title": "Vincent：微信小程序实战教程《二》全局配置之app.json ", "author": "天下雪", "pub_time": "2016-11-3 12:04", "article_content": "当我们使用开发工具创建好我们的工程时候，给到我们的app.json 文件并不是很完整，我们可以配置更多的参数，来让我们的小程序更加的强大包含所有配置项的 app.json{\r\n  \"pages\": [\r\n    \"pages/index/index\",\r\n    \"pages/logs/logs\"\r\n  ],\r\n  \"window\": {\r\n    \"navigationBarBackgroundColor\": \"#ffffff\",\r\n    \"navigationBarTextStyle\": \"black\",\r\n    \"navigationBarTitleText\": \"小程序app.json文件\",\r\n    \"backgroundColor\": \"#eeeeee\",\r\n    \"backgroundTextStyle\": \"light\"\r\n  },\r\n  \"tabBar\": {\r\n    \"color\": \"#353535\",\r\n    \"selectedColor\": \"#3cc51f\",\r\n    \"borderStyle\": \"white\",\r\n    \"backgroundColor\": \"#ffffff\",\r\n    \"list\": [{\r\n      \"pagePath\": \"pages/index/index\",\r\n      \"iconPath\": \"images/icon_API.png\",\r\n      \"selectedIconPath\": \"images/icon_API_HL.png\",\r\n      \"text\": \"首页\"\r\n    }, {\r\n      \"pagePath\": \"pages/logs/logs\",\r\n      \"iconPath\": \"images/icon_component.png\",\r\n      \"selectedIconPath\": \"images/icon_component_HL.png\",\r\n      \"text\": \"日志\"\r\n    }]\r\n  },\r\n  \"networkTimeout\": {\r\n    \"request\": 10000,\r\n    \"downloadFile\": 10000\r\n  },\r\n  \"debug\": true\r\n}\r\n配置项释义pages必填配置，设置页面路径，数组类型window可选配置，设置默认页面的窗口表现，对象类型navigationBarBackgroundColor: 导航栏背景颜色，如”#000000”,十六进制颜色navigationBarTextStyle:导航栏标题颜色，仅支持 black/whitenavigationBarTitleText: 导航栏标题文字内容backgroundColor:窗口的背景色，十六进制颜色backgroundTextStyle:下拉背景字体、loading 图的样式，仅支持 dark/lightenablePullDownRefresh:是否开启下拉刷新，后面讲解tabBar可选配置，如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。color :tab 上的文字默认颜色,必填selectedColor:tab 上的文字选中时的颜色，必填backgroundColor:tab的背景色,必填，十六进制颜色borderStyle:tabbar上边框的颜色， 仅支持 black/white,可选list:tab 的列表，最少2个、最多5个 tab,以下四个参数必填pagePath : 页面路径，必须在 pages 中先定义text: tab 上按钮文字iconPath : 图片路径，icon 大小限制为40kbselectedIconPath :选中时的图片路径，icon 大小限制为40kbnetworkTimeout可选配置，可以设置各种网络请求的超时时间。request: 发起https请求的超时时间，单位毫秒connectSocket: 创建一个 WebSocket 连接的超时时间，单位毫秒uploadFile: 将本地资源上传到开发者服务器的超时时间，单位毫秒downloadFile: 下载文件资源到本地的超时时间，单位毫秒debug可选配置可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有Page的注册，页面路由，数据更新，事件触发 。 可以帮助开发者快速定位一些常见的问题。代码下载：WX1文件夹：wechatpra-master.zip"}
{"title": "Vincent：微信小程序实战教程《三》第一个微信小程序 ", "author": "天下雪", "pub_time": "2016-11-3 12:07", "article_content": "创建我们的工程getApp()var app = getApp()获取到当前小程序实例对象,可用此实例对象访问到全局变量和当前页面实例(后面会讲解)1234console.log(app.getCurrentPage())console.log(app.globalData)Page()函数的介绍Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等data : 页面的初始数据,一个json格式的对象类型，将会用来显示在.wxml上onLoad : 生命周期函数–监听页面加载,一个页面只会调用一次;有iOS编程基础的同学会知道，相当于 viewDidLoadonReady : 生命周期函数–监听页面初次渲染完成,每次打开页面都会调用一次。有iOS编程基础的同学会知道，相当于 viewWillAppearonShow : 生命周期函数–监听页面初次渲染完成,每次打开页面都会调用一次。有iOS编程基础的同学会知道，相当于 viewDidAppearonHide : 生命周期函数–监听页面隐藏,有iOS编程基础的同学会知道，相当于viewWillDisAppear，实质上是当navigateTo或底部tab切换时调用onUnload : 生命周期函数–监听页面卸载,有iOS编程基础的同学会知道，相当于viewDidDisAppear，实质上是当redirectTo或navigateBack的时候调用onPullDownRefresh : 页面相关事件处理函数–监听用户下拉动作（后面会讲解）开发者可以添加任意的函数或数据到 object 参数中，用 this 可以访问（后面会讲解）在index.js中键入如下代码：1234567891011121314151617181920212223242526272829303132333435363738//index.js//获取应用实例var app = getApp()Page({    data: {        name: \"vincent\",        description: \"a developer for html5 and iOS\",        text: \"待我代码编成,娶你为妻可好\",        userInfo:{}    },    //开始加载数据    onLoad: function(options) {        console.log(\"onLoad\")         var that = this        //当我们创建完程序后，在app.js中就有一个getUserInfo方法，我们用app实例调用getUserInfo方法获取当前用户信息，并赋值给userInfo        app.getUserInfo(function(cur_userInfo){            //更新数据            that.setData({                //获取到当前用户信息cur_userInfo赋值给页面变量userInfo                userInfo:cur_userInfo            })        })    },    //开始渲染    onReady: function() {        console.log(\"onReady\")    },        onShow: function() {        console.log(\"onShow\")    },    onHide: function() {        console.log(\"onHide\")    },    onUnload: function() {        console.log(\"onUnload\")    },})在index.wxml中键入如下代码：12345678910<view class=\"container\">  <view  bindtap=\"bindViewTap\" class=\"userinfo\">    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>    <text class=\"userinfo-nickname\">{{name}}</text>    <text class=\"userinfo-nickname\">{{description}}</text>  </view>  <view class=\"usermotto\">    <text class=\"user-motto\">{{text}}</text>  </view></view>###本文代码请查看此目录下面的 wx2 文件夹wechatpra-master.zip"}
{"title": "Vincent：微信小程序实战教程《四》组件学习 ", "author": "天下雪", "pub_time": "2016-11-3 12:33", "article_content": "创建应用程序开始项目选中pages文件夹下的index文件夹下的index.js文件，键入如下代码:1234567891011121314151617181920212223242526272829303132赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              Vincent：微信小程序实战教程《三》第一个微信小程序 \n              前端外行的微信小程序瞎折腾之旅 \n            \n             \n            \n                  原作者: vincentcwlove \n                  来自: 原文地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • Vincent：微信小程序实战教程《一》小程序文件介绍\n                                    \n                  • Vincent：微信小程序实战教程《二》全局配置之app.json\n                                    \n                  • Vincent：微信小程序实战教程《三》第一个微信小程序\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cScBYTqV', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序第三方框架对比 ( wepy / mpvue / ta2019-01-28微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30分享一款拥有历史搜索记录的微信小程序搜索2019-01-28小程序点睛之三：才不是你想的那种组件2019-01-28微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n微信小程序Demo:Canvas图片拖拽生成实现2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo：精美的画板小程序2019-02-21微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：仿 [one] 微信小程序2019-02-18微信小程序Demo：3D旋转效果2019-02-18微信小程序Demo: flappy-bird小游戏2019-02-15微信小程序Demo：群应用（群通知、群接龙、2019-02-15微信小程序Demo：咩咩单词2019-02-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164058|1852b4049798faae4bd534f5b897c0ff|2';"}
{"title": "新手入门选修教程：小程序的框架及逻辑层 ", "author": "天下雪", "pub_time": "2016-11-3 15:34", "article_content": "一：小程序的框架-minaMINAMINA(MINA IS NOT APP) 是在微信中开发小程序的框架。MINA的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生APP体验的服务。MINA提供了自己的视图层描述语言WXML和WXSS，以及基于JavaScript的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。\r\n文件结构框架程序包含一个描述整体程序的 app 和多个描述各自页面的 page。一个框架程序主体部分由三个文件组成，必须放在项目的根目录，如下：文件必填作用app.js是小程序逻辑app.json是小程序公共设置app.wxss否小程序公共样式表一个框架页面由四个文件组成，分别是：文件类型必填作用js是页面逻辑wxml是页面结构wxss否页面样式表json否页面配置\r\n配置我们使用app.json文件来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多\r\n tab 等。以下是一个包含了所有配置选项的简单配置app.json ：{\"pages\": [\"pages/wechat/wechat\",\"pages/note/note\",\"pages/find/find\",\"pages/mine/mine\",\"pages/message/message\",\"pages/audio/audio\",\"pages/info/info\",\"pages/newfriend/newfriend\",\"pages/moments/moments\",\"pages/picker/picker\",\"pages/upload/upload\",\"pages/ws/ws\",\"pages/index/index\",\"pages/logs/logs\"],\"window\":{\"navigationBarBackgroundColor\": \"#000\",\"navigationBarTextStyle\": \"white\",\"navigationBarTitleText\": \"\",\"backgroundColor\": \"#eee\",\"backgroundTextStyle\": \"dark\"},\"tabBar\": {\"backgroundColor\":\"#333\",\"selectedColor\":\"red\",\"list\": [{\"pagePath\": \"pages/wechat/wechat\",\"iconPath\":\"image/wechat.png\",\"selectedIconPath\":\"image/wechat_2.png\",\"text\": \"微信\"}, {\"pagePath\": \"pages/note/note\",\"iconPath\":\"image/note.png\",\"selectedIconPath\":\"image/note_2.png\",\"text\": \"通讯录\"}, {\"pagePath\": \"pages/find/find\",\"iconPath\":\"image/find.png\",\"selectedIconPath\":\"image/find_2.png\",\"text\": \"发现\"}, {\"pagePath\": \"pages/mine/mine\",\"iconPath\":\"image/mine.png\",\"selectedIconPath\":\"image/mine_2.png\",\"text\": \"我\"赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序学习点滴《七》：数据存储 参数传递 数据缓存 \n              微信小程序准备工作：微信开发实战《四》URL、Token认证、java源码、免费新浪SAE部署 ... \n            \n             \n            \n                   \n                  来自: 原文地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSUL4q89', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164060|d4c60c473e9ef75f69c40e0a7c4e3620|2';"}
{"title": "微信小程序准备工作：微信开发实战《四》URL、Token认证、java源码、免费新浪SAE部署 ... ", "author": "天下雪", "pub_time": "2016-11-3 15:38", "article_content": "上篇文章概要介绍了微信公众号开发的原理，偏重于讲解理论。本篇文章通过Java web应用实现微信公众号的URL、Token认证。并部署到免费的新浪SAE服务器上，轻松教你实现公众号成为开发者号。一、URL、Token接口说明URL和Token接口的相关说明的详细内容可以参考接口文档。这里概要说明一下，就三步：1、填写服务器配置    上篇提到我们需要一个公网服务器，介绍使用免费的新浪SAE云服务器。    开发Java web应用并部署，提供URL和Token。填写到微信平台对应的接口配置中。2、验证服务器地址的有效性    主要通过sha1进行加密认证，详见源码。3、依据接口文档实现业务逻辑    认证通过之后，URL就作为开发者服务器与微信服务器之间互动通信的桥梁。在后面一篇文章介绍。二、java web应用提供URL和Tokenwindows环境2.1，软件相关版本：JDK1.7+；链接：http://pan.baidu.com/s/1o7EFjuE密码：kr03Tomcat 7；链接：http://pan.baidu.com/s/1qYTe0mK密码：lg2wSpringMVC4.1 + Freemarker2.3 (目前还没涉及数据库)2.2，开发工具：eclipse链接：http://pan.baidu.com/s/1jH9xDf4密码：i11y2.3，javaweixin下载地址（包括war包和源码）链接：http://pan.baidu.com/s/1cGFNbw密码：eikn2.4，源码结构及说明1，主要技术是spring + freemarker ，目前还未涉及到数据库，但是 lib 包中是包含 mybatis 的jar包，后面文章涉及数据库（mysql）就会用到。2，目前没有使用maven进行项目构建，后期会使用。3，目前只是实现了URL和Token认证功能。参考WxApiController.java文件4，项目导入eclipse，并在tomcat中启动之后，访问http://ip:port/javaweixin，成功显示如下：三、新浪SAE部署访问新浪sae：http://www.sinacloud.com3.1，创建云应用SAE动图如下：3.2，配置二级域名，创建应用，上传war包动图如下：3.3，访问链接访问：http://1.javaweixincoder10.applinzi.com/成功界面如下：四、配置开发者账号4.1，新浪SAE提供的URL和Token：URL（域名换成开发者自己的）：http://1.javaweixincoder10.applinzi.com/wxapi/message.htmlToken（详见WxApiController.java，开发者可以修改）：javaweixinToken4.2，登录公众号测试号将4.1中的URL和Token填写到 接口配置信息 中，点击提交即可！恭喜你，成功了！！！"}
{"title": "前端外行的微信小程序瞎折腾之旅 ", "author": "天下雪", "pub_time": "2016-11-3 15:42", "article_content": "前言惭愧，最近下班回家沉迷山口山了，前一阵子搞antlr语法转换，这一阵子搞微信小程序，一直拖着没写点啥，一步一步来吧，肯定都得总结点东西留给自己看的。新技术尝鲜我一直是一个iOS客户端开发，前端经验只停留在w3cschool上面很基础的最初版本html,css,js学习，纯helloworld水准，就学了不到10分钟。所以这里也算是给客户端开发们打点气，新的东西阻碍的永远是你上手的动力，而不是这个东西的难易。顺带强调自己是前端外行，也是希望各位看官关于内容里如果有很多关于前端理解的偏差，帮我指正和修改。加了一些小程序开发群，发现很多常问的问题是：我想上手小程序，需要先学啥语言，先学习html css js吗？小程序是用js开发吗？那我是不是要去先学js？想上手学小程序，需要什么知识储备吗？我的看法是，我反正从来都不是这样学任何一个新东西的，我就一句话直接开干啊!遇到啥问题再具体查啥问题。这也跟个人接触新东西的习惯有关，反正我是完全不喜欢那种打算学个新东西（注意是’新’东西），然后就问一下有啥经典书籍么？先抱着一本16开，三四厘米厚的一本大厚书，（我习惯叫砖书，很厚很大砸人很疼），看个好几天一个礼拜的，然后还没上手。或者听到个新东西技术是html，然后美名其曰技术储备，俩仨礼拜略微看明白点html，css，但也毫无实战经验，俩仨礼拜，连小程序的边都没摸到。对于’新’东西，等系统化的出书，黄花菜都凉了啊，以前捣鼓RN的时候，无数人问RN有什么好书看，现在RN书停留的版本都是0.2X之前，并且一个个都很浅，现在0.3X已经天翻地覆了，这种啥都等系统化整理文章，做好技术储备，再开始动手，完全不是我的个人学习风格。直接上手是最快的，虽然资料少，但是有源码下，源码是最好的指导方案，没源码，官方文档，Github交流，网上及时阅读最新的碎片化博客文章，这些绝对是最快的学习和了解’新’东西的手段。光读光看是绝对没用的，最有效最有效的手段是，直接上手，上项目，哪怕是仿写一些开放API接口的app（知乎日报，豆瓣电影，有太多开放提供服务器api，让广大客户端开发者练手的）以上只是我的个人学习习惯，因人而异扯淡吐槽xx火了，客户端要完蛋，前端要火小程序会不会灭掉客户端开发明年培训机构大量前端要涌入了小程序也不一定就会火，客户端不可代替当初RN出来就是这样一波风气，小程序出来也是，我对任何这种话题是毫无兴趣！这种然并卵的话题，键盘侠们热火朝天讨论几个小时，时间就过去了，然后就可以happy下班了，有这功夫demo都写出来了，项目都上线了开发环境上面其实也扯了太多的废话，微信小程序其实有自己的IDE开发环境，一切都在这个开发环境里面，下载官方IDE开发包，开始运行，就可以直接开发预览小程序了。但这里有个IDE开发包破解的问题，小程序目前需要是需要邀请码的，有邀请码你就会有属于你业务的微信小程序appId，有邀请码的好处是你可以把小程序部署到真机上，没有邀请码，无论你是否破解了IDE，你都无法真机预览，但是IDE里面的模拟器预览完全没有问题，能运行，能实现绝大部分功能，完全可以项目上先开发起来，等待一旦公测，就直接上线。不破解IDE先说结论：现在的最新版本IDE，完全不需要破解！最新版本的92300的IDE，mac下是一个dmg包，直接安装就能使用选择+号添加项目你能看到创建新项目必须填写AppID在92300版本里面，已经贴心的新增了一个无AppID的按钮，点了后会得到提示无AppID部分功能受限说的很吓人，这部分API很少，就2个，并且IDE提供了模拟数据返回，完全不影响绝大部分开发你就是破解了，不提示部分功能受限，也是该没法正常还照样没法正常工作，毕竟微信也有自己的服务器验证，你破解后填的AppID终归是假的选择工程目录，这时候切记如果你是从0开始创建工程，而不是拥有线程的wx小程序demo代码，一定要在选择工程目录的时候，创建全新文件夹只有全新创建的文件夹才会开启quickstart自动创建初始工程文件功能，(如下图）自动创建好一个helloworld工程quickstart的自动创建工程，是可以无报错直接运行run起来的。但如果文件夹内有文件，IDE就不会创建任何的初始文件的。破解IDE首先，感谢@老郭以迅雷不及掩耳盗铃之神速第一时间破解了微信官方IDE，并且开源提供给大家使用，GitHub weapp-ide crack因为在早期的版本，微信的IDE，没有AppID的人是无法体验的，必须经过破解，才能开始自己写demo进行练手。而老郭在第一时间破解了IDE，让所有人能从代码上第一时间体验这个神秘的小程序（真机就没办法了）后来倒逼微信官方，把小程序IDE直接开放，才有了上面提到的无AppID模式。但是，我使用破解IDE的时候，发现很多人遇到了个问题，按部就班一步一步把IDE破解了，创建新工程的时候，是没有quickstart这一部的，如果什么都不太懂的人做到这一部，一打开工程，一个文件没有直接点运行，直接会报错，什么can not find app.js之类的，context之类的错误，我看到这个后，直接从网上顺手找个demo（就在老郭的git里就有）扔到目录里，就一切运行了。所以目前我的感受就是，破解倒逼了微信官方开放无AppID体验，简直太威武了，但对于经验尚浅的新手，破解的一大堆东西和步骤，很可能会出现一大堆不知道为啥的错误提示的时候，真的不如直接下最新版IDE，不破解直接无AppID体验。开动起来官方文档全在这里 官方文档，里面包含简易教程，框架，组件，API，工具等等官�"}
{"title": "微信小程序第一个公测实战教程：实际注册全流程曝光！ ", "author": "天下雪", "pub_time": "2016-11-3 22:54", "article_content": "一：二：三：四：五：六：七：八："}
{"title": "微信小程序公测接入指南 ", "author": "天下雪", "pub_time": "2016-11-3 23:03", "article_content": "产品定位及功能介绍微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。小程序注册注册小程序帐号在微信公众平台官网首页（mp.weixin.qq.com）点击右上角的“立即注册”按钮。选择注册的帐号类型选择“小程序”，点击“查看类型区别”可查看不同类型帐号的区别和优势。填写邮箱和密码请填写未注册过公众平台、开放平台、企业号、未绑定个人号的邮箱。激活邮箱登录邮箱，查收激活邮件，点击激活链接。填写主体信息点击激活链接后，继续下一步的注册流程。请选择主体类型选择，完善主体信息和管理员信息。选择主体类型主体类型说明如下：帐号主体范围企业企业、分支机构、企业相关品牌。企业（个体工商户）个体工商户。政府国内、各级、各类政府机构、事业单位、具有行政职能的社会组织等。目前主要覆盖公安机构、党团机构、司法机构、交通机构、旅游机构、工商税务机构、市政机构等。媒体报纸、杂志、电视、电台、通讯社、其他等。其他组织不属于政府、媒体、企业或个人的类型。填写主体信息并选择验证方式企业类型帐号可选择两种主体验证方式。 方式一：需要用公司的对公账户向腾讯公司打款来验证主体身份。打款信息在提交主体信息后可以查看到。 方式二：通过微信认证验证主体身份，需支付300元认证费。认证通过前，小程序部分功能暂无法使用。政府、媒体、其他组织类型帐号，必须通过微信认证验证主体身份。认证通过前，小程序部分功能暂无法使用。微信认证入口：登录小程序 - 设置 - 微信认证详情填写管理员信息确认主体信息不可变更点击确认完成注册流程选择对公打款的用户，请根据页面提示，向指定的收款帐号汇入指定金额。 注意：请在10天内完成汇款，否则将注册失败选择通过微信认证验证主体身份的用户，完成注册流程后请尽快进行微信认证，认证完成之前部分功能暂不可使用。小程序信息完善及开发前准备登录小程序管理平台完成注册后，在微信公众平台官网首页（mp.weixin.qq.com）的登录入口直接登录完善小程序信息完成注册后，微信小程序信息完善步骤和开发可同步进行。选择对公打款的用户，完成汇款验证后，可以补充小程序名称信息，上传小程序头像，填写小程序介绍并选择服务范围。选择通过微信认证验证主体身份的用户，需先完成微信认证后，才可以补充小程序名称信息，上传小程序头像，填写小程序介绍并选择服务范围。 提示：如果选择了特殊行业的服务类目，需要提供资质材料提交审核。点击查看所需资质材料开发前准备绑定开发者登录微信公众平台小程序，进入用户身份- 开发者，新增绑定开发者。已认证的小程序可以绑定不多于20个开发者。未认证的小程序可以绑定不多于10个开发者。获取AppID进入“设置-开发设置”，获取AppID信息。阅读开发文档并下载开发者工具点击页面右上角文档-开发，详细阅读开发者文档并进入下载页面，下载开发者工具。开发者工具的使用下载并安装开发者工具登录开发者工具使用管理员或者绑定的开发者微信号扫码登录。创建项目小程序的管理员或已绑定的开发者可以创建项目。需要填写AppID、项目名称及本地开发目录。开发管理员和开发者可在开发者工具内完成小程序的开发、调试、预览、上传代码等操作。预览小程序的管理员或是开发者可点击左侧“项目”，进入上传/预览页面。点击“预览”，开发者可用本人微信扫码，在手机内预览小程序的效果。注意：开发工具上的二维码仅限于登录开发工具的开发者本人可以扫码并预览，其他人无法扫码预览。请用微信客户端iOS或Android的6.3.27及以上版本才可以扫码预览。上传代码小程序的管理员可点击左侧“项目”，进入上传/预览页面，使用管理员本人微信号扫码确认上传。 注意：只有管理员有权限可以上传，开发者没有权限上传。代码上传后可在微信公众平台（mp.weixin.qq.com），开发管理页面中看到对应提交的版本。代码审核与发布提交审核登录微信公众平台小程序，进入开发管理，开发版本中展示已上传的代码，管理员可提交审核或是删除代码。审核信息填写绑定测试帐号（选填）该微信号将提供给微信审核人员审核微信小程序时登录使用，测试微信号需能够体验小程序的全部功能，请勿使用常用微信号扫描。配置功能页面为了用户可以快速搜索出小程序，需要填写重要业务页面的类目与标签。重要业务页面组数不多于5组。完成提交提交审核完成后，开发管理页中审核版本模块展示审核进度。提示：开发者可参考《微信小程序平台常见拒绝情形》，详细了解审核标准。代码发布代码审核通过，需要开发者手动点击发布，小程序才会发布到线上提供服务。注意： 内测期间，代码发布按钮不可点击。小程序申请微信认证政府、媒体、其他组织类型帐号，必须通过微信认证验证主体身份。企业类型帐号，可以根据需要确定是否申请微信认证。已认证帐号可使用微信支付、微信卡券等高级权限。认证入口：登录小程序—设置—基本设置—微信认证—详情小程序申请微信支付已认证的小程序可申请微信支付。小程序绑定微信开放平台帐号小程序绑定微信开放平台帐号后，可与帐号下的其他移动应用、网站应用及公众号打通，通过UnionID机制满足在多个应用和公众号之间统一用户帐号的需求。UnionID机制说明：如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过UnionID来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的unionid是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。用户的UnionID可通过调用“获取用户信息”接口获取。了解“获取用户信息”接口请查看开发文档—API—开放接口—用户信息。绑定小程序流程说明：登录微信开放平台（open.weixin.qq.com）—管理中心—公众帐号—绑定公众帐号注意：微信开放平台帐号必须完成开发者资质认证才可以绑定小程序。"}
{"title": "微信小程序官方注册地址：开放注册范围及接入流程 ", "author": "天下雪", "pub_time": "2016-11-4 01:09", "article_content": "官方注册地址：https://mp.weixin.qq.com/cgi-bin/registermidpage?action=wxopenintro"}
{"title": "注册及注册后必看！微信小程序接入流程，主体验证及名称设置规范 ... ", "author": "天下雪", "pub_time": "2016-11-4 10:38", "article_content": "小程序介绍小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。主要优势1、用户可便捷地获取服务，无需安装或下载即可使用2、具有更丰富的功能和出色的使用体验3、封装一系列接口能力，帮助快速开发和迭代开放注册的范围：企业、政府、媒体及其他组织接入流程：1、注册在微信公众平台注册小程序，完成注册后可以同步进行信息完善和开发。2、小程序信息完善填写小程序基本信息，包括名称、头像、介绍及服务范围等。3、开发小程序完成小程序开发者绑定、开发信息配置后，开发者可下载开发者工具、参考开发文档进行小程序的开发和调试。4、提交审核和发布完成小程序开发后，可以提交代码至微信团队审核，审核通过后即可发布。温馨提示：请开发者注意，公测期间暂不支持发布小程序小程序注册流程选择字号：大 中 小小程序注册访问公众平台官网1、在微信公众平台官网首页（mp.weixin.qq.com）点击右上角的“立即注册”按钮。2、选择注册的帐号类型选择“小程序”，点击“查看类型区别”可查看不同类型帐号的区别和优势。3、填写邮箱和密码请填写未注册过公众平台、开放平台、企业号、未绑定个人号的邮箱。4、激活邮箱登录邮箱，查收激活邮件，点击激活链接。5、填写主体信息点击激活链接后，继续下一步的注册流程。请选择主体类型选择，完善主体信息和管理员信息。选择主体类型主体类型说明如下：帐号主体范围企业企业、分支机构、企业相关品牌。企业（个体工商户）个体工商户。政府国内、各级、各类政府机构、事业单位、具有行政职能的社会组织等。目前主要覆盖公安机构、党团机构、司法机构、交通机构、旅游机构、工商税务机构、市政机构等。媒体报纸、杂志、电视、电台、通讯社、其他等。其他组织不属于政府、媒体、企业或个人的类型。填写主体信息并选择验证方式企业类型帐号可选择两种主体验证方式。方式一：支付验证需要用公司的对公账户向腾讯公司打款来验证主体身份。打款信息在提交主体信息后可以查看到。对公打款请根据页面提示，向指定的收款帐号汇入指定金额。注意：请在10天内完成汇款，否则将注册失败。方式二：微信认证通过微信认证验证主体身份，需支付300元认证费。认证通过前，小程序部分功能暂无法使用。填写管理员信息确认主体信息不可变更小程序注册主体验证方式选择字号：大 中 小企业类型帐号可选择两种主体验证方式。方式一：支付验证需要用公司的对公账户向腾讯公司打款来验证主体身份。打款信息在提交主体信息后可以查看到。选择对公打款的用户，请根据页面提示，向指定的收款帐号汇入指定金额。注意：请在10天内完成汇款，否则将注册失败。方式二：微信认证通过微信认证验证主体身份，需支付300元认证费。认证通过前，小程序部分功能暂无法使用。政府、媒体、其他组织类型帐号，必须通过微信认证验证主体身份。认证通过前，小程序部分功能暂无法使用。微信认证入口：登录小程序 -> 设置 - >微信认证详情温馨提示：选择通过微信认证验证主体身份的用户，完成注册流程后请尽快进行微信认证，认证完成之前部分功能暂不可使用。小程序名称设置规范名称设置1、小程序名称可以由中文、数字、英文和加号组成（加号必须在名称最后）。长度在3-20个字符之间，一个中文字等于2个字符。2、小程序名称不得与公众平台已有的订阅号、服务号重复。如提示重名，请更换名称进行设置。3、小程序名称在帐号信息设置时完成，请谨慎设置，一旦设置暂不支持修改。提示重名怎么办？更换名称进行设置。如果企业商标，组织名称等名称被侵权，可通过公众平台侵权投诉流程发起投诉，取回名称使用权。（参见平台投诉指引请“点击这里”）如果同一主体想要用订阅号或服务号的名称怎么办？确认平台内只有该主体占用该名称时，可对订阅号或服务号名称进行修改，将名称更换给小程序使用。但平台存在大量帐号重名的，如：健康生活，即使对单个订阅号或服务号名称进行了修改，小程序依然会命中名称重复，无法申请使用。名称中含有加号的规则"}
{"title": "nyoj_lvy实战开发系列《一》：发送JSON信息，加密数据解密算法，UnionID机制说明 ... ... ", "author": "天下雪", "pub_time": "2016-11-15 13:18", "article_content": "前期小程序开发只进行到根据微信用户登录获取的code 去微信的API去获取到该用户的openId和session_key，到了第二阶段，老大让我重写OAuthManager的代码来实现微信小程序和微信公众号平台获取用户信息的优化，即将OAuthManager重写成父类抽象类，微信小程序（WechatAppManager）和微信公众号（PublicAccountMananger）来继承并开发，具体方法不赘述。。。在开发微信小程序的时候，由于对于需求的不理解，导致半天都发在获取用户信息的方法上，由于微信小程序没有access_token，所以，用户信息只能从前台发出，后台负责接收并封装JSON格式的用户信息。。。在这里，我要重点阐述我在发送JSON信息时候所遇到的低级错误！！！1.发送JSON格式信息，需要Headers添加Content-Type:application/json后台始终接收不到，就因为少了一个这个headers，接着因为JSON的格式是{    \"code\": \"CODE\",    \"wechatAppUserInfo\": {        \"errMsg\": \"getUserInfo:ok\",        \"rawData\": \"{\\\"nickName\\\":\\\"NICKNAME\\\",\\\"gender\\\":0,\\\"language\\\":\\\"LANGUAGE\\\",\\\"city\\\":\\\"CITY\\\",\\\"province\\\":\\\"PROVINCE\\\",\\\"country\\\":\\\"COUNTRY\\\",\\\"avatarUrl\\\":\\\"AVATARURL\\\"}\",        \"signature\": \"SIGNATURE\",        \"encryptData\": \"ENCRYPTDATA\"    }}请注意好JSON格式，格式错了也是发不过去的，可以上网在线监测自己的JSON格式，后台接收的时候，我出于方便的目的，用dto的形式接收将json数据封装成一个dto，直接接收public String getSessionByCode(@RequestBody WechatAppUser wechatAppUser, HttpServletRequest request)WechatAppUser里只有两个属性（code , wechatAppUserInfo(wechatAppUserInfo)是一个封装类） 我将rawData和encryptData也进行了封装。。。经过一系列的封装，反序列化之后，我们需要将encryptData数据进行解密，这个解密的过程让我心焦。。。 整了两天才发现原来是自己的数据出问题。。。 加密数据解密算法接口如果涉及敏感数据（如wx.getUserInfo当中的 openid ），接口的明文内容将不包含敏感数据。开发者如需要获取敏感数据，需要对接口返回的加密数据( encryptData )进行对称解密。 解密算法如下：1.对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。\r\n2.对称解密的目标密文为 Base64_Decode(encryptData),\r\n3.对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节\r\n4.对称解密算法初始向量 iv = aeskey, 同样是16字节 \r\n上网各种百度该解密算法，让我在千万条链接中找到了它 http://blog.csdn.net/aflight/article/details/13626385 这个链接的key和iv是自动生成的，需要自己手动修改代码（iv的生成需要传入session_key转化的byte[]）//生成iv    public static AlgorithmParameters generateIV(byte [] iv) throws Exception{        //iv 为一个 16 字节的数组，这里采用和 iOS 端一样的构造方法，数据全为0        AlgorithmParameters params = AlgorithmParameters.getInstance(KEY_ALGORITHM);        params.init(new IvParameterSpec(iv));        return params;    }    //转化成JAVA的密钥格式    public static Key convertToKey(byte[] keyBytes) throws Exception{        SecretKey secretKey = new SecretKeySpec(keyBytes,KEY_ALGORITHM);        return secretKey;    }解密的代码byte[] data = WechatAppDecryptor.decrypt(wechatAppUser.getWechatAppUserInfo().getEncryptData(),                oAuthResult.getSession_key());            logger.debug(\"解密得到的数据 : \" + new String(data,\"UTF-8\"));            wechatAppUser.getWechatAppUserInfo().setEncryptDatas(CacheUtil.doJacksonDeserialize(new String(data,\"UTF-8\"),EncryptData.class));灰常好，这里我们就可以得到微信用户的基本信息以及最重要的unionId UnionID机制说明：如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的unionid是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。简而言之就是根据这个字段，用户在数据库中只会存在一条数据！！！encryptData 解密后为以下 json 结构{    \"openId\": \"OPENID\",    \"nickName\": \"NICKNAME\",    \"gender\": 1,    \"city\": \"CITY\",    \"province\": \"PROVINCE\",    \"country\": \"COUNTRY\",    \"avatarUrl\": \"AVATARURL\",    \"unionId\": \"UNIONID\"}"}
{"title": "入门知识：微信小程序中的wxss和css的部分区别 ", "author": "天下雪", "pub_time": "2016-11-16 23:34", "article_content": "集成微信提供 的weui进微信小程序wxss 最开始将weui.css 全部复制进入app.wxss里面，发现跑不起来。搜索了下，常见原因有如下几点：wxss和css的部分区别：不支持:first-child这类写法，不支持:active不支持:checked不支持自定义字体@font-face {font-weight: normal;font-style: normal;font-family: \"weui\";.a>.b.a~.b没有body,html这些鬼dom不支持keyframe动画不支持   [class^=\"icon-\"] :before :after 改成  ::before  ::aftera p span h1 h6等这些标记可以改成相应的view text等img   ->   imageinput ->     加上结束标记checkbox   改成     radio image 等类似，严谨的均要有结束标记text内部只能有text标记"}
{"title": "jsongo0：微信小程序发布流程详解（附Https（干货）） ", "author": "天下雪", "pub_time": "2016-11-19 01:17", "article_content": "作者：jsongo公众号：半圆生活由于之前没有内测资格，很多人学习小程序的开发，大都用的破解版，可以解决网络请求等问题。不过要发布，就需要申请真正的小程序账号，拿到appId，才能在手机预览、及提交审核。下面我们一起来看下小程序的预览和发布流程。本文假设读者已经申请到了小程序的账号，拿到了appId，并且也开发完了要上线的应用。 一、事前准备：Https（干货）首先要说明的一点是，正式上线后的网络请求的域名只能是申请时填写的域名，而且必须是https的。一看到https估计很多开发者就苦脑了：这玩意没这么容易搞到。不过我们有办法，我们有https://letsencrypt.org/，完全免费可用的https，用go语言开发的，github地址：https://github.com/certbot/certbot。用它来生成证书，导入到nginx里就可以用了。github里有它的使用方式，可能对于大部分读者来说，还是太复杂，为了方便大家使用，我把它打包成docker镜像了，通过：sudo docker pull jsongo/certbot:latest可以把镜像拉取下来，然后运行：sudo docker run -it --rm -v /data/www:/data/www -v /etc/letsencrypt:/etc/letsencrypt jsongo/certbot certonly --webroot -w /data/www -d <yourdomain>.com注意，把上面的<yourdomain>换成你的域名，/data/www都换成你的root路径就可以了。非常简单，用docker一步就可以搞定一个https证书。（如果读者没接触过docker，可以到网上搜索下如何安装到相应的linux系统上，然后再执行pull操作及上面生成证书的操作）接下去把上面生成的证书导入nginx，方法也很简单，在相应的配置文件里加上：listen 443 ssl;\r\n\r\nssl_certificate /etc/letsencrypt/live/<yourdomain>.com/cert.pem;\r\n\r\nssl_certificate_key /etc/letsencrypt/live/<yourdomain>.com/privkey.pem;另外，用这个方法生成的https证书，也可以用在自己的网站上，让自己的网站更安全一些，关键是还不用钱。证书在大部分主流的浏览器上都测过没问题，至少比国内的大部分证书靠谱（国内的不少https证书都被谷歌等公司的浏览器封锁了）。加上这三个代码就ok了，重启nginx生效。（这是作者本人探索的方法，有什么法律问题作者概不负责。不过letsencrypt声称是开源的，大胆用） 二、预览及调试1、预览开发者开发完一个应用时，为了查看有没有问题，或想看看真实的体验怎么样，都会选择在手机上先预览一下再发布。如图，选择项目，再点击预览。如果你的appId没问题的话，这里就会先帮你打包上传代码，打包完之后的代码非常小，我们本例中的demo，只有20k左右。上传完之后，会弹出一个二维码。只能用登录这个开发工具的账号扫描才可能预览。而且25分钟过期。前几次扫描，由于要加载一些资源文件，所以会出现一个界面：然后进入主页面，长这个样子：看起来跟网页H5应用差别不大，主要还是在体验上（反应速度、流畅度等等）2、调试右上角“…”弹出来的菜单：大家可能会注意到，它可以直接在手机上调试，点击“打开调试”可以先看下它的效果，会有一个提示：需要你重新扫码进入。接着会有右下角显示一个按钮：点击它就可以进入控制台，如下：有两个主要的tab，一个记录程序打出来的普通日志，包含Info、Warn、Error等；另一个是系统的信息：这里主要是查看系统及网络相关的一些信息开发者在调试的时候，打出来的日志可以在第一个tab上查看，之所以需要这个控制台，可能还是因为小程序不支持alert，调试时不方便看数据。 三、发布1、上传开发完之后，确认没问题，就可以点击上图中的“上传”按钮，上传到微信后台，这里也只有管理员和开发者才能进行操作。可以看到上传的编译包大小其实是很小的，只有24k，这里主要是没有本地图片的原因，有图片的话会大些。 2、提交前准备登录微信小程序的后台，如图：上传完之后，下一步就是提交审核。不过在这之前，需要我们做几个操作：（1）补充小程序的基本信息，如名称、图标、描述等（2）如果发布者不是管理员，则必须要在这里添加开发者，进行代码上传和发布（3）配置服务器域名，如果你的小程序用到了网络请求，那么这里要先在“设置”-“开发设置”里添加域名。（4）提交审核小程序的基础信息，如名称、图标等是这个账号全局的信息。logo图标一个月内可申请修改5次。而名称一旦设置，就不能再修改了，而且不得与公众平台已有的订阅号、服务号重复，这里有详细说明。如果开发者本人就是管理员，则上面的第（2）步可以忽略，因为管理员“自动拥有开发者的所有权限，无需重复绑定”。一个邮箱账号只能申请一个小程序，如果想开发多个小程序怎么办？平台这里有说明：除个体工商户类型可认证5个小程序外，其他类型一个主体可认证50个小程序。也就是说，如果你是企业主体，你可以弄50个邮箱，申请50个账号，开发50个小程序，而且每个都必须认证才能发布。所以设置名称要谨慎，一旦设置了一个，你就少了一次机会。另外，对于服务器域名，再次强调一下，一定要配置https，否则你是没办法用api进行网络数据请求的。 3、提交审核前面的准备工作做完后，点击左侧的“开发管理”菜单，就可以看到之前我们上传的包：点击提交审核，弹出二维码：扫码通过之后，进入补充审核信息的页面：这里可以绑定测试微信号，这个号最好是用户不常用的账号，因为微信的审核人员要登录你的这个账号进行审核。当然不提供这个测试账号也没事，这个功能感觉有点鸡肋。下方区域要配置添加功能页面：这些功能页面，主要是为了方便用户快速搜索到你的应用。可以添加多个功能页面，增加被搜索到的概率。填写完之后，提交审核。上图，提交后会显示“审核中”，大概两三个工作日会通过（这是作者的小程序审核的时间，这个时间不一定，看具体情况）。右边有个“详情”链接，点击可查看版本详情：最后通过审核时，就可以看到如下界面：这里的“提交发布”按钮还不能点，微信还没有开放上线的操作，所以目前也只能到这一步。等微信放开的时候，再提交发布就可以了。"}
{"title": "花了一晚上将博客上了 https ，还是蛮简单的 ", "author": "天下雪", "pub_time": "2016-11-14 10:47", "article_content": "作者：wensonsmith；本文选择v2ex，是作者为了微信小程序而对自己的博客做的https的过程，其中包含大量有用地址；推荐阅读；由于微信小程序要求接口使用 https, 以后会用到，所以先拿自己的博客练一练手。用的是 let's encrypt 免费证书，环境是 CentOS+ Nginx , 使用 certbot 安装证书。步骤是：确保自己的域名解析全部是 A 记录使用 certbot 安装证书使用 crontab 自动 renew 证书配置 NGINX ,ssl server将 http 跳转到 https , 将 WWW 跳转到 NON-WWW现在域名前面跟一个绿色的 https ,看着倍爽呀 https://seekbetter.me 1 条附言  ·  5 天前经过又一晚的折腾（滑稽脸）， 我也变成优等生啦 ！十分感谢 @mikeshinoda 的 SSL 配置生成器，好评！F到A+一步到位！就此总结一下评论里面比较好用的工具：###1. 工具类@dynaguy ,SSL 测试工具 ： https://www.ssllabs.com/ssltest/index.html@zqcolor ,acme-tiny证书安装工具： https://github.com/diafygi/acme-tiny@Technetiumer , 阿里云有免费的 Symantec: https://common-buy.aliyun.com/?commodityCode=cas#/buy@justyy ,一条龙服务cloudflare： https://www.cloudflare.com/@mikeshinoda ,牛逼的SSL配置生成器：https://mozilla.github.io/server-side-tls/ssl-config-generator/###2. 参考资料@yizhilee ,https://blog.yizhilee.com/post/letsencrypt-certificate/@ylsc633 ,https://www.iphpt.com/detail/42@youyoulemon ,https://imququ.com/post/my-nginx-conf.html###3. 感谢感谢 @anjunecha , @uncleroot, 两位大神给出的建议！最后 @sadscv , 我觉的看这些资料应该够了，我的步骤和记录不一定适合你。 看下面那么多评论说我还得用一晚上才能搞定的，你应该能感受到这确实不难。 安装证书看let' encrypt 官方说明， 配置 nginx用ssl配置生成器。 很简单！"}
{"title": "蓝狐锅锅：微信小程序实用教程系列《一》数组操作 ", "author": "天下雪", "pub_time": "2016-11-14 11:47", "article_content": "前言\r\n相信在小程序推出公测之后，很多小伙伴都已经抓紧申请注册小程序了。在开发阶段中也碰到了很多的问题，例如wx.request数据请求不成功，在数组操作时，不知道如何往数组里push数据，input如何监听用户输入的状态，css的background-image无法获取本地资源等等，本博客会出一个专题，给碰到这些问题的小伙伴解决思路。\r\n数组操作\r\n今天我们主要讲的是，数组操作。相信对于用过vuejs、reactjs等mvvm框架的童鞋，微信小程序的数组操作就显得很简单啦，原理是一样的。\r\n''\r\n\r\n''\r\n\r\n这是简单做的一个demo，已经上传到github，到时大伙可以直接下载。我们主要讲在数组中常用的一些操作方法，对数组向前向后插入新的数据、修改数组、删除数组、清空数组，其他的一些操作方式，我会给大伙学习思路。\r\ndemo数组操作的例子路径：/pages/array/array.wxml\r\n向前向后插入新的数据Page({\r\n  data: {\r\n     list:[{\r\n        id:1,\r\n        name:'应季鲜果',\r\n        count:1\r\n     },{\r\n        id:2,\r\n        name:'精致糕点',\r\n        count:6\r\n     },{\r\n        id:3,\r\n        name:'全球美食烘培原料',\r\n        count:12\r\n     },{\r\n        id:4,\r\n        name:'无辣不欢生猛海鲜',\r\n        count:5\r\n     }]\r\n  }\r\n})\r\n我们初始化一些数据，我们需要对list的添加新的数据里，需要用到JavaScript concat()的方法，concat() 方法用于连接两个或多个数组，该方法不会改变现有的数组。 其实我们的所说的向前向后插入数据，其实也就是把两个数组合拼起来，组成一个新的数组，然后再使用this.setData()即可渲染到页面上。 我们看一下在微信小程序里的代码。向前插入数据demo //向前增加数据\r\n  add_before:function (){\r\n\r\n\r\n//要增加的数组\r\nvar newarray = [{\r\n    id:6,\r\n    name:'向前增加数据--'+new Date().getTime() ,\r\n\r\n    count:89\r\n}];\r\n\r\n//使用concat()来把两个数组合拼起来\r\nthis.data.list = newarray.concat(this.data.list);\r\n\r\n//将合拼之后的数据，发送到视图层，即渲染页面\r\n//大伙请记录，修改了数据后，一定要再次执行`this.setData()`，页面才会渲染数据的。\r\nthis.setData({\r\n    'list': this.data.list\r\n });\r\n\r\n\r\n  }向后插入数据demo  //向后增加数据\r\n  add_after:function (){\r\n\r\n    //要增加的数组\r\n    var newarray = [{\r\n            id:5,\r\n            name:'向后增加数据--'+new Date().getTime() ,\r\n            count:89\r\n    }];\r\n\r\n\r\n    this.setData({\r\n        'list':this.data.list.concat(newarray)\r\n    });\r\n\r\n\r\n  },细心的小伙伴应该会发现，这两段在用concat()合拼数据时，concat括号里的数据是不一样的。向前向后插入数据的区别就在这里了。//假设这一段是我们要新增的数组\r\nvar newarray = [{\r\n        id:5,\r\n        name:'向后增加数据--'+new Date().getTime() ,\r\n        count:89\r\n}];\r\n\r\n//向前--用newarray与this.data.list合拼\r\nthis.data.list = newarray.concat(this.data.list);\r\n\r\n//向后--用this.data.list与newarray合拼\r\nthis.data.list = this.data.list.concat(newarray);\r\n修改数组对展示的数据进行修改，在开发过程是常见得不在常见的事情啦。  //修改数组\r\n  edit:function (e){\r\n\r\n//这个参数“e”的具体作用，请参考微信小程序官方提供的说明，地址为https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html?t=20161107\r\n\r\nvar dataset = e.target.dataset;\r\nvar Index = dataset.index; //在通过在wxml页面里使用 data-index=\"{{index}}\"传递过来的，是为识别正在编辑修改哪个数组。\r\n\r\n//我们要修改的数组\r\nthis.data.list[Index].name = '修改了内容'+new Date().getTime();\r\n\r\n//将合拼之后的数据，发送到视图层，即渲染页面\r\n//大伙请记录，修改了数据后，一定要再次执行`this.setData()`，页面才会渲染数据的。\r\nthis.setData({\r\n    list:this.data.list\r\n});\r\n\r\n\r\n\r\n  }删除某条数据有增有改也必有删。 删除需要用到JavaScript splice()方式，splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。//删除\r\n  remove:function (e){\r\n\r\n    var dataset = e.target.dataset;\r\n    var Index = dataset.index;\r\n\r\n    //通过`index`识别要删除第几条数据，第二个数据为要删除的项目数量，通常为1\r\n    this.data.list.splice(Index,1);\r\n\r\n    //渲染数据\r\n    this.setData({\r\n        list:this.data.list\r\n    });\r\n\r\n\r\n  }\r\n清空数据增修删之后，还得再来一个清空数据呀。//清空\r\n  clear:function (){\r\n\r\n    //其实就是让数组变成一个空数组即可\r\n    this.setData({\r\n        list:{}\r\n    });\r\n\r\n  } 总结\r\n今天我们主要讲了增修删清空，其实对数组的操作还有很多方式的，可以看以下截图。\r\n\r\n''\r\n\r\n具体的每一个的操作方法，可以去国内的w3s多学习下。http://www.w3school.com.cn/jsref/jsref_splice.asp\r\ndemo地址：https://github.com/bluefox1688/wxapp_studydemo下载：wxapp_study-master.zip"}
{"title": "微信小程序学习摘要系列《一》目录结构，配置 ", "author": "天下雪", "pub_time": "2016-11-14 12:33", "article_content": "分享者：helloconch一：目录结构MINA程序包含一个描述整体程序的app和多个描述各自页面的page一个MINA程序主体部分由三个文件组成，必须放在项目根目录下app.js      必须项  小程序逻辑\r\napp.json    必须项  小程序公共设置\r\napp.wxss    可选项  小程序公共样式表\r\n一个MINA页面由四个文件组成，分别是wxml        必须项    页面结构\r\nwxss        可选项    页面样式表\r\njson        可选项    页面配置\r\njs          必须项    页面逻辑\r\n\r\n为了方便开发者少配置项，规定描述页面的四个文件必须具有 相同的路径与文件名。二：配置app.json文件对微信小程序进行全局配置，决定页面文件的路径，窗口表现，设置网络超时时间，设置多个tab等。{\r\n  \"pages\": [\r\n    \"page/index/index\",\r\n    \"page/logs/index\"\r\n  ],\r\n  \"window\": {\r\n    \"navigationBarTitleText\": \"Demo\"\r\n  },\r\n  \"tabBar\": {\r\n    \"list\": [{\r\n      \"pagePath\": \"page/index/index\",\r\n      \"text\": \"首页\"\r\n    }, {\r\n      \"pagePath\": \"page/logs/logs\",\r\n      \"text\": \"日志\"\r\n    }]\r\n  },\r\n  \"networkTimeout\": {\r\n    \"request\": 10000,\r\n    \"downloadFile\": 10000\r\n  },\r\n  \"debug\": true\r\n}\r\napp.json配置项列表pages       StringArray     必选项   设置页面路径\r\n\r\nwindow      Object          可选项   设置默认页面的窗口\r\n\r\ntabBar      Object          可选项   设置底部tab的表现\r\n\r\nnetworkTimeout  Object      可选项   设置网络超时时间\r\n\r\ndebug        Boolean        可选项   设置是否开启debug模式\r\npages接受一个字符串数组，来指定小程序由那些页面组成，每一项代表页面的信息，数组的第一项代表小程序的初始页面。\r\n小程序新增、减少页面，都需要对pages数组进行修改。\r\nwindow 用于设置小程序的状态栏、导航条、标题、窗口背景色navigationBarBackgroundColor  导航背景色 #000000\r\nnavigationBarTextStyle        导航栏标题颜色，仅支持 black/white\r\nnavigationBarTitleText        导航栏标题文字内容\r\nbackgroundColor               窗口的背景色#ffffff\r\nbackgroundTextStyle           下拉背景字体、loading图的样式，仅支持dark/light\r\nenablePullDownRefresh         是否开启下拉刷新false\r\n\r\n页面.json只能设置window相关的配置项，以决定本页面窗口表现，所以无需写window这个关键字。tabBar如果我们小程序是一个多tab应用，那么我们可以通过tabBar配置项指定tab栏的表现，以及tab切换时显示的对应页面。\r\ntabBar是一个数组，只能配置最少2个，最多5个tab，tab按数组的顺序排序。\r\n\r\ncolor              必选项    tab上文字默认颜色\r\nselectedColor      必选项    tab上文字选中时的颜色\r\nbackgroundColor    必选项    tab的背景色\r\nborderStyle        可选项    tab上边框的颜色，仅支持black/white\r\nlist               必选项    tab的列表，详见list属性\r\n\r\n其中list接受一个数组，数组中的每一项都是一个对象，其属性如下:\r\npagePath           必选项    页面路径，必须在pages中先定义\r\ntext               必选项    tab上按钮文字\r\niconPath           必选项    图片路径，icon大小限制为40kb\r\nselectedIconPath   必选项    选中时的图片路径，icon大小限制为40kb\r\nnetworkTimeout设置各种网络请求超时时间\r\n\r\nrequest             可选项   wx.request的超时时间，单位毫秒\r\nconnectSocket       可选项   wx.connectSocket的超时时间，单位毫秒\r\nuploadFile          可选项   wx.uploadFile的超时时间，单位毫秒\r\ndownloadFile        可选项   wx.downloadFile超时时间，单位毫秒\r\ndebug可以在开发者工具中开启debug模式，在开发者工具的控制台面板，调试信息以info的形式给出，其信息有Page的注册，页面路由，数据更新，事件触发 。"}
{"title": "微信小程序学习摘要系列《二》逻辑层 ", "author": "天下雪", "pub_time": "2016-11-14 14:35", "article_content": "逻辑层(App Service)\r\n\r\nMINA的逻辑层是由JavaScript编写。\r\n\r\n逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。\r\n\r\n在JavaScript的基础上，我们做了一些修改，以方便地开发MINA程序。\r\n\r\n增加App和Page方法，进行程序和页面的注册。\r\n提供丰富的API，如扫一扫，支付等微信特有能力。\r\n每个页面有独立的作用域，并提供模块化能力。\r\n由于MINA并非运行在浏览器中，所以JavaScript在web中一些能力都无法使用，如document，window等。\r\n开发者写的所有代码最终将会打包成一份JavaScript，并在小程序启动的时候运行，直到小程序销毁。类似ServiceWorker，所以逻辑层也称之为App Service。\r\n\r\n注册程序App()函数用来注册一个小程序，接受一个Object参数，其指定小程序\r\n生命周期函数等。\r\n\r\nobject参数说明\r\n属性             类型          描述                                 触发时机\r\nonLaunch       Function   生命周期函数-监听小程序初始化       当小程序初始化完成时，全局只触发一次\r\nonShow         Function   生命周期-监听小程序显示            小程序启动或者从后台进入到前台\r\nonHide         Function   生命周期-监听小程序隐藏            小程序从前台进入到后台\r\n其他           Any        可以添加任意的函数或数据到Object参数中，用this可以访问\r\n\r\n前台、后台定义:当用户点击左上角关闭，或者按了设备Home键离开微信，\r\n小程序并没有正在销毁，而是进入了后台，当再次启动微信或再次打开小程序，又会从后台进入前台。\r\n\r\n只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正销毁。\r\n\r\n示例代码：\r\n\r\nApp({\r\n  onLaunch: function() { \r\n    // Do something initial when launch.\r\n  },\r\n  onShow: function() {\r\n      // Do something when show.\r\n  },\r\n  onHide: function() {\r\n      // Do something when hide.\r\n  },\r\n  globalData: 'I am global data'\r\n})\r\n\r\n\r\nApp.prototype.getCurrentPage()获取当前页面实例\r\n\r\ngetApp()获取小程序实例\r\n\r\n注意:App()必须在app.js中注册，且不能注册多个。\r\n不要在定义App（）内的函数中调用getApp()，使用this\r\n不要在onLaunch的时候调用getCurrentPage()，此时page还没有生成\r\n通过getApp获取实例之后，不要私自调用生命周期的函数。\r\n\r\n注册页面page()函数用来注册一个页面，接受一个object参数，其指定页面初始数据，生命周期函数，事件处理函数等。\r\n\r\nobject参数说明:\r\n\r\n属性                                      类型                             描述\r\n\r\ndata                                      Object                           页面的初始数据\r\n\r\nonLoad                                    Function                         生命周期函数-监听页面加载\r\n\r\nonReady                                   Function                         生命周期函数-监听页面渲染完成\r\n\r\nonShow                                    Function                         生命周期函数-监听页面显示\r\n\r\nonHide                                    Function                          生命周期函数-监听页面隐藏\r\n\r\nonUnload                                  Function                          生命周期函数-监听页面卸载\r\n\r\n其他                                      Any        可以添加任意的函数或数据到Object参数中，用this可以访问\r\n\r\n\r\n示例代码：\r\n//index.js\r\nPage({\r\n  data: {\r\n    text: \"This is page data.\"\r\n  },\r\n  onLoad: function(options) {\r\n    // Do some initialize when page load.\r\n  },\r\n  onReady: function() {\r\n    // Do something when page ready.\r\n  },\r\n  onShow: function() {\r\n    // Do something when page show.\r\n  },\r\n  onHide: function() {\r\n    // Do something when page hide.\r\n  },\r\n  onUnload: function() {\r\n    // Do something when page close.\r\n  },\r\n  // Event handler.\r\n  viewTap: function() {\r\n    this.setData({\r\n      text: 'Set some data for updating view.'\r\n    })\r\n  }\r\n})\r\n\r\n\r\n初始化数据\r\n\r\n初始化数据将作为页面的第一次渲染。data将会以JSON的形式由逻辑层传至渲染层，所以其数据必须是可以转成JSON的格式：字符串，数字，布尔值，对象，数组。\r\n\r\n渲染层可以通过WXML对数据进行绑定。\r\n\r\n示例代码：\r\n\r\n<view>{{text}}</view>\r\n<view>{{array[0].msg}}</view>\r\nPage({\r\n  data: {\r\n    text: 'init data',\r\n    array: [{msg: '1'}, {msg: '2'}]\r\n  }\r\n})\r\n\r\n\r\n事件处理函数\r\n    除了初始化数据和生命周期函数，Page中还可以定义一些特殊的函数：事件处理函数，在渲染层可以在组件中加入事件绑定，\r\n    当达到触发事件时，就会执行Page中定义的事件处理函数。\r\n示例代码：\r\n    <view bindtap=\"viewTap\">click me</view>\r\n\r\n    page({\r\n\r\n        viewTap:function(){\r\n            console.log('view tap')\r\n        }\r\n\r\n        })\r\n\r\n\r\n page.prototype.setData()\r\n\r\n setData函数用于将数据从逻辑层发送到视图层，同时改变对应的this.data的值。\r\n\r\n 注意：\r\n\r\n1.直接修改this.data无效，无法改变页面的状态，还会造成数据不一致。\r\n2.单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。\r\n\r\n\r\nsetData()参数格式\r\n接受一个对象，以key，value的形式表示将this.data中的key对应的值改变成value。\r\n\r\n其中key可以非常灵活，以数据路径的形式给出，如array[2].message，a.b.c.d，并且不需要在this.data中预先定义。\r\n示例代码：\r\n<!--index.wxml-->\r\n<view>{{text}}</view>\r\n<button bindtap=\"changeText\"> Change normal data </button>\r\n<view>{{array[0].text}}</view>\r\n<button bindtap=\"changeItemInArray\"> Change Array data </button>\r\n<view>{{obj.text}}</view>\r\n<button bindtap=\"changeItemInObject\"> Change Object data </button>\r\n<view>{{newField.text}}</view>\r\n<button bindtap=\"addNewField\"> Add new data </button>\r\n//index.js\r\nPage({\r\n  data: {\r\n    text: 'init data',\r\n    array: [{text: 'init data'}],\r\n    object: {\r\n      text: 'init data'\r\n    }\r\n  },\r\n  changeText: function() {\r\n    // this.data.text = 'changed data'  // bad, it can not work\r\n    this.setData({\r\n      text: 'changed data'\r\n    })\r\n  },\r\n  changeItemInArray: function() {\r\n    // you can use this way to modify a danamic data path\r\n    var changedData = {}\r\n    var index = 0\r\n    changedData['array[' + index + '].text'] = 'changed data'\r\n    this.setData(changedData)\r\n  },\r\n  changeItemInObject: function(){\r\n    this.setData({\r\n      'object.text': 'changed data'\r\n    });\r\n  },\r\n  addNewField: function() {\r\n    this.setData({\r\n      'newField.text': 'new data'\r\n    })\r\n  }\r\n})\r\n\r\n\r\n\r\n页面路由\r\n在小程序中所有页面的路由全部由MINA进行管理，对于路由的触发方式以及页面生命周期函数如下：\r\n\r\n路由方式                    触发时机                                    路由后页面                       路由前页面\r\n初始化                      小程序打开的第一个页面                        onLoad，onShow \r\n打开新页面               调用APIwx.nativateTo或使用组件Natigator        onLoad，onShow                    onHide\r\n页面重定向               调用APIwx.redirectTo或使用组件Natigator        onLoad，onShow                    onUnload\r\n页面返回                 调用APIwx.navigatBack或用户按左上角返回按钮   onShow                             onUnload\r\nTab切换                    多Tab模式下用户切换Tab         第一次打开onLoad，onshow；否则onShow               onHide\r\n\r\n\r\n模块化文件作用域\r\n\r\n在JavaScript文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。\r\n\r\n通过全局函数getApp()可以获取全局的应用实例，如果需要全局的数据可以在App()中设置，如：\r\n\r\n// app.js\r\nApp({\r\n  globalData: 1\r\n})\r\n// a.js\r\n// The localValue can only be used in file a.js.\r\nvar localValue = 'a'\r\n// Get the app instance.\r\nvar app = getApp()\r\n// Get the global data and change it.\r\napp.globalData++\r\n// b.js\r\n// You can redefine localValue in file b.js, without interference with the localValue in a.js.\r\nvar localValue = 'b'\r\n// If a.js it run before b.js, now the globalData shoule be 2.\r\nconsole.log(getApp().globalData)\r\n\r\n\r\n\r\n模块化\r\n\r\n我们可以将一些公共的代码抽离成为一个单独的js文件，作为一个模块。模块只有通过module.exports才能对外暴露接口。\r\n\r\n// common.js\r\nfunction sayHello(name) {\r\n  console.log('Hello ' + name + '!')\r\n}\r\nmodule.exports = {\r\n  sayHello: sayHello\r\n}\r\n​在需要使用这些模块的文件中，使用require(path)将公共代码引入。\r\n\r\nvar common = require('common.js')\r\nPage({\r\n  helloMINA: function() {\r\n    common.sayHello('MINA')\r\n  }\r\n})"}
{"title": "微信小程序学习摘要系列《三》视图层 ", "author": "天下雪", "pub_time": "2016-11-14 14:36", "article_content": "MINA的视图层由WXML与WXSS编写。\r\n\r\n将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。\r\n\r\nWXML(WeiXin Markup language)用于描述页面的结构。\r\n\r\nWXSS(WeiXin Style Sheet)用于描述页面的样式。\r\n\r\n组件(Component)是视图的基本组成单元。\r\n\r\nWXML-数据绑定WXML中动态数据均来自对应Page的data\r\n\r\n简单绑定\r\n数据绑定使用\"Mustache\"语法（双大括号）将变量包起来，可以作用于：\r\n\r\n内容\r\n<view> {{ message }} </view>\r\nPage({\r\n  data: {\r\n    message: 'Hello MINA!'\r\n  }\r\n})\r\n\r\n\r\n组件属性(需要在双引号之内)\r\n<view id=\"item-{{id}}\"> </view>\r\nPage({\r\n  data: {\r\n    id: 0\r\n  }\r\n})\r\n\r\n控制属性(需要在双引号之内)\r\n<view wx:if=\"{{condition}}\"> </view>\r\nPage({\r\n  data: {\r\n    condition: true\r\n  }\r\n})\r\n\r\n\r\n运算\r\n可以在{{}}内进行简单的运算，支持的有如下几种方式：\r\n\r\n三元运算\r\n<view hidden=\"{{flag ? true : false}}\"> Hidden </view>\r\n\r\n\r\n算数运算\r\n<view> {{a + b}} + {{c}} + d </view>\r\nPage({\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n    c: 3\r\n  }\r\n})\r\nview中的内容为3 + 3 + d\r\n\r\n\r\n逻辑判断\r\n<view wx:if=\"{{length > 5}}\"> </view>\r\n字符串运算\r\n<view>{{\"hello\" + name}}</view>\r\nPage({\r\n  data:{\r\n    name:\"MINA\"\r\n  }\r\n})\r\n\r\n\r\n组合\r\n也可以在Mustache内直接进行组合，构成新的对象或者数组\r\n\r\n数组\r\n<view wx:for-items=\"{{[zero, 1, 2, 3, 4]}}\"> {{item}} </view>\r\nPage({\r\n  data: {\r\n    zero: 0\r\n  }\r\n})\r\n最终组合成数组[0, 1, 2, 3, 4]\r\n\r\n\r\n对象\r\n<template is=\"objectCombine\" data=\"{{for: a, bar: b}}\"></template>\r\nPage({\r\n  data: {\r\n    a: 1,\r\n    b: 2\r\n  }\r\n})\r\n\r\n最终组合成的对象是{for: 1, bar: 2}\r\n\r\nWXML-条件渲染\r\nwx:if\r\n在MINA中，我们用wx:if=\"{{condition}}\"来判断是否需要渲染该代码块：\r\n\r\n<view wx:if=\"{{condition}}\"> True </view>\r\n也可以用wx:elif和wx:else来添加一个else块：\r\n\r\n<view wx:if=\"{{length > 5}}\"> 1 </view>\r\n<view wx:elif=\"{{length > 2}}\"> 2 </view>\r\n<view wx:else> 3 </view>\r\nblock wx:if\r\n因为wx:if 是一个控制属性，需要将它添加到一个标签上。但是如果我们想一次性判断多个组件标签，我们可以使用一个<block/>标签将多个组件包装起来，并在上边使用wx:if控制属性。\r\n\r\n<block wx:if=\"{{true}}\">\r\n  <view> view1 </view>\r\n  <view> view2 </view>\r\n</block>\r\n注意： <block/>并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。\r\n\r\nwx:if vs hidden\r\n因为wx:if之中的模板也可能包含数据绑定，所有当wx:if的条件值切换时，MINA有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。\r\n\r\n同时wx:if也是惰性的，如果在初始渲染条件为false，MINA什么也不做，在条件第一次变成真的时候才开始局部渲染。\r\n\r\n相比之下，hidden就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。\r\n\r\n一般来说，wx:if有更高的切换消耗而hidden有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用hidden更好，如果在运行时条件不大可能改变则wx:if较好。\r\n\r\nWXML-列表渲染wx:for\r\n在组件上使用wx:for控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。\r\n\r\n默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item\r\n\r\n<view wx:for=\"{{items}}\">\r\n  {{index}}: {{item.message}}\r\n</view>\r\nPage({\r\n  items: [{\r\n    message: 'foo',\r\n  },{\r\n    message: 'bar'\r\n  }]\r\n})\r\n使用wx:for-item可以指定数组当前元素的变量名\r\n\r\n使用wx:for-index可以指定数组当前下标的变量名：\r\n\r\n<view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">\r\n  {{idx}}: {{itemName.message}}\r\n</view>\r\nwx:for也可以嵌套，下边是一个九九乘法表\r\n\r\n<view wx:for=\"{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}\" wx:for-item=\"i\">\r\n  <view wx:for=\"{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}\" wx:for-item=\"j\">\r\n    <view wx:if=\"{{i <= j}}\">\r\n      {{i}} * {{j}} = {{i * j}}\r\n    </view>\r\n  </view>\r\n</view>\r\nblock wx:for\r\n类似block wx:if，也可以将wx:for用在<block/>标签上，以渲染一个包含多节点的结构块。例如：\r\n\r\n<block wx:for=\"{{[1, 2, 3]}}\">\r\n  <view> {{index}}: </view>\r\n  <view> {{item}} </view>\r\n</block>\r\n\r\nWXML-模板WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。\r\n\r\n定义模板\r\n使用name属性，作为模板的名字。然后在<template/>内定义代码片段，如：\r\n\r\n<!--\r\n  index: int\r\n  msg: string\r\n  time: string\r\n-->\r\n<template name=\"msgItem\">\r\n  <view>\r\n    <text> {{index}}: {{msg}} </text>\r\n    <text> Time: {{time}} </text>\r\n  </view>\r\n</template>\r\n使用模板\r\n使用is属性，声明需要的使用的模板，然后将模板所需要的data传入，如：\r\n\r\n<template is=\"msgItem\" data=\"{{...item}}\"/>\r\nPage({\r\n  data: {\r\n    item: {\r\n      index: 0,\r\n      msg: 'this is a template',\r\n      time: '2016-09-15'\r\n    }\r\n  }\r\n})\r\nis属性可以使用Mustache语法，在运行时来决定具体需要渲染哪个模板：\r\n\r\n<template name=\"odd\">\r\n  <view> odd </view>\r\n</template>\r\n<template name=\"even\">\r\n  <view> even </view>\r\n</template>\r\n\r\n<block wx:for=\"{{[1, 2, 3, 4, 5]}}\">\r\n    <template is=\"{{item % 2 == 0 ? 'even' : 'odd'}}\"/>\r\n</block>\r\n模板的作用域\r\n模板拥有自己的作用域，只能使用data传入的数据。\r\n\r\nWXML-事件什么是事件\r\n事件是视图层到逻辑层的通讯方式。\r\n事件可以将用户的行为反馈到逻辑层进行处理。\r\n事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。\r\n事件对象可以携带额外信息，如id, dataset, touches。\r\n事件的使用方式\r\n在组件中绑定一个事件处理函数。\r\n如bindtap，当用户点击该组件的时候会在该页面对应的Page中找到相应的事件处理函数。\r\n\r\n<view id=\"tapTest\" data-hi=\"MINA\" bindtap=\"tapName\"> Click me! </view>\r\n在相应的Page定义中写上相应的事件处理函数，参数是event。\r\nPage({\r\n  tapName: function(event) {\r\n    console.log(event)\r\n  }\r\n})\r\n\r\n事件详解\r\n事件分类\r\n事件分为冒泡事件和非冒泡事件\r\n\r\n冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。\r\n非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。\r\nWXML的冒泡事件列表：\r\n\r\n类型      触发条件\r\ntouchstart  手指触摸\r\ntouchmove   手指触摸后移动\r\ntouchcancel 手指触摸动作被打断，如来电提醒，弹窗\r\ntouchend    手指触摸动作结束\r\ntap 手指触摸后离开\r\nlongtap 手指触摸后，超过350ms再离开\r\n注：除上表之外的其他组件自定义事件都是非冒泡事件，如<form/>的submit事件，<input/>的input事件，<scroll-view/>的scroll事件，(详见各个组件)\r\n\r\n事件绑定\r\n事件绑定的写法同组件的属性，以key、value的形式。\r\n\r\nkey以bind或catch开头，然后跟上事件的类型，如bindtap, catchtouchstart\r\nvalue是一个字符串，需要在对应的Page中定义同名的函数。不然当触发事件的时候会报错。\r\nbind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。\r\n\r\n如在下边这个例子中，点击inner view会先后触发handleTap1和handleTap2(因为tap事件会冒泡到middle view，而middle view阻止了tap事件冒泡，不再向父节点传递)，点击middle view会触发handleTap2，点击outter view会触发handleTap1。\r\n\r\n<view id=\"outter\" bindtap=\"handleTap1\">\r\n  outer view\r\n  <view id=\"middle\" catchtap=\"handleTap2\">\r\n    middle view\r\n    <view id=\"inner\" bindtap=\"handleTap3\">\r\n      inner view\r\n    </view>\r\n  </view>\r\n</view>\r\n事件对象\r\n如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。\r\n\r\n事件对象的属性列表：\r\n\r\n属性         类型       说明\r\ntype          String    事件类型\r\ntimeStamp     Integer   事件生成时的时间戳\r\ntarget        Object    触发事件的组件的一些属性值集合\r\ncurrentTarget Object    当前组件的一些属性值集合\r\ntouches       Array     触摸事件，触摸点信息的数组\r\ndetail        Object    额外的信息\r\n\r\n\r\nWXML-引用WXML提供两种文件引用方式import和include。\r\n\r\nimport\r\nimport可以在该文件中使用目标文件定义的template，如：\r\n\r\n在item.wxml中定义了一个叫item的template：\r\n\r\n<!-- item.wxml -->\r\n<template name=\"item\">\r\n  <text>{{text}}</text>\r\n</template>\r\n在index.wxml中引用了item.wxml，就可以使用item模板：\r\n\r\n<import src=\"item.wxml\"/>\r\n<template is=\"item\" data=\"{{text: 'forbar'}}\"/>\r\nimport的作用域\r\nimport有作用域的概念，即只会import目标文件中定义的template，而不会import目标文件import的template。\r\n\r\n如：C import B，B import A，在C中可以使用B定义的template，在B中可以使用A定义的template，但是C不能使用A定义的template。\r\n\r\n<!-- A.wxml -->\r\n<template name=\"A\">\r\n  <text> A template </text>\r\n</template>\r\n<!-- B.wxml -->\r\n<import src=\"a.wxml\"/>\r\n<template name=\"B\">\r\n  <text> B template </text>\r\n</template>\r\n<!-- C.wxml -->\r\n<import src=\"b.wxml\"/>\r\n<template is=\"A\"/>  <!-- Error! Can not use tempalte when not import A. -->\r\n<template is=\"B\"/>\r\ninclude\r\ninclude可以将目标文件出了<template/>的整个代码引入，相当于是拷贝到include位置，如：\r\n\r\n<!-- index.wxml -->\r\n<include src=\"header.wxml\"/>\r\n<view> body </view>\r\n<include src=\"footer.wxml\"/>\r\n<!-- header.wxml -->\r\n<view> header </view>\r\n<!-- footer.wxml -->\r\n<view> footer </view>\r\nWXSSWXSS(WeiXin Style Sheets)是MINA设计的一套样式语言，用于描述WXML的组件样式。\r\n\r\nWXSS用来决定WXML的组件应该怎么显示。\r\n\r\n为了适应广大的前端开发者，我们的WXSS具有CSS大部分特性。 同时为了更适合开发微信小程序，我们对CSS进行了扩充以及修改。\r\n\r\n与css相比我们扩展的特性有：\r\n\r\n尺寸单位\r\n样式导入\r\n尺寸单位\r\nrpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在iPhone6上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。\r\n设备                      rpx换算px (屏幕宽度/750)               px换算rpx (750/屏幕宽度)\r\niPhone5                     1rpx = 0.42px                            1px = 2.34px\r\niPhone6                     1rpx = 0.5px                             1px = 2rpx\r\niPhone6s                     rpx = 0.552px                           1px = 1.81rpx\r\nrem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。\r\n建议：开发微信小程序时设计师可以用iPhone6作为视觉稿的标准。\r\n\r\n样式导入\r\n使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。\r\n\r\n示例代码：\r\n\r\n/** common.wxss **/\r\n.small-p{\r\n  padding:5px;\r\n}\r\n/** app.wxss **/\r\n@import \"common.wxss\";\r\n.middle-p:{\r\n  padding:15px;\r\n}\r\n内联样式\r\nMINA组件上支持使用style、class属性来控制组件的样式。\r\n\r\nstyle：静态的样式统一写到class中。style接收动态的样式，在运行时会进行解析，所以不要将静态的样式写进style中，以免影响渲染速度。\r\n<view style=\"color:{{color}};\" />\r\nclass：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。\r\n<view class=\"normal_view\" />\r\n\r\n选择器\r\n目前支持的选择器有：\r\n\r\n选择器                       样例                      样例描述\r\n.class                     .intro               选择所有拥有class=\"intro\"的组件\r\n#id                     #firstname              选择拥有id=\"firstname\"的组件\r\nelement                      view                选择所有view组件\r\nelement, element       view checkbox           选择所有文档的view组件和所有的checkbox组件\r\n::after                 view::after             在view组件后边插入内容\r\n::before               view::before            在view组件前边插入内容\r\n\r\n全局样式与局部样式\r\n定义在app.wxss中的样式为全局样式，作用于每一个页面。在page的wxss文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖app.wxss中相同的选择器。"}
{"title": "微信小程序学习摘要系列《四》碎片知识点；推荐阅读 ", "author": "天下雪", "pub_time": "2016-11-14 14:39", "article_content": "bindtap和catchtap区别bindtap可以产生冒泡事件\r\ncatchtap只自身触发事件，不会传递到父视图\r\n事件方法中参数eventcurrentTarget:当前View对象\r\n\r\ntarget:事件源对象(点击view3Click时，查看view1的event里的target为view3,currentTarget为view1)\r\n\r\ndataSet：存放的是数据 title:\"标题1\"\r\n\r\n<view bindtap=\"view1Click\" id=\"view1\" data-title=\"标题1\">\r\n<view bindtap=\"view2Click\" id=\"view2\">\r\n<view bindtap=\"view3Click\" id=\"view3\">\r\n</view>\r\n</view>\r\n</view>\r\n生命周期A、B 两个界面\r\n1.应用启动\r\n触发App Launch()  Show()\r\nA:Load() Show() Ready()\r\n\r\n2.从A跳转[wx.navigateTo]到B\r\nA:Hide()\r\nB:Load() Show() Ready()\r\n\r\n3.关闭B\r\nB：unLoad()\r\nA: Show()\r\n\r\n4.来电话 ，切换到后台\r\n\r\nAPP：Hide()\r\nA:Hide()\r\n\r\n5.从后台切换到前台\r\nAPP:Show()\r\nA:Show()\r\n\r\n6:从A跳转[wx.rediectTo]到B\r\nA:unLoad()\r\nB:Load() Show() Ready()\r\n\r\n7.A通过wx.navigateTo进行传递数据到B\r\nwx:navigateTo({\r\n url:\"../logs/logs?id=10\"\r\n})\r\n\r\n然后通过B中onLoad(options)中取出\r\n\r\n8.通过navigator组件形式进行值传递\r\n\r\n<navigator url=\"../logs/logs?id=100\">\r\n <view>\r\n  <text>文章1</text>\r\n </view>\r\n</navigator>\r\n\r\n9.通过redirect形式进行值传递\r\n<navigator url=\"../logs/logs?id=100\" redirect>\r\n <view>\r\n  <text>文章1</text>\r\n </view>\r\n</navigator>\r\n\r\nflex容器属性详解flex-direction决定元素的排列方向\r\nflex-wrap决定元素如何换行\r\nflex-flow 是 flex-direction 和flex-wrap的简写\r\njustify-content元素在主轴的对齐方式\r\nalign-items元素在交叉轴的对齐方式\r\n\r\nflex元素属性详解flex-grow 当有多余空间时，元素的放大比例 默认值是0\r\nflex-shrink当空间不足时，元素的缩小比例  默认值是1\r\nflex-basis元素在主轴上占据的空间         px\r\nflex是grow /shrink/basis的简写\r\norder定义元素的排列顺序\r\nalign-self定义元素自身的对齐方式\r\n相对定位和绝对定位相对定位的元素是相对自身进行定位，参照物是自身。\r\n绝对定位的元素是相对离它最近的一个已定位的父级元素进行定位。"}
{"title": "微信小程序实战教程：音乐播放器 ", "author": "天下雪", "pub_time": "2016-11-14 16:15", "article_content": "主要实现功能1、播放音乐，调节进度，上一曲，下一曲，暂停，列表点歌，播放模式（随机，单曲，列表）2、歌单列表，新建歌单，删除，重命名，收藏到歌单，用户信息3、最近播放功能4、歌单全部播放功能这份文档是开发了几天后写的，有些细节忘了，好吧就这样。首先建立了两个Page，音乐和用户，建立了tabbar首先想了首页的架构，每条我就显示歌曲名字和歌手就行，通过自己定义的一些数据渲染。添加了更多功能，主要用到了action-sheet，通过hidden属性控制隐藏显示，主要有收藏到歌单，下载，分享功能。单击歌曲我进行了跳转，在其他页面播放歌曲，构筑了play页面，跳转也学习了很久，我想带参数过去，分别有name poster src author 发现每次只能传三个过去就是以url+？+属性名+值，发现poster怎么都穿不过去，后来我把这些内容粘到txt里发现正正好好4kb！！！！蛋疼中。。。好像行不通了。就重新大改了一下。把数组单独写个js，每次用就require一下，解决了这个问题。再就是找播放icons花了好多时间，个人开发真苦逼，前后台美工都一体，最后还是丑丑的，弄不到一整套icons。然后碰到了播放之后，暂停，再播放就重新播放了，看了api研究了例子很长时间，好像是没写seek的缘故，现在准备试一试。2016.10.13升级了工具，页面塌了，首先想到flex，我之前解决了啊，怎么又成了这样至于原因我不知道，忘记当时怎么做的了，现在还好解决了page{    height:100%;}.play{    height: 100%;    display:-webkit-box;    -webkit-box-orient: vertical;         }.songname{    text-align: center;    height: 100rpx;    line-height: 100rpx;}.lyrics{    box-flex:1;    -webkit-box-flex:1;    text-align: center;    width: 100%;}.progress{    height: 76rpx;    display: flex;}.controls{    height: 200rpx;    line-height: 200rpx;    display:flex;  }用的display：box就好用了。主要是垂直两头固定，中间自适应。后来在群里看到是因为更新把page的高度百分百去掉了。播放问题解决了，获取播放进度，然后用seek加上就行了，要注意获取播放进度一定要播放着歌曲才能获得，我播放进度条是slider这个微信封装的组件，然后通过计时器，不断的更改playTime,把它填到slider的value里就实现了，现在要做的是，有个时间进度，估计也会用到计时器，写在那里就好了，还要format下时间，在util里写就好了，方便以后调用，现在不想写，看会书，听会音乐。2016.10.14今天没什么活，可以尽情开发了，新建了一个user页，可以展示我的歌单列表。还包括下载音乐，最近播放。花了一上午把页面基本架构搭建出来，下一步写js。完善功能。利用接口数据缓存 wx.getStorageSync(KEY) wx.setStorage(OBJECT) 这个分同步异步，看你需要，解决了如果点击相同音乐的话，就不会重新播放，而是继续播放2016.10.17今天想写一个动画，点击我的歌单，下滑出来一堆歌单，简单的试了一下，很容易的出现了效果。但是现在遇到了一个问题，有关于数据存储，少量数据可以调用官方api，但是大量的数据或者我想保存的用户信息如何访问我外界的数据库存起来呢。这个问题真的怎么搜也搜不到。https://www.qcloud.com/doc/product/448/6404 还没来及看，貌似能解释上诉问题，2016.10.18今天遇到了target和currentTarget的坑，我想在“更多”【。。。】就是这个图片的单击事件中传入歌曲的id，俺的wxml结构是这样的<block wx:for=\"{{music}}\"> <view class=\"cell\" bindtap=\"handleCell\" data-id=\"{{index}}\">  <view class=\"info\">                <view class=\"name\">{{item.name}}</view>                <view class=\"author\">{{item.author}}</view>            </view>            <view class=\"more\" catchtap=\"handleMore\" data-id=\"{{index}}\">                <image style=\"width:100%; height: 100%;\" src=\"resources/more.png\"></image>            </view>        </view>  </block><action-sheet hidden=\"{{actionSheetHidden}}\" bindchange=\"actionSheetChange\">             <action-sheet-item class=\"item\" bindtap=\"bindItemTap\" data-currid=\"{{currentid}}\">收藏到歌单</action-sheet-item>              <action-sheet-item class=\"item\" bindtap=\"bindItemTap\" data-currid=\"{{currentid}}\">下载</action-sheet-item>            <action-sheet-item class=\"item\" bindtap=\"bindItemTap\" data-currid=\"{{currentid}}\">分享</action-sheet-item>            <action-sheet-cancel class=\"cancel\">取消</action-sheet-cancel>   </action-sheet> 我单击更多并得不到index，我用的是e.target.dataset,最后我改成     e.currentTarget.dataset 就好使了，也是碰到了死耗子，我并没有事先懂得原理改的，而是碰巧试出来的，仔细想了一下，原来我点的是image，冒泡到view接收到了。新技能get。。。。小坑：action-sheet放入block中直接给currid传index不就好了，非得那么麻烦。实则不然，牵一发动全身的hidden属性。我开始设想用数组来改变，遇到了一堆坑，我退却了，这么麻烦肯定不是最优解。学会放弃，save time。2016.10.19今天开发的是添加新歌单这个功能，逻辑比较复杂。多思考就解决了。因为没有连外界，所以用的是本地存储存歌单。。。。对于{}判断有没有值学习到了。然后写了把歌曲添加到歌单，今天至今没遇到坑。2016.10.20歌单详细列表的开发完毕。request接口并不知道去请求谁，一开始就打算的是本地的，但是还是想连上其他资源的。整的没有动力了，开发完也是个单机小demo，一点也不高大上。哎~~~~prev遇到问题，不知是我逻辑错误还是相同url的问题，歌曲总是不重头播，好像播放了很多背景音乐2016.10.24大家程序员节快乐，可惜是苦逼的周一，今天学习到了动态删除对象中的属性。在我做歌单删除功能时遇到的。var objtest = {      prop: 'delete me'  };  //或者这么声明的对象  var objtest = new Array();  objtest['prop'] = 'delete me';  //删除属性'prop'：  delete objtest.prop;  //或者  delete objtest['prop'];    //还可以删除任意变量  var numb = 17;  delete numb;  项目地址：https://github.com/pagnkelly/wxdemo下载：wx-master.zip"}
{"title": "前端圈：微信小程序开发一周总结 ", "author": "天下雪", "pub_time": "2016-11-14 17:31", "article_content": "本文原发自公众号：前端圈编辑器我直接用 vscode（其它编辑器同理，预览还是用的微信开发工具），语法高亮将 wxml 设置成 html, wxss 设置成 css\"files.associations\": {  \"*.wxss\": \"css\",  \"*.wxml\": \"html\"}也可以安装小程序相关插件开始写代码首先需要完整看完微信小程序文档（框架，组件和 API），方便后面用到时查找。view 组件对应 html 里的 divtext 对应 spanwxss 里选择器只支持 element, #id, .className, ::after, ::before公用组件项目目录里新建 components ，按类似 pages 目录结构，将每个组件的模板，样式和 js 文件放在同一个文件夹模板可以直接  或者需要传值的使用  + 样式使用 @import 导入js 使用 require 引入到页面，然后使用下面的 mergePage 来加载到页面对象中。mergePage组件的加载使用mergePage方法将所有组件方法及页面事件注册到页面对象组件的编写方式组件里使用可以 this.setData 来更新页面数据，或者注册 onLoad，onShow等页面事件，mergePage 的最后一个参数的事件会最先调用。mergePage 的源码es 6箭头函数，函数参数默认值及解析构一些函数参数也可以直接使用默认参数。拓展运算符 和 对象属性简写在给 template 传 data 参数时，可以使用对象属性简写，如<template is=\"...\" data=\"{{...obj, id: otherIdVariable, name}}\"></template>这样 template 中可以使用变量为 obj 对象的所有 key，以及 id 和 name模板字符串小程序里可以直接方便的使用 es 6 模板字符串let url = `${app.globalData.API_PREFIX}/cart/add`;更多 es 6 特性请参考：https://uedsky.com/2016-06/es6/ ，也可以参考下一篇es6语法简介其它注意wx.showToast 图标只支持\"success\"、\"loading\"，错误提示得自定义如果 template 里面的变量没值，请看 data 传进来没有。开发工具（v0.10.102800）可以用下面方法添加接口请求域名，遗憾的是微信里不行。所有页面的 JS 会在启动时立即执行，而不是打开页面才执行，所以一些写在全局的代码应该尽量放到　onLoad 之后，下面是从调试 source 里看到加载的代码：define(\"pages/index/index.js\", function(require, module, exports, window,document,frames,self,location,navigator,localStorage,history,Caches,screen,alert,confirm,prompt,XMLHttpRequest,WebSocket ){    'use strict';        var app = getApp();        var util = require('../../../utils/util');        var ErrorMsg = require('../../../components/error-msg/error-msg');        var AddressPicker = require('../../../components/address-picker/address-picker');    Page(util.mergePage({              // 页面代码省略    }, AddressPicker, ErrorMsg));        //# sourceMappingURL=data:application/json;...});require(\"pages/index/index.js\")参考官方文档https://mp.weixin.qq.com/debug/wxadoc/dev/framework/MINA.html"}
{"title": "微信小程序学习用精品demo：麻将骰子：附详细教程 ", "author": "天下雪", "pub_time": "2016-11-14 18:26", "article_content": "作者：小飞侠424；原文地址核心知识点：微信小程序框架中的单向数据绑定应用微信小程序框架中按钮组件的使用以�"}
{"title": "一斤代码系列《七》微信小程序中使用微信风格样式库-WeUI ", "author": "天下雪", "pub_time": "2016-11-15 10:17", "article_content": "WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含button、cell、dialog、 progress、 toast、article、actionsheet、icon等各式元素。\r\nWeUI\r\n\r\nWeUI的官方演示地址是：https://weui.io/WeUI的官方GitHub地址是：https://github.com/weui\r\nWeUI最初是为HTML5的页面设计的样式库，现在微信小程序使用的样式机制也是css风格的样式机制（不过稍稍有些不一样的地方），WeUI理所当然的推出了WXSS版本。它的GitHub地址是：https://github.com/weui/weui-wxss\r\n我们可以直接去Github上下载它的代码，也可以通过npm来方便的获取：\r\nnpm install weui-wxss\r\n下载下来的代码中，包含了weui的源代码以及一个基于weui的示例小程序的：\r\n示例小程序\r\n\r\n里面包含了丰富的使用weui的示例代码，可以很好的学习weui提供的各个样式的使用。\r\n我们可以通过微信web开发者工具来打开这个示例代码：\r\n示例代码\r\n\r\nbutton样式\r\n\r\n你的小程序主要是通过在你的app.wxss中导入weui.wxss来导入WeUI的样式的：\r\n@import \"style/weui.wxss\";\r\n之后，就可以在小程序的各个地方使用WeUI中定义的样式了。"}
{"title": "微信小程序新手开发记录文档《一》 ", "author": "天下雪", "pub_time": "2016-11-15 10:23", "article_content": "1、开发工具        从微信公众平台官方网站下载安装小程序：开发工具下载。这是是基于微信自己的开发者工具，可以实现同步本地的文件，进行开发调试，项目管理，编译，动态预览和上传，发布等功能。由于是基于原生的系统层开发框架，不需要通过在浏览器中运行，这与H5开发是不同的，所以document和window等方法不可以使用。小程序开发者工具界面\r\n相比       H5加载时，需要按顺序加载HTML、CSS、JS。然后从服务器端返回数据，最后动态渲染页面显示到浏览器。用户需要等待时间，影响体验。     小程序是基于两个进程同步执行并加载。两个线程：Appservice Thread和View Thread是基于service层和view层的。甚至Appservice Thread会更早执行，当视图线程加载完，通知Appservice，Appservice 会把准备好的数据用setData的方法返回给视图线程。    小程序的这种优化策略，可以减少用户的等待时间、加快小程序的响应速度。小程序生命周期执行流程图\r\n2、开发语言小程序自己开发了一套WXML标签语言和WXSS样式语言，并非直接使用标准的HTML5+CSS3。WXML1）标签WXML在语法上更接近XML语言，遵循SGML规范，区别于HTML语言随意的标签闭合方式，WXML语言必须包括开始标签和结束标签，以image标签为例，以下2种写法都支持：<image src=''  2333 '' />    或 <image src='' 2333 ''>   </image>注意：所有组件与属性都是小写，以连字符-连接。2）文件引入 WXML提供两种文件引入方式，import和include。区别在于：import可以引入定义好的template模板，模板是有作用域的；而include就是拷贝一个公用的代码片段到目标文件中，适合做公共页面片的拆分，文件引入在小程序做模块化拆分的过程中非常重要。文件引入两种方式\r\nWXSS1）尺寸单位WXSS支持的单位有px、rem和rpx，其中rem和rpx可以针对屏幕容器进行适配，px则为固定尺寸。其中1rpx=0.5px，在WXSS和WXML中定义的rpx单位最终会转换为在手机端可以识别的rem单位。建议：开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。所以工程师拿到750的设计稿，在PS中量取的容器大小，可以直接定义为rpx，不需要进行2倍尺寸的换算。view元素的样式配置\r\n注意：rpx的单位不光在样式中会自适应，写在WXML的style里也会根据屏幕自适应。2）样式引入\r\n   支持样式引入，格式如下： import \"../../wxss/common.wxss\";\r\n使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。\r\n示例代码：  /** common.wxss **/.small-p{padding:5px;} **/ /** app.wxss **/@import\"common.wxss\";.middle-p{padding:15px;} **/3）选择器小程序支持的选择器在官方公布的文档中包括.class、#id、 element、element,element、::after(注意是双冒号)、::before这6种选择器。小程序对于:first-child、:last-child、.class-a .class-b{}，甚至更多层级的嵌套都是支持的。几种选择器\r\n不过官方并不推荐级联的这种写法，因为考虑到后面切Native的扩展可能，会没办法支持级联选择。所以保险起见，不建议.class-a .class-b{}这种级联的写法，以免后期工具过滤导致页面错乱。3、开发组件封装小程序有许多自己独立的开发的原生APP组件，可以直接调用。H5和小程序组件标签的区别对比\r\n先来简单说明下： 1）viewdiv和view都是盒模型，默认display:block  盒模型在布局过程中，一般推荐display:flex的写法，配合justify-content:center;align-items:center;的定义实现盒模型在横向和纵向的居中。2）text文本。<text/>组件内只支持<text/>嵌套。除了文本节点以外的其他节点都无法长按选中.3）icon图标。icon可以直接用微信组件默认的图标，默认是iconfont格式icon图标对应属性\r\n4）表单组件好多啦。。去查文档咯。。"}
{"title": "微信小程序新手开发记录文档《二》 ", "author": "天下雪", "pub_time": "2016-11-15 10:33", "article_content": "一、小程序应用场景小程序主打的是比APP更轻量的形态，简单的开发，却接近app的体验，无需下载，扫码打开。一些高频的金融类、电商类、教育类等其实是不适合接入小程序的。这些应用服务对功能的要求都很重，小程序难以承载。而且小程序不能像微信公众号一样被关注、群推送消息以及转发朋友圈，这也就意味着，它没有办法获取用户更多的信息，也不便于深度营销。主打适合小程序的产品：* 初创型企业的MVP产品*开发和设计能力有限的产品*功能轻、用完即走、非即时、可异步*基于轻社交场景应用、跨平台使用二、从操作 DOM 转为操作数据微信开放的接口更为严谨，结构必须采用他提供给我们的组件，外部的框架和插件都不能在这里使用，让开发者完全脱离操作 DOM，开发思想转变很大。生命周期：( 从index.js文件看)1） 在首页的console 可以看出顺序是 App Launch-->App Show-->onload-->onShow-->onReady。首先是整个 app 的启动与显示，app 的启动在 app.js 里面可以配置，其次再进入到各个页面的加载显示等等。例如，App()函数用来注册一个小程序，接受一个Object参数，其指定小程序。生命周期函数等。App({onLaunch: function() {// Do something initial when launch.},onShow: function() {// Do something when show.},onHide: function() {// Do something when hide.},globalData: 'I am global data'})2）小程序的开发是基于微信提供的一套应用框架进行开发的。微信通过封装微信客户端提供的文件系统、网络通信、任务管理、数据安全等基础功能，对上层提供了一套完整的Javascript Api，使得开发者能够非常方便的使用到微信客户端提供的各种基础功能，快速构建一个应用。框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层之间通过**单向数据绑定**进行数据传输，使开发者更加聚焦于数据与逻辑上。三、新建的项目各文件详解：1） pages文件夹：是页面管理文件夹下面一般可以自定义页面，如demo中的index欢迎页面。首页index页面包含几个文件：index.js，index.wxss，index.wxml，index.json先来逐一介绍下这些文件是干嘛的。index.js文件是以js结尾的文件，是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数，获取小程序实例，声明并处理数据，响应页面交互事件等。是必须要的。index.wxml文件是页面的结构文件（类似于H5的html标记文件）。是必须要的。index.wxss文件是页面的样式表。非必要。当有页面样式表文件时候，页面样式表中的样式规则会层叠覆盖app.wxss文件中的样式规则。如果不指定页面的样式规则表，也可以在页面的结构文件中直接使用app.wxss中指定的样式规则。index.json文件是页面的配置文件。非必要。当有页面的配置文件时候，配置项在该页面会覆盖app.json文件中的window中相同的配置项，如果没有指定配置文件，则在该页面直接使用app.json中的默认配置文件。2） app.js文件是小程序的脚本代码。监听并处理小程序的生命周期函数，并声明全局变量，调用框架的API，同步存储和同步读取本地数据。3）app.json文件是对整个小程序的全局配置。可以在该文件中配置小程序有哪些页面组成，配置小程序窗口背景，配置导航条样式，配置默认标题。（注意，不可添加注释）4）app.wxss文件是小程序的公共样式表文件。我们可以在页面组件的class属性上直接使用app.wxss文件中声明的样式规则。  在index.wxss中设计组件位置和属性样式。   rpx单位是微信小程序中css的尺寸单位，rpx可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。UI设计图建议：使用设计稿使用设备宽度750px比较容易计算750px的话1rpx=1px，这样的话，设计图上量出来的尺寸是多少px就是多少rpx。"}
{"title": "跟读：使用过程遇到的坑丶记录 ", "author": "天下雪", "pub_time": "2016-11-15 10:56", "article_content": "你可以在这聊一聊自己遇到过的坑，怎么解决的？http://www.wxapp-union.com/forum.php?mod=viewthread&tid=479使用说明由于微信安全域名的限制，如果你填了自己的APPID，所有请求都会失败无APPID的情况下，使用微信登录会存在问题，请使用手机号登录目前是测试版本，故未接入短信平台，所以手机是收不到验证码的，直接点获取验证码就已经填上了使用过程遇到的坑丶记录背景图不生效，改用image或者Base64执行POST请求异常，将data中的JSON对象格式化为from序列页面切换的参数接收异常，在onload方法中，默认的参数即使上一页面传过来的Object参数在使用data-readingItem的时候，微信解析为dataset的时候会转成小写多页面的时候，在app.json中重复配置，会编译失败直接使用 this.data.XXX = XXX 赋值的时候，数据是不会同步输出到VM即WXML中的，必须使用其setData方法循环加载JSON数据集合时，如果其中有项是null，在开发工具中加载正常，但是在手机中浏览时显示空白页，并且调试时没有错误信息，所以需要对可能为null的数据进行判断 PS:由于有预处理，所以没有遇到这个问题针对swiper控件，设置min-height不生效，必须设置height，同时swiper-item的间隙也有坑，项目中有实践使用uploadFile-formData传递参数的时候，formData是个三项的JSON,PHP通过$_REQUEST尽然只能接到最后一个参数 PS:怀疑是微信的坑，后来使用的是将其以GET方式提交，才正常接到在使用for循环的时候，用的是立即执行的闭包函数，但是PHP端接到的三个请求的time竟然是一样的，这直接导致了文件获取的异常， 目前未找到真实原因，是本人对for循环理解太浅？后通过额外加参数解决微信录制的音频格式为.silk格式，具体可以Google，强大的ffmpeg都没法直接解码，最后使用了GitHub上的一个开源Decoder库， 解码成功转成了MP3，感谢作者，地址：https://github.com/kn007/silk-v3-decoder未解之谜|改进方向for循环中的立即执行函数时间是完全一致的？在页面切换的时候，切换到特定页面，需要先校验其是否登陆，然后跳转登陆页，结果真机上实践，几乎都是失败的后期考虑使用登陆蒙层来解决，但是每个页面怎么自动引入登陆的template？代码执行完之后，在回调中直接navigateTo或者redirectTo失败率很高，暂时用setTimeOut缓解。下拉刷新的样式后期考虑自己定制，封装成方法进一步扩充工具类，封装实用方法"}
{"title": "微信小程序的缓存策略分析 ", "author": "天下雪", "pub_time": "2016-11-15 12:03", "article_content": "文件缓存特性：1.由于小程序的缓存没有时效性2.文件缓存大小限制3.需要针对特定业务群进行缓存更新4.一键清空缓存5.针对不同用户，对应的缓存是公共的，没有隔离。因此缓存针对不同的用户，使用该用户特定的key来隔离。 那么对应的解决方案是什么呢 解决方案：1.缓存前缀，带上用户标识_缓存名2.每个缓存，需要记录缓存大小、缓存名、缓存类名、缓存生成时间、缓存失效时间到一个公共的缓存类中。3.有一个设置缓存，如果目前系统缓存大小，启动失效缓存清理机制方法。4.当手机网络非常好的情况下，基本上走线上实时数据策略    当网络不好，尽量走本地缓存策略。5.为了更好地提高用户体验度，有一个提前加载数据的策略。例如打开首页后2秒，自动加载请求未来用户需要请求的数据，入缓存数据。初步分析的，希望对大家有用 缓存策略的好坏，影响到小程序加载的效率和用户体验度 缓存，可以在客户端后台，进行静默加载常用的，这样用户在进入第二页，将会加快打开。提高用户体验度。"}
{"title": "疯狂早茶微信小程序基础篇《四》：数据绑定（上） ", "author": "天下雪", "pub_time": "2016-11-15 12:05", "article_content": "在之前的教程中写到，微信小程序框架将程序分为逻辑层(.js文件)和视图层(.wxml文件)。这是一种常见的UI和逻辑分离的程序设计方式，开发出来的程序更加灵活，易扩展。这种程序设计方式通常要解决两个问题:UI层响应逻辑层逻辑和数据的变化UI层将用户的操作反馈到逻辑层通常来说可以让UI层和逻辑层互相暴露接口给对方，不过出于对灵活性和扩展性的考虑，会引入中间层来进行管理，这样可以避免UI层和逻辑层之间的直接依赖。微信小程序框架正是基于这种模式进行设计的，.wxml文件来描述UI层(微信官方名称为视图层，教程后续也将用视图层来命名)，.js文件来处理逻辑层，而微信的框架则作为中间层管理两者之间的调用。为了更好的帮助开发者开发微信小程序，微信定义了一些语法和规则来帮助开发者连接视图层和逻辑层。数据绑定显示字符串内容//page.wxml\r\n<text class=\"user-motto\">{{motto}}</text>\r\n\r\n//page.js\r\n data: {\r\n    motto: 'Hello World',\r\n  },通过将\"{{motto}}\"嵌入视图层代码中，界面会显示\"Hello World\"更改字符串内容setData({\r\n  motto:'Hello My World'\r\n  })当执行上述代码后，界面会显示\"Hello My World\"上述部分有两点需要说明:1: 视图层嵌入的是{{motto}}而不是{{data.motto}}，微信框架默认设定视图层绑定的变量定义在Page对象的data属性中，也就是说，如果变量需要绑定到视图层，一定要定义data属性中2: 通过调用Page对象的setData(Page对象预定义)方法，可以更新界面数据，但是直接设置变量是无效的，因此对于绑定到视图层的变量，要永远使用setData方法来设置变量值显示图片在开发工具默认生成的程序首页，显示了用户的头像，相关代码如下://index.wxml\r\n <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\r\n\r\n//index.js\r\nonLoad: function () {\r\n    console.log('onLoad')\r\n    var that = this\r\n    //调用应用实例的方法获取全局数据\r\n    app.getUserInfo(function(userInfo){\r\n      //更新数据\r\n      that.setData({\r\n        userInfo:userInfo\r\n      })\r\n    })\r\n  }image标签的src属性绑定了userInfo.avatarUrl变量，并在onLoad方法中通过调用setData方法设置userInfo。属性绑定可以将变量绑定到视图组件的属性值上(如上面image标签的src属性)，注意在绑定到属性时，需要在外面加入一对双引号。src=\"{{userInfo.avatarUrl}}\"除了用于显示图片外，属性绑定还有许多作用。关联数据假设要做一个学生管理程序，页面使用列表来展示用户数据，当用户点击某一学生信息时，进入该学生的详情页页面。当获取到用户的点击事件时，必须要知道点击的是哪一个学生的数据，这时可以将学生的id绑定到视图组件的id属性中来进行数据关联。控制视图的隐藏/显示可以将变量绑定到视图组件的hidden属性中，通过更改组件hidden属性的值，可以控制组件是否显示。控制属性上面说到可以通过属性绑定的方法来控制视图组件是否显示，还可以通过控制属性来实现这一功能。//Page.wxml\r\n<view wx:if=\"{{condition}}\"> </view>\r\n\r\n//Page.js\r\nPage({\r\n  data: {\r\n    condition: true\r\n  }\r\n})通过绑定数据到wx:if属性，可以控制该组件是否显示。框架还提供了wx:elif和wx:else属性，用法如下:<view wx:if=\"{{length > 5}}\"> 1 </view>\r\n<view wx:elif=\"{{length > 2}}\"> 2 </view>\r\n<view wx:else> 3 </view>如果想同时控制多个视图组件，可以使用block wx:if<block wx:if=\"{{true}}\">\r\n  <view> view1 </view>\r\n  <view> view2 </view>\r\n</block>同样，控制属性绑定时也需要添加双引号wx:if vs hidden一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden更好，如果在运行时条件不大可能改变则 wx:if 较好。关键字框架提供了两个关键字来表示真和假true：boolean 类型的 true，代表真值。false： boolean 类型的 false，代表假值。代码示例<checkbox checked=\"{{false}}\"> </checkbox>特别注意：不要直接写 checked=\"false\"，其计算结果是一个字符串，转成 boolean 类型后代表真值。关于数据绑定的更多讲述，敬请期待微信小程序开发教程(基础篇)8-数据绑定下"}
{"title": "阿东入门系列《一》注意点和快捷键 ", "author": "天下雪", "pub_time": "2016-11-19 01:40", "article_content": "注意点1. 微信小程序官方给出的定义是： 微信小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。其实他更像一个WEB APP，用户可以像打开一个网页一样打开一个微信小程序。所以，微信对小程序的要求是整体大小不能超过1MB。 2. .json 是配置文件，其内容必须符合JSON格式，所以文件内部不允许有注释。 3. app.json 是全局配置文件，微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页 4. .wxss 文件是样式表文件，app.wxss是全局的样式表文件。页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。 .json 文件具有相同的规则。 5. 每一个页面的路径名和文件名必须相同。 6. tabBar（客户端窗口的底部用于切换页面的tab栏）在 app.json 文件中配置，只能配置最少2个、最多5个 tab，显示顺序同tabBar标签下的pei 7. tabBar 的 iconPath 和 selectedIconPath 属性可以接受一个图片的路径，这个图片必须是本地图片不能是网络图片。 8. 像素单位最好使用 rpx ，微信会根据手机屏幕大小自适应。 9. 微信小程序存放资源文件，需要在根目录下创建文件夹，引用时以 /文件夹名/资源名 的形式引用。 10. 一个应用同时只能打开5个页面。wx.navigateTo 打开页面不会销毁之前的页面，如果页面层数较多注意使用 wx.redirectTo。快捷键格式调整 - Ctrl+S：保存文件 - Ctrl+[， Ctrl+]：代码行缩进 - Ctrl+Shift+[， Ctrl+Shift+]：折叠打开代码块 - Ctrl+C Ctrl+V：复制粘贴，如果没有选中任何文字则复制粘贴一行 - Shift+Alt+F：代码格式化 - Alt+Up，Alt+Down：上下移动一行 - Shift+Alt+Up，Shift+Alt+Down：向上向下复制一行 - Ctrl+Shift+Enter：在当前行上方插入一行光标相关 - Ctrl+End：移动到文件结尾 - Ctrl+Home：移动到文件开头 - Ctrl+i：选中当前行 - Shift+End：选择从光标到行尾 - Shift+Home：选择从行首到光标处 - Ctrl+Shift+L：选中所有匹配 - Ctrl+D：选中匹配 - Ctrl+U：光标回退界面相关 - Ctrl + \\：隐藏侧边栏 - Ctrl + m: 打开或者隐藏模拟器"}
{"title": "阿东入门系列《二》轮播，Tab分页 ", "author": "天下雪", "pub_time": "2016-11-19 01:43", "article_content": "一：Tab分页1.1 组件 tabBar微信小程序提供了一个组件tabBar用来实现多tab分页功能。如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。微信小程序提供了一个组件tabBar用来实现多tab分页功能。如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。1.2 配置位置微信小程序中认为整个页面分为 导航栏navigationBar，tab栏 tabBar 和 页面区域（就是在pages中配置的页面显示区域），所以tabBar的配置位于全局配置文件app.json 文件中。   \"tabBar\": {    \"color\": \"#a9a9a9\",    \"selectedColor\": \"#1f1f1f\",    \"backgroundColor\": \"#fefefe\",    \"borderStyle\": \"white\",    \"list\": [      {        \"pagePath\": \"pages/main/main\",        \"text\": \"首页\",        \"iconPath\": \"image/icon_home.png\",        \"selectedIconPath\": \"image/icon_home_select.png\"      },赞赏 \n                             \n                 \n                邀请 \n              \n              \n               \n               \n              \n              \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (3)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (3 人)\r\n\r\n\r\n\r\n\r\n冉冉之光\r\n\r\n\r\n\r\n梦中剑神\r\n\r\n\r\n\r\nshaoronggang\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n            \n            \n             \n                         \n              阿东入门系列《一》注意点和快捷键 \n              阿东入门系列《三》网络请求 \n            \n             \n            \n                  原作者: 阿东 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 阿东入门系列《一》注意点和快捷键\n                                    \n                  • 阿东入门系列《三》网络请求\n                                    \n                  • 阿东入门系列《四》列表上拉加载下拉刷新\n                                    \n                  • 阿东入门系列《五》仿找事吧APP附近三公里Demo\n                                    \n                  • 阿东入门系列《六》微信小程序map地图，页面跳转\n                                    \n                  • 微信小程序分页功能（上拉触底事件）\n                                  \n              \n            \n             \n            \n          \n          \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cStSvj8J', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n      \n      \n       \n    \n  \n  \n    \n    \n    \n     \n      \n      \n       \n    \n  \n\n\n\n \n  \n  \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164091|ab0a42f75397b9bccda3fc8adb2bb810|2';"}
{"title": "阿东入门系列《三》网络请求 ", "author": "笑若天河", "pub_time": "2016-11-19 11:07", "article_content": "前文讲配置的时候我们说过，开发小程序时可以选择有 APPID 和 无 APPID ，两种方式。1. 当有APPID的情况下，进行网络通信，只能和指定的域名进行通信。如果没有进行配置，编译时会报如下错误：配置方法：设置域名 需要在微信公众平台的小程序中设置域名。在微信小程序的设置界面可以看到设置选项： 选择开发设置：可以看到服务器设置:这里我们可以设置我们这个APPID可以访问的域名，每种最多可以设置两个。(注意，此处只能使用 https 的域名，这个申请过程需要花费一定的时间)2. 当没有APPID的情况下，就方便多了，可以随意进行网络请求，不限制域名，但是，这种情况下不能进行发布，也不能在手机上预览。如果想正式做小程序开发，还是需要有一个https的域名，但是学习的情况下http的就足够了。在小程序中网络请求大致分为四种类型。· 普通HTTPS请求(wx.request) · 上传文件(wx.uploadFile) · 下载文件(wx.downloadFile) · WebSocket通信(wx.connectSocket)这里主要讲 wx.request：使用wx.request可以发起一个http请求，一个微信小程序被限制为同时只有5个网络请求。注意是同时。wx.request({    url: 'http://192.168.1.137:80/app/guanggao',    method: 'POST',    data: {        type: \"1\"    },    header: {        'Accept': 'application/json'    },    success: function (res) {        that.setData({            images: res.data.data.guanggao        })    }    fail:function(err){        console.log(err)    }})Page(conf);上面的代码会发送一个http get请求，其中的参数也比较容易理解。· url 服务器的url地址 · data 请求的参数可以采用String data:”xxx=xxx&xxx=xxx”的形式或者Object data:{“userId”:1}的形式 · header 设置请求的header · method http的方法,默认为GET请求 · success 接口成功的回调 · fail 接口失败的回调另外还有一个参数没有在代码里: · complete 调用接口结束之后的回调，无论成功或者失败该接口都会被调用超时的设置在前文中已经提到了在app.js中设置networkTimeout可以设置四种类型网络访问的超时时间：\"networkTimeout\":{   \"request\": 10000,   \"connectSocket\": 10000,   \"uploadFile\": 10000,   \"downloadFile\": 10000}"}
{"title": "阿东入门系列《四》列表上拉加载下拉刷新 ", "author": "笑若天河", "pub_time": "2016-11-19 11:14", "article_content": "1.列表（本部分内容出入官方文档）对于这个功能，微信小程序中并没有提供类似于Android中listview性质的控件，所以我们需要使用 wx:for 控制属性绑定一个数组，用数组中各项的数据重复渲染该组件，来达到列表的效果。<view wx:for=\"{{array}}\">  {{index}}: {{item.message}}</view>Page({  data: {    array: [{      message: 'foo',    }, {      message: 'bar'    }]  }})默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item，当然也可以通过 wx:for-item 和 wx:for-index 指定。<view wx:for=\"{{array}}\" wx:for-index=\"idx\" wx:for-item=\"itemName\">  {{idx}}: {{itemName.message}}</view>wx:for也可以嵌套，下边是一个九九乘法表<view wx:for=\"{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}\" wx:for-item=\"i\">  <view wx:for=\"{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}\" wx:for-item=\"j\">    <view wx:if=\"{{i <= j}}\">      {{i}} * {{j}} = {{i * j}}    </view>  </view></view>block wx:for 类似block wx:if，也可以将wx:for用在标签上，以渲染一个包含多节点的结构块。例如：<block wx:for=\"{{[1, 2, 3]}}\">  <view> {{index}}: </view>  <view> {{item}} </view></block>wx:key如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如  中的输入内容， 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。wx:key 的值以两种形式提供1. 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 2. 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如： 当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。示例代码：赞赏 \n                             \n                 \n                邀请 \n              \n              \n               \n               \n              \n              \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (2)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                (1)\r\n\r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (3 人)\r\n\r\n\r\n\r\n\r\n骑猪射马\r\n\r\n\r\n\r\n冉冉之光\r\n\r\n\r\n\r\nzero3412\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n            \n            \n             \n                         \n              阿东入门系列《三》网络请求 \n              阿东入门系列《五》仿找事吧APP附近三公里Demo \n            \n             \n            \n                  原作者: 阿东 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 阿东入门系列《一》注意点和快捷键\n                                    \n                  • 阿东入门系列《二》轮播，Tab分页\n                                    \n                  • 阿东入门系列《三》网络请求\n                                    \n                  • 阿东入门系列《五》仿找事吧APP附近三公里Demo\n                                    \n                  • 阿东入门系列《六》微信小程序map地图，页面跳转\n                                    \n                  • 微信小程序之上拉加载（分页加载）实例\n                                  \n              \n            \n             \n            \n          \n          \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSwuasgU', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n      \n      \n       \n    \n  \n  \n    \n    \n    \n     \n      \n      \n       \n    \n  \n\n\n\n \n  \n  \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164093|251d02a02515a21c7e6fbfdcf7aaaa03|2';"}
{"title": "阿东入门系列《五》仿找事吧APP附近三公里Demo ", "author": "笑若天河", "pub_time": "2016-11-19 11:16", "article_content": "源码下载地址 ：Github效果图如下：分析一下页面，主要内容分为顶部轮播，中间10个分类图标的排版和单击事件，下部列表下拉刷新上拉加载更多。大部分知识点前面都讲过。这里主要说一下微信小程序中的数据绑定，前后台传值以及加载更多时的数据合并。1. 数据绑定和前后台传值中间分类图标的布局文件：<view class=\"items\" wx:for=\"{{array}}\" wx:for-item=\"item\" bindtap=\"typeclick\"  data-code=\"{{item.code}}\" data-text=\"{{item.text}}\" >        <image class=\"item-img\" mode=\"aspectFit\" src=\"{{item.src}}\"></image>        <view class=\"item-text\">{{item.text}}</view></view>可以看出是以 控制属性 wx:for 绑定数据 array 来循环渲染布局，并对view绑定了单击事件bindtap=\"typeclick\"。因为每一个分类点击都会刷新下部列表，所以需要在事件中获得当前分类数据的code。小程序中提供自定义标签 data-XXX，供开发者使用来绑定数据，XXX 可以随意取名，这里我们用 data-code=\"{{item.code}}\" data-text=\"{{item.text}}\"把每条数据的code和text传给function typeclick。然后在js中的 typeclick 函数中，我们可以通过event拿到绑定的数据。// 分类item单击事件typeclick: function (e) {    total = 0;    code = e.currentTarget.dataset.code + \"\";    var name = e.currentTarget.dataset.text + \"\";    this.data.dataArray = [];    this.setData({        title: \"附近三公里: \" + name    })    this.periphery();},e.currentTarget.dataset.code 后边的code就是我们在布局文件中定义的 data-XXX 中的XXX，这里需要注意一下，因为js的机制，有时候我们拿到的数据类型可能不对，需要自己处理一下。2. 加载更多时的数据合并    // 网络请求    periphery: function () {        var that = this        //sliderList        wx.request({            url: 'http://xxx',            method: 'POST',            data: {                city: \"深圳\",                code: code,                count: count + \"\",                total: total + \"\",                lat: app.globalData.latitude + \"\",                lng: app.globalData.longitude + \"\"            },赞赏 \n                             \n                 \n                邀请 \n              \n              \n               \n               \n              \n              \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\n梦中剑神\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n            \n            \n             \n                         \n              阿东入门系列《四》列表上拉加载下拉刷新 \n              程序员开发实战系列《一》注册、预览小程序 \n            \n             \n            \n                  原作者: 阿东 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 阿东入门系列《一》注意点和快捷键\n                                    \n                  • 阿东入门系列《二》轮播，Tab分页\n                                    \n                  • 阿东入门系列《三》网络请求\n                                    \n                  • 阿东入门系列《四》列表上拉加载下拉刷新\n                                    \n                  • 阿东入门系列《六》微信小程序map地图，页面跳转\n                                  \n              \n            \n             \n            \n          \n          \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSESa3Hy', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n      \n      \n       \n    \n  \n  \n    \n    \n    \n     \n      \n      \n       \n    \n  \n\n\n\n \n  \n  \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164094|cbb1089c623690b31c360c9640500c7d|2';"}
{"title": "电商类小程序实战教程 Vol.2：列表加载 ", "author": "whxiaobu", "pub_time": "2016-11-19 11:22", "article_content": "在上一期文章中，我们以爱范儿旗下的玩物志电商小程序作为 Demo，介绍了首页 banner 部分的开发，以及微信小程序内置组件、数据绑定和发送请求 API 的用法。本期，知晓程序依然以玩物志电商小程序为基础，为大家带来有关于列表加载的实现教程。为布局而生的 flex传统的布局方式一般都是基于 div 盒子模型，利用 float, position, display 来进行布局。每个前端开发者对这些布局方式都非常熟悉。对一些特殊的布局来说，使用这些属性并不方便，由此还衍生出各种 hack 方案。直到 CSS3 提出了专为布局而生的解决方案，就是 flex布局。但是，由于浏览器的兼容问题，大多数开发者都不敢将 flex 布局直接应用到实际项目之中。在常规项目中，大量应用 flex 布局还需要一个过程。而对于 WeChat Only 的小程序来说，则完全不用担心有浏览器兼容的问题，它只要适配微信客户端即可。同时，由于小程序的布局不会非常复杂，所以，也不用过多地担心大量使用 flex 引起的性能问题。我们可以放心地在小程序中使用 flex 布局。如何更方便地使用 rpxrpx 的全称是 responsive pixel，它是小程序自己定义的一个尺寸单位，可以根据当前设备的屏幕宽度进行自适应。小程序中规定，所有的设备屏幕宽度都为 750rpx，根据设备屏幕实际宽度的不同，1rpx 所代表的实际像素值也不一样。例如，在 iPhone 6 上，屏幕实际宽度为 375px，则 750rpx = 375px，1rpx = 0.5px；而在 iPhone 5 上，屏幕实际宽度为 320px，则 750rpx = 320px，1rpx = 0.42px。其实，我们并不必关心每种设备屏幕下 1rpx 到底代表多少个像素，只要抓住 「所有的设备屏幕宽度都为 750rpx」这个原则，就能很好地实现对任意设备屏幕大小的自适应布局。知晓程序（微信号 zxcx0101）强烈建议设计人员用 iPhone 6 作为视觉稿的标准，即将视觉稿总宽度设成 750px。这样，开发者就能很方便地对相关的尺寸进行量取。比如，在总宽度为 750px 的 iPhone 6 视觉稿中，量取一个图片的宽度为 200px，那么，这个图片的宽度即可设置为 200rpx。简单一句话解释：量取多少就设置多少。flex 配合 rpx 的使用案例现在，我们就在小程序中使用 flex 和 rpx 进行布局，体验一下这种解决方案的便利。案例一：货架列表来看看货架列表的效果图：首先还是贴两段代码。以下是 WXML 的实现：然后 WXSS 的代码如下，我们在关键代码处已经给出简要注释：简单几步就完成了货架列表的布局，并且完美兼容各种大小的设备屏幕。案例二：货架分类标题再来一个例子，看一下商品列表货架分类的标题：如上图所示，货架标题居左，「查看更多」的图标居右并且垂直居中。代码结构如下：有经验的同学一眼就可以看出，要实现需求需要：让 .shelf-title 向左浮动让 .shelf-more 水平方向右对齐、垂直方向居中最后还要给 .shelf-header clearfix 一下那现在来看看 flex 是怎么做的：只要区区几行代码，就能轻松使用 flex 调整排版。接下来，结合上一期的内容，发起一个请求获取数据，然后 setData() 绑定数据：货架列表就完成了。template 模板的使用我们再来看看，首页的分类列表和货架分类列表页两个页面的对比：不难发现，这两个页面的列表的样式是一模一样的。那么，我们就可以把每个商品视为一个模块，暂且把这个商品模块称为 product-card，我们可以将它用 template 封装起来，在需要的地方就将它引入并进行调用。这里先要弄清楚一个概念，template 的主要功能更多的是在于定义一个 wxml 的代码片段，然后在不同的地方调用。template 拥有自己的作用域，只能使用 data 传入的数据。我们来看下 template 到底如何使用。1. 定义 template 模板为了方便代码组织，我们在 templates 目录下，新建一个 productCard 文件夹，并在 product-card 文件夹下新建 productCard.wxml 和 productCard.wxss 文件。代码如下：使用 name 属性定义模板的名字，然后将代码片断保存在 template 中。2. 引入 template 模板以首页为例，当要使用到 productCard 模板时，我们只需要使用 import 引入模板。在需要显示的位置，外层用 wx:for 循环渲染列表，template 为子项，使用 is 声明需要的使用的模板，用 data 传入数据：留意一下 data=\"{{ ...item }} 的写法，item 是 wx:for 中代表数组当前项的默认变量名，item 前面的 ... 操作符相当于 ES6 中的展开运算符，可用于需要解构赋值的地方，没有了解过展开运算符和解构（Destructuring）的同学可以先了解一下它们的基本概念。通过解构，template 中就可以直接写成 {{ id }}, {{ cover_image }}，而不用写 {{ item.id }}, {{ item.cover_image }}。它的意义在于实现了 template 与 wx:for-item 之间的解耦，比如这里设置了 wx:for-item＝\"product\"，我们只要设改变 data=\"{{ ...product }} 就可以了。如果数据没有通过解构，就要将 template 的 {{ item.id }} 修改成 {{ product.id }}，很不方便。接下来是 productCard.wxss 的引入。先在 productCard 写好样式，这里就不贴代码了。模板的 WXSS 文件如何引入首先请思考一下，在哪里可以引入 WXSS 文件？一种方法是在用到 productCard 模板的页面里引入，在这里是在 list.wxss 中 import进来。另一种方法是，直接在 app.wxss 中引入。相比较于上一种方法，这个方法只需要一次引入，而所有用到 productCard 模板的页面都不用再去引入 productCard.wxss 了。获取商品列表数据，渲染视图先通过 onLoad 的 options 取得货架 id：最后，调用 wx:request() 获取商品列表数据，通过 setData() 设置，即可在视图层渲染出完整的列表。到这里，一个像样的列表页面就做好了。但如上面的代码所示，现在小程序会一次性将所有商品列表查询并渲染至页面中。现实中，这种做法显然是不科学的。我们还需要一个「加载更多」的功能。这个功能要求我们做到：用户访问时，页面加载 20 个商品，点击列表底部的「查看更多」按钮可再多加载 10 个商品。具体如何实现呢？请继续关注下一期的内容。"}
{"title": "微信小程序中JavaScript代码书写习惯与命名规范建议 ", "author": "天下雪", "pub_time": "2016-11-19 23:07", "article_content": "本文来自公众号：TITF，欢迎关注代码命名原则便于程序员开发与后期维护；便于程序员读取并理解代码含义。代码命名规则    变量及名称开头必须是以下字符中的其中一个字母：a-z或者A-Z中其中一个，例如：var a1　　a1:function(){}  下划线：_，例如：var _a1　　_a1:function(){}美元符号：$，例如：var $a1　　_a1:function(){}注：尽管JavaScript中可以使用中文字符命名，在微信开发工具（版本：0.10.102800）和手机（微信版本：6.3.30）上运行不会报错，但是此处并不建议使用中文命名。代码命名规范根据变量（函数）的功能与用途对其进行命名变量名（函数名）开头使用小写字母使用驼峰命名法命名（适用于变量名中包含多个单词）全局变量使用全大写命名（优点：提高代码可读性）代码命名错误示范没有使用var关键字声明变量（注：调试程序时会报错）变量名（函数名）中出现空格变量名首个字符为数字函数名首个字符为数字或直接用数字命名变量名称随意，降低代码可读性"}
{"title": "练手可用免费API推荐列表及后台配置列表推荐 ", "author": "天下雪", "pub_time": "2016-11-20 00:14", "article_content": "社区征集地址：http://www.wxapp-union.com/forum.php?mod=viewthread&tid=803；假如如下列表不完整，你可以在本文内评论或在原贴内评论增加；增加后，将会在本文正文内加入你推荐的地址及你的名字；@兜兜乐客：后台配置域名建议：由于一个月只有三次配置机会，推荐第一次，就将练手所需的全部配置进去api.weixin.qq.com，这个要加进去愿意的话，api.wxapp-union.com，我们的域名也欢迎加进去，方便以后使用我们的开放api@ 287637915：http://apis.baidu.com非常丰富大量的商业API，商业化小程序必不可少，例如速递速查：http://apis.baidu.com/kuaidicom/express_api/express_api @天下雪：感谢这位同学的建议，我刚发现一个，也顺便提上来：api.github.com好推二维码微信小程序统计地址：wxapi.hotapp.cn聚合数据及百度开放数据列表：聚合的免费API接口数据：手机号码归属地API接口：https://www.juhe.cn/docs/api/id/11历史上的今天API接口：https://www.juhe.cn/docs/api/id/63股票数据API接口：https://www.juhe.cn/docs/api/id/21全国WIFI接口：https://www.juhe.cn/docs/api/id/18星座运势接口：https://www.juhe.cn/docs/api/id/58黄金数据接口：https://www.juhe.cn/docs/api/id/29语音识别接口：https://www.juhe.cn/docs/api/id/134周公解梦接口：https://www.juhe.cn/docs/api/id/64天气预报API接口：https://www.juhe.cn/docs/api/id/73身份证查询API接口：https://www.juhe.cn/docs/api/id/38笑话大全API接口：https://www.juhe.cn/docs/api/id/95邮编查询接口：https://www.juhe.cn/docs/api/id/66老黄历接口：https://www.juhe.cn/docs/api/id/65网站安全检测接口：https://www.juhe.cn/docs/api/id/19手机固话来电显示接口：https://www.juhe.cn/docs/api/id/72基金财务数据接口：https://www.juhe.cn/docs/api/id/28成语词典接口：https://www.juhe.cn/docs/api/id/157新闻头条接口：https://www.juhe.cn/docs/api/id/235IP地址接口：https://www.juhe.cn/docs/api/id/1问答机器人接口：https://www.juhe.cn/docs/api/id/112汇率API接口：https://www.juhe.cn/docs/api/id/80电影票房接口：https://www.juhe.cn/docs/api/id/44万年历API接口：https://www.juhe.cn/docs/api/id/177NBA赛事接口：https://www.juhe.cn/docs/api/id/92百度 api集市免费接口IP地址查询 http://apistore.baidu.com/apiworks/servicedetail/114.html频道新闻API_易源 http://apistore.baidu.com/apiworks/servicedetail/688.html微信热门精选 http://apistore.baidu.com/apiworks/servicedetail/632.html天气查询 http://apistore.baidu.com/apiworks/servicedetail/112.html中国和世界天气预报 http://apistore.baidu.com/apiworks/servicedetail/478.html股票查询 http://apistore.baidu.com/apiworks/servicedetail/115.html身份证查询http://apistore.baidu.com/apiworks/servicedetail/113.html美女图片 http://apistore.baidu.com/apiworks/servicedetail/720.html音乐搜索 http://apistore.baidu.com/apiworks/servicedetail/1020.html图灵机器人 http://apistore.baidu.com/apiworks/servicedetail/736.html汇率转换 http://apistore.baidu.com/apiworks/servicedetail/119.html节假日 http://apistore.baidu.com/apiworks/servicedetail/1116.htmlpullword在线分词服务 http://apistore.baidu.com/apiworks/servicedetail/143.html去哪儿网火车票 http://apistore.baidu.com/apiworks/servicedetail/697.html笑话大全 http://apistore.baidu.com/apiworks/servicedetail/864.html银行卡查询服务 http://apistore.baidu.com/apiworks/servicedetail/735.html语音合成 http://apistore.baidu.com/apiworks/servicedetail/867.html宅言API-动漫台词接口 http://apistore.baidu.com/apiworks/servicedetail/446.html去哪儿景点门票查询 http://apistore.baidu.com/apiworks/servicedetail/140.html手机号码归属地 http://apistore.baidu.com/apiworks/servicedetail/794.html体育新闻 http://apistore.baidu.com/apiworks/servicedetail/711.html手机归属地查询http://apistore.baidu.com/apiworks/servicedetail/709.html科技新闻 http://apistore.baidu.com/apiworks/servicedetail/1061.html空气质量指数 http://apistore.baidu.com/apiworks/servicedetail/116.html天狗健康菜谱 http://apistore.baidu.com/apiworks/servicedetail/987.html热门游记列表 http://apistore.baidu.com/apiworks/servicedetail/520.html天狗药品查询 http://apistore.baidu.com/apiworks/servicedetail/916.html汉字转拼音 http://apistore.baidu.com/apiworks/servicedetail/1124.html国际新闻 http://apistore.baidu.com/apiworks/servicedetail/823.html彩票 http://apistore.baidu.com/apiworks/servicedetail/164.html微信精选 http://apistore.baidu.com/apiworks/servicedetail/863.html天狗健康资讯 http://apistore.baidu.com/apiworks/servicedetail/888.html兴趣点检索 http://apistore.baidu.com/apiworks/servicedetail/182.html用药参考 http://apistore.baidu.com/apiworks/servicedetail/754.html天狗健康知识 http://apistore.baidu.com/apiworks/servicedetail/899.html奇闻趣事 http://apistore.baidu.com/apiworks/servicedetail/633.html花边新闻 http://apistore.baidu.com/apiworks/servicedetail/768.html天狗医院大全 http://apistore.baidu.com/apiworks/servicedetail/988.html生活健康 http://apistore.baidu.com/apiworks/servicedetail/989.html"}
{"title": "小技巧：wx.canvasToTempFilePath与获取屏幕宽高 ", "author": "天下雪", "pub_time": "2016-11-20 12:21", "article_content": "wx.canvasToTempFilePath wx.saveFile官方文档中只有一行，真是坑爹啊，原来wx.canvasToTempFilePath参数为一个对象包括canvasID,success,fail,complete，和wx.saveFile差不多；            wx.canvasToTempFilePath({\r\n              canvasId: 'target',\r\n              success: function success(res) {\r\n                wx.saveFile({\r\n                  tempFilePath: res.tempFilePath,\r\n                  success: function success(res) {\r\n                    console.log('saved::' + res.savedFilePath);\r\n                  },\r\n                  complete: function fail(e) {\r\n                    console.log(e.errMsg);\r\n                  }\r\n                });\r\n              },\r\n              complete: function complete(e) {\r\n                console.log(e.errMsg);\r\n              }\r\n            }); wx.saveFile，保存的图片，我在iphone6上测试，提示保存成功，但在手机相册中无法查看，应该是这个保存功能不够完善，以后可能会出一个保存到相册吧。  **获取设备宽高wx.getSystemInfo(OBJECT)获取系统信息。OBJECT参数说明：参数类型必填说明successFunction是接口调用成功的回调failFunction否接口调用失败的回调函数completeFunction否接口调用结束的回调函数（调用成功、失败都会执行）success回调参数说明：属性说明model手机型号pixelRatio设备像素比windowWidth窗口宽度windowHeight窗口高度language微信设置的语言version微信版本号  **尺寸问题在小程序中，支持还可以使用vw(1%的屏幕宽),vh(1%的屏幕高)，在wxss中虽然使用表达式calc不会报错，但这个值是无效的。尺寸单位rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。设备rpx换算px (屏幕宽度/750)px换算rpx (750/屏幕宽度)iPhone51rpx = 0.42px1px = 2.34rpxiPhone61rpx = 0.5px1px = 2rpxiPhone6 Plus1rpx = 0.552px1px = 1.81rpxrem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。"}
{"title": "入门实战：我的第一个微信小程序 ", "author": "天下雪", "pub_time": "2016-11-20 12:26", "article_content": "1. 前言牛客网第三期编程作业是体验下微信小程序的编写， 由于本菜鸟对前端这块理解并不深入，整起来比较费劲， 突然想到一个idea， 顺手简单实现一下， 基本效果如下： 有点恶搞的成分， 哈哈~~2. 注意点这个问题在于， 没有在utils.js 中将需要的函数进行导出3. 基本实现3.1 项目框架3.2 indexindex.js//index.js//获取应用实例var app = getApp()Page({  data: {    motto: '来让我们看看百度的源码吧',    userInfo: {}  },  //事件处理函数  bindViewTap: function() {    wx.navigateTo({      url: '../source_get/source_get'    })  },  onLoad: function () {    console.log('onLoad')    var that = this    //调用应用实例的方法获取全局数据    app.getUserInfo(function(userInfo){      //更新数据      that.setData({        userInfo:userInfo      })    })  }})index.wxml<!--index.wxml--><view class=\"container\">  <view  bindtap=\"bindViewTap\" class=\"userinfo\">    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>    <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>  </view>  <view class=\"usermotto\">    <text class=\"user-motto\">{{motto}}</text>  </view></view>index.wxss<!--index.wxml-->/**index.wxss**/.userinfo {  display: flex;  flex-direction: column;  align-items: center;}.userinfo-avatar {  width: 128rpx;  height: 128rpx;  margin: 20rpx;  border-radius: 50%;}.userinfo-nickname {  color: #aaa;}.usermotto {  margin-top: 200px;}3.3 source_getsource_get.js<!--index.wxml-->赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              练手可用免费API推荐列表及后台配置列表推荐 \n              微信小程序入门必须掌握的几个知识点 \n            \n             \n            \n                  原作者: 枯萎的海风 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cScFjqsD', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164101|a4ccae98cd7dc26edf9bdf089387042c|2';"}
{"title": "微信小程序入门实战：知识准备及入门实战基础 ", "author": "天下雪", "pub_time": "2016-11-20 14:04", "article_content": "一：知识准备基本的准备工作-知识储备--基础:HTML+JS+CSS--进阶：React、Vue-工具安装--工具由微信官方提供---下载地址：https://github.com/zce/weapp-demo-项目预览>校验环境--根据目录进行操作--在开发者工具预览效果--页面基本结构，几乎每个小程序都是这个结构--nav bar--body--tab bar开发体验阶段-理解微信小程序的架构--开发基础骨架：https://github.com/zce/weapp-boilerplate.git└─ empty-folder/ ·································· 项目所在目录├─ pages/ ······································ 页面目录│ ├─ index/ ··································· index页面│ │ ├─ index.js ······························ index页面逻辑│ │ ├─ index.wxml ···························· index页面结构│ │ └─ index.wxss ···························· index页面样式│ └─ logs/ ···································· logs页面│ ├─ logs.js ······························· logs页面逻辑│ ├─ logs.wxml ····························· logs页面结构│ └─ logs.wxss ····························· logs页面样式├─ utils/ ······································ 公共脚本目录│ └─ util.js ·································· 工具脚本├─ app.js ······································ 应用程序逻辑├─ app.json ···································· 应用程序配置└─ app.wxss ···································· 应用程序公共样式--app.js>用于定义整个应用的逻辑---app函数是一个全局函数---app函数作用就是用来创建一个应用程序实例---每个应用程序都会有他的生命周期--app.json---页面的基本配置信息--app.wxss---css代码，用来设置整个应用的样式-项目配置-页面结构--页面的结构必须由多个文件组成---js文件：定义页面的逻辑；app如上，page也是一个全局函数，用来创建页面对象---json文件：配置文件，根据需求创建，无需求便可不创建，因为页面有页面的配置，应用程序有应用程序的配置。可以不存在，但是应用程序必须配置json文件。---wxml文件：页面结构文件,是XML语法，不是HTML语法。---wxss文件：样式文件。--每个文件夹内的文件名次统一，只有后缀名不同，因为json配置文件中最终会将所有的页面整合成一个页面，-如何完成逻辑和界面-界面如何开发二：入门实战基础课程概要微信小程序基本介绍开发环境及工具的安装配置微信小程序的设计规范微信小程序基本结构分析WXML和WXSS语法规范微信小程序API使用微信小程序访问网络资源完整项目的开发流程Demo 项目地址https://github.com/zce/weapp-demoClone or Download（需准备GIT环境）$ cd path/to/project/root\r\n$ git clone https://github.com/zce/weapp-demo.git project-name --depth 1\r\n$ cd project-name没有git环境，可以直接下载安装开发环境下载地址Windows 64位Windows 32位macOS安装过程对于Windows用户直接双击下一步的方式安装即可，此处注意我们使用的版本是官方最新的版本（不需要破解），可以不用AppID，也就是说没有资格的开发者也可以测试。环境测试以及演示项目安装完成过后通过打开我们已经完成的应用测试环境是否正常开发者工具安装完成后，打开并使用微信扫码登录。选择创建“项目”，填入你在公众平台的AppID，如果没有的话可以点击无AppID。设置一个本地项目的名称（非小程序名称），比如WeApp Demo，并选择一个本地文件夹作为存储目录。接下来点击新建项目就可以在主界面中预览到我们的豆瓣电影示例了小程序开发初体验Hello world希望是一个从零到一的转换过程~创建项目接下来创建一个新的项目，理解小程序项目的基本结构和一些基础语法。官方的开发工具为此准备了一个QuickStart项目。在创建过程中，如果选择的文件夹是个空文件夹，开发者工具会提示：是否需要创建一个quick start项目。选择是，开发者工具会自动帮助我们在开发目录里生成一个简单的项目。借助官方的QuickStart项目完成最基本的Hello world，理解小程序项目的基本结构，学习基础操作与语法。项目结构└─ empty-folder/ ·································· 项目所在目录\r\n├─ pages/ ······································ 页面目录\r\n│ ├─ index/ ··································· index页面\r\n│ │ ├─ index.js ······························ index页面逻辑\r\n│ │ ├─ index.wxml ···························· index页面结构\r\n│ │ └─ index.wxss ···························· index页面样式\r\n│ └─ logs/ ···································· logs页面\r\n│ ├─ logs.js ······························· logs页面逻辑\r\n│ ├─ logs.wxml ····························· logs页面结构\r\n│ └─ logs.wxss ····························· logs页面样式\r\n├─ utils/ ······································ 公共脚本目录\r\n│ └─ util.js ·································· 工具脚本\r\n├─ app.js ······································ 应用程序逻辑\r\n├─ app.json ···································· 应用程序配置\r\n└─ app.wxss ···································· 应用程序公共样式页面结构每个页面组件也分为四个文件组成：[page-name].js页面逻辑文件，用于创建页面对象，以及处理页面生命周期控制和数据处理[page-name].json设置当前页面工作时的window的配置，此处会覆盖app.json中的window设置，也就是说只可以设置window中设置的属性[page-name].wxmlwxml指的是Wei Xin Markup Language用于定义页面中元素结构的，语法遵循XML语法，注意是XML语法，不是HTML语法，不是HTML语法，不是HTML语法[page-name].wxsswxml指的是Wei Xin Style Sheet用于定义页面样式的，语法遵循CSS语法，扩展了CSS基本用法和长度单位（主要就是rpx响应式像素）项目配置相关链接： - 官方文档 - 生成配置文件小程序中的配置文件分为两种：全局配置文件，根目录下的app.json页面配置文件，每个页面目录下的[page-name].jsonapp.json项目配置声明文件（指定项目的一些信息，比如导航栏样式颜色等等）{\r\n// 当前程序是由哪些页面组成的（第一项默认为初始页面）\r\n// 所有使用到的组件或页面都必须在此体现\r\n// https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#pages\r\n\"pages\": [ ... ],\r\n// 应用程序窗口设置\r\n// https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#window\r\n\"window\": { ... },\r\n// 应用导航栏设置\r\n// https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#tabBar\r\n\"tabBar\": { ... },\r\n// 网络超时设置\r\n// https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#networkTimeout\r\n\"networkTimeout\": {},\r\n// 是否在控制台输出调试信息\r\n// https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#debug\r\n\"debug\": true\r\n}[page-name].json用于指定特定页面工作时，window的设置：{\r\n// 导航条背景色\r\n\"navigationBarBackgroundColor\": \"#35495e\",\r\n// 导航条前景色（只能是white/black）\r\n\"navigationBarTextStyle\": \"white\",\r\n// 导航条文本\r\n\"navigationBarTitleText\": \"电影 « 豆瓣\",\r\n// 窗口背景颜色\r\n\"backgroundColor\": \"#fff\",\r\n// 窗口前景色\r\n\"backgroundTextStyle\": \"dark\",\r\n// 是否开启下拉刷新\r\n\"enablePullDownRefresh\": true\r\n}逻辑层分析应用程序逻辑app.jsapp.js作为项目主入口文件，用于创建应用程序对象// App函数是一个全局函数，用于创建应用程序对象\r\nApp({\r\n// ========== 全局数据对象（可以整个应用程序共享） ==========\r\n\r\nglobalData: { ... },\r\n\r\n// ========== 应用程序全局方法 ==========\r\nmethod1 (p1, p2) { ... },\r\nmethod2 (p1, p2) { ... },\r\n\r\n// ========== 生命周期方法 ==========\r\n// 应用程序启动时触发一次\r\nonLaunch () { ... },\r\n\r\n// 当应用程序进入前台显示状态时触发\r\nonShow () { ... },\r\n\r\n// 当应用程序进入后台状态时触发\r\nonHide () { ... }\r\n})也就是说，当应用程序启动时会自动执行项目目录下的app.js文件。在app.js中通过调用全局App([option])方法创建一个应用程序实例。其中通过参数指定的一些特定的方法，会在特定的执行时机去执行，也就是说通常所说的生命周期事件方法。属性 | 类型 | 描述 | 触发时机|------|------|--------- onLaunch | Function | 生命周期函数--监听小程序初始化 | 当小程序初始化完成时，会触发 onLaunch（全局只触发一次） onShow | Function | 生命周期函数--监听小程序显示 | 当小程序启动，或从后台进入前台显示，会触发 onShow onHide | Function | 生命周期函数--监听小程序隐藏 | 当小程序从前台进入后台，会触发 onHide也可以定义任意其他的对象成员（例如：方法和属性），这些成员可以在内部直接使用，或者外部通过获取app对象调用：属性 | 类型 | 描述|------|------ 其他 | Any | 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问，一般用于存放业务逻辑配置，比如：API地址app.jsApp({\r\ndata1: '123',\r\ndata2: { message: 'hello world' },\r\napi: {\r\nlist: 'https://github.com/zce/',\r\ndetail: 'https://github.com/zce/',\r\n},\r\nfoo () {\r\nreturn 'bar'\r\n}\r\n})other.js// getApp 也是全局函数，可以在任意地方调用，用于获取全局应用程序实例对象\r\nvar app = getApp()\r\nconsole.log(app.data1)\r\nconsole.log(app.data2)\r\nconsole.log(app.foo())页面逻辑[page-name].js[page-name].js是一个页面的重要组成部分，用于创建页面对象// 获取全局应用程序对象\r\nconst app = getApp()\r\n\r\n// Page也是一个全局函数，用来创建页面对象\r\nPage({\r\n// ========== 页面数据对象（可以暴露到视图中，完成数据绑定） ==========\r\ndata: { ... },\r\n\r\n// ========== 页面方法（可以用于抽象一些公共的行为，例如加载数据，也可以用于定义事件处理函数） ==========\r\nmethod1 (p1, p2) { ... },\r\nmethod2 (p1, p2) { ... },\r\n\r\n// ========== 生命周期方法 ==========\r\n// 页面加载触发\r\nonLoad () { ... }\r\n\r\n...\r\n})在应用程序执行到当前页面时，会执行当前页面下对应的[page-name].js文件。 在[page-name].js中通过调用全局Page([option])方法创建一个页面实例。Page([option])方法[option]参数说明属性 | 类型 | 描述| ---- | ---- data | Object | 页面的初始数据 onLoad | Function | 生命周期函数--监听页面加载 onReady | Function | 生命周期函数--监听页面初次渲染完成 onShow | Function | 生命周期函数--监听页面显示 onHide | Function | 生命周期函数--监听页面隐藏 onUnload | Function | 生命周期函数--监听页面卸载 onPullDownRefreash | Function | 页面相关事件处理函数--监听用户下拉动作 其他 | Any | 开发者可以添加任意的函数或数据到 object 参数中，用 this 可以访问视图层分析[page-name].wxml页面结构WXML（WeiXin Markup Language）是MINA框架设计的一套标签语言，基于XML。结合一些基础组件、事件系统、模板数据绑定，可以构建出页面的结构。简单来说：wxml ≈ xml + 事件系统 + 模板引擎例如：// js\r\nPage({\r\ndata: {\r\ntodos: [\r\n{ text: 'JavaScript', completed: false },\r\n{ text: 'JavaScript+', completed: false },\r\n{ text: 'JavaScript++', completed: false }\r\n]\r\n},\r\ncompleted (e) { ... }\r\n})<!-- wxml -->\r\n<view>\r\n<view wx:for=\"{{ todos }}\">\r\n<block wx:if=\"{{ !item.completed }}\">\r\n<text>{{ item.text }}</text>\r\n<button bindtap=\"completed\" data-item-index=\"{{ index }}\"> √ </button>\r\n</block>\r\n</view>\r\n</view>[page-name].wxss页面样式WXSS（WeiXin Style Sheets）是MINA框架设计的一套标签语言，基于XML。WXSS用来决定了在WXML中定义的组件应该怎么显示。为了适应广大的前端开发者，我们的WXSS具有CSS大部分特性。 同时为了更适合开发微信小程序，我们对CSS进行了扩充以及修改。与CSS相比我们扩展的特性有：尺寸单位样式导入（CSS也有）尺寸单位rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。设备 | rpx换算px (屏幕宽度/750) | px换算rpx (750/屏幕宽度) | rem换算rpx (750/20)| ------------------------ | ------------------------ | ------------------------ iPhone5 | 1rpx = 0.42px | 1px = 2.34rpx | 1rem = 37.5rpx iPhone6 | 1rpx = 0.5px | 1px = 2rpx | 1rem = 37.5rpx iPhone6s | 1rpx = 0.552px | 1px = 1.81rpx | 1rem = 37.5rpx建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。样式导入使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。@import \"common.wxss\";\r\ntext {\r\nbackground-color: #ff0;\r\n}选择器目前只支持如下选择器选择器 | 样例 | 样例描述| ---- | -------- .class | .intro | 选择所有拥有 class=\"intro\" 的组件id | #firstname | 选择拥有 id=\"firstname\" 的组件element | view | 选择所有 view 组件 element, element | view | checkbox 选择所有文档的 view 组件和所有的 checkbox 组件 ::after | view::after | 在 view 组件后边插入内容 ::before | view::before | 在 view 组件前边插入内容全局样式与局部样式定义在app.wxss中的样式为全局样式，作用于每一个页面。在[page-name].wxss文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖app.wxss中相同的选择器。小程序开发中，我们JS代码的组织方式就是以CommonJS的规范来组织"}
{"title": "微信小程序入门必须掌握的几个知识点 ", "author": "天下雪", "pub_time": "2016-11-20 15:04", "article_content": "小程序配置app.json文件小程序设置全局配置 ，包括页面路径、窗口、选项卡，以及网络超时等{\r\n  \"pages\": [\r\n    \"pages/index/index\",\r\n    \"pages/logs/index\"\r\n  ],\r\n  \"window\": {\r\n    \"navigationBarTitleText\": \"Demo\"\r\n  },\r\n  \"tabBar\": {\r\n    \"list\": [{\r\n      \"pagePath\": \"pages/index/index\",\r\n      \"text\": \"首页\"\r\n    }, {\r\n      \"pagePath\": \"pages/logs/logs\",\r\n      \"text\": \"日志\"\r\n    }]\r\n  },\r\n  \"networkTimeout\": {\r\n    \"request\": 10000,\r\n    \"downloadFile\": 10000\r\n  },\r\n  \"debug\": true\r\n}\r\n通过appapp.js文件中App()来注册一个小程序 提供了生命周期方法App({\r\n  onLaunch: function() { \r\n    // Do something initial when launch.\r\n  },\r\n  onShow: function() {\r\n      // Do something when show.\r\n  },\r\n  onHide: function() {\r\n      // Do something when hide.\r\n  },\r\n  globalData: 'I am global data'\r\n})\r\n通过全局的getApp()函数，获取小程序实例// other.js\r\nvar appInstance = getApp()\r\nconsole.log(appInstance.globalData) // I am global data\r\n注意：App() 必须在 app.js 中注册，且不能注册多个。不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。不要在 onLaunch 的时候调用 getCurrentPage()，此时 page 还没有生成。通过 getApp() 获取实例之后，不要私自调用生命周期函数。通过Page() 函数用来注册页面//index.js\r\nPage({\r\n  data: {\r\n    text: \"This is page data.\"\r\n  },\r\n  onLoad: function(options) {\r\n    // Do some initialize when page load.\r\n  },\r\n  onReady: function() {\r\n    // Do something when page ready.\r\n  },\r\n  onShow: function() {\r\n    // Do something when page show.\r\n  },\r\n  onHide: function() {\r\n    // Do something when page hide.\r\n  },\r\n  onUnload: function() {\r\n    // Do something when page close.\r\n  },\r\n  onPullDownRefresh: function() {\r\n    // Do something when pull down.\r\n  },\r\n  onReachBottom: function() {\r\n    // Do something when page reach bottom.\r\n  },\r\n  // Event handler.\r\n  viewTap: function() {\r\n    this.setData({\r\n      text: 'Set some data for updating view.'\r\n    })\r\n  },\r\n  customData: {\r\n    hi: 'MINA'\r\n  }\r\n})\r\n小程序常用API接口wx.request https网络请求wx.request({\r\n  url: 'test.php', //仅为示例，并非真实的接口地址\r\n  method:\"GET\",\r\n  data: {\r\n     x: '' ,\r\n     y: ''\r\n  },\r\n  header: {\r\n      'content-type': 'application/json'\r\n  },\r\n  success: function(res) {\r\n    console.log(res.data)\r\n  }\r\n})\r\n本地缓存通过key的形式添加缓存setStorage （异步接口）wx.setStorage({\r\n  key:\"key\"\r\n  data:\"value\"\r\n})\r\n通过key的形式获取缓存getStorage （异步接口）wx.getStorage({\r\n  key: 'key',\r\n  success: function(res) {\r\n      console.log(res.data)\r\n  } \r\n})\r\n从本地缓存中异步移除指定 keywx.removeStorage({\r\n  key: 'key',\r\n  success: function(res) {\r\n    console.log(res.data)\r\n  } \r\n})\r\n清理本地数据缓存wx.clearStorage()\r\n显示、隐藏消息提示框wx.showToast({\r\n  title: '加载中',\r\n  icon: 'loading',\r\n  duration: 10000\r\n})\r\n\r\nsetTimeout(function(){\r\n  wx.hideToast()\r\n},2000)\r\n动态设置当前页面的标题wx.setNavigationBarTitle({\r\n  title: '当前页面'\r\n})\r\n导航保留当前页面，跳转到应用内的某个页面wx.navigateTo({\r\n  url: 'test?id=1'\r\n})\r\n关闭当前页面，跳转到应用内的某个页面wx.redirectTo({\r\n  url: 'test?id=1'\r\n})\r\n获取用户信息，需要先调用 wx.login 接口wx.getUserInfo({\r\n  success: function(res) {\r\n    var userInfo = res.userInfo\r\n    var nickName = userInfo.nickName\r\n    var avatarUrl = userInfo.avatarUrl\r\n    var gender = userInfo.gender //性别 0：未知、1：男、2：女 \r\n    var province = userInfo.province\r\n    var city = userInfo.city\r\n    var country = userInfo.country\r\n  }\r\n})\r\n设备获取网络类型wx.getNetworkType({\r\n  success: function(res) {\r\n    var networkType = res.networkType // 返回网络类型2g，3g，4g，wifi\r\n  }\r\n})\r\n获取系统信息（异步接口）wx.getSystemInfo({\r\n  success: function(res) {\r\n    console.log(res.model)\r\n    console.log(res.pixelRatio)\r\n    console.log(res.windowWidth)\r\n    console.log(res.windowHeight)\r\n    console.log(res.language)\r\n    console.log(res.version)\r\n  }\r\n})\r\n拨打电话wx.makePhoneCall({\r\n  phoneNumber: '1340000' //仅为示例，并非真实的电话号码\r\n})\r\n获取当前的地理位置、速度wx.getLocation({\r\n  type: 'wgs84',\r\n  success: function(res) {\r\n    var latitude = res.latitude\r\n    var longitude = res.longitude\r\n    var speed = res.speed\r\n    var accuracy = res.accuracy\r\n  }\r\n})"}
{"title": "滴滴出行在小程序里的实践 ", "author": "天下雪", "pub_time": "2016-11-21 01:07", "article_content": ""}
{"title": "「微信小程序」入坑总结：相关demo：仿one ", "author": "天下雪", "pub_time": "2016-11-17 10:50", "article_content": "相关demo地址：http://www.wxapp-union.com/forum.php?mod=viewthread&tid=437前段时间去了广州参加了关于「微信小程序」的技术沙龙，整场下来收获颇多。实际上微信小程序刚刚发布出来的时候就关注，弄了破解了的开发工具，跑了个官方的 Demo。听完回来之后就想着挖个相关的坑，正好看到手机上的 「ONE · 一个」。上网找到了 ONE 的接口，打算搞一个仿照 ONE 官方 APP 的小程序，最后就有了 weapp-one 这个项目。关于小程序微信小程序不是 Web 也不是 Native，尝试之后给我的感觉有点像是 weex。因为之前尝试 weex 的时候是下载一个 APP，然后通过应用内扫码来运行对应的应用。这一点上小程序类似。在沙龙上有位分享嘉宾有提到，小程序实际上是在 Webview 之上再加上一层原生的组件。例如底部的 tabbar 以及顶部的 navbar 就是原生的。还有小程序的 map 组件，是调用原生的 map 组件。请求限制一开始就遇到了问题，ONE 官方的接口是 http 的，而且是 8000 这个端口。微信小程序对发送的请求有限制，必须是 https（在本地开发可以用 http），而且不能带端口号。所以我就使用了比较暴力的方法，把开发工具中对应用来限制的代码给注释掉了，反正只是用来体验一下小程序开发，所以就无所谓了。添加页面在小程序中添加页面都需要将路径添加到 app.json 中的 page 项中，否则会找不到页面。与 Vue 类似，每个小程序页面包含 page.js，page.wxml，page.wxss，分别对应脚本，模板以及样式。还可以添加一个 page.json 对页面进行单独配置，比如配置 navigationBarTitleText 来改变导航上的文字显示，诸如此类的对页面的窗口表现配置。奇怪的组件view、text在 wxml 里面写的是类似 HTML 的标签，标准的 HTML 标签是无法使用的。只能使用微信小程序官方的组件，组件对应有一些属性或事件可以调用。有类似于 <div> 的 <view> 组件，基本上页面上的组件都会被<view> 包裹住。然后文字方面是使用 <text>，虽然直接显示文字也没什么问题。不过我还是把所有的文字都加上了 <text>标签。image说起组件，微信小程序里最让我不爽的就是 <image> 这个组件了。给这个组件一个图片地址之后，默认的样式不是图片的大小，而是固定的 300px * 225px。与 HTML 中的 <img> 完全不同，用起来有点不舒服。<image> 组件还提供了不同显示方式的 mode，不过用起来还是觉得怪怪的。audio音频播放的话有 <audio> 这个组件，但是这个组件的样式好像是固定的，类似于在网页也加上网易云音乐的外链那样。不过幸好有音频播放相关的 api 可以用，这样就可以当用户触发某些操作的时候播放音频，即可实现播放按钮点击后播放音频。微信小程序在播放音频的时候，开发工具上会出现对应的音乐栏，可以对播放的音频进行播放/暂停。猜猜在真机上使用时，会在通知栏出现音频控制。上面会显示音频的作者以及歌曲名称。但是在实际使用中有一点比较尴尬，使用调用 api 的方式播放音频没有设置音频作者的选项。详情可以见 音乐播放控制 · 小程序video相较与 HTML5 中的 <video> 标签，微信小程序中的 <video> 组件缺失了很多东西，例如 loop 与 poster。也就是说无法在用户点击播放按钮前显示特定的图像，只能是显示视频最开头。<video> 组件同样有默认的尺寸 300px * 225px，但没有 <image> 组件中的显示模式的设置。未全屏状态下，在不同的分辨率上，上下或者左右可能会存在黑边。特殊的 rpx微信小程序中有特有的一个尺寸单位 —— rpx，1rpx 表示屏幕宽度的 1/750 大小，也就是说，100% 宽度就是 750rpx。还有一个会被忽略的尺寸单位 —— rem，与 Web 中的 rem 不同，1rem 表示屏幕宽度的 1/20 大小。在高度上使用 rpx 的话，也会根据屏幕的宽度的大小而改变。我更倾向与宽度使用 rpx 而高度使用 rem，不过其实比较喜欢用 px 来写样式，这可能算是一个不好的习惯。实现滑至最右切换页面在仿照 ONE 写微信小程序的时候遇到了一个问题，使用滑块视图组件 <swiper> 去显示每日图文，一共10个图文，当滑动至最右时切换到选择往期列表的页面。如下图所示：但是 <swiper> 组件并没有提供对应的事件，使用就自己实现了一个。主要是使用滑块视图每一次切换视图时都会触发一个 bindchange 事件，还有设置滑块视图显示位置的 current 属性。在 <swiper> 组件中添加一个空的 <swiper-item> 子组件，当滑动到这个空的子组件的时候使用wx.navigateTo 这个 api 去切换到往期列表这个页面。同时将滑块视图的显示位置设置到倒数第二个，即最后一个非空的子组件。这样就实现了滑动至最右切换页面的功能，同时在点击返回的时候显示的也是滑块视图中的最后一个有内容的子组件。具体实现代码如下：12345678910111213141516171819202122232425Page({  data: {    current: 0  },  // ......  // more code  handleChange: function (e) {    let current = e.detail.current    let length = this.data.vols.length    if (current === length) {      this.setData({        current: length      })      wx.navigateTo({        url: '../history/history?page=index',        success: () => {          this.setData({            current: length - 1          })        }      })    }  }})这里使用了两次 this.setData 是因为在第二次执行上面的滑动切换页面再返回的时候，显示的子组件并不是最后一个非空的子组件，而是最后的那个空子组件。大概原因是因为第二次执行这个操作的时候，current并没有更新。所以解决的方案是在每次修改 current 之前修改一次它的值，使得后面修改 current 值时会触发视图的更新。"}
{"title": "TITF：tabBar的使用小技巧（附数据绑定一个对象到数组中，然后取值的一个注意点） ... ", "author": "天下雪", "pub_time": "2016-11-17 11:05", "article_content": "本文来自公众号：TITF一：tabBar的使用小技巧原理：在app.json中配置tabBar属性3、关键代码  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15\"tabBar\": {    \"color\":\"#666666\",    \"selectedColor\":\"#06bd04\",    \"list\": [{      \"pagePath\": \"index\",      \"text\": \"首页\",      \"iconPath\": \"images/index.png\",      \"selectedIconPath\": \"images/indexHL.png\"    },{      \"pagePath\": \"picDisplay\",      \"text\": \"图片展示\",      \"iconPath\": \"images/picDisplay.png\",      \"selectedIconPath\": \"images/picDisplayHL.png\"    }]  } 来自CODE的代码片snippet_file_0.txt4、操作方法新建一个项目，打开app.json文件，将关键代码复制到\"window\":{},后面，注意window的大括号前加逗号，如下图配置tabBar属性值  1\r\n  2\r\n  3\r\n  4\r\n  5\r\n  6\r\n  7\r\n  8\r\n  9\r\n 10\r\n 11\r\n 12\r\n 13\r\n 14\r\n 15\r\n 16\r\n 17\r\n 18\r\n 19\r\n 20\r\n 21\r\n 22 \"tabBar\": {    //设置tabBar文字默认颜色    \"color\":\"#666666\",    //设置tabBar文字被选中是的颜色    \"selectedColor\":\"#06bd04\",    //tab列表，数组类型，改数组内至少要有两个但不大于5个的tab对象    \"list\": [{      //设置tab跳转页面链接      \"pagePath\": \"index\",      //设置tab上的文字      \"text\": \"首页\",      //设置tab上的默认图标      \"iconPath\": \"images/index.png\",      //设置tab被选中时的图标      \"selectedIconPath\": \"images/indexHL.png\"    },{      \"pagePath\": \"picDisplay\",      \"text\": \"图片展示\",      \"iconPath\": \"images/picDisplay.png\",      \"selectedIconPath\": \"images/picDisplayHL.png\"    }]  }二：数据绑定一个对象到数组中，然后取值的一个注意点（分享者：guonei001）通过wx.request获取到服务器数据之后将数据(一个json对象)绑定至post数组，然后页面中获取数据的时候可以直接通过（数组名.属性）直接取值。数组中有多个json对象的话，则需要wx:for遍历取值。单个json对象数据绑定页面取值："}
{"title": "咔咔大韦：微信小程序 quick start项目解析 ", "author": "天下雪", "pub_time": "2016-11-17 11:09", "article_content": "很有意思的是微信自己的语言竟然是抄袭，wxml相当于html，把ht换成了wx  ，wxss相当于css，把c换成了wx而已。pages是存放网页的地方。utils是微信小程序的js工具类app.js是小程序的脚本代码app.json是小程序配置文件app.wxss是小程序样式表//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    //调用API从本地缓存中获取数据\r\n    var logs = wx.getStorageSync('logs') || []\r\n    logs.unshift(Date.now())\r\n    //将logs存储到缓存中\r\n    wx.setStorageSync('logs', logs)\r\n  },\r\n  getUserInfo:function(cb){\r\n    var that = this;\r\n   //如果能获取用户信息\r\n    if(this.globalData.userInfo){\r\n      typeof cb == \"function\" && cb(this.globalData.userInfo)\r\n    }else{\r\n      //如果不能获取用户信息\r\n      赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序的缓存策略分析 \n              如何在微信小程序里面实现跨页面通信？ \n            \n             \n            \n                  原作者: 咔咔大韦 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSPE9lV3', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n一周热门\r\n\r\n\r\n认识小程序云开发2019-02-21小程序 setData 为什么不能频繁设置2019-02-20小程序的登录与静默续期2019-02-22微信小程序特殊字符转义方法——&转义&amp;2019-02-20java后台的微信小程序支付的解决方案2019-02-21小程序的诞生2019-02-21微信小程序自定义组件的关键记录2019-02-20django与小程序实现登录验证功能2019-02-20实战·使用taro+云开发快速开发小程序2019-02-22\r\n\r\n\n     \n      \r\n推荐主题\r\n\r\n\r\n微信小程序webpack插件：支持分包，支持新2019-02-26共享充电线2019-02-26微信小程序Demo：群应用（群通知、群接龙、2019-02-15ThinkPHP5.0精仿网易严选微信小程序+前后端2018-04-25答题小程序(排名,错题集,倒计时,后台自定义2018-12-26新版博客小程序2019-01-15日历中如何实现左右切换的功能2019-02-25博客小程序2018-12-19个人小程序分享2019-01-29需要一个查询物流的小程序2019-02-22\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164110|1679e167cc8f95494290141bb4b4ab7c|2';"}
{"title": "微信小程序：开发之前要知道的三件事 ", "author": "天下雪", "pub_time": "2016-11-17 11:13", "article_content": "前言微信之父张小龙在年初的那次演讲中曾表示：“我自己是很多年的程序员，我觉得我们应该为开发的团队做一些事情”。几个月后，微信正式推出微信应用号（即微信小程序），在互联网中掀起了又一波热潮。 于是，很多人准备要开发微信的小程序，如果你真的想要开发小程序，就要先学会一套微信特制的“开发语言”。为了更好地上手这门开发语言，下面这三件事你一定要知道：语言与文件微信小程序来发与其他平台开发的最大差异在于：微信使用的开发语言和文件很“个性”。 小程序所使用的程序文件类型大致分为以下几种：WXML（WeiXin Mark Language， 微信标记语言）WXSS（WeiXin Style Sheet，微信样式表）JS（JavaScript， 小游戏的主体）在语言方面，下程序看似重新定义了一套标准。但实际上，他们与“前端三件套”（HTML、CSS和JavaScript）差不太多。来来来，看一下微信小程序开发语言和“前端三件套”的异同点。 界面搭建1、基本逻辑WXML和WXSS两种文件是小程序界面元素声明及样式描述文件。WXML最大的特点是以视图（View）的方式串联界面元素，并通过程序逻辑（AppService）将信息更新实时传递至视图层。View类似于HTML中的div元素，在构建的时候，View可以被多级嵌套，View内可以放置任意视觉元素。需要注意的是，元素一旦超出屏幕之外，用户就无法看到了，这是与HTML哟较大的不同。小程序哟专门用于滚动的视图。如果希望界面是一个可以自由滚动的界面（例如列表等），可以使用scroll-view视图，在WXSS中将其大小调整为整个屏幕，并设置scroll-y（上下滚动）或scroll-x（左右滚动）为true，注意，小程序中不能直接使用DOM控制WXML元素。如果需要进行数据更新，就要使用WXML提供的数据绑定及元素渲染方法，还有一点，小程序的栅格排版系统使用的是Flex布局，它是W3C在2009年提出的一种排版标准。2、绑定数据对于单个字段，开发者可以使用数据绑定的方法进行信息更新。绑定的数据除了在加载的时候可以更新，也可以在JS主程序中以函数形式进行更新，更新同样可以反应到界面上被绑定的数据中。3、条件渲染与列表（循环）渲染条件渲染适用于有意外情况提示的页面（如无法加载列表或详情时，做出提示等等）。它的渲染带有触发条件，即符合条件时渲染这个页面，否则忽略或渲染另一端代码。两个花括号所包含的判断条件中的变量于主程序JS代码中的data中声明。将同一元素渲染代码进行集合。循环的数据可以通过数组的方式写入data中供WXML访问。渲染完毕后，渲染判断条件的变动可以影响界面变动。4、模板与引用WXML支持使用模板与引用减少代码体积。模板是在WXML代码中对相同的代码进行复用的方式。可以将多个模板写入至同一个文件，并使用import在其他文件中进行引用。如果需要整个页面引用，需要使用include。5、样式通过WXSS样式表，开发者可以定义WXML中的元素样式。WXSS与CSS代码一样，可以直接使用选择器选择元素，在WXML中也可以直接定义元素的id和class以便于在WXSS文件中进行样式定义。6、用户操作与事件响应由于微信使用的不是HTML，所以也不能通过添加超链接（a元素）的方式来检测用户的点击事件。对于需要监听点击事件的元素，应该在WXML中使用bindtap属性或catchtap属性进行绑定。除了点击一次，微信也提供按住、开始触摸、松手等事件响应。在WXML中绑定好一个事件之后，就能在主程序中使用。其他的API中也有相应的事件，这些事件乐意在微信小程序的官方文档中查阅到。当需要在小程序的页面间进行跳转时，应该使用wx.navigateTo()方式。 注意，有关于页面层级跳转，微信将层级跳转限制在5层。在开发时一定注意不要超过了相应限制。网络请求方式网络访问小程序支持三种请求方式：HTTP连接、WebSocket、文件收发连接。HTTP连接：请求后直接返回结果，连接结束；Socket连接：持续性连接，当一方主动关闭连接时，连接结束；文件收发连接：顾名思义，发生在文件传输时的连接。（录制的语音和选择的照片都需要这个连接完成）。注意，通过小程序访问网络需要服务器必须支持HTTPS连接，且端口必须为443。同时，小程序只能访问开发者在登记小程序时设定的服务器地址。开发语言和“前端三件套”的异同点HTML与WXML：两者差异比较大，如果之前没有接触过Android开发，可能会觉得有些头疼。事实上，WXML更像是Android开发中的界面XML描述文件，适合于程序界面的构建；而HTML则倾向于文章的展示（这与HTML的历史有关），以及互联网页面的构建。WXSS与CSS：两者在语言上几乎没有差别，可以直接通用。JS文件：小程序的JS文件与前端开发使用的JS几乎没有区别，只是小程序的JS新增了微信的一些API接口，并去除了一些不必要的功能（如DOM）。在有眼上，小程序完全向学习成本最低的前端开发看齐，但这不代表所有开发者都能无缝迁移。如果你是从前端开发转向小程序，就要注意这两点：1、HTML与WXML两种文件的构建思想差异较大，如果之前只接触过前端开发，需要一点时间才能适应WXML的编写方法。2、虽然小程序使用的是前端语言，但不代表可以继续沿用的开发思想进行开发。小程序对前端开发的要求从【构建界面】升级成【开发完整应用】，前端开发需要在意识上进行转变。"}
{"title": "微信小程序购物商城系统开发系列《一》目录结构 ", "author": "天下雪", "pub_time": "2016-11-17 15:45", "article_content": "作者灵动生活，的实战开发系列，一步步带领你完成开发任务：相信大家都已经蠢蠢欲试建立一个自己的小程序，去完成一个独立的商城网站。先别着急我们一步步来，先尝试下写一个自己的小demo.这一篇文章我们主要的是介绍一下小程序的一些目录结构，以及一些语法，为我们后面的微信小程序商城系统做铺垫。首先我们来了解下小程序的目录结构 Pages 我们新建的一些页面将保存在这个文件夹下面，每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js后缀的文件是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件，.wxml后缀的文件是页面结构文件。Utils 我们写的一些公共的工具js可以放里面。app.js 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。{\r\n\r\n  \"pages\":[\r\n\r\n    \"pages/index/index\",\r\n\r\n    \"pages/logs/logs\"\r\n\r\n  ],\r\n\r\n  \"window\":{\r\n\r\n    \"backgroundTextStyle\":\"light\",\r\n\r\n    \"navigationBarBackgroundColor\": \"#fff\",\r\n\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n\r\n    \"navigationBarTextStyle\":\"black\"\r\n\r\n  }\r\n\r\n} 注：app.json中是对整个小程序的全局设置，当然每个页面也有自己的json文件。每个页面下的json文件只能对window 进行设置，所以页面json文件下只需写入window的配置即可{\r\n\r\n    \"backgroundTextStyle\":\"light\",\r\n\r\n    \"navigationBarBackgroundColor\": \"#fff\",\r\n\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n\r\n    \"navigationBarTextStyle\":\"black\"\r\n\r\n  }\r\n\r\n  app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。每个页面中也可以定义自己的wxss。Wxss也就是微信所提供的css样式表，里面的写法几乎和css差不多。不过他支持的选择器相对比较少。在写的时候我们以前的一些项目的css 基本可以拿过来用，不过除了下面这些选择器外，你使用了其他的选择器，可能使整个页面报错! Index.whtml  wxml后缀的文件夹也就是微信小程序提供给我们的页面结构文档，就相当于我们以前的web页面的html 差不多，只不过他自定义了一些自己的标签。 接下来我们就新建一个页面来尝试下 在pages 下新建页面test 注意新建的.js,.json,.xml,.wxss。和page 下定义的 test文件夹名称保持一致，微信微信小程序会自动读取这些文件，并生成小程序实例。首先我们要在app.json下配置好我们刚新建的页面注意:页面配置先后的顺序，在实际操作中发现，第一个配置的为首页。配置好后我们就可以编写我们的页面代码。 大家可以看到，我们在app.json 页面可以直接配置当前页面的一些window属性 Wxml 中我们可以编写一些我们页面展示的结构，也就是我们以前写html一样。这中间我们使用到了 <view> 标签，他就相当于我们以前用的div 差不多。 Wxss 大家看到是不是和我们以前写的css 差不多。这边是个我们之前定义的 .box 加一个样式。test.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。  这边我们使用bintap给view绑一个点击事件然后再弹出一个提示框。注意：这边js的写法和我们以前的写法完全一样，只不过这里面不能使用window对象和document对象，同样的也不能使用jquery ,zepto等框架，因为这些框架中会使用到window和document 对象。好啦！今天只是给大家简单介绍下小程序的目录结构和简单的使用了下，下一节我们会来开始我们商城系统的编写。"}
{"title": "微信小程序之注册配置详解 ", "author": "天下雪", "pub_time": "2016-11-17 15:49", "article_content": "小程序页面结构\r\npagespages/app.js（小程序注册入口）pages/app.json（小程序路由配置以及app窗口设置）pages/app.wxss（小程序公共样式）pages/moduleName/moduleName.js（小程序模块应用逻辑，MVC中的Model和Control）pages/moduleName/moduleName.json（小程序应用模块的窗口配置，会覆盖app.json的窗口配置）pages/moduleName/moduleName.wxml(小程序应用模块页面)pages/moduleName/moduleName.wxss（小程序应用模块样式）\r\n小程序框架与MVC简述\r\n\r\n\r\n小程序框架\r\n小程序划分为视图层（View）和逻辑层（AppService）的两层框架，并在视图层和逻辑层之间提供  数据传输和事件系统。严格意义上，按照MVC的框架模式而言，小程序的逻辑层包含MVC中的Model以及Controller.\r\n\r\n\r\nMVC简述\r\n\r\nView有两层作用，其一是负责从Model层接收、渲染和显示数据;其二是负责接受和传递数据到Controller层；\r\nController也有两层作用，其一是接收View层抑或是请求URL传递的表单数据，并对表单数据进行控制校验，其二是处理用户交互体验效果，比如在View进行动画效果设置、滚动加载体验等；\r\nModel层,负责接受Controller传输的数据并对数据进行逻辑处理后返回给View层。\r\n\r\n\r\n\r\nMVC优点\r\n其一，分层的设计有助于管理复杂的应用程序，将数据逻辑与界面显示分离，有助于后期针对相应的层级维护和管理；其二，简化分组开发，能够独让负责不同业务模块的开发者进行模块化功能开发，并行推进项目进度\r\n\r\n\r\n小程序入口文件app.js、app.json以及app.wxss\r\n\r\n\r\napp.js,小程序入口配置\r\n  App({\r\n    onLaunch: function() { \r\n      //小程序生命周期初始化，全局加载(调用)一次，一般是用于程序启动时加载应用共享资源，\r\n    },\r\n    onShow: function() {\r\n      //当小程序启动，或从`后台进入前台显示`，会触发 onShow，监听小程序显示，会被调用多次\r\n    },\r\n    onHide: function() {\r\n       //当小程序从前台进入后台时，会触发onHide事件，会被调用多次\r\n\r\n    },\r\n    globalData: 'I am global data'\r\n  })\r\n\r\n前台：指重新打开小程序显示，即从退出当前应用，用户又打开该应用\r\n后台：是指退出小程序应用（并非完全退出或关闭），相当于按手机返回键退出当前应用，但是小程序还在所谓的【后台】运行\r\nApp() 必须在 app.js 中注册，且不能注册多个\r\n不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例\r\n不要在 onLaunch 的时候调用 getCurrentPage()，此时 page 还没有生成\r\n通过 getApp() 获取实例之后，不要私自调用生命周期函数,即onLaunch,onShow,onHide这三个周期函数,自定义的函数是不属于周期函数范围内    \r\n\r\n\r\n\r\napp.json,小程序应用模块的路由配置、窗口以及Tab配置，#仅作为注释说明，实际配置应该去掉\r\n  {\r\n      \"pages\":[\r\n          \"page/index/index\",    ##page配置的数组的第一项作为小程序的初始页面\r\n          \"page/logs/logs\"    \r\n      ],    \r\n\r\n      \"window\":{\r\n          ## 配置导航条\r\n          \"navigationBarBackgroundColor\":\"#9084cc\", ##背景颜色，HexColor类型（16进制颜色值）\r\n          \"navigationBarTextStyle\":\"dark\",##标题颜色，仅支持dark/white\r\n          \"navigationBarTitleText\":\"我的订单\",##标题内容,String\r\n\r\n          ## 配置窗口\r\n          \"backgroundColor\":\"#909902\",##窗口背景色，HexColor类型\r\n          \"backgroundTextStyle\":\"dark\",##下拉背景字体,String,仅支持 dark/light\r\n\r\n          \"enablePullDownRefresh\"true，##是否开启下拉刷新\r\n      },\r\n\r\n      \"tabBar\":{\r\n          \"color\":\"\",                ##tab 上的文字颜色\r\n          \"selectedColor\":\"\",    ##tab 上的文字选中时的颜色\r\n          \"backgroundColor\":\"\",    ##tab 的背景色\r\n          \"borderStyle\":\"\",        ##tabbar上边框的颜色， 仅支持 black/white\r\n\r\n          ##tab 的列表，最少2个、最多5个 tab\r\n          \"list\":[\r\n              {\r\n                  \"pagePath\":\"\",            ##页面路径，必须在 pages 中先定义\r\n                  \"text\":\"\",                ##tab 上按钮文字\r\n                  \"iconPath\":\"\",            ##图片路径，icon 大小限制为40kb \r\n                  \"selectedIconPath\":\"\"  ##选中时的图片路径，icon 大小限制为40kb\r\n              },\r\n          ]\r\n      },\r\n\r\n      ##时间单位 「毫秒」\r\n      \"networkTimeout\":{\r\n          \"request\":3000,           ##    wx.request的超时时间\r\n          \"connectSocket\":5000, ## wx.connectSocket的超时时间\r\n          \"uploadFile\":10000,    ## wx.uploadFile的超时时间\r\n          \"downloadFile\":10000  ## wx.downloadFile的超时时间\r\n      },\r\n\r\n      ##开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有Page的注册，页面路由，数据更新，事件触发 \r\n      \"debug\":true\r\n  }\r\n\r\npages是属于Array类型，Array的每一项都是url的字符串，url为相对根目录下的module路径，无需扩展名，框架会自动加载module下的js、wxml、wxss、json文件\r\n配置的pages下的module的js,wxss,json，wxml必须为相同的名称，框架会根据module名称自动加载上述的扩展名文件\r\ntab上的list，最少2个、最多5个\r\n\r\n\r\n\r\napp.wxss \r\n  app.wxss\r\n  /**定义的样式将应用到小程序所有的模块中**/\r\n  view,image,scroll-view,text{\r\n  margin: 0px;\r\n  padding: 0px;\r\n  }\r\n  .headerView{\r\n  width: 100%;\r\n  height: 32px;\r\n  background: floralwhite;\r\n  }\r\n  /**其他样式**/\r\n  .....\r\n\r\n\r\n尺寸单位\r\n\r\nresponsive pixel,即rpx,响应式像素，是一种能够提供各种设备都能阅读的一种设计方法,在微信小程序中，以iphone6作为屏幕标准，1rpx = 0.5px,微信小程序在底层会根据我们设定的px来对屏幕自适应，有助于开发者更集中于开发，应用场景在设置间距、长宽等\r\nroot em,即rem，是css3新定义的一种长度单位，相对于页面定义的html根元素来调整大小，与em相对父元素调整大小更兼具相对和绝对字体调整大小的优势，在微信小程序中，1rem = 750/20 rpx = 75px，规定标准的iphone6的宽度是20rem，应用场景在于设置字体大小\r\n\r\n\r\n\r\n样式导入\r\n\r\n使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束\r\n框架组件上支持使用 style、class 属性来控制组件的样式"}
{"title": "微信小程序填坑之：多重三元表达式，Page({data:{}}) 页面里 data 的值取出来 ... ... ", "author": "天下雪", "pub_time": "2016-11-17 23:50", "article_content": "一：页面中多重三元表达式  解析有问题：解决方法：1234567<!--{{index}}  {{(index==0)?\"A\":                             (index==1)?\"B\":                             (index==2)?\"C\":\"D\"}}-->                <block wx:if=\"{{index==0}}\">A</block>                <block wx:elif=\"{{index==1}}\">B</block>                <block wx:elif=\"{{index==2}}\">C</block>                <block wx:else=\"{{index==3}}\">D</block>二：Page({data:{}}) 页面里 data 的值   可以通过 that.setData 设置   但是 怎么直接取出来 在 js 里面用呢解决： 在page 之外定义全局变量  和page 内的data中的变量  一一对应  每次 赋初始值或者更改 先给全局变量赋值或者 做更改  然后把 更新后的全局变量赋值给   page 内 data 中 对应的变量  代码如下var app=getApp();\r\n  var globalTestPaperID=\"\",\r\n        globalTestPaperTitle=\"\",\r\n        globalTestPaperNum=\"\",\r\n        globalQuestionList=[],\r\n        globalQuestionIndex=0,\r\n        globalQuestion={},\r\n       // globalAnswerList={},\r\n        globalUserSelectAnswer={},\r\n        golbalUserSelectAnswerContent=\"\"\r\nPage({\r\n    data:{\r\n        testPaperID:\"\",\r\n        testPaperTitle:\"\",\r\n        testPaperNum:\"\",\r\n        questionListSize:0,\r\n        questionIndex:0,\r\n        question:{},\r\n        answerList:{},\r\n        userSelectAnswerContent:\"\"\r\n        \r\n    },\r\n    onReady:function(){},\r\n    onLoad:function(query)\r\n    {\r\n        var that=this;        \r\n      console.log(\"testPaperTitle-->\"+query.testPaperTitle);\r\n      console.log(\"testPaperID-->\"+query.testPaperID);\r\n      console.log(\"testPaperOrderNum-->\"+query.testPaperOrderNum);\r\n            globalTestPaperID=query.testPaperID\r\n             globalTestPaperTitle=query.testPaperTitle\r\n             globalTestPaperNum=query.testPaperOrderNum\r\n         that.setData({\r\n            //  testPaperID:query.testPaperID,\r\n            //  testPaperTitle:query.testPaperTitle,\r\n            //  testPaperNum:query.testPaperOrderNum\r\n            testPaperID:globalTestPaperID,\r\n             testPaperTitle:globalTestPaperTitle,\r\n             testPaperNum:globalTestPaperNum\r\n             }),\r\n三：使用flex属性两边边距自适应解决方案index.wxml"}
{"title": "微信小程序实践教程：知乎专栏：页面，功能及API分析 ", "author": "天下雪", "pub_time": "2016-11-18 00:04", "article_content": "花了几天时间体验了微信小程序,借助知乎专栏的API 码出一个项目，也深有体会 拿出来跟大家分享下页面查看专栏首页查看专栏文章列表查看文章详情编写文章功能各种基本组件使用微信上拉加载更多本地预览图片API本地上传图片API弹窗 toast loading等视图模板使用基于flexbox封装库的使用事件使用catchtap bindtappromise集成\r\nAPI分析微信小程序渲染方式？\r\n目前网上流传2种论点  \r\n第一种: 认为微信基于react native 那套高性能jsbridge 造了一个轮子.所有的视图渲染为 是原生解析绘制\r\n第二种 认为微信创造了一个沙箱 webview环境， 渲染由 一个优化过，定制过的webkit去做. \r\n就我目前体验来看 小程序极有可能为第二种 ，在我开发过程中 我是用了大量目前前端现有的经验 比如说 负外边距居中，absolute 定位 relative,css3 animation等  这些在rn中应该没有或者实现不全面的.\r\n微信小程序体验？\r\n\r\n离线cache微信端的html5产品有个通病 静态资源没有离线cache 访问慢 每次打开白屏等待，离线环境不能用.小程序很好解决了这个问题  首次访问时候会下载静态资源包 解压到本地 从本地打开文件访问 剩下的数据请求 从服务器拉保证 和原生相同的体验。(增量更新目前未知)\r\n\r\n      2.转场性能众所周知  html5模拟转场动画 在android机型中 会出现卡顿性能不佳. 微信小程序 采用原生界面做转场动画切换 \r\n      3.布局性能flexbox 当下布局的热门规范 小程序正好实现了它 目前体验了下 实现度挺高 简单 复杂的布局也能去做.\r\n\r\n\r\n     4.mvvm目前前端已经进入了 组件式开发 和 数据驱动UI的时代 小程序自然也不例外总体来说熟悉 vue 和 react 的同学 应该能很容易上手  目前mvvm 完整实现度不是非常高 只能满足简单业务开发。\r\n     5.es6的拥抱公测的版本 已经可以使用es6开发了  小程序会使用bable进行编译，但是小程序并未集成promise  需要我们自己去找对应的polyfill\r\n以上几点保证微信小程序 开发体验 和 用户使用体验.\r\n最佳实践\r\n1. 网络层promise封装\r\n export default class NetUtil { static postJson(url,data){    return NetUtil.requestJson(url,data,\"post\"); } static getJson(url,data){     return NetUtil.requestJson(url,data,\"get\"); }  static requestJson(url,data,method){       data = data || {};       return new Promise(function(resolve, reject) {            wx.request({                    \"method\":method,                    \"url\": url,                    \"data\": data,                    \"header\": {                        'Content-Type': 'application/json'                    },                    success: function(res) {                       resolve(res);                    },                    fail : function(err){                        reject(err);                    }                })       });  }}\r\n\r\n使用的时候:\r\n    //获得文章详情      API.getPostDetailBySlug(this.query.slug)        .then((res)=>{            //业务处理          });\r\n\r\n\r\n2. 布局层flexbox 封装\r\n为了方便使用flexbox布局，对常用布局封装成class 方便使用.https://github.com/sherlock221/zhihuZhuanlan/blob/master/utils/flex.wxss\r\n\r\n\r\n    <view class=\"fx-row fx-row-center fx-row-space-between\">                    <text class=\"cover-util-left\">小明·6个月前</text>                    <text class=\"cover-util-right\">300赞·200评论</text>    </view>\r\n\r\n   <view class=\"fx-row fx-row-center \" wx:for=\"{{postList}}\" wx:key=\"{{index}}\">            <image mode=\"aspectFill\"  class=\"column-head\" src=\"{{item.image_url}}\"></image>            <view class=\"fx\">                   <text>标题</text>                   <text>描述</text>            </view>            <view class=\"column-enter fx-col-center\">{{item.column.name}}</view>        </view>\r\n\r\n这样的网格也是支持的:\r\n\r\n3. 上拉加载更多\r\n这个地方 很简单 微信已经帮我们封装好了 不需要我们自己判断onReachBottom 为触底触发的事件\r\n\r\n1.在当前页面page注册此方法函数2.声明两个状态isLoadmore和isEnd 代表 正在加载更多 和 加载完成3.在onReachBottom 做判断 if(!this.data.isEnd && !this.data.isLoadMore)4.返回的业务接口里面控制显示\r\n  Page({  data: {    commentList : [],    isLoadMore : false,    isEnd : false  },onReachBottom : function(){       //加载更多      if(!this.data.isEnd && !this.data.isLoadMore){          this.loadComment();      }  }  });\r\n\r\nloadComment 为业务接口拉取数据\r\nloadComment : function(){      this.setData({        isLoadMore : true      });      //获得文章评论   API.getPostCommentsBySlug(this.query.slug,Config.POST_DETAIL.COMMENT.LIMIT,offset)        .then((res)=>{            console.log(\"res- POST>\",res);            if(res.data.length <=0){              this.setData({                isLoadMore : false,                isEnd : true              });              return;            }          else{       this.setData({                  commentList : this.data.commentList.concat(res.data)                  isLoadMore : false                });        }          });  }\r\n\r\n\r\nview视图层\r\n    <view  class=\"loading-more\" >                 <image  wx-if=\"{{isLoadMore}}\" src=\"../../imgs/loading_48.png\" class=\"loading-img ani-loading\"  />                 <text class=\"loading-more-end-text\" wx-if=\"{{isEnd}}\">加载完成</text>            </view>\r\n\r\n是不是很简单，同样的上拉刷新官方也封装了 具体文档.\r\n微信小程序限制 2016.11.10\r\n1.服务端须为https 安全接口需要在微信后台配置2.程序包大小为1m 超出报错3.不完全的 component目前只能使用template抽象view层 不能完整抽离组件4.不支持npm模块 希望开放5.app bar上面 无法定制右侧按钮 \r\ngithub 源码地址 https://github.com/sherlock221/zhihuZhuanlan文件下载：zhihuZhuanlan-master.zip"}
{"title": "疯狂早茶微信小程序基础篇《六》：事件 ", "author": "天下雪", "pub_time": "2016-11-18 00:16", "article_content": "前面说到，微信小程序框架是逻辑层与UI层分析的设计方式，这种设计方式需要解决两个问题\r\nUI层响应逻辑层逻辑和数据的变化UI层将用户的操作反馈到逻辑层\r\n其中前面讲到的数据绑定解决了第一个问题，而事件则解决第二个问题\r\n什么是事件事件是视图层到逻辑层的通讯方式。事件可以将用户的行为反馈到逻辑层进行处理。事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。事件对象可以携带额外信息，如 id, dataset, touches。\r\n总结下来事件就是指发生了一些事情，通常是用户进行了一些操作，如点击某个按钮或在手机屏幕上滑动了手指。当事件发生时，框架会调用事件处理函数(如果有的话)，这样就可以实现对用户操作的响应。\r\n事件绑定\r\n通过事件绑定来完成对用户操作的响应，比如要处理view标签的tap事件，在标签属性中添加bindtap = 'tapName', 然后在.js中添加tapName函数\r\n//wxml\r\n<view id=\"tapTest\" data-hi=\"WeChat\" bindtap=\"tapName\"> Click me! </view>\r\n\r\n//.js\r\nPage({\r\n  tapName: function(event) {\r\n    console.log(event)\r\n  }\r\n})\r\nevent对象包含一些关于事件的数据：\r\ntarget：触发事件的组件currentTarget：当前组件type：事件类型timeStamp：时间戳(页面打开到触发事件所经过的毫秒数)touches：包含触摸点的数组(多点触控)changedTouches ：发生改变的触摸点的数组(多点触控)detail：额外的自定义信息\r\n冒泡事件和非冒泡事件\r\n为什么会有target和currentTarget之分呢，这是由于事件分为两类，冒泡事件和非冒泡事件\r\n冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。\r\n其中tap事件是属于冒泡事件(这也是为什么上面例子中的event会包含currentTarget)，另外其它的冒泡事件还包括| 类型 | 触发条件 || ------------- |-------------|| touchstart | 手指触摸动作开始 || touchmove | 手指触摸后移动 || touchcancel | 手指触摸动作被打断，如来电提醒，弹窗 || touchend | 手指触摸动作结束 || tap | 手指触摸后马上离开 || longtap | 手指触摸后，超过350ms再离开 | \r\n为什么需要冒泡事件\r\n有了冒泡事件，就可以更加方便的实现一些功能。\r\n比如程序有一个视图，包含用户头像和姓名，当用户点击头像或姓名时，进入用户详情页面。如果没有冒泡事件，就需要处理头像和姓名的点击事件，而现在只需在外层包裹一个组件，并处理该组件的事件即可。\r\n阻止事件冒泡\r\n在有些情况下可能会希望阻止事件的冒泡行为，可以使用catch事件绑定，如catchtap，就可以阻止事件的冒泡行为。\r\n可以通过下面的代码示例来加深对冒泡事件的理解\r\n//.wxml\r\n<view id=\"outter\" bindtap=\"handleTapOutter\">\r\n  我是父亲节点\r\n  <view id=\"middle\" catchtap=\"handleTapMiddle\">\r\n    我是儿子节点\r\n    <view id=\"inner\" bindtap=\"handleInner\">\r\n      我是孙子节点\r\n    </view>\r\n  </view>\r\n</view>\r\n\r\n//.js\r\nPage({\r\n  handleTapOutter: function(event) {\r\n    console.log(\"父亲节点被点击\")\r\n  },\r\n  handleTapMiddle: function(event) {\r\n    console.log(\"儿子节点被点击\")\r\n  },\r\n  handleInner: function(event) {\r\n    console.log(\"孙子节点被点击\")\r\n  },\r\n})\r\n尝试修改各级节点的tap事件绑定方式，查看输出的日志会有什么变化。"}
{"title": "用nodejs快速实现微信小程序的websocket服务端 ", "author": "天下雪", "pub_time": "2016-11-18 10:47", "article_content": "作者：小水熊；原文地址摘要: 微信小程序服务端使用websocket方式。socket.io已作为nodejs体系中"}
{"title": "jsongo0：微信小程序实战：手势解锁（附demo下载） ", "author": "天下雪", "pub_time": "2016-11-18 11:28", "article_content": "作者：jsong原文地址（已获授权）作者微信公众号：半圆生活，欢迎关注代码：https://github.com/jsongo/wx-gesture-lock这个手势解锁的demo使用了https://github.com/lvming6816077/H5lock 这个项目的算法和主逻辑，整合到微信小程序来，修改了很多地方的语法来适配小程序，去掉了window、document等函数，同时也添加了新的机制来解耦界面的操作和第三方库，这个下面会介绍到。不过可惜的是，这个demo也只能在开发工具上玩玩，到真机上测试的时候，手指一滑动，页面会跟着滚动，手势没法使用。 下面我们从这个例子中，来分析两个可以学习的点。1、引入第三方库我们上面提到的H5lock这个库，是个大神写的、专给H5用的一个功能。我们对它进行了一翻修改，把它引入到小程序上来了。这里讨论下如何把第三方js库引入到小程序来，分以下几个步骤：（1）模块化小程序代码中，只能通过module.exports来导出的模块才能被引用，所以第一步，我们要对代码进行第一个改造，做exports导出：module.exports = {\r\n\r\n...\r\n\r\n}如果要在被引入的时候，执行一些操作，可以用以下两种方式：//// mylib.js\r\n\r\nmodule.exports = (function() {\r\n\r\n// 这里写上你要执行的代码\r\n\r\n…\r\n\r\nreturn xxx; //返回你要导出的方法，如果多个就写成一个map\r\n\r\n})();\r\n\r\n\r\n\r\n…\r\n\r\n\r\n\r\n//// 其它文件中这么引用和执行：\r\n\r\nlet MyLib = require('mylib.js');\r\n\r\nlet lib = Mylib();\r\n\r\nlib.xxx(); // 执行或es6中的class：//// mylib.js\r\n\r\nmodule.exports = class {\r\n\r\n    constructor() { // \r\n\r\n        // 这里写上你要执行的代码\r\n\r\n    }\r\n\r\n    // 其它方法\r\n\r\n    xxx() { \r\n\r\n        ...\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n…\r\n\r\n\r\n\r\n//// 其它文件中这么引用和执行：\r\n\r\nlet MyLib = require('mylib.js');\r\n\r\nlet lib = new Mylib(); // 用new来生成类的对象\r\n\r\nlib.xxx(); // 执行（2）对第三方库中的一些函数进行改造小程序不支持以下几个函数或api：windowdocumentframesselflocationnavigatorlocalStoragehistorycachesscreenalertconfirmpromptXMLHttpRequestWebSocket跟以上相关的代码一个个搜索出来，并想办法替换掉。最常见的一般是document操作，第三方库主要是用它来引用dom，并对它进行设置或修改。这个可以通过下面第2点会讲的解耦技巧来巧妙地绕过。其它的就靠开发者自己去想了，这里没办法一一列出所有的情况。本文的demo用的是class的方式来改造了第三方库。 2、一种解耦的方式在小程序开发的时候，如果一个页面的js写得太长，甚至超过了上千行，那你就要考虑把这个文件分拆成几个。或者你写的逻辑代码，可以几个页面共用，那么你也是要把代码从这个页面的js里拆出来的。这里就引出了一个比较显明的问题：在其它文件中，要修改页面上的数据，又不能耦合性太大，因为你的这段逻辑代码，在页面A中会引用到，在页面B中也会引用到，这样总不能把setData操作放到这个共用的文件里吧。那有什么办法可以解耦呢？这个时候，可能你会想到普通页面开发时，用到的trigger机制，可惜这个只能在dom上绑定。也或许你用过http://statejs.org/ 这个库，通过状态机的变化来触发某些特定的操作，这个方法非常巧妙，没接触过这个库的开发者，建议学习一下。不过我们还不需要再引入一个库，这里，我们来写个简单的。简单到只有几行代码。代码在这里：https://github.com/jsongo/wx-gesture-lock/blob/master/lib/event.jsmodule.exports = function(app) {\r\n\r\n    app && (app.trigger = function(eventType, data) {\r\n\r\n        var pages = getCurrentPages(),\r\n\r\n            curPage = pages[pages.length-1],\r\n\r\n            methodName = 'on' + eventType.charAt(0).toUpperCase() + eventType.substr(1),\r\n\r\n            callback = curPage[methodName];\r\n\r\n        callback && callback.call(curPage, data);\r\n\r\n    });\r\n\r\n};如何使用这个库？分析一下大概的过程，其实非常简单，就是给app添加一个trigger方法，当它被调用的时候，去查找当前页面是否在onXXX方法，有的话就调用。这个方法名，是通过eventType这个参数变形而成的，如app.trigger('textChange') ，则这里会去查找页面中是否有onTextChange方法。所以其实这个解耦方法，本质上，是定义了一种规范。首页在app.js里引入，并在onLaunch里调用：var event = require('lib/event.js');\r\n\r\nApp({\r\n\r\n  onLaunch: function () {\r\n\r\n      event(this); // 在onLaunch里调用，传入的this就是app本身\r\n\r\n  },\r\n\r\n  globalData:{\r\n\r\n  }\r\n\r\n});然后在共用的抽离出来的文件中，在需要用到setData的地方，写成如下形式：app.trigger('titleChanged', '请解锁');接着在页面的js代码里，添加对这个trigger的响应：Page({\r\n\r\n…\r\n\r\n    onTitleChanged: function(newTitle) { // 文字变化的事件，自定义\r\n\r\n        this.setData({\r\n\r\n            title: newTitle\r\n\r\n        });\r\n\r\n    }\r\n\r\n...\r\n\r\n});这三步做完就ok了。"}
{"title": "微信小程序学习点滴《十五》：用户系统 一键登录 获取session_key和openid ... ", "author": "天下雪", "pub_time": "2016-11-18 16:13", "article_content": "思来想去不愿自己的微信小程序是个单机版本.自己又不会写后台.现在借助leancloud可以实现微信小程序一键登录功能.尝试后,做笔记.第一步:下载av-weapp.js,放到utils下.第二步:使用 const AV = require('../../utils/av-weapp.js');路径根据具体情况而定.第三步:做初始化.[javascript] view plain copyAV.init({      appId: 'EJx0NSfY********-gzGzoHsz',      appKey: 'FBVPg5G**********T97SNQj',    });  第四步:在微信公众平台获取AppID(小程序ID) 和AppSecret(小程序密钥)第五步:leancloud控制台配置AppID(小程序ID) 和AppSecret(小程序密钥)第六步:用户登录[javascript] view plain copy<span style=\"font-size:24px;\">AV.User.loginWithWeapp().then(user => {    this.globalData.user = user.toJSON();  }).catch(console.error);</span>  登陆后在平台查看用户信息获取到: session_key和openid第七步:获取当前用户信息[javascript] view plain copyconst user = AV.User.current();  // 调用小程序 API，得到用户信息  wx.getUserInfo({    success: ({userInfo}) => {      // 更新当前用户的信息      user.set(userInfo).save().then(user => {        // 成功，此时可在控制台中看到更新后的用户信息        this.globalData.user = user.toJSON();      }).catch(console.error);    }  });  注意:wx.request() 需要配置合法域名,否则会报错.在上一次笔记中已经写明.1.如何配置合法域名 2.在微信小程序中使用 LeanCloud"}
{"title": "小程序知识点小结 ", "author": "天下雪", "pub_time": "2016-11-18 16:31", "article_content": "0、文件导入\r\n    <import src=\"../a.wxml\"/>\r\n    <include src=\"../a.wxml\"/>\r\n    import \"../common.wxss\";\r\n1、规定屏幕宽度rpx(df750rpx), rem(20rem)\r\n2、内联样式影响渲染速度\r\n3、可使用模板template片段\r\n    定义模板\r\n    <template name=\"msgItem\">\r\n      <view>\r\n        <text> {{index}}: {{msg}} </text>\r\n      </view>\r\n    </template>\r\n    使用 is 导入模板, data 传入数据\r\n    <template is=\"msgItem\" data=\"{{...item}}\"/>\r\n\r\n\r\n4、App生命周期：onLaunch|onShow|onHide|...自定义\r\n    other.js\r\n    var appInstance = getApp()\r\n    console.log(appInstance.globalData)\r\n4.1、不要在App()中使用 getApp()\r\n4.2、不要在 onLaunch 的时候调用 getCurrentPage()\r\n4.3、不要在其它地方调用 app的生命周期函数\r\n\r\n5、Page生命周期：onLoad|onReady|onShow|onHide|onUnload|...自定义\r\n6、扩展事件：onPullDownRefresh(下拉-触发)、onReachBottom(上拉-触底)\r\n7、事件绑定：1.组件事件绑定函数如bindtap=\"tabName\" 2.在Page中定义如tabName\r\n8、view不仅作为组件、也可作为变量\r\n9、几乎所有组件都有各自定义的属性\r\n10、data-参数： 小写 e.target.dataset.*\r\n11、wx:for 循环数据，下标index,值item\r\n12、wx:if 切换高消耗 ，hidden初始化高消耗\r\n组件1、小写：所有组件及属性\r\n2、- ：连字符\r\n3、组件共同属性： id | class | style | hidden | data-* | bind*/catch*\r\n3.1、样式共同属性：#id | .class | element | element,element | ::after | ::before\r\n4、组件分类\r\n4.1、视图窗器 view/scroll-view/swiper\r\n4.2、基础 icon/text/progress\r\n4.3、表单组件 button/checkbox/form/input/label/picker/radio-group/radio/slider/switch/textarea\r\n代码route> 页面打开、重定向、返回\r\nwx.redirectTo|wx.navigateTo({\r\n    url:\"test?id=1\"\r\n    [,success:func,fail:func,complete:func]\r\n})\r\n\r\nwx.navigateBack({\r\n    delta:1 // getCurrentPages()\r\n})\r\n\r\nstorage-10M\r\nwx.setStorageSync(key,data)\r\nwx.setStorage({\r\n    key:\"key\",\r\n    data:\"value\"\r\n    [,success:func,fail:func,complete:func]\r\n\r\n})\r\n\r\n\r\nvar res = wx.getStorageInfoSync();\r\nwx.getStorageInfo({\r\n    success:function({keys:[],currentSize:1024,limitSize:2048})\r\n    [,fail:func,complete:func]\r\n})\r\n\r\nvar res = wx.getStorageSync(key)\r\nwx.getStorage({\r\n    key:\"key\",\r\n    success:function({data:\"value\"})\r\n    [,fail:func,complete:func]\r\n})\r\n\r\n\r\nwx.removeStorageSync(key)\r\nwx.removeStorage({\r\n    key:\"key\",\r\n    success:function({data:\"value\"})\r\n    [,fail:func,complete:func]\r\n})\r\n\r\nwx.clearStorageSync()\r\nwx.clearStorage();\r\n\r\ntry{//Sync...}catch(e){}\r\ntoastwx.hideToast()\r\nwx.showToast({\r\n    title:\"\"\r\n    [,icon:\"success|loading\",duration:1000,success:func,fail:func,complete:func]\r\n})\r\n\r\nwx.showModal({\r\n    title:\"\",\r\n    content:\"\"\r\n    [,showCancel:true|false,cancelText:\"\",confirmText:\"\",cancelColor:\"#000000\",confirmColor:\"#000000\",success:func,fail:func,complete:func]\r\n})\r\n\r\nwx.showActionSheet({\r\n    itemList:[\"\",\"\"]\r\n    [,itemColor:\"#000000\",success:function({cancel:true|false,tapIndex:\\d}),fail:func,complete:func]\r\n})\r\nImagewx.chooseImage({\r\n    success:function({tempFilePaths:[]}),\r\n    [,fail:func,complete:func,count:9,sizeType:[\"original|compressed\"],sourceType:[\"album|camera\"]]\r\n})\r\nwx.previewImage({\r\n    urls:[\"\"]\r\n    [,success:func,fail:func,complete:func,current:\"urls[0]\"]\r\n})\r\n\r\nwx.getImageInfo({\r\n    src:\"\"\r\n    [,success:function({width:0,height:0}),fail:func,complete:func]\r\n})\r\n\r\ntelephone\r\nwx.makePhoneCall({\r\n    phoneNumber:\"\"\r\n    [,success:func,fail:func,complete:func]\r\n})\r\n\r\nFile\r\nloginwx.login({\r\n    [success:function({errMsg:\"\",code:\"有效期五分钟\"}),fail:func,complete:func]\r\n})\r\n\r\n请求\r\nwx.request({\r\n    url:\"\"\r\n    [,success:func,fail:Func,complete:Func,method:\"GET|POST...\",data:\"\"|{},header:{}]\r\n})\r\n\r\nwebSocket\r\nwx.connectSocket({\r\n    url:\"\"\r\n    [,success:func,fail:Func,complete:Func,method:\"GET|POST...\",data:{},header:{}]\r\n})\r\n\r\nwx.onSocketOpen(callback)\r\nwx.onSocketError(callback)\r\nwx.onSocketMessage(callback)\r\nwx.sendSocketMessage({\r\n    data:\"\"|[]\r\n    [,success:Func, fail:func, complete:Func]\r\n})\r\nwx.closeSocket()\r\nwx.onSocketClose(callback)"}
{"title": "hss01248：微信小程序登录逻辑梳理 ", "author": "天下雪", "pub_time": "2016-11-18 16:36", "article_content": "官方文档\r\n文档相关地址:\r\n用户登录获取用户数据用户数据的签名验证和加解密\r\n\r\n\r\n微信两个api所拿到的信息:login和getUserInfo\r\n\r\n\r\n注册/登录\r\n小程序端:\r\n通过上面wx.login和wx.getUserInfo两个api拿到相应的信息,并通过上方接口传给自己的服务器.需要传输的信息有7个参数:appid  小程序唯一标识\r\nsecret  小程序的 app secret\r\njs_code  //wx.login登录时获取的 code,用于后续获取session_key\r\n\r\n//下面两个参数用户服务器端签名校验用户信息的\r\nsignature 使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息。\r\nrawData  不包括敏感信息的原始数据字符串，用于计算签名。\r\n\r\n//下面两个参数是用于解密获取openId和UnionId的\r\nencryptedData  包括敏感数据在内的完整用户信息的加密数据\r\niv 加密算法的初始向量当然,可以精简为以下三个参数.其余的签名校验的参数可省略,而appid和secret可以直接写在服务器.js_code //  wx.login登录时获取的 code,用于后续获取session_key\r\nencryptedData  包括敏感数据在内的完整用户信息的加密数据\r\niv 加密算法的初始向量服务端处理逻辑\r\n相关的信息传输给服务器后,服务器\r\n1.先根据js_code去微信服务器拿到session_key2.(此步可省略)使用 sha1( rawData + sessionkey )拿到字符串,判断与signature值是否相同,如果相同则用户信息无误,可进行下一步.如果不同,则说明用户信息被篡改或过期.3.然后根据解密算法自行解密(输入参数为appId,sessionKey,encryptedData,iv,返回一个jsonObj),拿到openId和unionId等信息,执行服务器端的注册/登录操作.4.注册/登录操作逻辑完成后,将我们服务器的sessionId(或其他token),以及用户信息返回给客户端.\r\n其中,服务器去获取session_key的请求为:\r\n(小写为固定写好的,大写为待替换的)https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code\r\n返回:\r\n    //正常返回的JSON数据包\r\n    {\r\n          \"openid\": \"OPENID\",\r\n          \"session_key\": \"SESSIONKEY\"\r\n          \"expires_in\": 2592000\r\n    }\r\n    //错误时返回JSON数据包(示例为Code无效)\r\n    {\r\n        \"errcode\": 40029,\r\n        \"errmsg\": \"invalid code\"\r\n    }\r\n相关解密算法:\r\nhttps://mp.weixin.qq.com/debug/wxadoc/dev/api/signature.html\r\n注意:示例代码中有node,c++,php,python的,没有java的.\r\n需要服务器返回的信息:sessionId/token 登录状态标识\r\nuserInfo: jsonObject,用户在我们平台上的信息,其内容与getPersonalInfo接口返回的相同.\r\n最后,将登录操作封装成方法,需要处调用即可//最终供外面调用的方法\r\nfunction login(){\r\n    console.log('logining..........');\r\n    //调用登录接口\r\n    wx.login({\r\n        success: function (e) {\r\n            console.log('wxlogin successd........');\r\n            var code = e.code;\r\n            wx.getUserInfo({\r\n                success: function (res) {\r\n                    console.log('wxgetUserInfo successd........');\r\n                    var encryptedData = encodeURIComponent(res.encryptedData);\r\n                    thirdLogin(code,encryptedData,res.iv);//调用服务器api\r\n                }\r\n            })\r\n        }\r\n    });\r\n}\r\n\r\nfunction  thirdLogin(code,encryptedData,iv){\r\n    var url = \"eeee/xxx/login/ttttt\";\r\n    var params = new Object();\r\n    params.code = code;\r\n    params.encryptedData = encryptedData;\r\n    params.iv =iv;\r\n\r\n    buildRequest(new Object(),url,params,{\r\n        onPre: function(page){},\r\n        onSuccess:function (data){\r\n            console.log('my  login successd........');\r\n            console.log(data);\r\n            getApp().globalData.session_id = data.session_id;\r\n            getApp().globalData.uid = data.uid;\r\n            getApp().globalData.isLogin = true;\r\n        },\r\n        onError : function(msgCanShow,code,hiddenMsg){\r\n        }\r\n    }).send();\r\n}"}
{"title": "nyoj_lvy实战开发系列《二》： 微信端开发：登录小程序 ", "author": "天下雪", "pub_time": "2016-11-15 13:21", "article_content": "这个小程序的主要目的是为了用户用微信的用户信息登录后将用户信息授权存入自己的数据库中，这样以后每次微信登录得到的code 所得到的 openid 可以在项目的数据库中查到该用户的相关信息。在测试的过程中，需要用户登录得到的code，所以会用到微信开发小工具~！ 该工具的使用必须被项目授权所生成的code是有时间限制的微信登录端口的api如下接口地址：https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code请求参数： 参数 必填 说明 appid 是 小程序唯一标识 secret 是 小程序的 app secret js_code 是 登录时获取的 code grant_type 是 填写为 authorization_code返回参数： 参数 说明 openid 用户唯一标识 session_key 会话密钥 expires_in 会话有效期, 以秒为单位, 例如2592000代表会话有效期为30天返回说明：//正常返回的JSON数据包{      \"openid\": \"OPENID\",      \"session_key\": \"SESSIONKEY\"      \"expires_in\": 2592000}//错误时返回JSON数据包(示例为Code无效){    \"errcode\": 40029,    \"errmsg\": \"invalid code\"}所以我们可以将代码写成如下公司将发送的报文格式自己都写好了的，我只需要写出请求路径和请求参数就ok//@Param code 用户登录微信生成的code//@Return  OAuthResult  返回包含openid和session_key和expires_in的类public OAuthResult getOAuthResultByCode(String code) {        String path = \"/sns/jscode2session\";        Map<String, Object> parameters = new HashMap<>();        parameters.put(\"appid\", WechatConstant.WECHAT_APP_ID);        parameters.put(\"secret\", WechatConstant.WECHAT_APP_SECRET);        parameters.put(\"js_code\", code);        parameters.put(\"grant_type\", \"authorization_code\");        OAuthResult oAuthResult = messageSender.getMessageForObject(path, parameters, OAuthResult.class, false);        if (oAuthResult.getOpenid() == null){            throw new BusinessException(BusinessException.Code.OAUTH_PROCESS_ERROR, \"OAuth异常，原因：\" + oAuthResult.getErrmsg());        }        return oAuthResult;    }"}
{"title": "微信小程序开发初探：我的第一个小程序 ", "author": "天下雪", "pub_time": "2016-11-26 02:37", "article_content": "一、关于微信小程序1.1 小程序诞生的背景　　张小龙说道：　　（1）一切以用户价值为依归→用户是微信的核心，所以微信中没有很多与客户无关的功能，比如QQ中的乱七八糟一系列东西。　　（2）让创造发挥价值→所有围绕微信的创造比如公众号都应该发挥其应有的价值。　　（3）用完即走的高效服务→这一点就厉害了word天，微信要打造一个以微信为中心的生态链，不以绑定用户为目标。比如生活中有一些不太常用的app，我们可能一年也使用不了几次，但是有时候就需要用到，微信就想要提供这样一个平台，让你可以在微信中使用这中所谓的app的功能。或者说可以这样理解，让微信成为一个类似于Windows的操作系统，各种小程序就是操作系统上的应用软件。　　（4）无形存在的商业化→微信使得人与人之间的联系变成了无形的商业化网，这个网可以创造很多无形的商业价值。1.2 小程序是个什么鬼？　　张小龙在朋友圈里这样解释道：小程序是一种不需要下载安装即可使用的应用，它实现了应用「触手可及」的梦想，用户扫一扫或搜一下即可打开应用。也体现了「用完即走」的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。1.3 技术层面的小程序　　微信小程序 = XML + CSS + JS 的移动应用程序1.4 为什么要开发微信小程序？　　（1）更好的给用户提供用完即走的服务　　（2）给用户提供更好的使用体验　　（3）功能更加深入：https://mp.weixin.qq.com/debug/wxadoc/dev/　　（4）设计更加统一：https://mp.weixin.qq.com/debug/wxadoc/design/index.html?t=20161109　　（5）类似于微信钱包中的第三方服务二、开发工具的安装2.1 下载微信开发者工具　　Windows 64位：点我下载　　Windows 32位：点我下载　　Mac 版 ：点我下载2.2 安装微信开发者工具　　这里我使用的是wechat_web_devtools_0.10.102800_x64版：　　     　　　　安装完成后，第一次启动时会出现一个二维码，需要使用微信扫描该二维码才可登录开发者工具：三、第一个微信小程序3.1 添加微信小程序项目　　Step1.选择调试类型：本地小程序项目→添加项目　　Step2.由于我们暂时没有AppID，所以选择无AppID（无AppID部分功能会受限）　　Step3.进入开发者工具界面，默认是选中“调试”面板　　可以看到，在调试面板中，左侧是页面效果预览窗口，右侧是类似于Chrome的开发者的工具。在预览窗口可以选择一些常见的手机型号和不同的分变率，大家可以看出这简直就是Chrome开发者工具的翻版。3.2 微信小程序结构一览　　新建了一个小程序之后，开发工具为我们默认生成了一些文件，下面我们来看看这些文件都是看些什么用，以及程序结构又是什么样子的。　　（1）项目结构　　（2）应用程序级文件　　① app.js//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    //调用API从本地缓存中获取数据\r\n    var logs = wx.getStorageSync('logs') || []\r\n    logs.unshift(Date.now())\r\n    wx.setStorageSync('logs', logs)\r\n  },\r\n  getUserInfo:function(cb){\r\n    var that = this\r\n    if(this.globalData.userInfo){\r\n      typeof cb == \"function\" && cb(this.globalData.userInfo)\r\n    }else{\r\n      //调用登录接口\r\n      wx.login({\r\n        success: function () {\r\n          wx.getUserInfo({\r\n            success: function (res) {\r\n              that.globalData.userInfo = res.userInfo\r\n              typeof cb == \"function\" && cb(that.globalData.userInfo)\r\n            }\r\n          })\r\n        }\r\n      })\r\n    }\r\n  },\r\n  globalData:{\r\n    userInfo:null\r\n  }\r\n})　　app.js定义了全局的一些重要事件，比如程序启动时要做些什么，如何获取微信用户信息等等。App函数是一个全局函数，它的作用就是用来创建一个应用程序实例，每个应用程序都会有它的生命周期，因此一些重要的生命周期事件都会在这里定义。例如，onLaunch事件就是程序在启动时需要干什么。　　② app.json{\r\n  \"pages\":[\r\n    \"pages/index/index\",\r\n    \"pages/logs/logs\"\r\n  ],\r\n  \"window\":{\r\n    \"backgroundTextStyle\":\"light\",\r\n    \"navigationBarBackgroundColor\": \"#fff\",\r\n    \"navigationBarTitleText\": \"Manulife WeChat Demo\",\r\n    \"navigationBarTextStyle\":\"black\"\r\n  }\r\n}　　app.json 则定义了程序有哪些页面，以及窗口标题及相关样式等。例如，我们再这里将navigationBarTitleText属性值改为了Manulife WeChat Demo，来看看调试窗口会显示什么？　　③ app.wxss/*赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              蓝狐锅锅：微信小程序列表渲染多层嵌套循环及wx:key的使用 \n              【官方培训班】小程序开发你遇到的问题，这里都有答案 ... \n            \n             \n            \n                  原作者: Edison Chou \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSKky059', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164126|52dfe8be61e6ae6fd600e14ba3c1464f|2';"}
{"title": "【官方培训班】小程序开发你遇到的问题，这里都有答案 ... ", "author": "天下雪", "pub_time": "2016-11-26 13:00", "article_content": "友情提示：凡是本站标注授权地址的文章，均为原作者授权发布的文章；今天是一篇没有歌的文章，因为货足够干，可能会干到你欲罢不能。请注意，以下内容，只展示大家在开发小程序过程中遇到的公共问题解答方案，至于其他相关的开发知识，由于腾讯要求，不方便透漏太多，见谅。如还是有泄露的内容，必会尽快删除。小程序自公测到现在已经将近一个月时间了，相信已经有很多相关从业人员已经投身到了小程序的开发中。尽管是腾讯，我相信，所做的产品也肯定是从0到1然后慢慢迭代完善的，所以，大家在开发的过程中，也一定会遇到很多问题。我们也是其中开发的一份子，恰巧微信开发者培训课程第二十一期开在了北京，那么也很恰巧的，我被选中成为了这一期的学员，于是就有了这篇除官方以外的深度答疑文章。先上一张进门的标志性照片（婚礼和培训班招牌同框，什么鬼！）\r\n此处省略微信生活以及医药服务等等开发的知识，直接进入小程序环节。小程序是什么，相信点进来看的人已经都知道了，所以就不在这里再放小程序的介绍图了。一.关于小程序产品层面1.关于小程序的性能可能所有关心小程序的人，第一个想到的问题，就是小程序的流畅度是否能够达到预期。来看一个例子（由于没有开发环境，第一个例子是网上找的，所以不够精细，开发人员可以自己登录后台看demo）。演示demo\r\n下面插入一个视频，是课程上面录制的展示demo。视频较大，建议wifi下观看。\r\n演示案例\r\n 转到视频页在我的概念里，小程序的交互是非常流畅的。虽然说小程序也是在微信的页面里面展示的，也和前端正常的开发流程是类似的。但是它整个页面的底层框架，都是微信自己定义的wx协议，和普通的html是还是有区别的，所以开发的时候，也尽量不要用html开发的眼光和思维去对待它。为什么不能用html开发的眼光对待它，后面一些例子会讲到。前面说到，小程序有独有的协议，所以也造就了它自己独有的离线能力。也就是说只要你第一次在网络情况下打开过页面，下一次就算是没有网络，也是可以看到内容的，这一点是和传统的web页面有着很大的区别。另外一点，就是小程序的兼容性很好，比如开发原生app需要适配不同的系统，而小程序只需要开发一次即可。2.关于小程序的注册以及开发小程序的开发，需要申请账号，完善信息，提交代码，审核发布等流程。它们是可以和小程序代码的编写同步进行，所以小程序更加偏向是一个开发者工具，而不是像订阅号或者服务号那样的运营工具。先说账号申请，阅读过官方文档的应该清楚，小程序目前，只支持两种类型的账号。第一种是企业，这个只需要注册账号，然后绑定对公账号即可。还有一种是一些类似政府企业，无法使用对公账户打款。也就是说第一种企业只要注册就可以使用，而第二种注册完需要认证才行，并且目前不支持个人账号。第二步就是完善信息，这里很简单，唯一需要特别注意的是，基本信息中，选择小程序的服务范围的时候，一定要特别谨慎，不能随意修改。因为这样容易造成数据混乱，比如你选的分类是打车，而用户搜完之后，发现你其实是做的美食，这就尴尬了。做好之后就可以去代码开发并且上传，上传代码只能是管理员账号才行。这里需要注意的第一点，是小程序不支持代码的合并和修改，所以，当你准备上传代码的时候，一定要确定，这是个完整的包，如果需要合并和修改，需要在其他类似git这样的平台进行。第二点是当你提交审核的时候，尽量不要在小程序页面里面出现例如test之类的文字，以及测试数据，尽可能做到完善，否则有可能会影响你的信用分。3.关于小程序产品体验常见问题\r\nQ：邮箱无法与公众号，开放平台，绑定个人微信号的邮箱重复。\r\nA：这里是腾讯开发公众号时候遗留的诟病，所以现在腾讯所有开放平台的所有账号都不能使用已经注册过的邮箱账号，请大家见谅。\r\n\r\nQ：是否需要认证，认证与不认证有什么却别？\r\nA：不认证除了不能调用微信支付之外，和认证用户没有任何其他区别。\r\n\r\nQ：管理员、开发者、体验者的不同是什么？\r\nA：能够登录小程序管理后台的只有管理员，开发者可以被授权使用。管理员的权限是最高的，开发者只有在后台进行开发的权限。而体验者，则是不能参与后台的管理和使用，只能参与体验。\r\n二.关于小程序技术开发1.关于小程序的数据结构和视图渲染小程序和其他前端非常不一样的一个地方，就是渲染方式、执行方式以及执行时间，都是由小程序自己自定的，并且可以在后台进行编译。以下图为例，appservice管理的是数据，视图层管理的是渲染，数据和视图层是完全分离的。这种视图结构中，你的脚本是没办法直接操控视图的，所以使用习惯了jQuery的人，这里就比较遗憾了，是完全不能用。第一是因为它是跑在两个独立线程中，另一个是因为开发者写的脚本文件，都是跑在jscode当中的，所以有很多dom是没有的。\r\n\r\n\r\n2.关于小程序的开发者组件为了方便开发者，微信官方推出了一系列的小程序组件，这些组件会有一些自己的功能，比如说一些button和cheakbox等等，会有自己微信的样子，所以说，即使是一些ui资源很弱的团队，也可以开发出来很不错的小程序。由于html对于组件的支持比较差，所以这些组件基本上都是微信自己自定义的。在技术上，微信吸取了web-component的精髓，研发了wx-component，研发的时候，假如你熟悉前者，你就会发现，他们的接口是很相似的。其实了解技术的人都清楚，这么做一套自定义组件，是非常耗时耗力的，微信之所以会做，一个是因为方便web和native之间的切换，另一个是可以和自己的自定义框架很好的结合起来。3.关于小程序的unionID如果开发者拥有多个移动应用，网络应用，和公众账号（包括小程序），可通过unionid来区分用户的唯一性。因为只要是同一个微信开放平台账号下的移动应用，网站应用和公众账号（包括小程序），用户的unionid是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。所以就可以用这个unionid把公众号的一些用户，以及之前你开发过的微信生态下的应用，和小程序里面的用户建立起联系，你会发现，他们都是同一批人。4.关于小程序的cooike不生效问题很多开发者会问，为什么某些set-cookie之类的不会生效，这里其实是因为，小程序开发并不是在一个浏览器的环境中把请求发了出去，所以服务器发回来的返回头，小程序是无法理解的。小程序的请求是jscode通过native发出去的，所以他们并不理解，但是以后可能会优化理解。处于安全需要，需要服务器支持Https。然后TLS（Transport Layer Security）版本需要支持到1.2，即最新版本，它可以在不支持TLS的环境中模拟。但是如果真机运转的话，还是需要把服务器版本升级到最新。在app.json中声明的页面，需要有相应的Page()函数进行注册。开发者经常遇到，在app.json写了a页面，但是没有创建a.js文件，那就会出错，并且如果你创建了a.js，没有在里面生成page()的函数，那也会出错。5.关于小程序常见问题答疑\r\nQ：为什么设置了scrool-view之后，页面不能滚动到底部，对滚动条不检测？\r\nA：因为Native层是在webview层之上的，所以无法检测到scroll-view的滚动。如果只是单独的一个scroll-view，是可以通过scroll-into这样的属性操作。如图：\r\n\r\n\r\nQ：编译的规范，小程序会开放吗？\r\nA：编译的规范还在开发，因为编译之后的大小并没有达到预期，还需要测试。\r\n\r\nQ：为什么逻辑层要和视图层分离？\r\nA：因为简单、效率比较高，并且比较安全。\r\n\r\nQ：小程序会加入开源力量吗？\r\nA：作为程序人员，还是很希望小程序可以开源的，但是这是一个微信的商业项目，所以不会这么做。\r\n\r\nQ：编译器，为什么wxs文件转换成了js而不是css？\r\nA：如果在后台直接转成css文件的话，我们是不知道屏幕的宽度和分辨率的，所以没办法做rpx的转换。保存js的主要目的，是为了让它在运行的时候，实时去计算react.js对应的值。\r\n以上，就是今天部分的课程内容，希望可以帮助到一些做小程序开发的童鞋。最后，如果希望了解更多专业信息，请关注我的简书，最近会整理更新关于微信支付的内容。"}
{"title": "xiaowindxiao：微信小程序常用知识-基础篇 ", "author": "天下雪", "pub_time": "2016-11-26 13:04", "article_content": "一、事件绑定        bindtap <button class=\"weui-btn\" type=\"default\" bindtap=\"openConfirm\">Confirm Dialog</button>\r\n <button class=\"weui-btn\" type=\"default\" bindtap=\"openAlert\">Alert Dialog</button> 二、样式导入        @import@import 'style/weui.wxss'; 三、列表渲染        wx:forPage({\r\n  items: [{\r\n    message: 'foo',\r\n  },{\r\n    message: 'bar'\r\n  }]\r\n})<view wx:for=\"{{items}}\" wx:for-index=\"index\" wx:for-item=\"item\">\r\n  {{index}}: {{item.message}}\r\n</view>        block wx:for<block wx:for=\"{{[1, 2, 3]}}\">\r\n  <view> {{index}}: </view>\r\n  <view> {{item}} </view>\r\n</block> 四、模块化定义：// common.js\r\n\r\nfunction sayHello() {\r\n    console.log(\"hello\");\r\n}\r\n\r\nmodule.exports = {\r\n   sayHello:sayHello\r\n}引用：\r\n//index.js\r\n\r\nconst common = require(\"../../utils/common.js\");\r\n\r\nfunction say() {\r\n    common.sayHello();\r\n} 五、8大组件 视图容器 基础内容 表单组件 操作反馈 导航 媒体组件 地图 画布 六、三个文件app.jsapp.jsonapp.wxss 赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              【官方培训班】小程序开发你遇到的问题，这里都有答案 ... \n              微信小程序开发之麦克风动画 帧动画 放大 淡出 \n            \n             \n            \n                  原作者: xiaowindxiao  \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    3 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n     \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         高高果实\r\n                \r\n       \r\n       2016-11-29 00:27\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    天下雪: 同学，现在学得怎么样了你好博主，我目前在进行接口的开发，完成后就开始小程序端的开发，您这边文章整理得很有层次感，看起来不费劲，对学习很有帮助的，赞赞赞！~\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n          \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         天下雪\r\n                \r\n       \r\n       2016-11-26 21:58\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    高高果实: 非常好的文章,赞一个!~同学，现在学得怎么样了\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n          \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         高高果实\r\n                \r\n       \r\n       2016-11-26 13:27\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    非常好的文章,赞一个!~\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n             \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSKPJZ7K', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164128|e093781d1742c2b16772291d2f5872fc|2';"}
{"title": "君莫叹：微信小程序实战尝鲜：今日头条（附代码） ", "author": "天下雪", "pub_time": "2016-11-26 13:09", "article_content": "微信小程序在近期比较火热，作者在闲暇之余研究后决定做一个今日头条的小demo。\r\n首先感谢此作者的接口提供。\r\n\r\n首页的开发过程。首先在app.json中配置每个页面{\r\n\"pages\":[\r\n \"pages/index/index\",\r\n \"pages/attention/attention\",\r\n \"pages/mine/mine\",\r\n \"pages/video/video\"\r\n],\r\n\"window\":{\r\n \"backgroundTextStyle\":\"light\",\r\n \"navigationBarBackgroundColor\": \"#d75b5d\",\r\n \"navigationBarTitleText\": \"今日头条\",\r\n \"navigationBarTextStyle\":\"white\"\r\n},\r\n\"tabBar\": {\r\n \"color\": \"#959394\",\r\n \"selectedColor\": \"#959394\",\r\n \"backgroundColor\": \"#f0f0f0\",\r\n \"borderStyle\": \"white\",\r\n \"list\": [{\r\n   \"pagePath\": \"pages/index/index\",\r\n   \"iconPath\":\"imges/tabbar/home_tabbar_22x22_.png\",\r\n   \"selectedIconPath\":\"imges/tabbar/home_tabbar_press_22x22_@2x.png\",\r\n   \"text\": \"首页\"\r\n }, {\r\n   \"pagePath\": \"pages/video/video\",\r\n   \"iconPath\":\"imges/tabbar/video_tabbar_22x22_.png\",\r\n   \"selectedIconPath\":\"imges/tabbar/video_tabbar_press_22x22_@2x.png\",\r\n   \"text\": \"视频\"\r\n },{\r\n   \"pagePath\": \"pages/attention/attention\",\r\n   \"iconPath\":\"imges/tabbar/newcare_tabbar_night_22x22_.png\",\r\n   \"selectedIconPath\":\"imges/tabbar/newcare_tabbar_press_22x22_@2x.png\",\r\n   \"text\": \"关注\"\r\n },{\r\n   \"pagePath\": \"pages/mine/mine\",\r\n   \"iconPath\":\"imges/tabbar/mine_tabbar_22x22_.png\",\r\n   \"selectedIconPath\":\"imges/tabbar/mine_tabbar_press_22x22_@2x.png\",\r\n   \"text\": \"我的\"\r\n }]\r\n}\r\n}随后我们创建导航条。布局：运用盒型布局即可。思路：由于这个有动画效果，当时的想法是利用js来控制动画效果，配合微信的wx.createAnimation(OBJECT)来创建动画并且实现，当我点击当前的按钮的时候，用js来控制其大小变化，当我点击其他按钮的时候，遍历所有按钮然后设当前的按钮为变大状态，其他则缩小。但是在实现的时候发现在数据源用的是微信中数据绑定的形式渲染的，当前的按钮变大后其他按钮都随之变化，控制较难，所以作者放弃了这种思路最终思路： 利用css3动画配合一个Bool值来使当前的视图发生变化。使用<scroll-view scroll-x=\"true\" scroll-y=\"false\" class=\"tpscview\" scroll-left=\"-2\">来对导航条进行横向设置。使用BOOL型数据animation来控制当前的状态。使用css3代码来控制动画.curPage {\r\n     animation:myfirst 0.1s;\r\n     animation-fill-mode:forwards;\r\n}\r\n\r\n@keyframes myfirst\r\n{\r\n    to {\r\n       font-size: 50rpx;\r\n    }\r\n}\r\n3. 获取内容作者封装了以下网络接口首先初始化数据端。import  {\r\n    device_id,\r\n    iid,\r\n    BASE_URL,\r\n} from \"./constant.js\"\r\nvar net = require(\"./netLoad.js\");\r\nfunction fetchHeadName(){\r\n    let url = BASE_URL + \"article/category/get_subscribed/v1/?\"\r\n    let params = {\"device_id\": device_id,\"aid\": 13,\"iid\": iid}\r\n     return net.fetchApi(url, params, \"GET\").then(data=>data)\r\n}\r\n\r\nfunction loadHomeCategoryNewsFeed(category){\r\n     let url = BASE_URL + \"api/news/feed/v39/?\"\r\n     let params = {\"device_id\": device_id,\"category\": category,\"iid\": iid}\r\n     return net.fetchApi(url,params,\"GET\").then(data=>data);\r\n}\r\n\r\nfunction loadHomeCategoryMoreNewsFeed(category, lastRefreshTime){\r\n     let url = BASE_URL + \"api/news/feed/v39/?\"\r\n     let params = {\"device_id\": device_id,\r\n                      \"category\": category,\r\n                      \"iid\": iid,\r\n                      \"last_refresh_sub_entrance_interval\": lastRefreshTime}\r\n     return net.fetchApi(url, params, \"GET\").then(data=>data);\r\n}\r\n\r\nexport {\r\n    fetchHeadName,\r\n    loadHomeCategoryNewsFeed,\r\n    loadHomeCategoryMoreNewsFeed\r\n}接下来通过NetLoad.js封装文件来对网络进行请求。import Promise from \"../../bluebird/js/browser/bluebird.min.js\"\r\nmodule.exports = {\r\nfetchApi (url,params,method) {\r\nreturn new Promise((resolve, reject) => {\r\n  wx.request({\r\n    url: `${url}`,\r\n    data: Object.assign({}, params),\r\n    method:method,\r\n    header: { 'Content-Type': 'application/json' },\r\n    success: resolve,\r\n    fail: reject\r\n  })\r\n})\r\n}\r\n}接下来通过wx.loading 组件来对用户进行请求提示<loading hidden=\"{{loading}}\">\r\n      加载中...\r\n</loading>最终完成了此页面。另外其他页面详见作者github上的代码。若觉得本文对您有帮助请给个star。若有改进欢迎一起讨论并学习。"}
{"title": "微信小程序和服务器通信-WebSocket ", "author": "天下雪", "pub_time": "2016-11-26 13:39", "article_content": "本文主要讲一下如何建立一个基于node.js的WebSocket服务器，并在小程序中使用这个提供实时服务的服务器。node.js中已经有很多现成的第三方库，用于构建WebSocket服务。我们今天选用一个叫做websocket的库，来构建一个可以提供标准WebSocket接口的node.js服务端程序。先建一个空文件夹，名叫ws-server，然后进入该文件夹，在命令行执行:npm install websocket然后在ws-server文件夹下，再新建一个名为app.js的文件，内容如下：因为WebSocket服务是建立在HTTP之上的，所以我们看到，代码中建立了一个http server, 然后建立了一个使用了该http server的WebSocket server，并让http server监听8080端口对外提供服务。这个服务端的功能也很简单，就是收到客户端发送的消息并打印出来，然后在接收到的消息前面加上一个[from server]的前缀后，返回给客户端。好，我们来实现调用该服务的微信小程序代码：首先我们需要用wx.connectSocket()方法去连接目标服务器，因为我们开发环境用的是非安全的http，所以这边的url参数是ws://打头的，在以后微信的实际运行环境中，你的服务端必须使用SSL，所以连接url就会是wss://的了。然后需要调用wx.onSocketOpen()方法来设置WebSocket连接打开时的回调函数。当连接打开后，就可以开始向服务端发送数据了，我们在这里使用wx.sendSocketMessage()方法，向服务端发送了一个后面跟随一个随机数的Hello,World字符串。我们运行一下程序，可以看到，服务端的控制台上会打印出这样的结果：说明服务端已经成功接收到了客户端发送的字符串消息。之后服务端会向客户端再反馈这个消息，那客户端这边如何接收这个从服务端过来的消息呢？我们可以在小程序中，使用wx.onSocketMessage()方法，监听服务端发送到客户端的消息，正如我们上面的示例代码写的那样：wx.onSocketMessage(function (msg) {console.log(msg)})我们在小程序的Console上，简单的打印了从服务端过来的消息，如下所示：这样，一个简单但完整的客户端和服务器端的WebSocket交互就完成了。如果你想关闭这个WebSocket连接，那么你可以调用wx.closeSocket()来进行关闭。「H5程序俱乐部」是一个专注微信小程序学习交流，相关外包/招聘需求信息发布的微信公众号。"}
{"title": "一斤代码：微信小程序中实现瀑布流布局和无限加载 ", "author": "天下雪", "pub_time": "2016-11-26 17:14", "article_content": "瀑布流布局是一种比较流行的页面布局方式，最典型的就是Pinterest.com，每个卡片的高度不都一样，形成一种参差不齐的美感。\r\n在HTML5中，我们可以找到很多基于jQuery之类实现的瀑布流布局插件，轻松做出这样的布局形式。在微信小程序中，我们也可以做出这样的效果，不过由于小程序框架的一些特性，在实现思路上还是有一些差别的。\r\n今天我们就来看一下如何在小程序中去实现这种瀑布流布局：\r\n小程序瀑布流布局\r\n\r\n我们要实现的是一个固定2列的布局，然后将图片数据动态加载进这两列中（而加载进来的图片，会根据图片实际的尺寸，来决定到底是放在左列还是右列中）。\r\n/* 单个图片容器的样式 */\r\n.img_item {\r\n  width: 48%;\r\n  margin: 1%;\r\n  display: inline-block;\r\n  vertical-align: top;\r\n}\r\n我们知道，在HTML中，我们要动态加载图片的话，通常会使用new Image()创建一个图片对象，然后通过它来动态加载一个url指向的图片，并获取图片的实际尺寸等信息。而在小程序框架中，并没有提供相应的JS对象来处理图片加载。其实我们可以借助wxml中的组件来完成这样的功能，虽然有点绕，但还是能满足我们的功能要求的。\r\n<!-- 在页面上放一个隐藏区域，并用image组件去加载一个或多个图片资源 -->\r\n<view style=\"display:none\">\r\n  <image wx:for=\"{{images}}\" wx:key=\"id\" id=\"{{item.id}}\" src=\"{{item.pic}}\" bindload=\"onImageLoad\"></image>\r\n</view>\r\n我们可以在Page中通过数据绑定，来传递要加载的图片信息到wxml中，让组件去加载图片资源，然后当图片加载完成的时候，通过bindload指定的事件处理函数来做进一步处理。\r\n我们来看一下Page文件中定义的onImageLoad函数。在其中，我们可以从传入的事件对象e上，获取到组件的丰富信息，包括通过它加载进来的图片的实际大小。然后我们将图片按照页面上实际需要显示的尺寸，计算出同比例缩放后的尺寸。接着，我们可以根据左右两列目前累积的内容高度，来决定把当前加载进来的图片放到哪一边。\r\nlet col1H = 0;\r\nlet col2H = 0;\r\n\r\nPage({\r\n\r\n    data: {\r\n        scrollH: 0,\r\n        imgWidth: 0,\r\n        loadingCount: 0,\r\n        images: [],\r\n        col1: [],\r\n        col2: []\r\n    },\r\n\r\n    onLoad: function () {\r\n        wx.getSystemInfo({\r\n            success: (res) => {\r\n                let ww = res.windowWidth;\r\n                let wh = res.windowHeight;\r\n                let imgWidth = ww * 0.48;\r\n                let scrollH = wh;\r\n\r\n                this.setData({\r\n                    scrollH: scrollH,\r\n                    imgWidth: imgWidth\r\n                });\r\n\r\n                //加载首组图片\r\n                this.loadImages();\r\n            }\r\n        })\r\n    },\r\n\r\n    onImageLoad: function (e) {\r\n        let imageId = e.currentTarget.id;\r\n        let oImgW = e.detail.width;         //图片原始宽度\r\n        let oImgH = e.detail.height;        //图片原始高度\r\n        let imgWidth = this.data.imgWidth;  //图片设置的宽度\r\n        let scale = imgWidth / oImgW;        //比例计算\r\n        let imgHeight = oImgH * scale;      //自适应高度\r\n\r\n        let images = this.data.images;\r\n        let imageObj = null;\r\n\r\n        for (let i = 0; i < images.length; i++) {\r\n            let img = images[i];\r\n            if (img.id === imageId) {\r\n                imageObj = img;\r\n                break;\r\n            }\r\n        }\r\n\r\n        imageObj.height = imgHeight;\r\n\r\n        let loadingCount = this.data.loadingCount - 1;\r\n        let col1 = this.data.col1;\r\n        let col2 = this.data.col2;\r\n\r\n        //判断当前图片添加到左列还是右列\r\n        if (col1H <= col2H) {\r\n            col1H += imgHeight;\r\n            col1.push(imageObj);\r\n        } else {\r\n            col2H += imgHeight;\r\n            col2.push(imageObj);\r\n        }\r\n\r\n        let data = {\r\n            loadingCount: loadingCount,\r\n            col1: col1,\r\n            col2: col2\r\n        };\r\n\r\n        //当前这组图片已加载完毕，则清空图片临时加载区域的内容\r\n        if (!loadingCount) {\r\n            data.images = [];\r\n        }\r\n\r\n        this.setData(data);\r\n    },\r\n\r\n    loadImages: function () {\r\n        let images = [\r\n            { pic: \"../../images/1.png\", height: 0 },\r\n            { pic: \"../../images/2.png\", height: 0 },\r\n            { pic: \"../../images/3.png\", height: 0 },\r\n            { pic: \"../../images/4.png\", height: 0 },\r\n            { pic: \"../../images/5.png\", height: 0 },\r\n            { pic: \"../../images/6.png\", height: 0 },\r\n            { pic: \"../../images/7.png\", height: 0 },\r\n            { pic: \"../../images/8.png\", height: 0 },\r\n            { pic: \"../../images/9.png\", height: 0 },\r\n            { pic: \"../../images/10.png\", height: 0 },\r\n            { pic: \"../../images/11.png\", height: 0 },\r\n            { pic: \"../../images/12.png\", height: 0 },\r\n            { pic: \"../../images/13.png\", height: 0 },\r\n            { pic: \"../../images/14.png\", height: 0 }\r\n        ];\r\n\r\n        let baseId = \"img-\" + (+new Date());\r\n\r\n        for (let i = 0; i < images.length; i++) {\r\n            images[i].id = baseId + \"-\" + i;\r\n        }\r\n\r\n        this.setData({\r\n            loadingCount: images.length,\r\n            images: images\r\n        });\r\n    }\r\n\r\n})\r\n这里是显示在两列图片的wxml代码，我们可以看到在组件上，我们通过使用bindscrolltolower设置了事件监听函数，当滚动到底部的时候，会触发loadImages去再加载下一组的图片数据，这样就形成了无限的加载：\r\n<scroll-view scroll-y=\"true\" style=\"height:{{scrollH}}px\" bindscrolltolower=\"loadImages\">\r\n  <view style=\"width:100%\">\r\n    <view class=\"img_item\">\r\n      <view wx:for=\"{{col1}}\" wx:key=\"id\">\r\n        <image src=\"{{item.pic}}\" style=\"width:100%;height:{{item.height}}px\"></image>\r\n      </view>\r\n    </view>\r\n    <view class=\"img_item\">\r\n      <view wx:for=\"{{col2}}\" wx:key=\"id\">\r\n        <image src=\"{{item.pic}}\" style=\"width:100%;height:{{item.height}}px\"></image>\r\n      </view>\r\n    </view>\r\n  </view>\r\n</scroll-view>\r\n好了，挺简单的一个例子，如果你有更好的方法，不吝分享一下哦。\r\n完整代码可以在我的Github下载：https://github.com/zarknight/wx-falls-layout文件下载：wx-falls-layout-master (1).zip"}
{"title": "微信小程序开发之麦克风动画 帧动画 放大 淡出 ", "author": "dzp", "pub_time": "2016-11-26 17:30", "article_content": "想做个录音机,第一步就卡在麦克风动画这里了.先上gif.再吐槽.① 上面gif中声波的动画是个半成品.没有循环播放.在微信小程序的开发文档上找了很久,也没找到循环模式的参数设置.用setInterval()并不执行动画.我在 微信小程序文档 动画最下面找到这么一行字.这个锅是不是可以甩出去了?ps:如果有同学能实现动画循环,一定告诉我.② 麦克风里面是个帧动画.没有前端的基础,只能用非主流的办法凑合了.用wx:if{{}}判断js中定义的值是不是等于图片对应的数字来控制图片的显示和隐藏.css中应该有更好的方法.我css基础不牢,就不说了.上代码:1.index.wxml<!--index.wxml--><view  class=\"voice-style\" bindtap=\"startSpeak\"><image class=\"bg-style\" src=\"../../images/voice_icon_speaking_bg_normal.png\" ></image><image class=\"bg-style\" animation=\"{{spreakingAnimation}}\" src=\"../../images/voice_video_loading_0.png\"></image><image class=\"bg-style\" animation=\"{{spreakingAnimation_1}}\" src=\"../../images/voice_video_loading_0.png\"></image><image class=\"bg-style\" animation=\"{{spreakingAnimation_2}}\" src=\"../../images/voice_video_loading_0.png\"></image><image class=\"sound-style\" src=\"../../images/voice_icon_speech_sound_1.png\" ></image><image wx:if=\"{{j==2}}\" class=\"sound-style\" src=\"../../images/voice_icon_speech_sound_2.png\" ></image><image wx:if=\"{{j==3}}\" class=\"sound-style\" src=\"../../images/voice_icon_speech_sound_3.png\" ></image><image wx:if=\"{{j==4}}\" class=\"sound-style\" src=\"../../images/voice_icon_speech_sound_4.png\" ></image><image wx:if=\"{{j==5}}\"class=\"sound-style\" src=\"../../images/voice_icon_speech_sound_5.png\" ></image></view>2.index.js//index.js//获取应用实例var app = getApp()Page({  data: {    spreakingAnimation: {},//放大动画    j: 1,//帧动画初始图片    isSpeaking: false,//是否在录音状态  },  onLoad: function () {  },  //点击开始说话  startSpeak: function () {    var _this = this;    if (!this.data.isSpeaking) {      speaking.call(this);      this.setData({        isSpeaking: true      })    } else {      //去除帧动画循环      clearInterval(this.timer)      this.setData({        isSpeaking: false,        j: 1      })    }  },})function speaking() {  //话筒帧动画  var i = 1;  this.timer = setInterval(function () {    i++;    i = i % 5;    _this.setData({      j: i    })    return  }, 200);  //波纹放大,淡出动画  var _this = this;  var animation = wx.createAnimation({    duration: 1000  })  animation.opacity(0).scale(3, 3).step();//修改透明度,放大  this.setData({    spreakingAnimation: animation.export()  }) setTimeout(function(){    //波纹放大,淡出动画  var animation = wx.createAnimation({    duration: 1000  })  animation.opacity(0).scale(3, 3).step();//修改透明度,放大  _this.setData({    spreakingAnimation_1: animation.export()  })  },250)   setTimeout(function(){    //波纹放大,淡出动画  var animation = wx.createAnimation({    duration: 1000  })  animation.opacity(0).scale(3, 3).step();//修改透明度,放大  _this.setData({    spreakingAnimation_2: animation.export()  })  },500)}3.index.wxss/**index.wxss**/.voice-style {  margin-top: 400px;  display: flex;  position: relative;  flex-direction: column;  align-items: center;}.bg-style {  position: absolute;  width: 100px;  height: 100px;}.sound-style{  position: absolute;  width: 37.6px;  height: 60px;  margin-top: 20px;}demo下载地址: http://download.csdn.net/detail/qq_31383345/9694388我的博客:http://blog.csdn.net/qq_31383345"}
{"title": "微信小程序入门基础知识 ", "author": "天下雪", "pub_time": "2016-11-27 00:50", "article_content": "一、微信小程序文件格式1、根据最新的微信公开文档，我们知道微信的编码格式是固定的。在每一个的文件夹下面，至少都会有一个.wxml和.js的文件，有可能还会包含.wxss和.json；而且，从文件夹到文件命名，都必须是一样的（都是index），如图所示：2、微信小程序的文件都包含什么内容呢？（1）index.js。很显然，我们可以知道，index.js是一个js文件，我们学习过html5的人都知道，js文件就是用来存放逻辑代码的。所以，我们知道，这里的js文件是用来保存方法和数据。根据图片我们知道，在inde.js里面，几乎所有的处理逻辑都在Page()里面，Page()里面传入的是一个json可是的数据，里面必须存在的一个键值对是data：{}；这里存放的是初始数据，整个页面里面需要调用的数据都会在这里存放，也可以在这里启用，一般调用的地方都在index.wxml里面；调用方式是：{{motto}}或者{{info.name}}。这里的click键值对使用带存放一个函数方法的，这里的function（）{}里面就是你的处理逻辑；这里的click方法可以通过this.click()在Page（）里面的别的方法里面使用，也可以在index.wxml里面通过bindtap=\"click\"来调用。(2)index.wxml:这里的index.wxml，我们知道在Android里面xml是布局文件，在html里面.html也用来存放布局格式的，所以，我们知道这里的index.wxml也是用来存放布局文件的。如图所示：我们可以知道html文件是使用<div></div>来包裹布局，而这里的微信小程序十分简洁，只使用<view></view>来包裹布局文件，当然这里还有别的布局文件，例如<text>、<slider>、<wiper>、<scroll-view>...这些在微信小程序的官网会有说明。(3)index.wxss:我们学习前端的都知道，css是html里面的样式文件，用来给所有的标签编写样式，比如字体颜色，背景颜色等有事可以配置。这里的style样式一样可以使用class样式。（4）index.json:这里的index.json文件是用来保存配置文件的。以键值对的形式来储存数据，一般如果是page里面的json文件，就只需要配置app.json的windows里面选项配置。一般只有navigationBarBackgroundColor（顶部栏颜色）、navigationBarTextStyle（顶部栏样式）、navigationBarTitleText（顶部栏标题）、backgroundColor（背景色）、backgroundTextStyle（背景样式）。3、微信小程序里面有一个全局的以app命名的文件，包括app.js,app.wxml，app.wcss,app.json。这里面的app.js里面包含的是全局的方法和数据，可以通过全局的方法getApp（）获得一个app对象，来调用app.js里面的方法和数据。二、微信小程序的基本数据格式。1、微信if条件语句：在微信中，用 wx:if=\"{{condition}}\" 来判断是否需要渲染该代码块：condition里面的就是判断条件，如果true就执行<view>里面包裹的内容，如果false就会进行下一步。2、微信for循环语句：在微信里面，使用wx：for=\"{{list}}\" 和wx:for-item=\"{{item}}\",来实现循环。使用wx:for控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item。使用 wx:for-item 可以改变数组当前元素的变量名，使用 wx:for-index 可以改变数组当前下标的变量名：这里是一个九九乘法表的代码，使用的是嵌套循环。而且小程序的循环既可以在xml文件里面使用，也可以在js文件里面使用，在js文件里面使用就和原生的js使用方法相同。"}
{"title": "微信小程序ajax实现请求服务器数据，模版遍历数据 ", "author": "天下雪", "pub_time": "2016-11-27 00:52", "article_content": "昨天下载了一个微信小程序的开发者工具，大概看了一下文档，简单的用他的方法实现了ajax请求。微信小程序文档地址：https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1474632113_xQVCl&token=&lang=zh_CN头部标题和底部tab配置都在 app.json文件中，底部tab位最少两个，最多五个。下面是app.json文件代码和相关注释[javascript] view plain copy赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序入门基础知识 \n              github精选：微信小程序开发技巧（12月31日更新） \n            \n             \n            \n                  原作者: XiaoBaiduQs \n                  来自: 原文地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序--ajax服务器交互及页面渲染\n                                    \n                  • 微信小程序的ajax数据请求wx.request\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSsVpRAl', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164136|9cb67b0cbe9b5f59566b147185ca52d8|2';"}
{"title": "《微信小程序七日谈》- 第二天：你可能要抛弃原来的响应式开发思维 ... ", "author": "天下雪", "pub_time": "2016-11-27 12:10", "article_content": "上篇文章第一天：人生若只如初见简单记录了笔者初步上手开发微信小程序遇到的一些问题，其中提到了wxss的部分细节问题。这篇文章以笔者在开发小程序响应式UI当中遇到的一些问题为例，简单记录一下使用wxss为响应式开发带来的一些模式和思维上的改变。rem的重定义前端工程师对rem非常熟悉，rem是以html元素的font-size为基准的尺寸计量单位。rem方便了开发者对响应式UI的尺寸进行统筹管理。wxss中的rem与css中的rem的含义完全不同，下面是微信官方文档中对rem的定义：rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx其中的750这个数值是wxss将设备屏幕的宽统一定义为750rpx，对此，下文会讲解。各位读到这里是否脑海里浮现了一个想法：wxss的rem怎么听起来有点像bootstrap的栅格系统呢？wxss将屏幕宽分为20rem，bootstrap将设备屏幕宽度分为12列。初看起来确实有点类似。但其实wxss的rem和bootstrap的栅格系统并不相同。虽然wxss和bootstrap都是讲屏幕尺寸分割为单元格，但rem和栅格的定位不同。bootstrap的开发者使用指定的classname进行元素间的比例分配，这其实接近为css3中的flexbox；而wxss的rem是一个尺寸单位，你可以在合理的场景下将任何以px为单位的属性值替换为rem。所以，开发小程序UI时，需要抛弃思维中对rem的常规认知。截止目前，笔者还未遇到必须使用小程序rem的需求，希望大家踊跃探讨。rpx的奇妙之处上文提到wxss将设备屏幕的宽统一定义为750rpx，其中的rpx是wxss带来的新的尺寸单位。rpx的定义如下：rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。css中的px与设备的物理像素并非绝对的一比一关系。尤其是在移动设备上，px与物理像素的比例与设备的dpr（devicePixelRadio）有关，详细的对应关系各位可自行查阅。rpx称为相对像素值，rpx与物理像素也并非绝对的一比一关系。wxss将设备宽定义为750rpx，是以iPhone6的分辨率（750x1334）为基准划分的。也就是说，在iPhone6上，1rpx=1物理像素=0.5px。官方文档列出了几种屏幕的rpx对应关系如下：大家可以从中得到rpx和px的换算公式：1rpx = 1px/dpr其中iPhone6的dpr=2。那么rpx带给响应式UI什么改变呢？目前大部分UI工程师在制作UI稿的时候是按照iPhone6的尺寸设计，然后前端工程师按照UI稿尺寸的一半进行UI的还原开发。这样在iPhone6以及接近iPhone6尺寸的设备上是没有任何问题的。但是移动设备的尺寸多种多样，我们的产品不可能只应对iPhone6（况且iPhone7已经来了哈哈...），所以通常的做法是使用css的媒体查询根据设备的尺寸再进行适配微调。如果使用rpx是不是就可以解决这个问题呢？笔者在开发过程中尝试使用rpx代替px，使用UI稿的原始尺寸还原UI，截止到目前体验非常好。rpx本身代表的是相对像素，所以不论多大尺寸的屏幕，rpx的UI占据的屏幕比例是绝对固定的，是等比缩放的。但是rpx并非万能的，比如使用css sprites的图标。请看下文。sprites图标的响应式处理使用css sprites作为图标背景时，每个图标的尺寸是以px为单位固定的，比如：.icon{\r\n  background-image: url('//image.daojia.com/icon.png');\r\n  display: inline-block;\r\n  vertical-align: middle;\r\n}\r\n.icon__circle{\r\n  background-position: 0 0;\r\n  width: 40px;\r\n  height: 40px;\r\n}如果图标的尺寸不符合UI设计，则进行一定比例的缩放：.icon__circle{\r\n    transform: scale(0.5);\r\n}也就是说，使用sprites图标不可避免地会用到px，如果与rpx结合使用，是不能保证同rpx一样等比缩放效果的。那么怎么去解决这个问题呢？根据上文总结出的rpx与px的换算公式，如果想要将以px规定的UI达到同rpx一样的响应式缩放效果，必须将px与设备的dpr进行计算。但是css作为一种标记语言，并不具备动态特性，无法动态地获取设备dpr并计算。所以，单纯使用wxss并不能解决上文提到的问题。好消息是小程序提供了获取设备信息的API，并且支持CommonJS模块化方案。有了这些功能，我们可以在封装组件时加入动态的逻辑配置。还是以上文的代码为例，sprites图的icon__circle尺寸为40px*40px，我们的目标是将其适配为20rpx，以下是笔者的开发方案。比如项目中有一个user组件，包含了一些sprites图标节点。user组件的文件目录如下：user.wxml - 组件模板；user.wxss - 组件样式；user.js - 组件逻辑。首先给user.wxml中icon对应的element设置动态的transform：<view class='icon icon__circle' style=\"transform: scale({{iconScale}})\"></view>其中iconScale是引用user的外部组件index传递给user组件的：<import src='user.wxml'/>\r\n<template is='product-user' data=\"{{iconScale: userIconScale}}\"/>userIconScale是index组件的一个data，userIconScale的值并非index组件规定的，而是由index组件的js调用user.js动态获取的。以下代码是user.js暴露的API：const ORIGIN_ICON_PX = 40;\r\nconst TARGET_ICON_RPX = 20;\r\n\r\nmodule.exports = {\r\n  getIconScale() {\r\n    let result = 1;\r\n    wx.getSystemInfo({\r\n      success: function(res) {\r\n        let _dpr = res.pixelRatio;\r\n        result = TARGET_ICON_RPX/(ORIGIN_ICON_PX * _dpr);\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n}然后在index组件的js中调用以上API：let getIconScale = require('user.js').getIconScale;\r\nPage({\r\n    data: {\r\n        userIconScale: 1\r\n    },\r\n    onLoad(){\r\n        this.setData({\r\n            userIconScale: getIconScale()\r\n        });\r\n    }\r\n});以上只是初步的方案，很多地方需要再仔细琢磨。不过以上方案基本上具备了一个组件的逻辑封装，并且达到了我们对响应式的开发需求。总结第二天的开发经历还是颇有收获的，不仅仅是对小程序开发模式的熟悉，而且对一些综合方案也有一定的深入。期待后续吧。"}
{"title": "Mjw：微信小程序之踩坑之旅一，wx.request 和 wx.uploadFile ", "author": "天下雪", "pub_time": "2016-11-27 13:34", "article_content": "感谢作者@mjw同学；uploadFile困扰着很多人，本文可以作为参考之一，希望mjw同学可以继续完善之。。。假如你在解决wx.request 和 wx.uploadFile中有心得，也欢迎分享出来！微信小程序公测也有段时间了，但是里面的坑踩了一个又一个，心也是够累的。本文说说关于 wx.request 和 wx.uploadFile 对请求响应的不同表现。wx.request使用 wx.request 发出请求，在对接口的响应做处理时，官方提供了三个回调函数，分别是 success，fail，complete，看了官方文档，其实也很清晰什么时候用什么回调，在这里也不多赘述了。wx.uploadFile使用 wx.uploadFile 可以上传文件，并可以携带一些额外的信息，在对接口的响应做处理时，和 wx.request 一样，也提供了同样的三个回调函数，在官方文档中，其描述几乎是一样的（除了success）。在对这两个接口有了一定的了解后，说说这两个接口对请求的相应的不同表现。先上张图体会下：wx.request 发出请求后，无论请求接口返回的 HTTP 状态码（200也好，500也好）是什么，都会进入 success 回调，和一般认为的 500 会进入 fail 回调不一样。（吐槽：对，接口是微信开发团队定的，按照这个规律，我们只能遵循，然后我就遵循这一规律继续写）wx.uploadFile 发出请求后，如果请求接口返回的 HTTP 状态码为200时，会进入 success 回调，而返回其他状态码（如400、405、500等）时，会进入 fail 回调（黑人问号.jpg）。虽然这不是啥大问题，但在微信小程序的开发过程中，上面提到的问题还是会让人一下子摸不着路子。个人觉得接口保持一致性还是很重要的，不过游戏的制定者不是我们，只能希望越改越好吧。感觉不坑，对吧？下面其实才是坑人的地方。本文得出结果是在微信开发者工具上运行的结果，跟实际手机预览得出的结果又有出入（微信你搞什么鬼！！！），如果在手机上预览（我是在iOS上预览的）的话会变成—— wx.request 和 wx.uploadFile 的回调被调用的情况是一样的。相关问题：问题描述：手机预览时 wx.uploadFile 自定义 header 不生效我遇到的问题：手机预览时 wx.uploadFile 自定义 header 不生效。下面是我的问题描述：我在使用 wx.uploadFile 这个接口上传文件时，需要在 header 中添加一些自定义的字段，根据文档，我完成了小程序的代码：这是后端接口的代码，用的是 PHP 的 Symfony 框架：代码在开发者工具运行时，可以正确上传文件，后台接口也可以正确获取信息，如上传的文件、额外的 formData 数据和自定义的 header 字段，但在手机预览时，却无法正确获取 header 的自定义字段，添加了 header 的日志记录之后发现，在手机端预览的时候，header 中没有包含我代码中自定义的字段。我也针对这个测试接口自己写了测试代码：运行如上截图的测试代码并查看日志输出：解决过程：小程序端，我把自定义的 header 字段放到了 formData 的位置，后端就可以正常接收自定义的 header 字段了。但我还是有点懵逼，难道文档是用来骗人的？补充：测试时使用到：微信开发者工具 v0.11.112300手机预览 iPhone6s 微信6.3.31后台使用 Symfony 3.1.7PHP 5.6.28Nginx经过测试，发现小程序在调用 wx.uploadFile 目前（不知道微信开发团队后续会怎样修复）是如下情况：如果在微信开发者工具想正确传递自定义 header 到后台接口时，只需要按照官方文档所说，把自定义 header 放在 wx.uploadFile 接口的 header 配置选项。如果想在手机预览正确传递自定义 header 到后台接口时，就要把自定义 header 放到 wx.uploadFile 接口的 formData 配置选项。前方有坑！在使用 wx.uploadFile 时，配置选项中 formData 使用时，在开发者工具和手机预览时，又有出入（什么鬼！）。举个例子，我需要在上传文件时传递一个额外的 flag 到后台接口，这个 flag 的值是 true，经过测试，发现小程序目前得出的结果是：如果想在微信开发者工具正确传递这个 flag 到后台接口，则可以用如下代码传递：wx.uploadFile({\r\n    // 省略其他\r\n    formData: {\r\n        flag: true\r\n    }\r\n})如果想在手机预览正确传递这个 flag 到后台接口，则需要用如下代码传递：wx.uploadFile({\r\n    // 省略其他\r\n    formData: {\r\n        flag: 'true'\r\n    }\r\n})其实看了官方文档，的确是有看到 formData 的属性值有用引号引起来，但却没有在文档中做出说明，而且，这个用法在微信开发者工具和在手机预览时有着明显的区别。如上，如果在手机预览时，flag 的值没有使用引号引起来，则后台通过 request 是获取不了的（黑人问号.jpg）。在这里吐槽一下微信小程序没有提供一个很好的 bug 反馈渠道，按照官方文档，我尝试过发送邮件给微信开发团队，但始终没有回音。上面是我最新的测试结果，微信小程序不知道会不会有所修复，又或者是我所用的技术栈所导致的问题，所以这里也希望用其他技术栈的童鞋尝试一下。本文 Demo 的仓库：https://github.com/jwma/daily-coding/tree/master/wechat-app/request-and-upload-file文件下载：wechat-app.zip"}
{"title": "微信小程序开发之录音机 音频播放 动画 (真机可用) ", "author": "天下雪", "pub_time": "2016-11-27 13:41", "article_content": "replyreload += ',' + 6547;原文地址趁着周末用微信小程序做了个简易录音机.跟大家分享,欢迎批评!老规矩,先几张图.1.为了进来看得清楚.刚开始没有加载音频列表.代码往前挪一挪即可.2.按住 录音按钮的时候会出现麦克风.中间的麦克风是个帧动画.其实就是用js控制图片显示隐藏.没啥好说的.这里值得说一说的是录音.微信的录音API后,如果录音时间太短,会录音失败.所以fail的时候还是需要处理一下.录音时间的限制和微信语音是一样的.60秒.3.我在录音完成后才加载列表.下图就是从微信存储的文件里获取到的列表信息.有储存路径,创建时间,文件大小.这里的文件可能不只是音频.这里我没做判断.下面的路径都是wx:file//store_...我也去找了下.在Tencent/micromsg/wxafiles/wx..../这一级目录就能找到了.时间是格式化之后的.文件大小是B,转成KB如下.\r\n手机目录如下.但是打开之后播放不了.目前原因不明.\r\n下面是文件全名称.1.tempFilePath : 录音之后的临时文件.第二次进入小程序就不能正常使用了.2.savedFilePath :持久保存的文件路径.值得注意的是微信只给100M的储存空间.还是尽早上传到后台吧.\r\n4.播放录音音频.点击item就能听到你的声音了.别被自己吓住.哈哈.\r\n\r\n上代码:1.index.wxml<scroll-view>\r\n <view wx:if=\"{{voices}}\" class=\"common-list\" style=\"margin-bottom:120rpx;\">\r\n<block  wx:for=\"{{voices}}\">\r\n     <view class=\"board\">\r\n                        <view class=\"cell\"  >\r\n                            <view class=\"cell-bd\" data-key=\"{{item.filePath}}\" bindtap=\"gotoPlay\" > \r\n                                       <view  class=\"date\">存储路径:{{item.filePath}}</view>\r\n                                <view  class=\"date\" >存储时间:{{item.createTime}}</view>\r\n                                <view  class=\"date\">音频大小:{{item.size}}KB</view>\r\n                            </view>  \r\n                                                \r\n                        </view>\r\n        </view>\r\n</block>\r\n </view>\r\n </scroll-view>\r\n \r\n<view  wx:if=\"{{isSpeaking}}\"  class=\"speak-style\">\r\n<image class=\"sound-style\" src=\"../../images/voice_icon_speech_sound_1.png\" ></image>\r\n<image wx:if=\"{{j==2}}\" class=\"sound-style\" src=\"../../images/voice_icon_speech_sound_2.png\" ></image>\r\n<image wx:if=\"{{j==3}}\" class=\"sound-style\" src=\"../../images/voice_icon_speech_sound_3.png\" ></image>\r\n<image wx:if=\"{{j==4}}\" class=\"sound-style\" src=\"../../images/voice_icon_speech_sound_4.png\" ></image>\r\n<image wx:if=\"{{j==5}}\"class=\"sound-style\" src=\"../../images/voice_icon_speech_sound_5.png\" ></image>\r\n </view>\r\n <view class=\"record-style\">\r\n <button class=\"btn-style\" bindtouchstart=\"touchdown\" bindtouchend=\"touchup\">按住 录音</button>\r\n </view>\r\n2.index.wxss.speak-style{\r\n    position: relative;\r\n    height: 240rpx;\r\n    width: 240rpx;\r\n    border-radius: 20rpx;\r\n    margin: 50% auto;\r\n    background: #26A5FF;\r\n}\r\n.item-style{\r\n    margin-top: 30rpx;\r\n    margin-bottom: 30rpx;\r\n}\r\n.text-style{\r\n    text-align: center;\r\n\r\n}\r\n.record-style{\r\n    position: fixed;\r\n    bottom: 0;\r\n    left: 0;\r\n    height: 120rpx;\r\n    width: 100%;\r\n}\r\n.btn-style{\r\n  margin-left: 30rpx;\r\n  margin-right: 30rpx;\r\n}\r\n\r\n.sound-style{\r\n  position: absolute;\r\n  width: 74rpx;\r\n  height:150rpx;\r\n  margin-top: 45rpx;\r\n  margin-left: 83rpx;\r\n}\r\n\r\n.board {\r\n  overflow: hidden;\r\n  border-bottom: 2rpx solid #26A5FF;  \r\n}\r\n/*列布局*/\r\n.cell{\r\n    display: flex;\r\n    margin: 20rpx;\r\n}\r\n.cell-hd{\r\n    margin-left: 10rpx;\r\n    color: #885A38;\r\n}\r\n.cell .cell-bd{\r\n    flex:1;\r\n    position: relative;\r\n   \r\n}\r\n/**只显示一行*/\r\n.date{\r\n    font-size: 30rpx;\r\n    text-overflow: ellipsis; \r\n    white-space:nowrap;\r\n    overflow:hidden; \r\n}\r\n\r\n\r\n3.index.js\r\n\r\nvar app = getApp()\r\nPage({\r\n  data: {\r\n    j: 1,//帧动画初始图片\r\n    isSpeaking: false,//是否正在说话\r\n    voices: [],//音频数组\r\n  },\r\n  onLoad: function () {\r\n  },\r\n  //手指按下\r\n  touchdown: function () {\r\n    console.log(\"手指按下了...\")\r\n    console.log(\"new date : \" + new Date)\r\n    var _this = this;\r\n    speaking.call(this);\r\n    this.setData({\r\n      isSpeaking: true\r\n    })\r\n    //开始录音\r\n    wx.startRecord({\r\n      success: function (res) {\r\n        //临时路径,下次进入小程序时无法正常使用\r\n        var tempFilePath = res.tempFilePath\r\n        console.log(\"tempFilePath: \" + tempFilePath)\r\n        //持久保存\r\n        wx.saveFile({\r\n          tempFilePath: tempFilePath,\r\n          success: function (res) {\r\n            //持久路径\r\n            //本地文件存储的大小限制为 100M\r\n            var savedFilePath = res.savedFilePath\r\n            console.log(\"savedFilePath: \" + savedFilePath)\r\n          }\r\n        })\r\n        wx.showToast({\r\n          title: '恭喜!录音成功',\r\n          icon: 'success',\r\n          duration: 1000\r\n        })\r\n        //获取录音音频列表\r\n        wx.getSavedFileList({\r\n          success: function (res) {\r\n            var voices = [];\r\n            for (var i = 0; i < res.fileList.length; i++) {\r\n              //格式化时间\r\n              var createTime = new Date(res.fileList.createTime)\r\n              //将音频大小B转为KB\r\n              var size = (res.fileList.size / 1024).toFixed(2);\r\n              var voice = { filePath: res.fileList.filePath, createTime: createTime, size: size };\r\n              console.log(\"文件路径: \" + res.fileList.filePath)\r\n              console.log(\"文件时间: \" + createTime)\r\n              console.log(\"文件大小: \" + size)\r\n              voices = voices.concat(voice);\r\n            }\r\n            _this.setData({\r\n              voices: voices\r\n            })\r\n          }\r\n        })\r\n      },\r\n      fail: function (res) {\r\n        //录音失败\r\n        wx.showModal({\r\n          title: '提示',\r\n          content: '录音的姿势不对!',\r\n          showCancel: false,\r\n          success: function (res) {\r\n            if (res.confirm) {\r\n              console.log('用户点击确定')\r\n              return\r\n            }\r\n          }\r\n        })\r\n      }\r\n    })\r\n  },\r\n  //手指抬起\r\n  touchup: function () {\r\n    console.log(\"手指抬起了...\")\r\n    this.setData({\r\n      isSpeaking: false,\r\n    })\r\n    clearInterval(this.timer)\r\n    wx.stopRecord()\r\n  },\r\n  //点击播放录音\r\n  gotoPlay: function (e) {\r\n    var filePath = e.currentTarget.dataset.key;\r\n    //点击开始播放\r\n    wx.showToast({\r\n      title: '开始播放',\r\n      icon: 'success',\r\n      duration: 1000\r\n    })\r\n    wx.playVoice({\r\n      filePath: filePath,\r\n      success: function () {\r\n        wx.showToast({\r\n          title: '播放结束',\r\n          icon: 'success',\r\n          duration: 1000\r\n        })\r\n      }\r\n    })\r\n  }\r\n})\r\n//麦克风帧动画\r\nfunction speaking() {\r\n  var _this = this;\r\n  //话筒帧动画\r\n  var i = 1;\r\n  this.timer = setInterval(function () {\r\n    i++;\r\n    i = i % 5;\r\n    _this.setData({\r\n      j: i\r\n    })\r\n  }, 200);\r\n}\r\n\r\n注意:1.录音的音频默认是存在本地的临时路径下.第二次进入小程序无法正常使用,可以存持久,但是本地文件大小的限制是100M,最好还是上传后台.2.录音的时间不能太短.否则会失败;也不能超过60秒.到了60秒会自动停止录音.3.音频播放不能同时播放多个音频.\r\ndemo代码下载下载地址：http://download.csdn.net/detail/qq_31383345/9694664文件下载： Record.rar我的博客.欢迎批评!\r\nRecord.rar"}
{"title": "微信小程序学习实践记录《三》：视图容器，icon ", "author": "天下雪", "pub_time": "2016-11-28 00:56", "article_content": "一：视图容器1. Viewflex-direction:row:横向布局模式；如果不设置该属性，默认为横向flex-direction:column:纵向布局。界面样式代码注意：1.如果想要改模式有效，父控件必须设置显示方式为flex模式，display:flex;           2.要想控件的背景颜色显示出来，必须view设置大小，否则background-color属性无效。2.scroll-view[html] view plain copy<view class=\"section\">    <view class=\"section__title\">vertical scroll</view>    <!--如果是垂直滚动，必须设置scrollview的高度，切记-->    <scroll-view scroll-y=\"true\" style=\"height: 200px;\" bindscrolltoupper=\"upper\" bindscrolltolower=\"lower\" bindscroll=\"scroll\" scroll-into-view=\"{{toView}}\" scroll-top=\"{{scrollTop}}\">      <view id=\"green\" class=\"scroll-view-item bc_green\"></view>      <view id=\"red\"  class=\"scroll-view-item bc_red\"></view>      <view id=\"yellow\" class=\"scroll-view-item bc_yellow\"></view>      <view id=\"blue\" class=\"scroll-view-item bc_blue\"></view>    </scroll-view>      <view class=\"btn-area\">      <button size=\"mini\" bindtap=\"tap\">click me to scroll into view </button>      <button size=\"mini\" bindtap=\"tapMove\">click me to scroll</button>    </view>  </view>  <view class=\"section section_gap\">    <view class=\"section__title\">horizontal scroll</view>    <scroll-view class=\"scroll-view_H\" scroll-x=\"true\" style=\"width: 100%\">      <view id=\"green\" class=\"scroll-view-item_H bc_green\"></view>      <view id=\"red\"  class=\"scroll-view-item_H bc_red\"></view>      <view id=\"yellow\" class=\"scroll-view-item_H bc_yellow\"></view>      <view id=\"blue\" class=\"scroll-view-item_H bc_blue\"></view>    </scroll-view>  </view>  界面渲染代码：[css] view plain copy.section {  赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序开发之录音机 音频播放 动画 (真机可用) \n              微信小程序学习实践记录《四》：text组件，progress进度条 \n            \n             \n            \n                  原作者: IT小痞子 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序学习记录《一》：目录结构介绍，开发工具菜单介绍 ... ...\n                                    \n                  • 微信小程序学习记录《二》：系统配置app.json，程序和页面注册.js ... ...\n                                    \n                  • 微信小程序学习实践记录《四》：text组件，progress进度条\n                                    \n                  • 微信小程序学习实践记录《五》：button控件\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSjDh7T2', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164141|dfb0964a25cefe38aca7c3206b179867|2';"}
{"title": "微信小程序学习实践记录《四》：text组件，progress进度条 ", "author": "天下雪", "pub_time": "2016-11-28 00:59", "article_content": "一：text组件text文本组件特点：1>  支持转义符\"\\\"；2> <text/> 组件内只支持 <text/> 嵌套。中间不能嵌套其他任何组件；3> 该组件中的内容可以通过长按进行选中的，其他组件中的内容都不支持长按选中。界面渲染代码：[css] view plain copy.btn {    margin-top: 30px;    display: flex;    flex-direction: column;    justify-content: space-around;    align-items: center;    margin-left: 20px;    margin-right: 20px;  }    text {    margin-top: 10px;    font-size: 25px;  }  控制层代码：[javascript] view plain copy//logs.js  var util = require('../../utils/util.js')  Page({    data: {      // <text>{{text}}</text>      text:\"这里的内容是通过js设置的变量\"    }  })  再次提示：如果界面文本的固定的建议使用第一种text组件形式，如果文本是会改变的，用第三种方法，通过修改控制层变量的值实现页面变化二：progress进度条progress进度条控件：主要用于一项任务的完成进度，例如：数据下载进度、视频播放进度、安装进度等。1.控件参数2.属性对控件的影响show-info和active默认为false，如果为true的时候可以不写属性值，也可以写为active=“true”"}
{"title": "Mr.ning：微信小程序初体验：获取坐标位置和根据坐标查看地址 ... ", "author": "天下雪", "pub_time": "2016-11-28 10:43", "article_content": "文档地址：https://mp.weixin.qq.com/debug/wxadoc/dev/?t=1474644089434根据文档地址中下载微信开发工具后，按照文档指引可以创建一个快速体验的小demo ，样例中的文件说明如下：小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：app.js是小程序逻辑app.json是小程序公共设置app.wxss否小程序公共样式表   一个小程序页面由四个文件组成，分别是：文件类型必填作用js是页面逻辑wxml是页面结构wxss否页面样式表json否页面配置     为了学习下API的调用，体验了下【获取坐标位置】和【根据坐标查看地址】两个接口，更多接口信息请查看：https://mp.weixin.qq.com/debug/wxadoc/dev/api/?t=20161122或者直接下载源码：https://mp.weixin.qq.com/debug/wxadoc/dev/demo/demo.zip?t=20161122简单贴一下体验的小程序相关目录和内容：目录结构： 未打开的文件夹就是根据文档指引快速生成的默认内容，未做修改format-location.js中的内容：1234567891011function formatLocation(longitude, latitude) {  longitude = longitude.toFixed(2)  latitude = latitude.toFixed(2)   return {    longitude: longitude.toString().split('.'),    latitude: latitude.toString().split('.')  }} module.exports = formatLocation　index.js赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序学习实践记录《四》：text组件，progress进度条 \n              [Wondgirl] 入门系列教程《二》视图渲染 \n            \n             \n            \n                  原作者: Mr.ning \n                  来自: 原文地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSQMirZr', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164144|273ba2a456dba6a31d01c2a1fe58708a|2';"}
{"title": "微信小程序新手开发记录文档《三》 ", "author": "天下雪", "pub_time": "2016-11-24 10:54", "article_content": "感谢本站会员御宅喵人，奖励50点积分在开发阶段中会碰到很多的问题，例如wx.request数据请求不成功，在数组操作时，不知道如何往数组里push数据，input如何监听用户输入的状态，css的background-image无法获取本地资源等。注意1：一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。注意2： wx.request(OBJECT): wx.request发起的是https请求。一个微信小程序，同时只能有5个网络请求连接。OBJECT参数选择\r\n\r\n在编写可复用的代码的时候，常用功能：搜索、注册。底部导航条状态栏设置。注意：tabBar参考官方文档， tabBar的配置。如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。1）写在page数组中的页面，第一项必须是初始页面，这个页面也必须是tabBar的第一项。2）tabBar 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。是在app.json的配置文件中用list存放对象。  list 接受一个数组，数组中的每个项都是一个对象。底部导航状态页面tabBar配置例如在底部导航栏，我们点击购物车，会跳转到购物车页面（底子字体会高亮变红），配置路径如下：{\"pagePath\": \"page/cart/index\",\"iconPath\": \"image/cart.png\",\"selectedIconPath\": \"image/cart_hover.png\",\"text\": \"购物车\"}点击底部导航购物车栏，跳转到我的购物袋页面\r\n3）可如果你有给每个页面都添加tabBar的需求，小程序做不到，因为现在微信只能在首页加载。Page页面配置页面是通过Page对象来渲染的，每个页面对应的js文件必须要创建page，最简单的方式就是在js文件下写入Page({})，在page中有管理页面渲染的生命周期，以及数据处理，事件都在这完成。先创建页面，然后处理JS文件。购物车页面page创建\r\n页面路由Page route在微信中有两种路由方式一种是在wxml文件使用组件，一种是调 wx.navigateTo。例如，Wxml文件搜素页面：首页搜索页面结构\r\nJS文件事件处理函数：<!--bindtap:function(event){wx.navigateTo({url: “search/search”})}-->或者使用组件：\r\n以上仿的这个淘宝小Demo，主要涉及导航样式、Input、View、Text、点击、JS交互的使用，主要是理解每个后缀文件的使用功能，然后才能更好的进行开发。"}
{"title": "wyao：微信小程序入门四：框架详解（1）：配置 ", "author": "天下雪", "pub_time": "2016-11-24 11:00", "article_content": "-app.json文件对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、tab等 1 {\r\n 2   \"pages\": [ //决定页面文件的路径\r\n 3     \"pages/index/index\", //第一项配置为默认打开时显示的页面，不需要后缀名，因为其包含.js文件、.wxml文件、.wxss文件以及.json文件，\r\n 4     \"pages/logs/logs\"\r\n 5   ],\r\n 6   \"window\": { //窗口默认的表现\r\n 7     \"backgroundTextStyle\": \"light\",  //下拉背景字体、loading 图的样式，仅支持 dark/ligh,默认值为dark\r\n 8     \"navigationBarBackgroundColor\": \"#fff\", //导航栏背景颜色\r\n 9     \"navigationBarTitleText\": \"导航栏文本\", //导航栏显示的文本内容\r\n10     \"navigationBarTextStyle\": \"black\" //导航栏标题颜色，仅支持 black/white，默认值white\r\n11   },\r\n12   \"tabBar\": { //设置tab栏，tabBar是一个数组，若是配置，最少2个，最多5个，tab按数组的顺序排序\r\n13     \"list\": [\r\n14       {\r\n15         \"pagePath\": \"pages/index/index\",\r\n16         \"text\": \"首页\"\r\n17       },\r\n18       {\r\n19         \"pagePath\": \"pages/logs/logs\",\r\n20         \"text\": \"日志\"\r\n21       }\r\n22     ]\r\n23   },\r\n24   \"networkTimeout\": { //设置各自网络请求的超时时间单位为毫秒\r\n25     \"request\": 10000,\r\n26     \"downloadFile\": 10000\r\n27   },\r\n28   \"debug\": true //可以在开发者工具中开启debug模式\r\n29 }　　-每一个页面也可以使用.json文件来对本页面的窗口进行配置　　　　--pages.json会覆盖app.json中window配置项中同的内容，若配置内容不相同，则不覆盖　　　　--页面的.json只能设置window相关的配置项，以决定页面窗口的表现，因此不需写window这个键1 {\r\n2   \"navigationBarBackgroundColor\": \"#f00\",\r\n3   \"navigationBarTextStyle\": \"white\",\r\n4   \"navigationBarTitleText\": \"具体页面导航栏演示\",\r\n5   \"backgroundColor\": \"#eeeeee\",\r\n6   \"backgroundTextStyle\": \"light\"\r\n7 }逻辑　　-小程序开发框架的逻辑层是由javascript编写　　-逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈　　　　--增加App和Page方法，进行程序和页面的注册　　　　--增加getApp和getCurrentPages方法，分别用来获取App实例和当前页面栈　　　　--每个页面有独立的作用域，并提供模块化能力　　　　--框架并非运行在浏览器中，不存在DOM等，所以javascript在web中的一些功能不能使用　　　　--开发者写的所有代码最终将会打包成一份javascript，并在小程序启动时运行，直到小程序销毁，类似serviceWorker，所以逻辑层也称之为App Service"}
{"title": "微信小程序基础之视图控件View、ScrollView、Swiper ", "author": "天下雪", "pub_time": "2016-11-24 14:33", "article_content": "作者:hbblzjy：原文地址首先显示首页结构。创建三个navigator，用来跳转页面：<!--index.wxml--><!--创建一个标签介绍--><view class=\"usermotto\">    <text class=\"user-motto\">{{motto}}</text>  </view><!--创建三个navigator,一定要记住为了便捷，可以把新创建的文件放在index文件下，然后对应写文件跳转路径，如：Component/View/View，在软件的最下面有对应编辑文件的路径地址--><view class=\"viewName\">  <navigator url=\"Component/View/View\">    <text class=\"view-Name\">View展示</text>  </navigator></view><view class=\"viewName\">  <navigator url=\"Component/ScrollView/ScrollView\">    <text class=\"view-Name\">Scroll-View展示</text>  </navigator></view><view class=\"viewName\">  <navigator url=\"Component/Swiper/Swiper\">    <text class=\"view-Name\">Swiper展示</text>  </navigator></view>然后分开创建三个样式界面：1.<!--View.wxml--><view class=\"viewTitle\">    <text>View展示</text></view><!--样式一，横向排列--><view class=\"section\">    <view class=\"section__title\">样式一，横向排列</view>    <view class=\"flex-wrp\">        <view class=\"flex-item bc_green\">111</view>        <view class=\"flex-item bc_red\">222</view>        <view class=\"flex-item bc_blue\">333</view>    </view></view><!--样式二，竖向排列,注意在 .wxml的文件中也可以通过style参数进行样式设计--><view class=\"section\">    <view class=\"section__title\">样式二，竖向排列</view>    <view class=\"flex-wrp\" style=\"height:300px\">        <view class=\"flex-item bc_green\" style=\"margin-top: 0px\">111</view>        <view class=\"flex-item bc_red\" style=\"margin-top: 100px\">222</view>        <view class=\"flex-item bc_blue\" style=\"margin-top: 200px\">333</view>    </view></view>其中样式展示中可以相互结合，减少代码量：/**View.wxss**/.flex-wrp{    height: 100px;    display: flex;    background-color: #ffffff;}/**记住，样式类名之间可以相互搭配使用，这样样式设计时可以减少代码量，不过这需要好的逻辑设计，如：View.wxml文件中<view class=\"flex-item bc_green\">111</view>的语句，就是flex-item与app.wxss中bc_green的结合**/.flex-item{    width: 100px;    height: 100px;    color: #ffffff;    display: flex;    justify-content: center;    align-items: center;}2.<!--ScrollView.wxml--><view class=\"viewTitle\">    <text class=\"titleName\">ScrollView视图展示</text>  </view>  <!--样式一，竖向滑动--><view class=\"section\">    <view class=\"section__title\">样式一，竖向滑动Vertical</view>    <view class=\"flex-wrp\">    <!--bindscrolltoupper后面的参数可以不写，在.js文件中    有对应的交互方法-->      <scroll-view scroll-y=\"true\" style=\"height: 200px;\"       bindscrolltoupper=\"upper\" bindscrolltolower=\"lower\"       bindscroll=\"scroll\" scroll-into-view=\"{{toView}}\"       scroll-top=\"{{scrollTop}}\">      <!--这里的id用来js中找到对应的显示视图，如果不进行js中data的{{toView}}      的数据交互，显示的是蓝黄红绿，如果进行js数据交互，那么初始化时显示的是      最下面的绿-->        <view id=\"blue\" class=\"scroll-view-item bc_blue\"></view>        <view id=\"yellow\"  class=\"scroll-view-item bc_yellow\"></view>        <view id=\"red\" class=\"scroll-view-item bc_red\"></view>        <view id=\"green\" class=\"scroll-view-item bc_green\"></view>      </scroll-view>    </view></view><!--样式二，横向滑动--><view class=\"section\">    <view class=\"section__title\">样式二，横向滑动Horizontal</view>    <view class=\"flex-wrp\">    <scroll-view class=\"scroll-view_H\" scroll-x=\"true\" style=\"width: 100%\">        <view id=\"green\" class=\"scroll-view-item_H bc_green\"></view>        <view id=\"red\"  class=\"scroll-view-item_H bc_red\"></view>        <view id=\"yellow\" class=\"scroll-view-item_H bc_yellow\"></view>        <view id=\"blue\" class=\"scroll-view-item_H bc_blue\"></view>      </scroll-view>    </view></view>3.<!--Swiper.wxml-->  <view class=\"viewTitle\">    <text class=\"titleName\">Swiper视图展示</text>  </view>  <view class=\"page__bd\">    <view class=\"section section_gap swiper\">      <swiper indicator-dots=\"{{indicatorDots}}\" vertical=\"{{vertical}}\"        autoplay=\"{{autoplay}}\" interval=\"{{interval}}\"         duration=\"{{duration}}\">        <block wx:for=\"{{background}}\">          <swiper-item>            <view class=\"swiper-item bc_{{item}}\"></view>          </swiper-item>        </block>      </swiper>    </view>    <view class=\"btn-area\">      <button type=\"default\" bindtap=\"changeIndicatorDots\">      显示/取消指示点</button>      <button type=\"default\" bindtap=\"changeVertical\">      {{vertical?'横显示':'竖显示'}}</button>      <button type=\"default\" bindtap=\"changeAutoplay\">      开始/停止轮播</button>    </view>    <slider bindchange=\"durationChange\" value=\"{{duration}}\"     show-value min=\"200\" max=\"2000\"/>    <view class=\"section__title\">轮播一次的时间duration</view>    <slider bindchange=\"intervalChange\" value=\"{{interval}}\"     show-value min=\"1000\" max=\"10000\"/>    <view class=\"section__title\">间隔多长时间显示下一个图interval</view>  </view>第三个视图展示的交互操作，包含文字显示，点击按钮，滑块操作变化等等：//Swiper.jsPage({  data: {    background: ['green', 'red', 'yellow'],    indicatorDots: true,    vertical: false,    autoplay: false,    interval: 3000,    duration: 1200  },  changeIndicatorDots: function (e) {    this.setData({      indicatorDots: !this.data.indicatorDots    })  },  changeVertical: function (e) {    this.setData({      vertical: !this.data.vertical    })  },  changeAutoplay: function (e) {    this.setData({      autoplay: !this.data.autoplay    })  },  intervalChange: function (e) {    this.setData({      interval: e.detail.value    })  },  durationChange: function (e) {    this.setData({      duration: e.detail.value    })  }})然后设计过程中，有些样式重复可以在app.wxss中进行样式确定，方便重复调用：/**这里可以设计所有界面中都包含的控件的公共样式，但是要记住类名要写一致，否则无法调用，比如下面的类名就是每个页面的标题样式**/.viewTitle{    margin-top: 20px;    height: 40px;    text-align: center;}.bc_green{    background-color: #09BB07;}.bc_red{    background-color: #F76260;}.bc_blue{    background-color: #10AEFF;}.bc_yellow{    background-color: #FFBE00;}.bc_gray{    background-color: #C9C9C9;}还要记住，需要在app.json中添加界面地址，否则会出现跳转失败的问题，而且文件的添加位置，不要写错:{  \"pages\":[    \"pages/index/index\",    \"pages/logs/logs\",    \"pages/index/Component/View/View\",    \"pages/index/Component/ScrollView/ScrollView\",    \"pages/index/Component/Swiper/Swiper\"  ],  \"window\":{    \"backgroundTextStyle\":\"light\",    \"navigationBarBackgroundColor\": \"#FFF0F5\",    \"navigationBarTitleText\": \"组件一介绍：视图控件\",    \"navigationBarTextStyle\":\"black\",    \"backgroundColor\": \"#fbf9fe\"  }}效果图展示：源码下载：https://github.com/hbblzjy/WXViewScrollSwiperDemo文件下载：WXViewScrollSwiperDemo-master.zip"}
{"title": "微信小程序仿IOS tableview及实现图片缩放 ", "author": "天下雪", "pub_time": "2016-11-24 14:46", "article_content": "一：IOS tableview最近小程序挺火的，于是我奉命弄弄小程序，好了废话不说，先实现个iOS里面最常见的tableview吧。基础的我就不说了，想要实现tableview，首先先弄个滑动的 ，那就它了 scroll-view;[plain] view plain copy<scroll-view scroll-y=\"true\" style=\"height:100%\" >  </scroll-view>  有了框架，我们得弄里面的内容了，在微信小程序里，for循环就好了，看下面代码[html] view plain copy<view wx:for=\"{{array}}\" style=\"width:100%\">  </view>  里面这一句比较厉害了 wx:for 这个就是小程序的for循环了。我们把数据卸载for的后面就好了 wx:for=\"{{array}}\"，就像这样。官方原画是这样的：在组件上使用wx:for控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item我们用的就是列表渲染。好了该细调一下里面的cell,像我这个就是一个图片集合，下面带着文字而已，ok，总体来说就酱（在wxml里）[plain] view plain copy<view>    <scroll-view scroll-y=\"true\" style=\"height:100%\" >      <view wx:for=\"{{array}}\" style=\"width:100%\">      <image id=\"{{index}}\" mode=\"aspectFill\" src=\"{{item}}\" style=\"width:100%;height:250px\" bindtap=\"tapName\" data-img=\"{{item}}\"></image>       <label style=\"width:100%;height:50px;font-family:'微软雅黑'\">{{item}}</label>      </view>    </scroll-view>  </view>  没有数据哇，数据在这呢（在.js里面）微信分的好清楚呢数据习惯用[plain] view plain copyPage({    data: {}  })  来表示，data里面放我们在wxml定义的array了，整体的代码就是[plain] view plain copyPage({    data: {      array: [       \"http://a.hiphotos.baidu.com/zhidao/pic/item/adaf2edda3cc7cd92d82d6b73b01213fb80e9135.jpg\"      ,      \"http://d.hiphotos.baidu.com/zhidao/pic/item/562c11dfa9ec8a13c8621b5ff103918fa0ecc011.jpg\"      ,      \"http://d.hiphotos.baidu.com/zhidao/pic/item/562c11dfa9ec8a13c8621b5ff103918fa0ecc011.jpg\"      ,      \"http://d.hiphotos.baidu.com/zhidao/pic/item/562c11dfa9ec8a13c8621b5ff103918fa0ecc011.jpg\"      ,      \"http://d.hiphotos.baidu.com/zhidao/pic/item/562c11dfa9ec8a13c8621b5ff103918fa0ecc011.jpg\"      ,      \"http://d.hiphotos.baidu.com/zhidao/pic/item/562c11dfa9ec8a13c8621b5ff103918fa0ecc011.jpg\"      ,      \"http://d.hiphotos.baidu.com/zhidao/pic/item/562c11dfa9ec8a13c8621b5ff103918fa0ecc011.jpg\"      ,      \"http://d.hiphotos.baidu.com/zhidao/pic/item/562c11dfa9ec8a13c8621b5ff103918fa0ecc011.jpg\"      ,      \"http://d.hiphotos.baidu.com/zhidao/pic/item/562c11dfa9ec8a13c8621b5ff103918fa0ecc011.jpg\"      ,      \"http://d.hiphotos.baidu.com/zhidao/pic/item/562c11dfa9ec8a13c8621b5ff103918fa0ecc011.jpg\"      ]    },      tapName:function(event){      console.log(event.target.dataset.img)       wx.navigateTo({        url: '../chakantu/chakantu?img='+event.target.dataset.img      })    }  })  我天下面的tapName是什么鬼，好吧这个是个点击事件，我们可以看见在wxml里面的image，里面有个赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              忽如寄：微信小程序demo简易教程：天气APP（附源码下载） \n              微信小程序七日谈 - 第一天：人生若只如初见 \n            \n             \n            \n                  原作者: 赫凯 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • iOS码农的微信小程序开发总结\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    2 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n     \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         天下雪\r\n                \r\n       \r\n       2017-3-18 11:07\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    wx_7dcfb361a3: 谢谢分享，请问图片放大后怎么实现手指滑动浏览呢？这个问题你可以在论坛里开贴提问\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n          \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         wx_7dcfb361a3\r\n                \r\n       \r\n       2017-3-15 16:45\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    谢谢分享，请问图片放大后怎么实现手指滑动浏览呢？\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n             \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSitDmgE', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n小程序第三方框架对比 ( wepy / mpvue / ta2019-01-28微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30分享一款拥有历史搜索记录的微信小程序搜索2019-01-28小程序点睛之三：才不是你想的那种组件2019-01-28微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n微信小程序Demo:Canvas图片拖拽生成实现2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo：精美的画板小程序2019-02-21微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：仿 [one] 微信小程序2019-02-18微信小程序Demo：3D旋转效果2019-02-18微信小程序Demo: flappy-bird小游戏2019-02-15微信小程序Demo：群应用（群通知、群接龙、2019-02-15微信小程序Demo：咩咩单词2019-02-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164149|9ef670aac229366146227c496844ae41|2';"}
{"title": "开发微信小程序 中遇到的坑 及解决方法 ", "author": "天下雪", "pub_time": "2016-11-24 14:56", "article_content": "原文地址：http://www.cnblogs.com/feiye512/p/6070052.html；作者正在更新，假如你在11月26日之后看到本文，请进入原文地址查看最新内容；1、wx.request 只能访问 https　 解决：　新建项目  不填appid  即可访问 localhost2、页面中多重三元表达式  解析有问题 　　解决：　　1234567<!--{{index}}  {{(index==0)?\"A\":                             (index==1)?\"B\":                             (index==2)?\"C\":\"D\"}}-->                <block wx:if=\"{{index==0}}\">A</block>                <block wx:elif=\"{{index==1}}\">B</block>                <block wx:elif=\"{{index==2}}\">C</block>                <block wx:else=\"{{index==3}}\">D</block> 3、Page({data:{}}) 页面里 data 的值   可以通过 that.setData 设置   但是 怎么直接取出来 在 js 里面用呢解决： 在page 之外定义全局变量  和page 内的data中的变量  一一对应  每次 赋初始值或者更改 先给全局变量赋值或者 做更改  然后把 更新后的全局变量赋值给   page 内 data 中 对应的变量  代码如下var app=getApp();\r\n  var globalTestPaperID=\"\",\r\n        globalTestPaperTitle=\"\",\r\n        globalTestPaperNum=\"\",\r\n        globalQuestionList=[],\r\n        globalQuestionIndex=0,\r\n        globalQuestion={},\r\n       // globalAnswerList={},\r\n        globalUserSelectAnswer={},\r\n        golbalUserSelectAnswerContent=\"\"\r\nPage({\r\n    data:{\r\n        testPaperID:\"\",\r\n        testPaperTitle:\"\",\r\n        testPaperNum:\"\",\r\n        questionListSize:0,\r\n        questionIndex:0,\r\n        question:{},\r\n        answerList:{},\r\n        userSelectAnswerContent:\"\"\r\n        \r\n    },\r\n    onReady:function(){},\r\n    onLoad:function(query)\r\n    {\r\n        var that=this;        \r\n      console.log(\"testPaperTitle-->\"+query.testPaperTitle);\r\n      console.log(\"testPaperID-->\"+query.testPaperID);\r\n      console.log(\"testPaperOrderNum-->\"+query.testPaperOrderNum);\r\n            globalTestPaperID=query.testPaperID\r\n             globalTestPaperTitle=query.testPaperTitle\r\n             globalTestPaperNum=query.testPaperOrderNum\r\n         that.setData({\r\n            //  testPaperID:query.testPaperID,\r\n            //  testPaperTitle:query.testPaperTitle,\r\n            //  testPaperNum:query.testPaperOrderNum\r\n            testPaperID:globalTestPaperID,\r\n             testPaperTitle:globalTestPaperTitle,\r\n             testPaperNum:globalTestPaperNum\r\n             }), 4、关于布局  最好都用 flex 去布局 　　布局时的 尺寸  我用的是 px   和ps 里的设计图有差距  如果ps 里字号是 30px  小程序对应的大概是 15px;  其他单位 如 rpx rem 等 暂未做测试5、form表单提交（发送模板消息），formId返回 the formId is a mock one；代码中绑定了appid　　　　　　解决。在开发工具中无法获取这个formId，只能在手机上获取。（群里聊天搜集来的  待验证）"}
{"title": "微信小程序学习点滴《十六》：下拉刷新 上拉加载 ", "author": "天下雪", "pub_time": "2016-11-24 19:22", "article_content": "微信小程序中的下拉刷新,上拉加载的功能很常见,目前我知道的有两种可行的方法,一是scroll-view,二是整个页面刷新.今天说说第一种,自己造轮子,难免有些瑕疵,日后慢慢完善.上gif:原理: scroll-view中有监听滑动的方法,这个跟Android类似.其中用到了滑动到顶部,滑动到底部的方法.1.下拉刷新,在滑动到顶部时,bindscrolltoupper被调用,根据自己的业务逻辑请求即可.我的demo只是随机换了个关键字.2.上拉加载,在滑动到底部时,bindscrolltolower被调用,我这里是页数加一,根据自己的业务逻辑修改,然后将获取到的集合添加到scroll-view的数据集合里即可.上代码:1.index.js//index.js  //获取应用实例  var app = getApp()  Page({    data: {      words: [],      windowHeight: 0,//获取屏幕高度      refreshHeight: 0,//获取高度      refreshing: false,//是否在刷新中      refreshAnimation: {}, //加载更多旋转动画数据      clientY: 0,//触摸时Y轴坐标    },    onLoad: function () {      var _this = this;      //获取屏幕高度      wx.getSystemInfo({        success: function (res) {          _this.setData({            windowHeight: res.windowHeight          })          console.log(\"屏幕高度: \" + res.windowHeight)        }      })      //获取words      wx.request({        url: 'http://api.avatardata.cn/ChengYu/Search?key=77f072d28eb141c8b6dda145ca364b92&keyWord=好',        complete: function (res) {          if (res.data.reason == 'Succes') {            _this.setData({              words: res.data.result            })          }        }      })    },    scroll: function () {      console.log(\"滑动了...\")    },    lower: function () {      var start = 0;      start += 1;      console.log(\"加载了...\")      var _this = this;      wx.request({        url: 'http://api.avatardata.cn/ChengYu/Search',        data: {          key: '77f072d28eb141c8b6dda145ca364b92', keyWord: '好', page: start        },        complete: function (res) {          if (res.data.reason == 'Succes') {            var words = _this.data.words.concat(res.data.result);            _this.setData({              words: words            })          }        }      })    },    upper: function () {      console.log(\"下拉了....\")      //获取用户Y轴下拉的位移      if (this.data.refreshing) return;      this.setData({ refreshing: true });      updateRefreshIcon.call(this);  赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              开发微信小程序 中遇到的坑 及解决方法 \n              微信小程序的小练手：活动列表及排序 \n            \n             \n            \n                  原作者: dzp_coder \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序学习点滴《一》：如何获取时间，页面跳转，传递参数 ... ...\n                                    \n                  • 微信小程序学习点滴《二》：开发者工具快捷键，轮播图 swiper图片组件 ...\n                                    \n                  • 微信小程序学习点滴《三》：开发工具及开发环境配置，尺寸单位rpx与px,rem相互转换 ...\n                                    \n                  • 微信小程序学习点滴《四》：网络请求\n                                    \n                  • 微信小程序学习点滴《五》：网络请求(POST请求)填坑指南\n                                    \n                  • 微信小程序学习点滴《六》：保留小数(toFixed) 四舍五入 获取整数 string转int ...\n                                    \n                  • 微信小程序学习点滴《七》：数据存储 参数传递 数据缓存\n                                    \n                  • 微信小程序学习点滴《八》：从相册获取图片 使用相机拍照 本地图片上传 ... ...\n                                    \n                  • 微信小程序学习点滴《九》：本地图片上传(leancloud)\n                                    \n                  • 微信小程序学习点滴《十》：真机测试 地图定位 map API 无法获取当前位置的问题 ... ...\n                                    \n                  • 微信小程序学习点滴《十一》：选择器 时间选择器 日期选择器 地区选择器 ... ...\n                                    \n                  • 微信小程序学习点滴《十二》：图片等比例缩放 获取屏幕尺寸图片尺寸 自适应 ... ...\n                                    \n                  • 微信小程序学习点滴《十三》：音乐播放器 真机测试 audio API\n                                    \n                  • 微信小程序学习点滴《十四》：拖拽 image 触目事件监听\n                                    \n                  • 微信小程序学习点滴《十五》：用户系统 一键登录 获取session_key和openid ...\n                                    \n                  • 微信小程序之上拉加载（分页加载）实例\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSus13o1', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n认识小程序云开发2019-02-21java后台的微信小程序支付的解决方案2019-02-21\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551164151|ce406b02899e48e6d1518fb980c175a9|2';"}
{"title": "天河微信小程序入门《四》：融会贯通，form表单提交数据库 ", "author": "天下雪", "pub_time": "2016-11-24 22:09", "article_content": "天河在阔别了十几天之后终于又回来了。其实这篇文章里的demo是接着（天河微信小程序入门《三》）后面就做了的，但是因为最近在做别的项目，所以就偷懒没有发出来。放到今天来看，从前台提交数据到数据库已经是没有什么可写的了。不过既然开篇了就不能太监么，所以还是分享出来给大家。\r\n我当时的目的是为了实验api的功能和跟后台数据的通讯存储，所以没有考虑到美观之类的，界面非常丑请大家包涵。\r\n一个带form表单的页面\r\n\r\n在这里定义好自己form表单的元素名称\r\n<view class=\"page\">  <view class=\"page__hd\">    <text>表单提交</text>  </view><form class=\"page__bd\" catchsubmit=\"formSubmit\" catchreset=\"formReset\">  <view class=\"section\">    <input name=\"name\" placeholder=\"姓名\" auto-focus/>  </view>  <view class=\"section\">    <input name=\"age\" type=\"number\" placeholder=\"年龄\"/>  </view>  <view class=\"section section_gap\">      <view class=\"section__title\">性别</view>      <radio-group name=\"gender\">        <label><radio value=\"MAN\"/>MAN</label>        <label><radio value=\"WOMAN\"/>WOMAN</label>      </radio-group>  </view>    <view class=\"btn-area\">      <button formType=\"submit\">提交</button>      <button formType=\"reset\">重置</button>    </view>    <view class=\"page__hd\" wx:if=\"{{error}}\">      <text>{{error}}</text>    </view></form>\r\n然后调用wx.request的API方法将表单提交到后台\r\nPage({  data: {    pickerHidden: true,    chosen: ''  },  pickerConfirm: function(e) {    this.setData({      pickerHidden: true    })    this.setData({      chosen: e.detail.value"}
{"title": "微信小程序的小练手：活动列表及排序 ", "author": "天下雪", "pub_time": "2016-11-25 11:25", "article_content": "微信推了小程序之后大家对它的关注度一直很高。所以就和朋神默默的写了个demo…10月底写的小程序…现在11月都快过完了才写博客2333(:зゝ∠)……..考虑了一下小程序用完即走的定位，我们做的这个东西功能十分的简单明确，就是用来进行活动的查看和签到，通过微信提供的位置的api获取坐标进行位置的判断。因为功能比较简单所以就没有用脚手架….结构整个项目的结构大概如图，小程序结构还是比较清晰&好理解的，.js脚本文件，.json配置文件，.wxss样式表文件app.json 是对整个小程序的全局配置,可以配置有你的项目哪些页面，tabBar，导航条，网络超时时间等。app.js是小程序逻辑。在app.js里用App() 函数用来注册一个小程序。指定小程序的生命周期函数等。tips：pages里的四个文件必须具有相同的路径与文件名。只能配置最少2个、最多5个 tab 。WXML有以下几个功能，感觉跟vue差不多- -….文档写的挺清楚的….没什么好讲的地方…数据绑定、列表渲染、条件渲染、模板、事件、引用WXSS跟CSS几乎是一样，多扩展了两个特性，rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。rem（root em）: 规定屏幕宽度为20rem；1rem = (750/20)rpx 。使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径。活动的排序获取活动的数据，活动有三种状态，正在进行，即将开始，已结束。要令正在进行的活动排在活动列表的最前面，然后按照活动的开始时间进行排序。12345678910111213141516171819202122232425262728wx.request({        url,        success: resp => {          const now = new Date()          const a = resp.data.data.map(i => {            i.start = new Date(i.start)            i.end = new Date(i.end)            return i          })          console.log(\"resp\",resp)          const cmp = (a, b) => b.start - a.start          const coming = a.filter(i => i.start > now).sort(cmp).map(i => (i.statu = 0,i))          const ing = a.filter(i => i.start < now && i.end > now).sort(cmp).map(i => (i.statu = 1,i))          const end = a.filter(i => i.end < now).sort(cmp).map(i => (i.statu = 2,i))          const items = [...ing, ...coming, ...end].map(i => {                                                    i.img = u + i.img                                                    i.time = util.formatTime(i.start)                                                    return i                                                  })                  if (items.length) {            this.setData({  items:that.data.items.concat(items), loading: true });          } else {            this.setData({ hasMore: false, loading: false });          }        },        fail: e => console.log(e)      })活动列表的下拉加载遇到了一点坑。。在wxml的代码里，需要对scroll-view给定一个固定的height，不然他不会有加载的效果，为了适配不同的分辨率，通过wx.getSystemInfo获取用户的窗口高度进行数据绑定。（WXML 中的动态数据均来自对应 Page 的 data）1234567891011121314151617181920<view class=\"container\"><scroll-view scroll-y=\"true\" style=\"height:{{windowH}}px\" class=\"list\" bindscrolltolower=\"handleLoadMore\" >  <view class=\"wrap\">    <view class=\"activity-box\"  wx:for=\"{{items}}\" wx:key=\"_id\">      <image src=\"{{ item.img }}\" class=\"img {{ item.statu !== 1 ? 'mask' : '' }} {{ item.statu === 0 ? 'coming' : '' }} {{ item.statu === 2 ? 'end' : '' }}\"></image>      <text class=\"block\">{{ item.title }}</text>      <text class=\"block time\">{{ item.time }}</text>    </view>  </view>   <view class=\"tips\">      <view wx:if=\"{{ hasMore }}\">        <image src=\"../../image/loading.gif\" mode=\"aspectFill\"/>        <text>努力加载中_(:зゝ∠)_</text>      </view>      <view wx:else>        <text>没有更多内容了</text>      </view>    </view>  </scroll-view></view>总而言之，跟vue有一点点像。。"}
{"title": "娇娇jojojojo：微信小程序踩坑录：canvas，post请求，页面刷新 ", "author": "天下雪", "pub_time": "2016-11-25 11:31", "article_content": "授权地址现在也不知道距离微信公测多少日子了，反正感觉我是埋在微信小程序这个坑里很久了，公司的项目终于快接近尾声，现在就腾点时间记录下我的收获，希望能给大家一点点帮助吧。我做的几乎都是canvas的东西，所以先说说这方面的坑以及一些解决办法，还有一些解决不了的希望大家多多提出解决方案哈。坑一：canvas适配刚开始做这方面的时候，我一直以为获取不到机型以及手机的宽高，所以硬生生的把canvas的宽高都设成了固定的320px，想想偌大的平板上就320那么大有多丑，产品估计也想把我活活掐死。好在无意间翻文档，看到了wx.getSystemInfo(OBJECT)这个方法，OBJECT参数有三种：success的情况下会返回：示例代码：wx.getSystemInfo({  success: function(res) {    console.log(res.model)    console.log(res.pixelRatio)    console.log(res.windowWidth)    console.log(res.windowHeight)    console.log(res.language)    console.log(res.version)  }})不管其他的，看见那个windowWidth，我的眼睛瞬间就亮了，自然而然，canvas的适配问题也就解决了。坑二：wx.canvasToTempFilePath()官方文档上就这样草草了事，所以我也是陷在坑里好久，后来才找到正确的方法。一开始我是写成这样的：wx.canvasToTempFilePath(\"1\");然后就是各种报错各种郁闷，不知道大家是不是一开始就写对了，反正我是找到正确方法后有一种想掐死小编的冲动，好歹举个代码实例，不然凭那一句话，我是想不到那么多的。下面是正确写法：wx.canvasToTempFilePath({    canvasId: '1',    success: function (res) {        var tempFilePath = res.tempFilePath;        console.log(tempFilePath);    },    fail: function (res) {        console.log(res);    }});话说，忽然想起由这个问题引发的另一个问题，就是当把canvas置为hidden的时候，这个方法就不生效了。按理说，文档上描述hidden只是简单的控制显示与隐藏，组件始终会被渲染，既然被渲染，wx.canvasToTempFilePath()这个方法不生效我是十分郁闷的，现在是没做这方面的功能，所以也没去深入研究了，有遇到同样情况的可以给我回复的。坑三：canvas画笔粗细当时做了画画的功能，在微信开发者工具上都是好好的，但一到真机上，每次一选择画笔粗细的时候，就画不出来东西了，当时也是郁闷好久，后来也不知道怎么找到原因的，但最后解决了。因为当时画笔的粗细我传的是字符串类型的，后来改成数字类型的就好了，不知道是微信太严格，还是没注意到这个小缺口。同样的，画笔颜色也只能是16进制的写法，直接red，green或者缩写成#ccc这样的都不生效，大家注意点就行了。坑四：context.clearActions()不知道是不是我写的有问题，这个方法一直不生效，所以我就用另外一个方法代替了：context.clearRect(0, 0, 320, 320);也是同样的效果，清除画布。坑五：wx.drawCanvas()context.clearRect(0, 0, 320, 320);wx.drawCanvas({   canvasId: 'firstCanvas',   actions: context.getActions() // 获取绘图动作数组})官方文档上举的栗子一直是这样的，所以我觉得是误导了n+1个人，出现的问题就是：后面画的一笔会把前面画的一笔给覆盖掉。我一开始也是这样，所以还痴痴的认为微信机制和js机制不一样，后来还想着每画一笔就把这一笔保存到一个数组中，然后画第二笔的时候，将这个数组全都展示出来，肉眼上看起来就像是一笔一笔画上去的一样，实际上是每画一笔，就把整个数组都渲染一遍。直到有天又看了下官方文档，才发现大可不必那么麻烦，微信有现成的方法：reverse方法置为true就可以解决这个问题了。  wx.drawCanvas({    canvasId: id,    actions: context.getActions(),    reverse:true  })canvas的坑就暂时告一段落，接着说一说其他方面的坑吧。坑六：post请求不生效记得当时我是这样写的：wx.request({    url: url,    method:\"POST\",    data: {       \"paintId\":0,       \"limit\":10,       \"openId\":openid    },    header:{'content-type': 'application/json'},    success: function(res) {        console.log(res)    }})每次都会返回下面这个结果：提示request:ok，但data偏偏是Array[0]。后来微信开发者工具升级了好几次说是修复了post请求问题，但实际上还是没完全修复，得再改一点点东西就可以了：将header的content-type改成application/x-www-form-urlencoded就可以了。wx.request({    url: url,    method:\"POST\",    data: {       \"paintId\":0,       \"limit\":10,       \"openId\":openid    },    header:{'content-type': 'application/x-www-form-urlencoded'},    success: function(res) {        console.log(res)    }})之前有各种说法，说application/json会被自动过滤掉，或者又加上一个application/json，成了2个，所以之前的解决办法是直接将header去掉不写就可以请求成功了。现在微信修复了bug后，要把content-type改成application/x-www-form-urlencoded才可以。坑七：刷新页面刷新页面的坑其实挺多的，我罗列一下：1、以前总有双击tabBar就能刷新页面，现在没法控制tabBar，这个也就没办法实现了；2、只有下拉刷新的样式（三个点转呀转那个），但没有上拉加载的样式（这个只能照着官方文档的样式自己去设计了）；3、下拉刷新在开发者工具上是好使的，3s后会自动拉回去，但在真机上就不生效，那三个小点点就回不去了，必须手动拉回去；4、从页面A跳到页面B，再从B返回到A，想让A自动刷新，这个怎么做呢？先说下小程序页面刷新的原理吧：小程序的框架逻辑比较类似react和vue框架，属于数据驱动界面刷新，所以想让页面刷新的关键就是setData()，但这只是被动的让页面刷新。想让页面返回的时候就刷新，那就要用到onShow这个生命周期函数了，onShow是每次打开页面都会调用一次，然后再和setData()结合就完美了。坑八：背景图只能是绝对路径应该不止一个人遇到这个问题了，背景图写的相对路径，在开发者工具上显示是正常的，但一到真机上就显示不出来，其实只要改成绝对路径就行了，也就是将图片先上传到自己的服务器，然后写这个路径就可以了。坑九：传对象到后台不生效当时传了一组对象到后台，结果后台收到的就是[Object Object]这个鬼样子，一直很郁闷，后来知道了JSON.stringify()方法，用了这个方法就OK了，因为传给后台的数据要提前字符串化。虽然现在是好使的，但中间其实也是波折不断，不过结果是好的，也就开心了，哈哈哈。顺便普及一下字符串转对象的方法：JSON.parse()。今天就写这么多吧，一直在踩坑中，上面也还有很多没解决的问题以及可能不对的地方，希望大家多多给我提意见哈。"}
